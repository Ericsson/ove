#!/usr/bin/env bash
# SPDX-License-Identifier: MIT
#
# MIT License
#
# Copyright (c) 2021 Ericsson
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is furnished
# to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice (including the next
# paragraph) shall be included in all copies or substantial portions of the
# Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
# FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS
# OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
# OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

_args="$*"
instance_global_flags=""
instance_ip=""
instance_name=""
ephemeral=0
_gid=0
_home="/root"
package_manager=""
packman=""
prefix="true"
tag=""
_uid=0
_user=
use_ssh=0

function _echo {
	if [[ ${OVE_INSTANCE_STEPS} == *verbose* ]]; then
		ove-echo stderr "$*"
	fi

	return 0
}

function instance_runtime {
	if command -v incus > /dev/null; then
		echo "incus"
	else
		return 1
	fi

	return 0
}

function init {
	local c
	local s

	if ! c=$(instance_runtime); then
		echo "error: no supported instance runtime found" 1>&2
		exit 1
	elif [ $# -ne 2 ]; then
		echo "usage: $(basename "$0") file|project|unittest image"
		exit 1
	fi

	if [ "$1" = "unittest" ]; then
		unittest=1
		OVE_INSTANCE_STEPS="ove verbose user"

		if ! command -v shunit2 > /dev/null; then
			echo "error: command 'shunit2' not found" 1>&2
			exit 1
		fi
	else
		unittest=0
		entry="$1"
	fi

	bash_opt=""
	image="$2"
	if [[ ${image} == *nixos* ]]; then
		bash_opt="-i"
	fi

	if [[ ${OVE_INSTANCE_STEPS} == *debug* ]]; then
		set -x
	fi

	if [[ ${OVE_INSTANCE_STEPS} == *X* ]]; then
		if ! command -v xpra > /dev/null; then
			echo "error: command 'xpra' not found" 1>&2
			exit 1
		fi
		OVE_INSTANCE_STEPS+=" ssh"
		OVE_INSTANCE_STEPS+=" ssh_config"
		if [ "${OVE_INSTANCE_XPRA_DE_CMD}" = "" ]; then
			echo "error: specify how to start '${OVE_INSTANCE_XPRA_DE}' in OVE_INSTANCE_XPRA_DE_CMD" 1>&2
			exit 1
		fi
	fi

	if [ ! -v OVE_INSTANCE_STEPS ]; then
		OVE_INSTANCE_STEPS=""
	fi

	instance_global_flags=""
	if [[ ${OVE_INSTANCE_STEPS} == *verbose* ]]; then
		for s in ${OVE_INSTANCE_STEPS//:/ }; do
			echo "${s}"
		done | LC_ALL=C sort -u
	elif "${c}" -h | grep -q '\-q'; then
		instance_global_flags+=" -q"
	fi

	if [[ ${OVE_INSTANCE_STEPS} == *ssh* ]]; then
		if ! command -v sshpass > /dev/null; then
			echo "error: command 'sshpass' not found" 1>&2
			exit 1
		fi
		ssh_opts=""
		ssh_opts+=" -o GlobalKnownHostsFile=/dev/null"
		ssh_opts+=" -o StrictHostKeyChecking=no"
		ssh_opts+=" -o UserKnownHostsFile=/dev/null"
		ssh_copy_id_opts="${ssh_opts}"
		if [[ ${OVE_INSTANCE_STEPS} == *debug* ]]; then
			ssh_opts+=" -v"
		fi
	fi
}

function run {
	local sleep_s

	_echo "[${image}]$ $*"
	while true; do
		if eval "$*" 2> "${OVE_TMP}/${tag:?}.err"; then
			return 0
		fi

		_echo "error: '$*' failed for '${image}'"
		if [ ! -s "${OVE_TMP}/${tag}.err" ]; then
			if [ "${NO_EXIT}" = "1" ]; then
				return 1
			else
				exit 1
			fi
		fi

		sleep_s=$((RANDOM%10))
		if grep "^Error:.*i/o timeout" "${OVE_TMP}/${tag}.err"; then
			_echo "$(instance_runtime): i/o timeout. Retry in ${sleep_s} sec"
			sleep ${sleep_s}
			continue
		elif grep "^Error: websocket:" "${OVE_TMP}/${tag}.err"; then
			_echo "$(instance_runtime): websocket error. Retry in ${sleep_s} sec"
			sleep ${sleep_s}
			continue
		elif grep "^Error: Missing event connection with target cluster member" "${OVE_TMP}/${tag}.err"; then
			_echo "$(instance_runtime): cluster error. Retry in ${sleep_s} sec"
			sleep ${sleep_s}
			continue
		elif grep "^Error: Operation not found" "${OVE_TMP}/${tag}.err"; then
			_echo "$(instance_runtime): operation not found error. Retry in ${sleep_s} sec"
			sleep ${sleep_s}
			continue
		elif grep -q "^Error: Command not found" "${OVE_TMP}/${tag}.err"; then
			true
		else
			cat "${OVE_TMP}/${tag}.err"
		fi

		if [ "${NO_EXIT}" = "1" ]; then
			return 1
		else
			exit 1
		fi
	done
}

function run_no_exit {
	if ! NO_EXIT=1 run "$@"; then
		return 1
	fi
}

function ssh_exec {
	local prefix
	local opts

	opts="${ssh_opts}"
	if is_cluster; then
		if [ "${HOSTNAME}" != "$(cluster_get_instance_location)" ]; then
			opts+=" -o ProxyJump=$(cluster_get_instance_location)"
		fi
	fi

	_echo "ssh -F /dev/null -t -q ${opts:?} ${_user:?}@${instance_ip:?} $*"
	# shellcheck disable=SC2086
	if ! ssh \
		-F /dev/null \
		-t \
		-q \
		${opts} \
		${_user}@${instance_ip} "$@"; then
		return 1
	fi

	return 0
}

function instance_exec {
	local e
	local instance_exec_options

	if [ "${use_ssh}" -eq 1 ]; then
		if ! ssh_exec "$@"; then
			return 1
		fi
		return 0
	fi

	instance_exec_options=""
	if [[ ${package_manager} == apt-get* ]];  then
		instance_exec_options+=" --env DEBIAN_FRONTEND=noninteractive"
	fi

	for e in ftp_proxy http_proxy https_proxy; do
		if [ "${!e}" = "" ]; then
			continue
		fi
		instance_exec_options+=" --env ${e}=${!e}"
	done

	if [ "${INSTANCE_EXEC_EXTRA}" != "" ]; then
		instance_exec_options+=" ${INSTANCE_EXEC_EXTRA}"
	fi

	run "$(instance_runtime)${instance_global_flags} exec${instance_exec_options} ${instance_name} -- $*"
}

function instance_exec_as_root {
	INSTANCE_EXEC_EXTRA="--user 0 --group 0" \
		use_ssh=0 \
		_user=root \
		instance_exec "$@"
}

function instance_exec_as_user {
	INSTANCE_EXEC_EXTRA="--user ${_uid:?} --group ${_gid:?} --env HOME=${OVE_HOME:?}" \
		use_ssh=0 \
		instance_exec "$@"
}

function instance_exec_no_exit {
	local e
	local instance_exec_options

	if [ "${use_ssh}" -eq 1 ]; then
		if ! ssh_exec "$@"; then
			return 1
		fi
		return 0
	fi

	instance_exec_options=""
	if [[ ${package_manager} == apt-get* ]];  then
		instance_exec_options+=" --env DEBIAN_FRONTEND=noninteractive"
	fi

	for e in ftp_proxy http_proxy https_proxy; do
		if [ "${!e}" = "" ]; then
			continue
		fi
		instance_exec_options+=" --env ${e}=${!e}"
	done

	if [ "${INSTANCE_EXEC_EXTRA}" != "" ]; then
		instance_exec_options+=" ${INSTANCE_EXEC_EXTRA}"
	fi

	if ! run_no_exit "$(instance_runtime)${instance_global_flags} exec${instance_exec_options} ${instance_name} -- $*"; then
		return 1
	fi
}

function instance_exec_no_exit_as_root {
	INSTANCE_EXEC_EXTRA="--user 0 --group 0" \
		use_ssh=0 \
		_user=root \
		instance_exec_no_exit "$@"
}

function package_manager_noconfirm {
	instance_exec "bash ${bash_opt} -c '${prefix}; ove-add-config \$HOME/.oveconfig OVE_INSTALL_PKG 1'"

	if [[ ${package_manager} == apt-get* ]];  then
		instance_exec "bash ${bash_opt} -c '${prefix}; ove-add-config \$HOME/.oveconfig OVE_OS_PACKAGE_MANAGER_ARGS -y -qq -o=Dpkg::Progress=0 -o=Dpkg::Progress-Fancy=false install'"
	elif [[ ${package_manager} == pacman* ]]; then
		instance_exec "bash ${bash_opt} -c '${prefix}; ove-add-config \$HOME/.oveconfig OVE_OS_PACKAGE_MANAGER_ARGS -S --noconfirm --noprogressbar'"
	elif [[ ${package_manager} == xbps-install* ]]; then
		instance_exec "bash ${bash_opt} -c '${prefix}; ove-add-config \$HOME/.oveconfig OVE_OS_PACKAGE_MANAGER_ARGS -y'"
	elif [[ ${package_manager} == zypper* ]]; then
		instance_exec "bash ${bash_opt} -c '${prefix}; ove-add-config \$HOME/.oveconfig OVE_OS_PACKAGE_MANAGER_ARGS install -y'"
	elif [[ ${package_manager} == dnf* ]]; then
		instance_exec "bash ${bash_opt} -c '${prefix}; ove-add-config \$HOME/.oveconfig OVE_OS_PACKAGE_MANAGER_ARGS install -y'"
	elif [[ ${package_manager} == apk* ]]; then
		instance_exec "bash ${bash_opt} -c '${prefix}; ove-add-config \$HOME/.oveconfig OVE_OS_PACKAGE_MANAGER_ARGS add --no-progress -q'"
	fi
}

function remove_tmp {
	if [[ ${OVE_INSTANCE_STEPS:?} != *debug* ]]; then
		find "${OVE_TMP:?}" -maxdepth 1 -type f -name "${tag:?}*" -exec rm {} \;
	fi
	return 0
}

function cleanup {
	local f

	f="${OVE_TMP}/${tag}-$(instance_runtime)-config-exit"
	if ! save_instance_config "$f"; then
		exit 1
	elif [[ ${OVE_INSTANCE_STEPS:?} == *running* ]]; then
		remove_tmp
		return
	fi
	run_no_exit "$(instance_runtime)${instance_global_flags} stop ${instance_name:?}"
	if [[ ${OVE_INSTANCE_STEPS:?} == *stopped* ]]; then
		remove_tmp
		return
	fi
	run_no_exit "$(instance_runtime)${instance_global_flags} delete ${instance_name:?} --force"
	remove_tmp
}

function setup_package_manager {
	run "$(instance_runtime)${instance_global_flags} file pull ${instance_name}/root/${tag}-packman ${OVE_TMP}/${tag}-packman"
	if [ ! -s "${OVE_TMP}/${tag}-packman" ]; then
		echo "error: could not determine package manager for ${image}" 1>&2
		exit 1
	fi

	packman=$(cat "${OVE_TMP}/${tag}-packman")
	if [ "${packman}" = "apk" ]; then
		package_manager="apk add --no-progress -q"
		cat >> "${OVE_TMP}/${tag}-services.sh" <<EOF
if ! timeout 10 apk update > /dev/null 2>&1; then
	sed -i 's,https,http,g' /etc/apk/repositories
	if ! timeout 10 apk update > /dev/null 2>&1; then
		echo "error: apk update failed"
		exit 1
	fi
fi
EOF
	elif [ "${packman}" = "pacman" ]; then
		cat >> "${OVE_TMP}/${tag}-services.sh" <<EOF
pacman -Syu --noconfirm -q --noprogressbar
EOF
		package_manager="pacman -S --noconfirm -q --noprogressbar"
	elif [ "${packman}" = "apt-get" ]; then
		package_manager="apt-get -y -qq -o=Dpkg::Progress=0 -o=Dpkg::Progress-Fancy=false install"
		if [ -s "/etc/apt/apt.conf" ]; then
			cp -a "/etc/apt/apt.conf" "${OVE_TMP}/${tag}-apt.conf"
			instance_file_push_root \
				"${OVE_TMP}/${tag}-apt.conf" \
				"${instance_name}/etc/apt/apt.conf"
		fi
		echo "apt-get update >/dev/null 2>&1" >> "${OVE_TMP}/${tag}-services.sh"
	elif [ "${packman}" = "xbps" ]; then
		package_manager="xbps-install -y"
	elif [ "${packman}" = "dnf" ]; then
		package_manager="dnf install -y"
	elif [ "${packman}" = "zypper" ]; then
		package_manager="zypper install -y"
	elif [ "${packman}" = "opkg" ]; then
		package_manager="opkg install"
	elif [ "${packman}" = "nix-env" ]; then
		package_manager="nix-env -iA"
	else
		echo "error: unknown package manager for '${image}'" 1>&2
		exit 1
	fi

	cat > "${OVE_TMP}/${tag}-packman" <<EOF
#!/usr/bin/env sh
${package_manager} "\$@"
EOF
	instance_file_push_root \
		"${OVE_TMP}/${tag}-packman" \
		"${instance_name}/sbin/packman" \
		"--mode 0755"
}

function is_cluster {
	# shellcheck disable=SC2086
	if "$(instance_runtime)"${instance_global_flags} cluster list &> /dev/null; then
		return 0
	else
		return 1
	fi
}

function cluster_get_instance_location {
	"$(instance_runtime)"${instance_global_flags} list --format csv -cL "^${instance_name}$"
}

function _setup_sshd {
	echo "${package_manager:?} openssh-server >/dev/null 2>&1" >> "${OVE_TMP}/${tag}-services.sh"
	echo "${package_manager} openssh >/dev/null 2>&1" >> "${OVE_TMP}/${tag}-services.sh"

	if [[ ${image} == *opensuse* ]]; then
		echo "cp -a /usr/etc/ssh/sshd_config /etc/ssh/" >> "${OVE_TMP}/${tag}-services.sh"
	elif [[ ${image} == *void* ]]; then
		echo "ln -s /etc/sv/sshd /var/service" >> "${OVE_TMP}/${tag}-services.sh"
	fi

	cat >> "${OVE_TMP}/${tag}-services.sh" <<EOF
if [ ! -s /etc/ssh/sshd_config ]; then
	echo 'error: ${instance_name:?}: could not find /etc/ssh/sshd_config' >&2
	exit 1
fi
if ! sed -i \
	-e 's,.*PermitRootLogin.*,PermitRootLogin yes,g' \
	-e 's,.*PermitUserEnvironment.*,PermitUserEnvironment yes,g' \
	-e 's,.*AllowAgentForwarding.*,AllowAgentForwarding yes,g' \
	-e 's,.*PasswordAuthentication.*,PasswordAuthentication yes,g' /etc/ssh/sshd_config; then
	exit 1
fi
EOF
	if [[ ${image} == *alpine* ]]; then
		echo "rc-update add sshd >/dev/null 2>&1" >> "${OVE_TMP}/${tag}-restart-ssh-daemon.sh"
		echo "/etc/init.d/sshd start >/dev/null 2>&1" >> "${OVE_TMP}/${tag}-restart-ssh-daemon.sh"
	elif [[ ${image} == *devuan* ]]; then
		echo "service ssh restart" >> "${OVE_TMP}/${tag}-restart-ssh-daemon.sh"
	elif [[ ${image} == *openwrt* ]]; then
		{
			echo "uci set dropbear.@dropbear[0].Port=2222"
			echo "uci commit dropbear"
			echo "/etc/init.d/dropbear restart"
			echo "/etc/init.d/firewall stop"
			echo "/etc/init.d/firewall disable"
			echo "/etc/init.d/sshd enable"
			echo "/etc/init.d/sshd start"
		} >> "${OVE_TMP}/${tag}-restart-ssh-daemon.sh"
	else
		for s in ssh sshd; do
			echo "systemctl -q restart $s >/dev/null 2>&1" >> "${OVE_TMP}/${tag}-restart-ssh-daemon.sh"
			echo "systemctl -q enable $s >/dev/null 2>&1" >> "${OVE_TMP}/${tag}-restart-ssh-daemon.sh"
		done
	fi
	echo "sh ${tag}-restart-ssh-daemon.sh" >> "${OVE_TMP}/${tag}-services.sh"
	instance_file_push_root \
		"${OVE_TMP}/${tag}-restart-ssh-daemon.sh" \
		"${instance_name}/root/${tag}-restart-ssh-daemon.sh"

	cat >> "${OVE_TMP}/${tag}-services.sh" <<EOF
i=0
while true; do
	i=\$((i+1))
	if [ \$i -gt 100 ]; then
		echo "error: sshd did not start"
		exit 1
	elif [ \$(( i % 10 )) -eq 0 ]; then
		sh /root/${tag}-restart-ssh-daemon.sh
	elif pgrep -f sshd >/dev/null 2>&1; then
		sleep 1
		break
	fi
EOF
	if [[ ${OVE_INSTANCE_STEPS} == *verbose* ]]; then
		echo -e "\techo \"waiting for sshd \$i\"" >> "${OVE_TMP}/${tag}-services.sh"
	fi
	cat >> "${OVE_TMP}/${tag}-services.sh" <<EOF
	sleep 0.1
done
EOF

	if [[ ${OVE_INSTANCE_STEPS} == *verbose* ]]; then
		sed -i -e "1iset -x" "${OVE_TMP}/${tag}-services.sh"
	fi

	sed -i -e "1i#!/usr/bin/env sh" "${OVE_TMP}/${tag}-services.sh"
}

function setup_X_apk {
	cat >> "${OVE_TMP}/${tag}-services.sh" <<EOF
# install Xpra
packman xpra

# install Desktop Environment
setup-desktop ${OVE_INSTANCE_XPRA_DE}
EOF
}

function setup_X_deb {
	cat >> "${OVE_TMP}/${tag}-services.sh" <<EOF
# install wget
packman wget

# xpra keyring
wget -q -O /usr/share/keyrings/xpra.asc https://xpra.org/xpra.asc

# xpra.sources
codename=\$(. /etc/os-release; echo \${VERSION_CODENAME})
wget -q -O /etc/apt/sources.list.d/xpra.sources https://raw.githubusercontent.com/Xpra-org/xpra/master/packaging/repos/\${codename:?}/xpra.sources

# refresh package manager
apt-get update

# install packages
packman cron xfce4-session xfce4-terminal xpra
EOF
}

function setup_X_rpm {
	cat >> "${OVE_TMP}/${tag}-services.sh" <<EOF
# install wget
packman wget

# xpra.sources
id=\$(. /etc/os-release; echo \${ID})
echo "id=\$id"

if [ "\${id,,}" = "fedora" ]; then
	id="Fedora"
elif [[ "\${id,,}" == *centos* ]]; then
	id="CentOS-Stream"
elif [[ "\${id,,}" == *almalinux* ]]; then
	id="almalinux"
elif [[ "\${id,,}" == *rocky* ]]; then
	id="rockylinux"
else
	id="almalinux"
fi
wget -O /etc/yum.repos.d/xpra.repo https://raw.githubusercontent.com/Xpra-org/xpra/master/packaging/repos/\${id}/xpra.repo

# install config-manager plugin
packman dnf-plugins-core

# enable CRB
dnf config-manager --set-enabled crb

# EPEL
packman epel-release

# refresh package manager
dnf update -y

# packages
packs=""
packs+=" cronie"
packs+=" xpra"

# install packages
packman \${packs}

# install xfce
dnf groupinstall -y xfce
EOF
}

function ssh_config_entry {
	cat << EOF
Host ${instance_name:?}
	HostName ${instance_ip:?}
	RequestTTY yes
	StrictHostKeyChecking no
	User ${_user:?}
EOF
	if [[ ${OVE_INSTANCE_STEPS} = *ove* ]] && \
		[[ ${OVE_INSTANCE_STEPS} = *user* ]]; then
		echo -e "\t#RemoteCommand cd ${OVE_BASE_DIR:?}; exec \$SHELL"
	fi

	if is_cluster; then
		if [ "${HOSTNAME}" != "$(cluster_get_instance_location)" ]; then
			echo -e "\tProxyJump $(cluster_get_instance_location)"
		fi
	fi
}

function update_ssh_config {
	local n
	local _user

	if [[ ${OVE_INSTANCE_STEPS} != *ssh* ]]; then
		return 0
	elif [[ ${OVE_INSTANCE_STEPS} != *ssh_config* ]]; then
		return 0
	fi

	if command -v flock > /dev/null; then
		exec {fd}>"${OVE_TMP}"/instance.lock
		flock ${fd}
	fi

	if [[ ${OVE_INSTANCE_STEPS} == *user* ]] && [ ${EUID} -ne 0 ]; then
		_user="${OVE_INSTANCE_USER:?}"
	else
		_user="root"
	fi

	if ! mkdir -p "${OVE_HOME}/.ssh"; then
		echo "error: mkdir ${OVE_HOME}/.ssh failed" 1>&2
		exit 1
	elif [ -s "${OVE_HOME}/.ssh/config" ] && \
		grep -q "^Host ${instance_name}$" "${OVE_HOME}/.ssh/config"; then
		# insert on top of existing host
		n=$(grep -m 1 -n "^Host ${instance_name}$" "${OVE_HOME}/.ssh/config" | cut -d: -f1)
		{
			echo -n "${n}i"
			ssh_config_entry | sed -e 's,$,\\,g'
		} > "${OVE_TMP}/${tag}-sed-script"
		if ! sed -i -f "${OVE_TMP}/${tag}-sed-script" "${OVE_HOME}/.ssh/config"; then
			echo "error: not possible to update ${OVE_HOME}/.ssh/config" 1>&2
			exit 1
		fi
	else
		# append
		ssh_config_entry >> "${OVE_HOME}/.ssh/config"
	fi

	if command -v flock > /dev/null; then
		flock -u "${fd}"
	fi
}

# $1: user
function setup_ssh {
	local pass="${RANDOM}${RANDOM}${RANDOM}"
	local _home
	local opts

	_user="$1"

	if [ "${_user}" = "root" ]; then
		_home="/root"
		if [ "${OVE_INSTANCE_ROOT_PASS}" != "" ]; then
			pass="${OVE_INSTANCE_ROOT_PASS}"
		fi
	else
		_home="${OVE_HOME}"
		if [ "${OVE_INSTANCE_USER_PASS}" != "" ]; then
			pass="${OVE_INSTANCE_USER_PASS}"
		fi
	fi

	if [[ ${image} == *alpine* ]]; then
		cat > "${OVE_TMP}/${tag}-passwd-${_user}" <<EOF
echo -e "${pass}\n${pass}" | passwd ${_user} &> /dev/null
EOF
		instance_file_push_root \
			"${OVE_TMP}/${tag}-passwd-${_user}" \
			"${instance_name}/root/${tag}-passwd-${_user}"

		# shellcheck disable=SC2097,SC2098
		instance_exec_as_root "sh /root/${tag}-passwd-${_user}"
	else
		if [[ ${image} == *openwrt* ]]; then
			instance_exec_as_root "${package_manager} shadow-usermod shadow-useradd" > /dev/null
		fi

		# shellcheck disable=SC2097,SC2098
		instance_exec_as_root "usermod -p '$(openssl passwd -1 "${pass}")' ${_user}"
	fi

	if [ "${_user}" = "root" ]; then
		instance_exec_as_root "mkdir -p .ssh"
		instance_exec_as_root "chmod 700 .ssh"
	else
		instance_exec_as_user "mkdir -p .ssh"
		instance_exec_as_user "chmod 700 .ssh"
	fi

	_echo "copy public key to instance for user: ${_user}"
	i=0
	opts="${ssh_copy_id_opts}"
	if is_cluster; then
		if [ "${HOSTNAME}" != "$(cluster_get_instance_location)" ]; then
			opts+=" -o ProxyJump=$(cluster_get_instance_location)"
		fi
	fi

	while true; do
		((i++))
		if [ ${i} -gt 100 ]; then
			echo "error: not possible to copy public key to ${instance_name} ${instance_ip}" 1>&2
			exit 1
		fi

		# shellcheck disable=SC2086
		if ! sshpass -p${pass} \
			ssh-copy-id \
			-f \
			${opts} \
			"${_user}"@"${instance_ip}" > /dev/null 2> "${OVE_TMP}/${tag}-ssh-copy-id.err"; then
			if [ -s "${OVE_TMP}/${tag}-ssh-copy-id.err" ]; then
				cat "${OVE_TMP}/${tag}-ssh-copy-id.err"
			fi
			_echo "copy public key to ${instance_name} ${instance_ip} failed - retry in 1 sec"
			sleep 1
			continue
		fi
		break
	done

	# from now on use ssh instead of exec
	use_ssh=1

	true > "${OVE_TMP}/${tag}-sshenv"
	for e in ftp_proxy http_proxy https_proxy; do
		if [ "${!e}" = "" ]; then
			continue
		fi
		echo "${e}=${!e}" >> "${OVE_TMP}/${tag}-sshenv"
	done

	opts="${ssh_opts}"
	if is_cluster; then
		if [ "${HOSTNAME}" != "$(cluster_get_instance_location)" ]; then
			opts="${ssh_opts} -o ProxyJump=$(cluster_get_instance_location)"
		fi
	fi

	if [ -s "${OVE_TMP}/${tag}-sshenv" ]; then
		# shellcheck disable=SC2086
		scp ${opts} -p -q "${OVE_TMP}/${tag}-sshenv" "${_user}"@"${instance_ip}":.ssh/environment
	fi
}

# $1: uid or gid
function get_id {
	local i
	local _id
	local sleep_s

	i=0
	while true; do
		((i++))
		if [ $i -ge 30 ]; then
			echo "error: could not retreive $1 for ${OVE_INSTANCE_USER:?} for ${instance_name}" 1>&2
			return 1
		fi
		_id=$(instance_exec "id -${1::1} ${OVE_INSTANCE_USER:?}")
		if [ "${_id}" = "" ]; then
			sleep_s=$((RANDOM%10))
			echo "warning: empty $1, retry in ${sleep_s}s ($i)" 1>&2
			sleep ${sleep_s}
			continue
		fi
		break
	done
	_id=${_id//[$'\t\r\n']/}
	if [[ ! "${_id}" =~ ^[0-9]+$ ]]; then
		echo "error: weird $1 '${_id}'" 1>&2
		return 1
	fi

	echo "$_id"
}

function instance_file_push_helper {
	local _cmd

	_cmd="$(instance_runtime)${instance_global_flags}"
	_cmd+=" file"
	_cmd+=" push"
	if [ $# -eq 3 ]; then
		_cmd+=" $3"
	fi

	if [[ "${FUNCNAME[1]}" == *_root ]]; then
		_cmd+=" --uid 0"
		_cmd+=" --gid 0"
	elif [[ "${FUNCNAME[1]}" == *_user ]]; then
		_cmd+=" --uid ${_uid:?}"
		_cmd+=" --gid ${_gid:?}"
	else
		echo "fatal: instance_file_push_helper" 1>&2
		exit 1
	fi
	_cmd+=" $1"
	_cmd+=" $2"

	run "${_cmd}"
}

function instance_file_push_root {
	instance_file_push_helper "$@"
}

function instance_file_push_user {
	instance_file_push_helper "$@"
}


function mkdir_var_tmp {
	local i

	i=0
	while true; do
		((i++))
		if [ $i -ge 100 ]; then
			echo "error: could not create /var/tmp for ${instance_name}" 1>&2
			exit 1
		elif ! instance_exec_no_exit "mkdir -p -v /var/tmp"; then
			sleep 0.1
			continue
		fi
		break
	done
}

function _uniq {
	if [ $# -eq 1 ]; then
		echo "${1}"
		return
	fi

	declare -A a_hash
	while [ $# -ne 0 ]; do
		if test "${a_hash["${1}"]+isset}"; then
			shift
			continue
		fi
		a_hash["${1}"]=1
		echo "${1}"
	done
}

function print_vars {
	local v

	for v in $(compgen -A variable OVE_INSTANCE_); do
		if [ "${!v}" != "" ]; then
			# shellcheck disable=SC2086
			echo "${v/OVE_INSTANCE_}=$(_uniq ${!v})"
		fi
	done | tr ',' '#' | xargs
}

# $1: file
function save_instance_config {
	# shellcheck disable=SC2086
	if ! "$(instance_runtime)"${instance_global_flags} config show ${instance_name} > "$1"; then
		return 1
	fi
}

# $1: file
function set_instance_config {
	# shellcheck disable=SC2086
	if ! "$(instance_runtime)"${instance_global_flags} config edit ${instance_name} < "$1"; then
		return 1
	fi
}

function set_instance_description {
	local f

	f="${OVE_TMP}/${tag}-$(instance_runtime)-config-init"
	g="${OVE_TMP}/${tag}-$(instance_runtime)-config-desc"
	if ! save_instance_config "$f"; then
		exit 1
	elif ! cp -a "$f" "$g"; then
		exit 1
	elif ! sed -i "s,^description:.*,description: \"${_args:?} $(print_vars)\"," "$g"; then
		exit 1
	elif ! set_instance_config "$g"; then
		exit 1
	fi

	rm "$g"
}

function launch_instance {
	_echo "$(instance_runtime)${instance_global_flags} launch ${image} ${instance_name} ${OVE_INSTANCE_EXTRA_ARGS//\#/ }"

	# shellcheck disable=SC2086
	if ! "$(instance_runtime)"${instance_global_flags} launch ${image} ${instance_name} ${OVE_INSTANCE_EXTRA_ARGS//\#/ } > /dev/null; then
		exit 1
	fi
	trap cleanup EXIT

	# use instance description for args and env vars
	set_instance_description

	wait_for_instance

	if ! instance_exec_no_exit "test -d /var/tmp"; then
		mkdir_var_tmp
	fi

	if [[ ${OVE_INSTANCE_STEPS} == *verbose* ]] && is_cluster; then
		# shellcheck disable=SC2086
		_echo "location:$(cluster_get_instance_location)"
	fi
}

function prepare_bootcheck {
	cat > "${OVE_TMP}/${tag}-bootcheck.sh" <<EOF
#!/usr/bin/env sh

if [ ! -s /root/${tag}-packman ]; then
	if command -v apk > /dev/null; then
		packman="apk"
	elif command -v pacman > /dev/null; then
		packman="pacman"
	elif command -v apt-get > /dev/null; then
		packman="apt-get"
	elif command -v dnf > /dev/null; then
		packman="dnf"
	elif command -v zypper > /dev/null; then
		packman="zypper"
	elif command -v xbps-install > /dev/null; then
		packman="xbps"
	elif command -v opkg > /dev/null; then
		packman="opkg"
	elif command -v nix-env > /dev/null; then
		packman="nix-env"
	else
		echo "bootcheck: unknown package manager for ${image}"
		packman="unknown"
	fi
	echo "\$packman" > /root/${tag}-packman
fi

if command -v systemctl > /dev/null; then
	cmd="systemctl is-system-running"
	exp="running"
elif command -v rc-status > /dev/null; then
	cmd="rc-status -r"
	exp="default"
elif command -v sv > /dev/null; then
	cmd="readlink -f /etc/runit/runsvdir/current"
	exp="/etc/runit/runsvdir/default"
elif command -v runlevel > /dev/null; then
	cmd="runlevel"
	exp="N 2"
elif command -v procd > /dev/null; then
	cmd="sleep 1"
	exp=""
else
	exit 0
fi

i=0
while true; do
	i=\$((i+1))
	if [ \$i -ge 100 ]; then
		exit 0
	fi
	s=\$(\$cmd 2> /dev/null);
	if [ "\$s" = "\$exp" ]; then
		break
	fi
	sleep 0.1
done
exit 0
EOF
	if [[ ${OVE_INSTANCE_STEPS} == *verbose* ]]; then
		sed -i -e "2iset -x" "${OVE_TMP}/${tag}-bootcheck.sh"
	fi

	instance_file_push_root \
		"${OVE_TMP}/${tag}-bootcheck.sh" \
		"${instance_name}/root/${tag}-bootcheck.sh"
}

function wait_for_instance {
	while true; do
		if instance_exec_no_exit_as_root "sh -c true"; then
			break
		fi
		sleep 1
	done
}

function run_bootcheck {
	instance_exec_no_exit_as_root "sh /root/${tag}-bootcheck.sh"
	wait_for_ip
}

function prepare_package_manager {
	if [[ ( ${OVE_INSTANCE_STEPS} == *user* && ${EUID} -ne 0 ) || \
		( ${OVE_INSTANCE_STEPS} == *ssh* ) || \
		( ${OVE_INSTANCE_STEPS} == *ove* ) ]]; then
		setup_package_manager
	fi
}

function wait_for_ip {
	local i

	if [[ ${image} == *openwrt* ]]; then
		_echo "openwrt: sleep 5: wait for real IPv4 address"
		sleep 5
	fi

	i=0
	while true; do
		((i++))
		if [ $i -ge 100 ]; then
			echo "error: no IPv4 address for ${instance_name}" 1>&2
			exit 1
		fi

		# shellcheck disable=SC2086
		instance_ip=$("$(instance_runtime)"${instance_global_flags} list -c4 --format csv ${instance_name})
		instance_ip=${instance_ip% *}
		if [ "${instance_ip}" = "" ]; then
			_echo "waiting for IPv4 address for ${instance_name} ($i)"
			sleep 1
			continue
		fi
		_echo "${instance_name}=${instance_ip}"
		break
	done
}

function run_X {
	if [[ ${OVE_INSTANCE_STEPS} != *X* ]]; then
		return 0
	fi

	# let cron start Xpra on reboot
	instance_exec "echo @reboot xpra ${OVE_INSTANCE_XPRA_SERVER_ARGS//:/ } --start-child=${OVE_INSTANCE_XPRA_DE_CMD} --exit-with-children | crontab -"

	# running as user => enable-linger (for Xpra)
	if [[ ${OVE_INSTANCE_STEPS} = *user* ]]; then
		instance_exec_no_exit "command -v loginctl > /dev/null && loginctl enable-linger ${OVE_INSTANCE_USER:?}"
	fi

	# restart
	restart_instance

	if [ "${OVE_INSTANCE_XPRA_CLIENT_ARGS}" != "" ]; then
		i=0
		while true; do
			((i++))
			if [ $i -ge 10 ]; then
				echo "error: xpra server is not alive" 1>&2
				exit 1
			elif ! xpra info --ssh="ssh -oRemoteCommand=none" ssh://"${instance_name}" &> /dev/null; then
				sleep $((RANDOM % 3 + 1))
				continue
			fi
			break
		done

		# shellcheck disable=SC2086
		xpra ${OVE_INSTANCE_XPRA_CLIENT_ARGS:?} \
			--ssh="ssh -oRemoteCommand=none" ssh://"${instance_name}" \
			--title "${instance_name} ${instance_ip}" &
		xpra_pid="$!"
	fi
}

function wait_X {
	if [[ ${OVE_INSTANCE_STEPS} == *X* ]] && kill -0 "${xpra_pid}" 2> /dev/null; then
		wait "${xpra_pid}"
	fi
}

function prepare_X {
	if [[ ( ${OVE_INSTANCE_STEPS} == *user* && ${EUID} -ne 0 ) || \
		( ${OVE_INSTANCE_STEPS} == *ssh* ) || \
		( ${OVE_INSTANCE_STEPS} == *ove* ) ]]; then
		if [[ ${OVE_INSTANCE_STEPS} == *X* ]]; then
			if [[ ${package_manager:?} == apt-get* ]];  then
				setup_X_deb
			elif [[ ${package_manager:?} == dnf* ]];  then
				setup_X_rpm
			elif [[ ${package_manager:?} == apk* ]];  then
				setup_X_apk
			else
				echo "error: X for '${image}' is not supported" 1>&2
				exit 1
			fi
		fi
	fi
}

function setup_sshd {
	if [[ ( ${OVE_INSTANCE_STEPS} == *user* && ${EUID} -ne 0 ) || \
		( ${OVE_INSTANCE_STEPS} == *ssh* ) || \
		( ${OVE_INSTANCE_STEPS} == *ove* ) ]]; then
		if [[ ${OVE_INSTANCE_STEPS} == *ssh* ]]; then
			_setup_sshd
		fi
	fi
}

function update_package_manager {
	local args
	local i

	if [[ ( ${OVE_INSTANCE_STEPS} == *user* && ${EUID} -ne 0 ) || \
		( ${OVE_INSTANCE_STEPS} == *ssh* ) || \
		( ${OVE_INSTANCE_STEPS} == *ove* ) ]]; then
		true "${package_manager:?}"
	else
		return 0
	fi

	i=0
	while true; do
		((i++))
		if [ $i -ge 100 ]; then
			echo "error: update packages failed for ${instance_name}" 1>&2
			exit 1
		elif [ "${packman}" = "nix-env" ]; then
			if ! instance_exec_no_exit_as_root "nix-channel --update"; then
				sleep $((RANDOM % 5))
				continue
			fi

			_echo "sleep 1s to get nix package manager ready"
			sleep 1
			break
		fi

		args="update"
		if [ "${packman}" = "apt-get" ]; then
			args+=" -y"
		elif [ "${packman}" = "xbps" ]; then
			args="-Syu"
		elif [ "${packman}" = "dnf" ]; then
			args+=" -y"
		elif [ "${packman}" = "zypper" ]; then
			args+=" -y"
		elif [ "${packman}" = "pacman" ]; then
			args="-Syu --noconfirm"
		fi

		if ! instance_exec_no_exit_as_root "${package_manager%% *} $args"; then
			sleep $((RANDOM % 5))
			continue
		fi
		break
	done
}

function prepare {
	local a
	local i
	local n
	local r
	local remotes
	local z

	if [ "${OVE_LAST_COMMAND}" != "" ]; then
		# re-use date+time (ignore micro/nano) from OVE_LAST_COMMAND
		tag="${OVE_LAST_COMMAND##*/}"
		tag="${tag:0:18}"
	else
		tag="$(date '+%Y%m%d-%H%M%S%N')"
	fi

	while true; do
		if [ ! -e "${OVE_GLOBAL_STATE_DIR}/${tag}" ]; then
			break
		fi
		# tag already used, append a random number"
		tag="${tag}-${RANDOM}"
	done
	touch "${OVE_GLOBAL_STATE_DIR}/${tag}"

	if [ "${OVE_INSTANCE_NAME}" != "" ]; then
		instance_name="${OVE_INSTANCE_NAME}"
	elif [ "${OVE_INSTANCE_NAME_RANDOM}" != "" ]; then
		a=$(grep -o -w -E '[a-z]{6}ed' "${OVE_SELF:?}" | \
			sort -u | \
			shuf -n 1)
		z=$(grep -o -w -E '[a-z]{8}' "${OVE_SELF:?}" | \
			grep -v 'ed$' | \
			sort -u | \
			shuf -n 1)
		instance_name="${a}-${z}"
	else
		# remove any leading remote name
		mapfile -t remotes < <($(instance_runtime) remote list --format=csv -cn)
		n=${image}
		for r in "${remotes[@]}"; do
			if [[ "$n" == $r:* ]]; then
				n=${n//$r:}
				break
			fi
		done
		instance_name="${OVE_USER}-${tag}-${n}"
	fi

	if [ "${OVE_INSTANCE_NAME}" = "" ] && \
		[ "${OVE_INSTANCE_NAME_PREFIX}" != "" ]; then
		instance_name="${OVE_INSTANCE_NAME_PREFIX}-${instance_name}"
	fi

	_echo "info: replace all spaces, slashes, dots, underscores and colons with hyphen-minus"
	instance_name="${instance_name// /-}"
	instance_name="${instance_name//\//-}"
	instance_name="${instance_name//./-}"
	instance_name="${instance_name//_/-}"
	instance_name="${instance_name//:/-}"

	if [ ${#instance_name} -gt 63 ]; then
		_echo "info: $(instance_runtime) name is ${#instance_name} chars, max allowed is 63. Truncating."
		instance_name=${instance_name:0:63}
	fi

	while true; do
		if [ "${#instance_name}" -eq 0 ]; then
			echo "error: $(instance_runtime) name can not be empty" 1>&2
			exit 1
		elif [ "${instance_name:0:1}" = "-" ]; then
			_echo "info: instance name '${instance_name}' can not start with hyphen-minus"
			instance_name="${instance_name:1}"
			continue
		elif [ "${instance_name: -1}" = "-" ]; then
			_echo "info: instance name '${instance_name}' can not end with hyphen-minus"
			instance_name="${instance_name::-1}"
			continue
		fi

		break
	done

	if [[ ${OVE_INSTANCE_STEPS} == *verbose* ]]; then
		echo
		for i in $(seq 1 $((OVE_COLUMNS / 2 - ${#instance_name}/2))); do
			echo -n " "
		done
		ove_echo_blue_noprefix "${instance_name}"
		echo
	fi

	# ephemeral instance?
	if [[ ${OVE_INSTANCE_STEPS} != *running* ]] && \
		[[ ${OVE_INSTANCE_STEPS} != *stopped* ]]; then
			ephemeral=1
			OVE_INSTANCE_EXTRA_ARGS+=" --ephemeral"
			OVE_INSTANCE_STEPS+=" stopped"
	fi

	if [[ ${image} == *archlinux* ]] || [[ ${image} == *fedora* ]] || [[ ${image} == *nixos* ]]; then
		OVE_INSTANCE_EXTRA_ARGS+=" -c security.nesting=true"
	fi
}

function run_services {
	if [ ! -s "${OVE_TMP}/${tag}-services.sh" ]; then
		return
	fi

	instance_file_push_root \
		"${OVE_TMP}/${tag}-services.sh" \
		"${instance_name}/root/${tag}-services.sh"
	instance_exec_no_exit_as_root "sh /root/${tag}-services.sh"
}

function prepare_ssh {
	if [[ ${OVE_INSTANCE_STEPS} != *ssh* ]]; then
		return 0
	elif [ "$1" != "root" ]; then
		if [ ${EUID} -eq 0 ]; then
			return 0
		elif [[ ${OVE_INSTANCE_STEPS} != *user* ]]; then
			return 0
		fi
	fi

	setup_ssh "$1"
}

function restart_instance {
	run "$(instance_runtime)${instance_global_flags} restart ${instance_name}"
	wait_for_instance
	run_bootcheck

	if [[ ${OVE_INSTANCE_STEPS} == *ssh* ]]; then
		cat > "${OVE_TMP}/${tag}-wait-for-ssh-daemon.sh" <<EOF
#!/usr/bin/env sh

i=0
while true; do
i=\$((i+1))
if [ \$i -gt 100 ]; then
	echo "error: sshd did not start"
	exit 1
elif [ \$(( i % 10 )) -eq 0 ]; then
	sh /root/${tag}-restart-ssh-daemon.sh
elif pgrep -f sshd > /dev/null 2>&1; then
	sleep 1
	break
fi

sleep 0.1
done
EOF

		if [[ ${OVE_INSTANCE_STEPS} == *verbose* ]]; then
			sed -i -e "2iset -x" "${OVE_TMP}/${tag}-wait-for-ssh-daemon.sh"
		fi

		instance_file_push_root \
			"${OVE_TMP}/${tag}-wait-for-ssh-daemon.sh" \
			"${instance_name}/root/${tag}-wait-for-ssh-daemon.sh"
		instance_exec_as_root "sh /root/${tag}-wait-for-ssh-daemon.sh"
	fi
}

function expose_user {
	local f
	local sul
	local t

	if [ ${EUID} -eq 0 ]; then
		return 0
	elif [[ ${OVE_INSTANCE_STEPS} != *user* ]]; then
		return 0
	fi

	if [[ ${image} == *nixos* ]]; then
		instance_exec "${package_manager} nixos.bash >/dev/null 2>&1"
		instance_exec "${package_manager} nixos.sudo >/dev/null 2>&1"
	else
		instance_exec "${package_manager} bash >/dev/null 2>&1"
		instance_exec "${package_manager} sudo >/dev/null 2>&1"
	fi

	if [[ ${image} == *alpine* ]]; then
		instance_exec "${package_manager} shadow shadow-login" > /dev/null
	elif [[ ${image} == *openwrt* ]]; then
		instance_exec "${package_manager} shadow-useradd" > /dev/null
	fi

	# create user?
	if ! instance_exec_no_exit "id -u ${OVE_INSTANCE_USER:?}" &> /dev/null; then
		if instance_exec_no_exit "command -v which > /dev/null"; then
			f=$(instance_exec "which bash" 2> /dev/null)
			f=${f//[$'\t\r\n']/}
		fi
		instance_exec "useradd --shell ${f:-/bin/bash} -m -d ${OVE_HOME:?} ${OVE_INSTANCE_USER:?}"
	fi

	if ! _uid=$(get_id "uid"); then
		exit 1
	elif ! _gid=$(get_id "gid"); then
		exit 1
	fi
	_home=${OVE_HOME}

	_echo "user: idmap"
	run "$(instance_runtime)${instance_global_flags} config set ${instance_name} security.idmap.isolated true"
	run "$(instance_runtime)${instance_global_flags} config set ${instance_name} security.idmap.base 200000000"

	# raw.idmap can not be updated when a VM is running
	t=$("$(instance_runtime)"${instance_global_flags} list -f csv -c t ${instance_name:?})
	if [ "$t" = "VIRTUAL-MACHINE" ]; then
		run "$(instance_runtime)${instance_global_flags} stop ${instance_name:?}"
	fi

	# shellcheck disable=SC2086
	printf "uid %s ${_uid}\ngid %s ${_gid}" "$(id -u)" "$(id -g)" | \
		"$(instance_runtime)"${instance_global_flags} config set "${instance_name}" raw.idmap -

	if [ "$t" = "VIRTUAL-MACHINE" ]; then
		run "$(instance_runtime)${instance_global_flags} start ${instance_name:?}"
		wait_for_instance
	fi

	_echo "user: sudo"
	if instance_exec_no_exit "test -d /etc/sudoers.d/"; then
		echo "${OVE_INSTANCE_USER:?} ALL=(ALL) NOPASSWD:ALL" > "${OVE_TMP}/${tag}-sudoers"
		instance_file_push_root \
			"${OVE_TMP}/${tag}-sudoers" \
			"${instance_name}/etc/sudoers.d/91-ove"
	elif instance_exec_no_exit "test -s /etc/sudoers"; then
		instance_exec "sed -i '$ a ${OVE_INSTANCE_USER:?} ALL=(ALL) NOPASSWD:ALL' /etc/sudoers"
	else
		_echo "warning: could not find /etc/sudoers.d nor /etc/sudoers"
	fi

	if instance_exec_no_exit "[ -s /etc/pam.d/su ]"; then
		sul=$(instance_exec_no_exit "grep -n '^auth.*sufficient.*pam_rootok.so' /etc/pam.d/su" | cut -d: -f1)
		if [ "${sul}" = "" ]; then
			_echo "warning: user: could not get auth line number from '/etc/pam.d/su'"
		else
			_echo "user: su: update '/etc/pam.d/su' to allow su without passwd"
			sul=$((sul + 1))
			instance_exec_no_exit_as_root "sed -i '${sul}iauth  [success=ignore default=1] pam_succeed_if.so user = root' /etc/pam.d/su"
			sul=$((sul + 1))
			instance_exec_no_exit_as_root "sed -i '${sul}iauth sufficient pam_succeed_if.so use_uid user = ${OVE_INSTANCE_USER:?}' /etc/pam.d/su"
			_echo "user: su: add '${OVE_INSTANCE_USER:?}' to 'root' group"
			if [[ ${image} == *openwrt* ]]; then
				instance_exec_no_exit_as_root "${package_manager} shadow-usermod" > /dev/null
			fi

			instance_exec_no_exit_as_root "usermod -a -G root ${OVE_INSTANCE_USER:?}"
		fi
	fi

	restart_instance
}

function prepare_ove {
	local ove_packs
	local re

	if [[ ${OVE_INSTANCE_STEPS} != *ove* ]]; then
		return 0
	elif [ "${packman}" = "apt-get" ]; then
		ove_packs="bsdmainutils procps "
	fi

	ove_packs+="bash bzip2 git curl file binutils coreutils tar make"
	if [[ ${image} = *nixos* ]]; then
		ove_packs="nixos.bash nixos.bzip2 nixos.git nixos.curl nixos.file nixos.binutils nixos.coreutils nixos.gnumake"
	elif [[ ${image} = *openwrt* ]]; then
		ove_packs+=" coreutils-comm"
		ove_packs+=" coreutils-du"
		ove_packs+=" coreutils-nproc"
		ove_packs+=" coreutils-readlink"
		ove_packs+=" coreutils-sort"
		ove_packs+=" coreutils-stat"
		ove_packs+=" coreutils-stty"
		ove_packs+=" coreutils-tac"
		ove_packs+=" coreutils-timeout"
		ove_packs+=" coreutils-tsort"
		ove_packs+=" diffutils"
		ove_packs+=" findutils"
		ove_packs+=" less"
		ove_packs+=" script-utils"
		ove_packs+=" sed"

		instance_exec_as_root "sh -c '
		opkg update
		opkg install gcc grep make libtool-bin
		wget https://mirrors.edge.kernel.org/pub/linux/utils/util-linux/v2.40/util-linux-2.40-rc1.tar.gz
		wget https://ftp.gnu.org/pub/gnu/gettext/gettext-0.22.5.tar.gz
		tar xvzf gettext-0.22.5.tar.gz
		cd gettext-0.22.5
		cd libtextstyle
		./configure
		make -j
		make install
		cd ../gettext-runtime
		./configure
		make -j
		make install
		cd ..
		cp -a /usr/local/include/textstyle* gettext-tools/src
		cp -a /usr/local/lib/libtextstyle.* libtextstyle/lib
		cd gettext-tools
		./configure
		make -j
		make install
		cd ../..
		tar xvzf util-linux-2.40-rc1.tar.gz
		cd util-linux-2.40-rc1
		opkg install flex bison automake
		./configure
		make -j
		make install || true'"
	else
		ove_packs+=" util-linux"
		re="fedora.*(42|43)"
		if [[ ${image} =~ ${re} ]]; then
			ove_packs+=" util-linux-script"
		fi
	fi

	# refresh packages
	update_package_manager

	# install OVE packages
	instance_exec_as_root "${package_manager} ${ove_packs}"

	if [[ ${image} == *archlinux* ]]; then
		instance_exec "sed -i 's|#en_US.UTF-8 UTF-8|en_US.UTF-8 UTF-8|g' /etc/locale.gen"
		instance_exec "locale-gen"
	elif [[ ${image} == *openwrt* ]]; then
		instance_exec_as_root "sh -c '
		rm /usr/bin/xargs
		echo exec busybox xargs \$\@ > /usr/bin/xargs
		chmod +x /usr/bin/xargs'"
	fi
}

function user_exec {
	if [[ ${OVE_INSTANCE_STEPS} != *user* ]]; then
		return 0
	elif [ ${EUID} -eq 0 ]; then
		return 0
	fi

	# from now on, run all exec commands as user
	export INSTANCE_EXEC_EXTRA="--user ${_uid} --group ${_gid} --env HOME=${OVE_HOME}"
}

function run_ove {
	local i

	if [[ ${OVE_INSTANCE_STEPS} != *ove* ]]; then
		return 0
	fi

	# gitconfig
	if [ -s "${OVE_HOME}"/.gitconfig ]; then
		cp -a "${OVE_HOME}"/.gitconfig "${OVE_TMP}/${tag}-gitconfig"
		instance_file_push_user \
			"${OVE_TMP}/${tag}-gitconfig" \
			"${instance_name}${_home}/.gitconfig"
	fi

	# oveconfig
	if [ -s "${OVE_HOME}"/.oveconfig ] && [ ${unittest} -eq 0 ]; then
		cp -a "${OVE_HOME}"/.oveconfig "${OVE_TMP}/${tag}-oveconfig"
		instance_file_push_user \
			"${OVE_TMP}/${tag}-oveconfig" \
			"${instance_name}${_home}/.oveconfig"
	fi

	# ove.bash
	if [ -s "${OVE_HOME}"/.ove.bash ]; then
		cp -a "${OVE_HOME}"/.ove.bash "${OVE_TMP}/${tag}-ove.bash"
		instance_file_push_user \
			"${OVE_TMP}/${tag}-ove.bash" \
			"${instance_name}${_home}/.ove.bash"
		# append to bashrc
		if instance_exec_no_exit "[ -s ${_home}/.bashrc ]"; then
			instance_exec "sed -i '$ a source ~/.ove.bash' ${_home}/.bashrc"
		else
			echo "source ~/.ove.bash" > "${OVE_TMP}/${tag}-bashrc"
			instance_file_push_user \
				"${OVE_TMP}/${tag}-bashrc" \
				"${instance_name}${_home}/.bashrc"
		fi
	fi

	if [[ ${OVE_INSTANCE_STEPS} == *user* ]]; then
		# expose OVE workspace
		run "$(instance_runtime)${instance_global_flags} config device add ${instance_name} ove-base disk source=${OVE_BASE_DIR} path=${OVE_BASE_DIR}"
		run "$(instance_runtime)${instance_global_flags} config device add ${instance_name} ove-tmp disk source=${OVE_TMP} path=${OVE_TMP}"
		run "$(instance_runtime)${instance_global_flags} config device add ${instance_name} ove-state disk source=${OVE_GLOBAL_STATE_DIR} path=${OVE_GLOBAL_STATE_DIR}"
		ws_name="${OVE_BASE_DIR}"
		prefix="cd ${ws_name}; source ove hush"

		i=0
		while true; do
			((i++))
			if [ $i -ge 100 ]; then
				echo "error: not possible to exec commands" 1>&2
				exit 1
			elif instance_exec_no_exit "true"; then
				break
			fi
			_echo "not possible to exec commands ($i)" 1>&2
			sleep 0.1
		done
	else
		if [ -x "${OVE_OWEL_DIR}/SETUP" ]; then
			instance_file_push_user \
				"${OVE_OWEL_DIR}/SETUP" \
				"${instance_name}${_home}/SETUP"
			instance_exec "bash ${_home}/SETUP"
		else
			instance_exec "bash -c '$(XDG_SESSION_TYPE='' ove-oneliner)'"
		fi
		ws_name=$(instance_exec "bash -c 'find -mindepth 2 -maxdepth 2 -name .owel' | cut -d/ -f2")
		ws_name=${ws_name//[$'\t\r\n']/}
		if [ "${ws_name}" = "" ]; then
			ws_name="ove-tutorial"
			_echo "using ${ws_name} as OVE workspace (fallback)"
			instance_exec "bash -c 'curl -sSL https://raw.githubusercontent.com/Ericsson/ove/master/setup | bash -s ${ws_name} https://github.com/Ericsson/${ws_name}'"
		fi
		prefix="cd ${ws_name}; source ove hush"
	fi

	if [ ${unittest} -eq 1 ]; then
		instance_exec "bash ${bash_opt} -c 'cd ${ws_name}; source ove'"
		instance_exec "bash ${bash_opt} -c '${prefix}; ove-env'"
		instance_exec "bash ${bash_opt} -c '${prefix}; ove-list-externals'"
		instance_exec "bash ${bash_opt} -c '${prefix}; ove-status'"
	fi

	# sanity check mktemp
	if ! instance_exec "mktemp" &> /dev/null; then
		exit 1
	fi

	if [[ ${OVE_INSTANCE_STEPS} = *ove* ]] && [[ ${OVE_INSTANCE_STEPS} = *user* ]]; then
		# sanity check /dev/ptmx (for OVE and script)
		if ! instance_exec_no_exit "[ -w /dev/ptmx ]"; then
			instance_exec_as_root "chmod 0666 /dev/ptmx"
		fi
	fi

	# sanity check OVE
	if ! instance_exec "bash ${bash_opt} -c '${prefix}; ove-nop'"; then
		exit 1
	fi

	# no questions asked
	package_manager_noconfirm
	if [ ${unittest} -eq 0 ] && [[ ${image} == *opensuse* ]]; then
		instance_exec "sudo zypper install -y -t pattern devel_basis"
	fi
}

function prepare_unittest {
	if [ ${unittest} -eq 0 ]; then
		return 0
	fi

	if [[ ${image} == *nixos* ]]; then
		instance_exec_as_root "${package_manager} nixos.python3"
	else
		instance_exec_as_root "${package_manager} python3"
	fi

	if [[ ${image} == *alpine* ]]; then
		instance_exec_as_root "${package_manager} py3-yaml"
	elif [[ ${image} == *archlinux* ]]; then
		instance_exec_as_root "${package_manager} python-yaml"
	elif [[ ${image} == *opensuse* ]]; then
		instance_exec_as_root "${package_manager} python3-PyYAML"
	elif [[ ${image} == *nixos* ]]; then
		instance_exec_as_root "${package_manager} nixos.python3Packages.pyyaml"
	else
		instance_exec_as_root "${package_manager} python3-yaml"
	fi

	# push shunit2 to instance
	instance_file_push_user \
		"$(command -v shunit2)" \
		"${instance_name}/var/tmp/shunit2"
}

function run_unittest {
	if [ ${unittest} -eq 0 ]; then
		return 0
	fi

	instance_exec_as_user "bash ${bash_opt} -c '${prefix}; ove-unittest $OVE_UNITTEST_TC'"
}

function run_entry_ove {
	if [ "${entry}" = "" ]; then
		return 0
	elif [[ ${OVE_INSTANCE_STEPS} != *ove* ]]; then
		return 0
	fi

	# sanity check project
	if ! instance_exec_no_exit "bash ${bash_opt} -c '${prefix}; ove-list-projects ${entry} > /dev/null'"; then
		exit 1
	fi

	packs=$(instance_exec "bash ${bash_opt} -c '${prefix}; DEBIAN_FRONTEND=noninteractive ove-list-needs ${entry}'")
	packs=${packs//[$'\t\r\n']/ }
	if [ "${packs}" != "" ]; then
		instance_exec_as_root "${package_manager} ${packs}"
	fi

	# worktree?
	if [[ ${OVE_INSTANCE_STEPS} == *worktree* ]]; then
		instance_exec "bash ${bash_opt} -c '${prefix}; ove-add-config ${_home}/.oveconfig OVE_REVTAB_CHECK 0'"
		if [[ ${OVE_INSTANCE_STEPS} == *user* ]]; then
			worktree_dir="${OVE_TMP}/${tag}"
		else
			worktree_dir="/var/tmp/${tag}"
		fi

		instance_exec "bash ${bash_opt} -c '${prefix}; ove-worktree add ${worktree_dir}'"
		# configurable?
		instance_exec "bash ${bash_opt} -c '${prefix}; ove-replicate localhost ${worktree_dir}'"
		prev_prefix="${prefix}"
		prefix="cd ${worktree_dir}; source ove hush"
	fi

	instance_exec "bash ${bash_opt} -c '${prefix}; OVE_AUTO_CLONE=1 ove entry ${entry}'"

	# remove the worktree if ephemeral
	if [[ ${OVE_INSTANCE_STEPS} == *worktree* ]]; then
		if [ ${ephemeral} -eq 0 ]; then
			_echo "the worktree '${worktree_dir}' is kept intact"
		else
			instance_exec "bash ${bash_opt} -c '${prev_prefix}; ove-worktree remove ${worktree_dir}'"
		fi
	fi
}

function run_entry_cmd {
	if [ "${entry}" = "" ]; then
		return 0
	elif [[ ${OVE_INSTANCE_STEPS} = *ove* ]]; then
		return 0
	elif [ -s "${entry}" ]; then
		cp -a "${entry}" "${OVE_TMP}/${tag}.cmd"
	else
		echo "${entry}" > "${OVE_TMP}/${tag}.cmd"
	fi

	chmod +x "${OVE_TMP}/${tag}.cmd"

	instance_file_push_root \
		"${OVE_TMP}/${tag}.cmd" \
		"${instance_name}/var/tmp/${tag}.cmd"
	instance_exec "/var/tmp/${tag}.cmd"
}

function push_files_helper() {
	declare -a _arr
	local d
	local i
	local s

	IFS=";" read -r -a _arr <<< "${1:?}"
	for i in "${!_arr[@]}"; do
		s=${_arr[i]%%:*}
		d=${instance_name}${_arr[i]##*:}
		instance_file_push_"${2:?}" \
			"${s}" \
			"${d}" \
			"--create-dirs"
	done
}

function push_files() {
	if [ "${OVE_INSTANCE_ROOT_FILES}" != "" ]; then
		push_files_helper "${OVE_INSTANCE_ROOT_FILES}" "root"
	fi

	if [ "${OVE_INSTANCE_USER_FILES}" != "" ]; then
		push_files_helper "${OVE_INSTANCE_USER_FILES}" "user"
	fi
}

function main {
	init "$@"
	prepare
	launch_instance
	prepare_bootcheck
	run_bootcheck
	prepare_package_manager
	update_package_manager
	setup_sshd
	prepare_X
	run_services
	prepare_ssh "root"
	expose_user
	prepare_ssh "${OVE_INSTANCE_USER:?}"
	prepare_ove
	user_exec
	update_ssh_config
	run_X
	run_ove
	prepare_unittest
	run_unittest
	push_files
	run_entry_ove
	run_entry_cmd
	wait_X
}

main "$@"
