#!/usr/bin/env bash
# SPDX-License-Identifier: MIT
#
# MIT License
#
# Copyright (c) 2019 Ericsson
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is furnished
# to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice (including the next
# paragraph) shall be included in all copies or substantial portions of the
# Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
# FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS
# OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
# OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

function ove_read_config {
	local p
	local p_arr
	local val
	local var

	if [ -e "$1" ]; then
		while read p; do
			# ignore comments
			[[ $p == \#* ]] && continue
			# ignore empty lines
			[[ $p == '' ]] && continue
			p_arr=( $p )
			var=${p_arr[0]}
			if [ "$2" == "clean" ]; then
				unset $var
			else
				val=${p_arr[*]:1}
				eval $var=\"$val\"
				export $var
			fi
		done <$1
	fi
}

function ove_unsource {
	# remove stage string from $PATH
	if [ "$OVE_STAGE_DIR" != "" ] && \
		[[ $PATH == *"$OVE_STAGE_DIR"* ]]; then
		PATH=${PATH/:${OVE_STAGE_DIR}${OVE_PREFIX}\/bin/}
		export PATH
	fi

	unset LD_LIBRARY_PATH

	# clean config variables
	if [ -e $HOME/.oveconfig ]; then
		ove_read_config $HOME/.oveconfig clean
	elif [ "${OVE_PROJECT_DIR}" != "" ] && \
		[ -e "${OVE_PROJECT_DIR}/.oveconfig" ]; then
		ove_read_config ${OVE_PROJECT_DIR}/.oveconfig clean
	fi

	# unset old ove[-_] functions
	unset -f $(compgen -A function | \
		grep -E '^ove($|[-_])' | \
		grep -E -v "ove_read_config|ove-unsource|$FUNCNAME" | \
		awk '{print $1}')

	# unset old ove_/OVE_ variables
	unset $(set -o posix ; set | \
		grep -i ^ove_ | \
		cut -d= -f1)

	# unset completion for ove
	if complete -p | grep -q ' ove$'; then
		complete -r ove
	fi
}

# unsource: :clean up all OVE vars/funcs from this shell
function ove-unsource {
	ove_unsource
	# unset leftovers and myself
	unset -f $(compgen -A function | \
		grep -E '^ove($|[-_])' | \
		awk '{print $1}') \
		$FUNCNAME
}

# interactive shell? clean up
[[ $- == *i* ]] && ove_unsource

function ove_welcome_msg {
	echo
	echo "This script will do a few things:"
	echo

	echo "* add $(set | grep -c ^ove-) bash functions:"
	set | \
		grep ^ove- | \
		cut -d' ' -f1 | \
		column
	echo
	( set -o posix ; set ) | \
		cut -d= -f1 > $OVE_TMP/bash-vars-after

	ove_bash_vars_diff=($(comm -1 -3 <(sort $OVE_TMP/bash-vars-before) <(sort $OVE_TMP/bash-vars-after) | sort ))
	rm $OVE_TMP/bash-vars-after $OVE_TMP/bash-vars-before
	echo "* add ${#ove_bash_vars_diff[@]} bash variables:"
	echo ${ove_bash_vars_diff[*]} | \
		xargs -n1 | \
		column
	unset ove_bash_vars_diff

	echo
	echo "* enable tab completion for ove"

	echo
	echo "Now what? Run 'ove fetch' to sync with the outside world or 'ove help' for more information"
}

function ove_main {
	/proc/self/exe --version | grep -q 'GNU bash'
	test $? -ne 0 && echo 'error: run this in bash' && return 1

	if [ ${BASH_VERSINFO[0]} -lt 4 ]; then
		echo "error: bash ${BASH_VERSINFO[0]}.${BASH_VERSINFO[1]} is way too old. I need bash 4.3+"
		return 1
	elif [ ${BASH_VERSINFO[0]} -eq 4 ] && [ ${BASH_VERSINFO[0]} -lt 3 ]; then
		echo "error: bash ${BASH_VERSINFO[0]}.${BASH_VERSINFO[1]} is too old. I need bash 4.3+"
		return 1
	fi

	# pretty terminals
	if [ -t 1 ]; then
		ove_green='\033[0;32m'
		ove_cyan='\033[0;36m'
		ove_yellow='\033[1;33m'
		ove_red='\033[0;31m'
		ove_blank='\033[0m'
	else
		ove_green=''
		ove_cyan=''
		ove_yellow=''
		ove_red=''
		ove_blank=''
	fi

	OVE_TMP=/tmp/$USER/ove
	export OVE_TMP
	! [ -d "$OVE_TMP" ] && mkdir -p "$OVE_TMP"

	# set OVE_OS_* variables
	ove_determine_dist_version_and_pack_manager

	# interactive shell?
	if [[ $- == *i* ]]; then
		# turn off monitor mode to get rid of "Done" messages
		set +m

		( set -o posix ; set ) | \
			cut -d= -f1 | \
			grep -v ^OVE > $OVE_TMP/bash-vars-before

		if ! ove_deps; then
			ove-unsource
			return 1
		fi

		if [[ "$*" == *"crawl"* ]]; then
			ove_crawl
			return 0
		fi

		if [ -e ".owel" ] && [ -e ove ]; then
			:
		else
			ove_echo_error_noprefix "you have to source this script from a OVE root"
			ove-unsource
			return 1
		fi

		if ! ove_init; then
			ove-unsource
			return 1
		fi

		ove-version
		if [ $OVE_LOGLEVEL -ne 0 ]; then
			ove_welcome_msg
		fi

		ove_post_checks

		# turn on monitor mode
		set -m
	fi
}

# $1: directory with strace pid files
function ove_analyze_strace_execve_timing {
	local cmd
	local diff
	local f
	local line
	local t0
	local t1

	! [ -d "$1" ] && return 1

	set -o noglob
	for f in $(find $1 -type f); do
		line=$(head -1 $f)
		if [[ "$line" == *"execve"* ]]; then
			cmd=$(echo $line | grep -o '\[.*')
			t0=${line%% *}
			t1=$(tail -1 $f | awk '{print $1}')
			diff=$(awk "BEGIN{printf \"%.6f\n\", ($t1 - $t0)}")
			echo "$diff:$cmd"
		fi
	done | \
		sed -e 's|:\[|: |g' -e 's|\].*=||g' | \
		tr -d '",' | \
		sort -nr
}

# $1: directory with strace pid files
function ove_analyze_strace_connect {
	local f
	local execve
	local ip
	local ip_lookup
	local line
	local port
	local port_lookup

	! [ -d "$1" ] && return 1

	if ! command -v dig > /dev/null; then
		ove_echo_error_noprefix "error: 'dig' is not found"
		return 1
	fi

	if ! command -v whois > /dev/null; then
		ove_echo_error_noprefix "error: 'whois' is not found"
		return 1
	fi

	for f in $(find $1 -type f); do
		# IPv4 only for now
		for line in $(grep -E -o 'port=htons\([0-9]+\).*[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}' $f | tr ' ' '-'); do
			ip=$(echo $line | \
				grep -E -o '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}')

			# ignore loopback
			[[ $ip == 127* ]] && continue

			ip_lookup=$(dig +short -x $ip | \
				tr '\n' ' ' | \
				xargs)
			if [ "$ip_lookup" == "" ]; then
				ip_lookup=$(whois $ip | \
					grep OrgName | \
					cut -d: -f2- | \
					xargs)
			fi

			[ "$ip_lookup" == "" ] && ip_lookup="N/A"
			execve=$(grep -m1 execve $f)
			if [ "$execve" == "" ]; then
				execve="$(grep -m1 connect $f | \
					awk '{print $1}') pid $(basename $f | cut -d'.' -f2)"
			fi

			port=$(echo $line | \
				cut -d'(' -f2- | \
				cut -d')' -f1)

			if [ -e /etc/services ]; then
				port_lookup=$(grep -m1 -w $port /etc/services | \
					awk '{print $1}')
			fi

			if [ "$port_lookup" == "" ]; then
				port_lookup="N/A"
			fi

			echo "$execve @ $ip @ $ip_lookup @ $port @ $port_lookup"
		done
	done | sort -n | column -s'@' -t
}

function ove {
	local args
	local candidates
	local cmd
	local re
	local ret
	local script_help
	local script_opts
	local strace_expression

	cmd="$1"
	if [ "$#" -eq 0 ]; then
		ove-help
	elif [ "$(type -t ove-"${cmd}")" != "function" ]; then
		re=\\b${cmd}
		if ! [[ "$OVE_ALL_COMMANDS" =~ $re ]]; then
			ove_echo_red_noprefix "error: '$cmd' unknown command"
			return 1
		fi

		candidates=$(ove-help $(echo $OVE_ALL_COMMANDS | \
			xargs -n1 | \
			grep --color=never ^${cmd} | \
			sed -e 's/^/^/g' -e 's/$/\\s/g'))

		if [ $OVE_AUTOCORRECT -eq 1 ] && [ $(printf "$candidates\n" | wc -l) -eq 1 ]; then
			cmd=$(printf "$candidates\n" | \
				sed -e "s/\x1B\[[0-9;]*[mK]//g" | \
				awk '{print $1}')
			ove $cmd ${*:2}
			return $?
		fi

		ove_echo_red_noprefix "error: '$cmd' unknown command"
		echo
		echo "Did you mean?"
		printf "$candidates\n"

		return 1
	elif [ "${cmd}" == "!" ] || \
		[ "${cmd}" == "cd" ] || \
		[ "${cmd}" == "dry-run" ] || \
		[ "${cmd}" == "loglevel" ] || \
		[ "${cmd}" == "checkout" ] || \
		[ "${cmd}" == "switch" ] || \
		[ "${cmd}" == "unsource" ]; then
		ove-${cmd} ${@:2}
	else
		# sanity check
		ove_get_base_dir > /dev/null

		args="${*:2}"
		mkdir -p ${OVE_LOG_DIR}/${OVE_SHA}
		(cd ${OVE_LOG_DIR} && ln -sfn ${OVE_SHA} current)
		OVE_NOW=$(date '+%Y%m%d-%H%M%S%N')
		export OVE_NOW
		OVE_LAST_COMMAND="${OVE_LOG_DIR}/${OVE_SHA}/${OVE_NOW}-ove-${cmd}-$(hostname)-${OVE_PROJECT_NAME}.log"

		if [ -t 1 ]; then
			script_help=$(2>&1 script --help)
			if [[ "$script_help" != *"invalid option"* ]] && \
				[[ "$script_help" == *"-e"* ]]; then
				script_opts+="-e "
			fi

			if [ $OVE_LOGLEVEL -eq 3 ] || [ $OVE_LOGLEVEL -eq 4 ]; then
				[ -e ${OVE_PROJECT_TMP_DIR}/strace-${cmd} ] && \
					rm -rf ${OVE_PROJECT_TMP_DIR}/strace-${cmd}
				mkdir -p ${OVE_PROJECT_TMP_DIR}/strace-${cmd}

				if [ $OVE_LOGLEVEL -eq 3 ]; then
					strace_expression="execve"
				elif [ $OVE_LOGLEVEL -eq 4 ]; then
					strace_expression="connect,execve"
				fi

				OVE_ANALYZE_EXECVE="strace \
					-s 1024 \
					-q \
					-o ${OVE_PROJECT_TMP_DIR}/strace-${cmd}/strace-${cmd} \
					-ff \
					-e $strace_expression \
					-ttt"
			else
				unset OVE_ANALYZE_EXECVE
			fi

			SHELL=$(command -v bash) \
				$OVE_ANALYZE_EXECVE script $script_opts -q -c \
				"source $OVE_BASE_DIR/ove; ove_init quick && ove-${cmd} $args" \
				$OVE_LAST_COMMAND
			ret=$?

			if ! [ -z "${OVE_ANALYZE_EXECVE+x}" ]; then
				if [ $OVE_LOGLEVEL -eq 3 ]; then
					ove_analyze_strace_execve_timing ${OVE_PROJECT_TMP_DIR}/strace-${cmd} | tee -a $OVE_LAST_COMMAND
				elif [ $OVE_LOGLEVEL -eq 4 ]; then
					ove_analyze_strace_connect ${OVE_PROJECT_TMP_DIR}/strace-${cmd} | tee -a $OVE_LAST_COMMAND
				fi
			fi

			sed -i -e 's/\r$//' -e 's/\x0//' $OVE_LAST_COMMAND
			ln -s -f $OVE_LAST_COMMAND $OVE_LOG_DIR/last

			return $ret
		else
			{
				ove-"${cmd}" $args
			} 2>&1 | tee -i $OVE_LAST_COMMAND
			ret=${PIPESTATUS[0]}
			sed -i 's/\x0//g' $OVE_LAST_COMMAND
			ln -s -f $OVE_LAST_COMMAND $OVE_LOG_DIR/last
			return $ret
		fi
	fi
}

function ove_projects_init {
	unset ove_projects_name
	unset ove_projects_deps
	unset ove_projects_path
	unset ove_projects_needs
	unset ove_projects_version
	unset ove_projects_name2index

	declare -a -g ove_projects_name
	declare -a -g ove_projects_deps
	declare -a -g ove_projects_path
	declare -a -g ove_projects_needs
	declare -a -g ove_projects_version
	declare -A -g ove_projects_name2index

	ove_number_of_projects=0
}

# not really a complete YAML parser
function ove_parse_yaml {
	local line

	while IFS=: read line; do
		[[ $line == "---" ]] && continue
		(echo ${line#*: } | sed -e 's/: /:/g' -e "s/\([a-z]\+\):/\" ove_${line%%:*}_\1=\"/g" -e "s/$/\"/g" -e "s/^\" //g" -e "s/ \"/\"/g" & )
	done < <(sed -e 's/^\([a-z]\+:$\)/\n\1/g' -e 's/#.*//g' $1 | awk NF=NF RS= OFS=' ')
	wait
}

# uniq list of project commands
function ove_project_commands_list {
	local f
	local proj
	local search_dirs

	# for each project, look for executable files
	# ignore files with hyphens and underscore
	for proj in $OVE_PROJECT_LIST common; do
		# ignore projects without a project directory
		[ ! -d ${OVE_PROJECT_DIR}/projects/$proj ] && continue

		search_dirs+="$proj "
	done

	[ "$search_dirs" == "" ] && return

	for f in $(cd ${OVE_PROJECT_DIR}/projects; find -L $search_dirs -perm -u=x -type f); do
		echo ${f#*/}
	done | \
		grep -v '[-_]' | \
		sort -u | \
		xargs
}

# uniq list of mandatory attributes
function ove_projects_attributes {
	if [ -f "${OVE_PROJECT_DIR}"/projs ]; then
		grep -E -o '  \w+:' "${OVE_PROJECT_DIR}"/projs | \
			cut -d: -f1 | \
			tr -d ' ' | \
			sort -u
	fi
}

# list of project tags and branches
function ove_project_tags_and_branches {
	(
	git -C "${OVE_PROJECT_DIR}" tag
	git -C "${OVE_PROJECT_DIR}" branch --no-color --all --list | \
		grep -v HEAD | \
		tr -d '*' | \
		xargs | \
		tr ' ' '\n'
	) | sort -V
}

# iterate through projects
function ove_projects_parse {
	local i
	local m
	local projects
	local tmp_var

	ove_number_of_projects=0

	[ ! -f "$1" ] && return

	eval $(ove_parse_yaml "$1")

	# create ove-functions for all project commands
	for m in $OVE_PROJECT_COMMANDS; do
		eval "ove-$m() {
			local count
			local helptext=\"$m:[PROJECT...]:run the '$m' step for all or individual projects\"
			local p

			if ! ove_build_pre \$*; then
				return 1
			fi

			if [ \$# -eq 0 ]; then
				count=0
				while ((count < ove_number_of_projects)); do
					if ! ove_projects_cmd "\${ove_projects_name[\$count]}" $m; then
						return 1
					fi
					let count+=1
				done
			else
				for p in \$@; do
					if ! ove_projects_cmd \$p $m; then
						return 1
					fi
				done
			fi

		}"
	done

	# create parallel ove-functions for all project commands
	for m in $OVE_PROJECT_COMMANDS; do
		eval "ove-$m-parallel() {
			local count
			local helptext=\"$m-parallel:[PROJECT...]:run the '$m' step for all or individual projects (in parallel)\"
			local p

			if ! ove_build_pre \$*; then
				return 1
			fi

			if [ \$# -eq 0 ]; then
				count=0
				while ((count < ove_number_of_projects)); do
					{
						if ! ove_projects_cmd "\${ove_projects_name[\$count]}" $m; then
							kill -USR1 \$\$
						fi
					} &
					let count+=1
				done
			else
				for p in \$@; do
					{
						if ! ove_projects_cmd \$p $m; then
							kill -USR1 \$\$
						fi
					} &
				done
			fi

			wait
		}"
	done

	projects=($OVE_PROJECT_LIST)
	ove_number_of_projects=${#projects[@]}

	# set projects deps|name|path|needs|version
	i=0
	while ((i < ove_number_of_projects)); do
		# name
		ove_projects_name[$i]=${projects[$i]}
		unset ove_${projects[$i]}

		# index
		ove_projects_name2index[${projects[$i]}]=$i

		# deps
		tmp_var="ove_${projects[$i]}_deps"
		ove_projects_deps[$i]=${!tmp_var}
		unset ${tmp_var}

		# path
		tmp_var="ove_${projects[$i]}_path"
		ove_projects_path[$i]=${!tmp_var}
		unset ${tmp_var}

		# needs
		tmp_var="ove_${projects[$i]}_needs"
		ove_projects_needs[$i]=${!tmp_var}
		unset ${tmp_var}

		# version
		tmp_var="ove_${projects[$i]}_version"
		ove_projects_version[$i]=${!tmp_var}
		unset ${tmp_var}

		let i+=1
	done
}

function ove_list_projects_without_deps {
	local i

	i=0
	while ((i < ove_number_of_projects)); do
		if [ "${ove_projects_deps[$i]}" == "" ]; then
			echo -n "${ove_projects_name[$i]} "
		fi
		let i+=1
	done
}

function ove_list_projects_with_deps {
	local i

	i=0
	while ((i < ove_number_of_projects)); do
		if [ "${ove_projects_deps[$i]}" != "" ]; then
			echo -n "${ove_projects_name[$i]} "
		fi
		let i+=1
	done
}

function ove_list_projects_paths {
	local i

	i=0
	while ((i < ove_number_of_projects)); do
		echo -n "$OVE_BASE_DIR/${ove_projects_path[$i]} "
		let i+=1
	done
}

# $1: target
# $2: command
function ove_projects_cmd {
	local cmd
	local index
	local path
	local ret
	local target

	target=$1
	cmd=$2

	# sanity check
	! [ -e "${OVE_PROJECT_DIR}/projects/$target/$cmd" ] && return

	index=${ove_projects_name2index[$target]}

	# create dir if needed
	[ ! -d "$OVE_BASE_DIR"/"${ove_projects_path[$index]}" ] \
		&& mkdir -vp "$OVE_BASE_DIR"/"${ove_projects_path[$index]}"

	path="$OVE_BASE_DIR/${ove_projects_path[$index]}"

	if [ $OVE_LOGLEVEL -ne 0 ]; then
		ove_echo_cyan_error "$target: $cmd"
	fi

	if [ "${OVE_DRY_RUN}" -eq 0 ]; then
		pushd "$path" &>/dev/null
	fi

	# common for this command?
	[ -e "${OVE_PROJECT_DIR}/projects/common/$cmd" ] && \
		source "${OVE_PROJECT_DIR}/projects/common/$cmd"

	# "$1"/$2 is no longer needed
	shift 2

	if [ $OVE_DRY_RUN -eq 0 ]; then
		# run it
		eval "${target}_version=${ove_projects_version[$index]} \
			${OVE_PROJECT_DIR}/projects/$target/$cmd \
			$OVE_REDIRECT_OUTPUT"
	else
		# dry: print the command
		ove_echo_stderr_noprefix "cd $path && ${OVE_PROJECT_DIR}/projects/$target/$cmd"
	fi

	# preserve return code
	ret="$?"

	# exit directory
	[ "${OVE_DRY_RUN}" -eq 0 ] && popd &>/dev/null

	if [ "$ret" -ne 0 ]; then
		ove_echo_error "$target: $cmd"
	else
		if [ $OVE_LOGLEVEL -ne 0 ]; then
			ove_echo_cyan_error "$target: $cmd: done"
		fi
	fi

	return "$ret"
}

function ove_revtab_init {
	unset ove_revtab_fetch_url
	unset ove_revtab_push_url
	unset ove_revtab_rev
	unset ove_revtab_git_name

	declare -a -g ove_revtab_fetch_url
	declare -a -g ove_revtab_push_url
	declare -a -g ove_revtab_rev
	declare -a -g ove_revtab_git_name
	declare -A -g ove_revtab_basename2index

	ove_revtab_num_repositories=0
}

function ove_revtab_parse {
	local array
	local line

	ove_revtab_num_repositories=0

	while read line; do
		# skip comments and blank lines
		[ "${line:0:1}" == "#" ] && continue
		[ "${line}" == "" ] && continue

		array=($line)

		ove_revtab_git_name[$ove_revtab_num_repositories]=${array[0]}
		ove_revtab_fetch_url[$ove_revtab_num_repositories]=${array[1]}
		ove_revtab_push_url[$ove_revtab_num_repositories]=${array[2]}
		ove_revtab_rev[$ove_revtab_num_repositories]=${array[3]}
		ove_revtab_basename2index[${array[0]##*/}]=$ove_revtab_num_repositories

		let ove_revtab_num_repositories+=1
	done < "$1"
}

# $1: git (either basename, sub dir or fullpath)
function ove_git2fullpath {
	local git_basename
	local git_fullpath
	local index

	git_basename=${1##*/}
	index=${ove_revtab_basename2index[$git_basename]}

	# product repo?
	if [ "$index" == "" ] && [ "${git_basename}" == "$OVE_PROJECT_NAME" ]; then
		git_fullpath="$OVE_BASE_DIR/$OVE_PROJECT_NAME"
	elif [ "$index" != "" ]; then
		git_fullpath="$OVE_BASE_DIR/${ove_revtab_git_name[$index]}"
	else
		ove_echo_error_noprefix "$FUNCNAME: ops, this should never occur"
		return
	fi

	echo $git_fullpath
}

# $1: git (either basename, sub dir or fullpath)
function ove_git2shortpath {
	local git_basename
	local git_shortpath
	local index

	git_basename=${1##*/}
	index=${ove_revtab_basename2index[$git_basename]}

	# product repo?
	if [ "$index" == "" ] && [ "${git_basename}" == "$OVE_PROJECT_NAME" ]; then
		git_shortpath="$OVE_PROJECT_NAME"
	elif [ "$index" != "" ]; then
		git_shortpath="${ove_revtab_git_name[$index]}"
	else
		ove_echo_error_noprefix "$FUNCNAME: ops, this should never occur"
		return
	fi

	echo $git_shortpath
}

# $1: git
function ove_status_one_repo {
	local git_fullpath

	git_fullpath=$(ove_git2fullpath $1)
	if [ "$git_fullpath" == "" ] || ! [ -d "$git_fullpath" ]; then
		return
	fi

	printf "$(ove_git2shortpath $1):$(git -c color.status=always -C "$git_fullpath" status -zbs -uno | tr '\0' ' ')\n"
}

function ove_validate_repo_list {
	local git_basename
	local repos

	while true; do
		git_basename=${1##*/}
		[ $# -eq 0 ] && break
		if [ "$1" != "$OVE_PROJECT_NAME" ] && ! [ -v ove_revtab_basename2index[$git_basename] ]; then
			ove_echo_error_noprefix "unknown repo '$1'"
		else
			repos+="$(ove_git2shortpath $1)\n"
		fi
		shift
	done

	echo -e "$repos" | sort -u | xargs -n1
}

function ove_revtab_status {
	local git
	local repos

	if [ $# -ge 1 ]; then
		repos=$(ove_validate_repo_list $*)
	else
		repos=$OVE_REPO_LIST
	fi

	[ "$repos" == "" ] && return

	> "${OVE_PROJECT_STATE_DIR}/${OVE_NOW}-revtab-status"
	for git in $repos; do
		ove_status_one_repo $git >> "${OVE_PROJECT_STATE_DIR}/${OVE_NOW}-revtab-status" &
	done

	wait

	sort "${OVE_PROJECT_STATE_DIR}/${OVE_NOW}-revtab-status" | \
		column -t -s:

	mv "${OVE_PROJECT_STATE_DIR}/${OVE_NOW}-revtab-status" "${OVE_PROJECT_STATE_DIR}/revtab-status"
}

# $1: ahead|behind
function ove_revtab_status_parse_one {
	local git_args
	local git_fmt
	local git_fullpath
	local git_status
	local i
	local nbr_commits
	local tense

	tense=$1
	shift

	git_fmt='%h?%ar?%ae?%s'
	git_fullpath=$(ove_git2fullpath $1)

	if [ "$git_fullpath" == "" ] || ! [ -d "$git_fullpath" ]; then
		return
	fi

	git_status=$(git -C "$git_fullpath" status -zbs -uno | tr '\0' ' ')
	nbr_commits=0

	# keep 'ahead X, behind Y'
	git_status=${git_status##*[}
	git_status=${git_status%%]*}

	if [[ "$git_status" == *"$tense"* ]]; then
		if [ "${tense}" == "ahead" ]; then
			git_status=${git_status%%,*}
			nbr_commits=${git_status##${tense} }
		elif [ "${tense}" == "behind" ]; then
			nbr_commits=${git_status##*${tense} }
			git_args="FETCH_HEAD"
		else
			ove_echo_error_noprefix "$FUNCNAME: ops, this should never occur"
			return 1
		fi

		ove_echo_yellow_noprefix "$(ove_git2shortpath $1): $nbr_commits new commit(s):"
		git --no-pager -C "$git_fullpath" log ${git_args} -n $nbr_commits --format="$git_fmt" | \
			column -t -s?
		echo
	fi
}

# $1: ahead|behind
function ove_revtab_status_parse {
	local git
	local repos
	local tense

	[ $# -eq 0 ] && return 1

	tense="$1"
	shift

	# turn off monitor mode to get rid of "Done" messages
	set +m

	if [ $# -ge 1 ]; then
		repos=$(ove_validate_repo_list $*)
	elif [ -e ${OVE_PROJECT_STATE_DIR}/revtab-status ] && grep -q "\[.*${tense}.*\]" ${OVE_PROJECT_STATE_DIR}/revtab-status; then
		repos=$(grep "\[.*${tense}.*\]" ${OVE_PROJECT_STATE_DIR}/revtab-status | \
			cut -d: -f1 | \
			xargs)
	else
		repos=$OVE_REPO_LIST
	fi

	for git in $repos; do
		ove_revtab_status_parse_one ${tense} ${git}
	done

	# turn on monitor mode
	set -m
}

function ove_revtab_list {
	local count
	local str
	local url

	count=0

	if [ "$ove_revtab_num_repositories" == 0 ]; then
		echo "run 'ove fetch' first!"
		return 1
	fi

	while ((count < ove_revtab_num_repositories)); do
		str+="${ove_revtab_git_name[$count]} ${ove_revtab_fetch_url[$count]} ${ove_revtab_push_url[$count]} ${ove_revtab_rev[$count]}\n"
		let count+=1
	done

	url=$(git -C "${OVE_PROJECT_DIR}" config --get remote.origin.url)
	str+="$OVE_PROJECT_NAME $url $url $(git -C "${OVE_PROJECT_DIR}" rev-parse --abbrev-ref HEAD)\n"

	printf "$str" | \
		sort | \
		column -t
}

function ove_revtab_check {
	local a
	local b
	local count
	local name
	local rev

	if [ "$ove_revtab_num_repositories" == 0 ]; then
		return 1
	fi

	count=0

	while ((count < ove_revtab_num_repositories)); do
		name=${ove_revtab_git_name[$count]}
		rev=${ove_revtab_rev[$count]}

		if [ -d "$OVE_BASE_DIR/$name" ]; then
			a=$(git -C $OVE_BASE_DIR/$name rev-list -n 1 --abbrev-commit HEAD --)
			if ! git -C $OVE_BASE_DIR/$name rev-list -n 1 --abbrev-commit $rev -- &> /dev/null; then
				b=""
			else
				b=$(git -C $OVE_BASE_DIR/$name rev-list -n 1 --abbrev-commit $rev --)
			fi

			if [ "$a" != "$b" ]; then
				echo
				ove_echo_cyan_noprefix "$name: HEAD ($a = $(git -C $OVE_BASE_DIR/$name describe --tags --always)) is different from the revtab revision ($b = $rev)"

				if test -z "$(git -C $OVE_BASE_DIR/$name --no-pager status --porcelain -uno)"; then
					ove_echo_cyan_noprefix "$name: checkout '$rev'"
					ove_revtab_checkout $name
					ove_patch_repositories
				else
					ove_echo_yellow_noprefix "$name: cannot checkout '$rev' as repo is dirty:"
				fi
				ove-status "$name"
			fi
		fi
		let count+=1
	done
}

function ove_revtab_list_fullpath {
	local git

	for git in "${ove_revtab_git_name[@]}" $(readlink .owel); do
		echo -n "$OVE_BASE_DIR/$git "
	done | xargs "$OVE_ECHO"
}

function ove_revtab_list_basename {
	local git

	for git in "${ove_revtab_git_name[@]}" $(readlink .owel); do
		echo -n "$git "
	done | xargs "$OVE_ECHO"
}

function ove_revtab_forall {
	local git
	local git_basename

	for git in $OVE_REPO_LIST; do
		! [ -d "$git" ] && continue
		git_basename=${git##*/}
		eval "pushd $git &>/dev/null && $1; popd&>/dev/null"
	done
}

function ove_revtab_forall_parallel {
	(
	local git

	for git in $OVE_REPO_LIST; do
		! [ -d "$git" ] && continue
		pushd "$git" &>/dev/null && eval "$1" &
	done
	wait
	)
}

function ove_revtab_forsome {
	local git
	local i

	for i in ${*:2}; do
		for git in $OVE_REPO_LIST; do
			! [ -d "$git" ] && continue
			if [ "$git" == "$OVE_BASE_DIR/$i" ]; then
				eval "pushd $git &>/dev/null && $1; popd&>/dev/null"
			fi
		done
	done
}

function ove_revtab_forsome_parallel {
	(
	local git
	local i

	for i in ${*:2}; do
		for git in $OVE_REPO_LIST; do
			! [ -d "$git" ] && continue
			if [ "$git" == "$OVE_BASE_DIR/$i" ]; then
				eval "pushd $git &>/dev/null; $1; popd&>/dev/null" &
			fi
		done
	done
	wait
	)
}

# $*: optional list of repositories
function ove_revtab_clone_and_checkout {
	(
	local count
	local git_basename
	local index
	local repo

	if [ $# -gt 0 ]; then
		for repo in $*; do
			git_basename=${1##*/}
			index=${ove_revtab_basename2index[$git_basename]}

			if [ ! -d "$OVE_BASE_DIR/$repo" ]; then
				git clone "${ove_revtab_fetch_url[$index]}" "$OVE_BASE_DIR/${ove_revtab_git_name[$index]}" && ove_revtab_checkout $git_basename &
			fi
			shift
		done
	else
		count=0
		while ((count < ove_revtab_num_repositories)); do
			if [ ! -d "$OVE_BASE_DIR/${ove_revtab_git_name[$count]}" ]; then
				git clone "${ove_revtab_fetch_url[$count]}" "$OVE_BASE_DIR/${ove_revtab_git_name[$count]}" && ove_revtab_checkout ${ove_revtab_git_name[$count]} &
			fi
			let count+=1
		done
	fi

	wait
	)
}

# $*: optional list of repositories
function ove_revtab_checkout {
	(
	local count
	local git_basename
	local index
	local repo

	if [ $# -gt 0 ]; then
		for repo in $*; do
			git_basename=${1##*/}
			index=${ove_revtab_basename2index[$git_basename]}
			git -C "$OVE_BASE_DIR/${ove_revtab_git_name[$index]}" -c advice.detachedHead=false checkout "${ove_revtab_rev[$index]}" &
			shift
		done
	else
		count=0
		while ((count < ove_revtab_num_repositories)); do
			git -C "$OVE_BASE_DIR/${ove_revtab_git_name[$count]}" -c advice.detachedHead=false checkout "${ove_revtab_rev[$count]}" &
			let count+=1
		done
	fi

	wait
	)
}

function ove_revtab_pull_one {
	local base
	local cmd
	local git
	local git_fullpath
	local loc
	local remote
	local upstream

	git="$1"
	upstream="@{u}"

	git_fullpath=$(ove_git2fullpath $1)
	if [ "$git_fullpath" == "" ] || ! [ -d "$git_fullpath" ]; then
		return
	fi

	# check if detached
	if ! git -C "$git_fullpath" rev-parse -q "$upstream" &> /dev/null; then
		return
	fi

	loc=$(git -C "$git_fullpath" rev-parse @)
	remote=$(git -C "$git_fullpath" rev-parse "$upstream")
	base=$(git -C "$git_fullpath" merge-base @ "$upstream")

	if [ "$loc" = "$remote" ]; then
		# up-to-date
		:
	elif [ "$remote" = "$base" ]; then
		# need to push
		:
	else
		ove_echo_yellow_noprefix "$git"
		cmd="git -C $git_fullpath pull --rebase"
		if ! $cmd; then
			ove_echo_error_noprefix "$cmd"
		fi
	fi
}

# $*: optional list of repositories
function ove_revtab_fetch {
	local co_list
	local count

	ove_revtab_parse "${OVE_PROJECT_DIR}"/revtab

	if [ $# -ge 1 ]; then
		ove_revtab_clone_and_checkout $*
		ove_revtab_forsome_parallel 'git -C $git fetch --all --tags | sed -e "s|$| for $i|g"' $*
		return $?
	fi

	count=0
	while ((count < ove_revtab_num_repositories)); do
		if [ ! -d "$OVE_BASE_DIR/${ove_revtab_git_name[$count]}" ]; then
			co_list+="${ove_revtab_git_name[$count]} "
		fi
		let count+=1
	done

	[ "$co_list" != "" ] && ove_revtab_clone_and_checkout $co_list

	ove_revtab_forall_parallel 'git -C $git fetch --all --tags | sed -e "s|$| for $(ove_git2shortpath $git)|g"'
	return $?
}

function ove_get_base_dir {
	local found
	local parentdir
	local searchdir

	pushd . &> /dev/null
	found="FALSE"
	parentdir=$PWD
	searchdir=$PWD
	while [ "$searchdir" != "" ]; do
		cd "$searchdir"
		if [[ -L ove && -L .owel && ( -d .ove || -d owel ) ]]; then
			echo "$searchdir"
			found="TRUE"
			break
		fi
		parentdir=$searchdir
		searchdir=${searchdir%/*}
	done

	popd > /dev/null

	# base directory found?
	if [ "$found" == "FALSE" ]; then
		ove_echo_error_noprefix "Not in an OVE workspace (or any parent up to mount point $parentdir). Try 'ove cd'"
		# Exit to shell without closing the shell itself
		kill -INT $$

	# First time? Do nothing
	elif [ -z "${OVE_BASE_DIR+x}" ]; then
		:

	# Have we moved to another OVE workspace? source that project
	elif [ "$searchdir" != "$OVE_BASE_DIR" ] && [[ $- == *i* ]]; then
		cd $searchdir && . ove > /dev/null && cd -
	fi
}
export -f ove_get_base_dir

function ove_list_projects {
	if [ -f "${OVE_PROJECT_DIR}"/projs ]; then
		grep -o '^[a-zA-Z0-9_]\+' ${OVE_PROJECT_DIR}/projs | \
			sort | \
			xargs "$OVE_ECHO"
	fi
}
export -f ove_list_projects

function ove_stage_dir_md5sum_parallel {
	local f

	for f in $(find $OVE_STAGE_DIR -type f); do
		md5sum $f &
	done
	wait
}

function ove_stage_dir_fingerprint {
	[ "${OVE_DRY_RUN}" -eq 1 ] && echo && return

	ove_stage_dir_md5sum_parallel | \
		sort -k 2 | \
		md5sum | \
		cut -d' ' -f1
}

# make:[PROJECT[-nodeps]]:build project(s)
function ove-make {
	local fingerprint_a
	local fingerprint_b
	local index
	local proj
	local stage_dir_updated_by
	local target
	local withdeps

	target=$*
	withdeps="true"

	[ $# -eq 0 ] && target="all"

	if [[ $target == *-nodeps ]]; then
		withdeps="false"
		target=${target%-nodeps}
	fi

	# build all?
	if [ "$target" == "all" ]; then
		if ! ove_build_pre; then
			return 1
		fi

		for proj in $OVE_BUILD_ORDER; do
			index=${ove_projects_name2index[$proj]}

			# does proj have any dependencies?
			if [ "${ove_projects_deps[$index]}" != "" ]; then
				# check if some of the deps has modified the stage dir
				for dep in ${ove_projects_deps[$index]}; do
					if [[ "$stage_dir_updated_by" == *"$dep"* ]]; then
						ove_projects_cmd "$proj" clean
						break
					fi
				done
			fi

			fingerprint_a=$(ove_stage_dir_fingerprint)
			ove_projects_cmd "$proj" build
			ove_projects_cmd "$proj" install
			fingerprint_b=$(ove_stage_dir_fingerprint)

			# remember if project modified the stage dir
			if [ "$fingerprint_a" != "$fingerprint_b" ]; then
				stage_dir_updated_by+="$proj "
			fi
		done
	else
		if ! ove_build_pre $target; then
			return 1
		fi

		if [ "$withdeps" == "false" ]; then
			ove_projects_cmd "$target" build
		else
			if [[ "$(caller 0)" != *"ove-make"* ]]; then
				# keep track of projects built
				_ove_projects_built=""
			fi

			index=${ove_projects_name2index[$target]}
			[ "$index" == "" ] && echo "$FUNCNAME: unknown target '$target'" && return 1

			# has deps?
			if [ "${ove_projects_deps[$index]}" != "" ]; then
				fingerprint_a=$(ove_stage_dir_fingerprint)

				for dep in ${ove_projects_deps[$index]}; do
					# already built? next!
					if [[ "$_ove_projects_built" == *"$dep"* ]]; then
						continue
					fi

					if ! ove-make "$dep"; then
						return 1
					fi
				done

				fingerprint_b=$(ove_stage_dir_fingerprint)

				# clean the project if OVE_STAGE_DIR was updated
				if [ "$fingerprint_a" != "$fingerprint_b" ]; then
					ove_projects_cmd "$target" clean
				fi
			fi

			if ! ove_projects_cmd "$target" build; then
				return 1
			fi

			if ! ove_projects_cmd "$target" install; then
				return 1
			fi

			# remember projects built
			_ove_projects_built+="$target "

			# cleanup
			if [[ "$(caller 0)" != *"ove-make"* ]]; then
				unset _ove_projects_built
			fi
		fi
	fi
}

# list-projects:[long]:list projects
function ove-list-projects {
	local f
	local f_basename
	local p
	local projects

	if [ "$1" != 'long' ]; then
		echo $OVE_PROJECT_LIST | \
			xargs -n1
	else
		projects=$OVE_PROJECT_LIST
		for p in $projects; do
			# ignore projects without a project directory
			[ ! -d "${OVE_PROJECT_DIR}"/projects/$p ] && continue

			for f in $(find "${OVE_PROJECT_DIR}"/projects/$p -perm -u=x -type f); do
				echo
				f_basename=${f##*/}
				ove_echo_green_noprefix $p:$f_basename
				cat ${OVE_PROJECT_DIR}/projects/$p/$f_basename
			done
		done
	fi
}

function ove_build_topology {
	local i

	i=0
	while ((i < ove_number_of_projects)); do
		if [ "${ove_projects_deps[$i]}" != "" ]; then
			for d in ${ove_projects_deps[$i]}; do
				echo "${ove_projects_name[$i]} $d"
			done
		fi
		let i+=1
	done | tsort | tac | xargs
}

function ove-build-order {
	local autonomous_projs
	local topology

	[ $ove_number_of_projects -eq 0 ] && return

	# just a bunch of projects without deps?
	if [ "$(ove_list_projects_with_deps)" == "" ]; then
		ove_list_projects_without_deps
		return
	fi

	topology=$(ove_build_topology)
	autonomous_projs=$(comm -3 \
		<(printf "%s\n" $OVE_PROJECT_LIST) \
		<(echo $topology | tr ' ' '\n' | sort))

	echo $autonomous_projs $topology
}

# forowel:COMMAND:run 'COMMAND' for all OVE workspaces on this host
function ove-forowel {
	local cmd
	local i
	local projs

	[ $# -eq 0 ] && return

	i=0
	projs=($(ove-locate | \
		grep -v '^\s'))
	while ((i < ${#projs[@]})); do
		cmd+=$(printf "
			echo '# %s'
			cd %s
			ove_init
			$*
			" $(ove_echo_green_noprefix $(basename ${projs[i]})) ${projs[i]})
		let i+=1
	done
	eval "$cmd"
}

# forowel-parallel:COMMAND:run 'COMMAND' in parallel for all OVE workspaces on this host
function ove-forowel-parallel {
	local cmd
	local i
	local projs

	[ $# -eq 0 ] && return

	i=0
	projs=($(ove-locate | \
		grep -v '^\s'))
	while ((i < ${#projs[@]})); do
		cmd=$(printf "
			cd %s
			ove_init
			$*
			" ${projs[i]})
		let i+=1
		{
			eval "$cmd"
		} &
	done
	wait
}

# forall:COMMAND:run 'COMMAND' for all git repositories
function ove-forall {
	[ $# -ne 0 ] && ove_revtab_forall "$*"
}

# forall-parallel:COMMAND:run 'COMMAND' in parallel for all git repositories
function ove-forall-parallel {
	[ $# -ne 0 ] && ove_revtab_forall_parallel "$*"
}

# list-systests: :list available system tests
function ove-list-systests {
	! [ -e ${OVE_PROJECT_DIR}/systests ] && return
	(
	grep -E -v '^$|^\s*\#|.*:|^#.*' "${OVE_PROJECT_DIR}"/systests | \
		awk '{print $1}'
	grep : "${OVE_PROJECT_DIR}"/systests | \
		grep -v '#' | \
		cut -d: -f1

	if [ -e ${OVE_PROJECT_DIR}/systests-groups ]; then
		grep : "${OVE_PROJECT_DIR}"/systests-groups | \
			sed 's|[-:[:space:]]||g'
	fi) | sort
}

# list-systests-aliases: :list available system test aliases
function ove-list-systests-aliases {
	grep : "${OVE_PROJECT_DIR}"/systests | \
		grep -v '#' | \
		cut -d: -f1 | \
		sort
}

# list-scripts: :list available scripts
function ove-list-scripts {
	local repo

	# project scripts
	if [ -d "${OVE_PROJECT_DIR}/scripts" ]; then
		find ${OVE_PROJECT_DIR}/scripts -perm -u=x -not -name '*.help' -type f
	fi

	# OVE scripts
	if [ -d "$OVE_DIR/scripts" ]; then
		find $OVE_DIR/scripts -perm -u=x -not -name '*.help' -type f
	fi

	# repo scripts
	for repo in $(ove_revtab_list_fullpath); do
		! [ -d "$repo/.ove/scripts" ] && continue
		find -L $repo/.ove/scripts -perm -u=x -not -name '*.help' -type f
	done
}

function ove_echo {
	local diff
	local diff_ns
	local diff_s
	local now
	local now_ns
	local now_s

	diff="00:00:00"
	diff_ns="000000000"

	now=$(date +%s:%N)
	now_s=${now%:*}
	now_ns=${now#*:}
	# remove leading zeros
	now_ns=$((10#$now_ns))

	if [ "$OVE_PREV_S" != "" ]; then
		diff_ns="$((now_ns - OVE_PREV_NS))"
		diff_s=$((now_s - OVE_PREV_S))
		if [ "$diff_ns" -lt 0 ]; then
			let diff_s-=1
			diff_ns="$((1000000000 + diff_ns))"
		fi

		diff="$(echo $diff_s | \
			awk '{printf "%02d:%02d:%02d\n", int($1/3600),int(($1%3600)/60),int($1%60)}')"
	fi

	echo -e "$(date -d @$now_s +'%Y-%m-%d %H:%M:%S').$(printf "%09d" $now_ns) (+$diff:$(printf "%09d" $diff_ns)):$*"

	OVE_PREV_S=$now_s
	OVE_PREV_NS=$now_ns
}

function ove_echo_cyan {
	ove_echo "$ove_cyan""$*""$ove_blank"
}

function ove_echo_cyan_error {
	ove_echo "$ove_cyan""$*""$ove_blank" 1>&2;
}

function ove_echo_yellow {
	ove_echo "$ove_yellow""$*""$ove_blank"
}

function ove_echo_green_noprefix {
	echo -e "$ove_green""$*""$ove_blank"
}

function ove_echo_red {
	ove_echo "$ove_red""$*""$ove_blank"
}

function ove_echo_red_noprefix {
	echo -e "$ove_red""$*""$ove_blank"
}

function ove_echo_yellow_noprefix {
	echo -e "$ove_yellow""$*""$ove_blank"
}

function ove_echo_warning {
	ove_echo_yellow "warning: $*" 1>&2;
}

function ove_echo_cyan_noprefix {
	echo -e "$ove_cyan""$*""$ove_blank"
}

function ove_echo_error {
	ove_echo_red "error: $*" 1>&2;
}

function ove_echo_error_noprefix {
	ove_echo_red_noprefix "error: $*" 1>&2;
}

function ove_echo_warning_noprefix {
	ove_echo_yellow_noprefix "warning: $*" 1>&2;
}

function ove_echo_stderr {
	ove_echo "$@" 1>&2;
}
function ove_echo_stderr_noprefix {
	echo "$@" 1>&2;
}

# systest:[TEST|GROUP...]:run one or more system tests/groups described in ${OVE_PROJECT_DIR}/systests-groups and ${OVE_PROJECT_DIR}/systests
function ove-systest {
	local exit_status
	local groups
	local i
	local match
	local nbr_tests
	local new_test_list
	local q
	local result
	local summary
	local systest_cmd
	local systest_exit_code
	local systest_path
	local systest_row
	local systest_timeout
	local systest_type
	local test_list
	local test_name

	if [ $# -eq 0 ]; then
		echo "Need arguments, plz see ove help systest"
		return 1
	fi

	if ! [ -e ${OVE_PROJECT_DIR}/systests-groups ]; then
		test_list="$*"
	else
		groups=$(grep : ${OVE_PROJECT_DIR}/systests-groups | \
			sed 's|[-:[:space:]]||g'| \
			sort)

		if [ "$groups" == "" ]; then
			test_list="$*"
		elif ! command -v python3 > /dev/null; then
			ove_echo_yellow_noprefix "python3 not found, not possible to launch 'yex'"
			test_list="$*"
		else
			for test_name in $*; do
				if echo $groups | grep -w -q $test_name; then
					test_list+=" $($OVE_DIR/yex ${OVE_PROJECT_DIR}/systests-groups -s -r --groups "$test_name")"
				else
					test_list+=" $test_name"
				fi
			done
		fi
	fi

	[ "$test_list" == "" ] && echo "error: no tests found" && return 1

	# repeat?
	if ! [ -z "${OVE_SYSTEST_REPEAT+x}" ] && \
		[ "${OVE_SYSTEST_REPEAT}" -gt 1 ]; then

		for test_name in $test_list; do
			for q in $(seq 1 $OVE_SYSTEST_REPEAT); do
				new_test_list+=" $test_name"
			done
		done

		test_list=$new_test_list
	fi

	# skip tests
	if ! [ -z "${OVE_SYSTEST_SKIP+x}" ] && \
		[ "${OVE_SYSTEST_SKIP}" -gt 1 ]; then

		i=0
		for test_name in $test_list; do
			if (( i % OVE_SYSTEST_SKIP == 0 )); then
				new_test_list+=" $test_name"
			fi
			let i=i+1
		done

		test_list=$new_test_list
	fi

	nbr_tests=$(echo $test_list | \
		wc -w)
	if [ $nbr_tests -gt 1 ]; then
		echo "$FUNCNAME:Will run $nbr_tests test cases:"
		i=0
		for test_name in $test_list; do
			let i=i+1
			printf "$FUNCNAME:[%03d/%03d    ]:$test_name\n" $i $nbr_tests
		done
		echo
	fi

	# trap SIGINT to allow user to press CTRL+C
	trap true SIGINT

	i=0
	for test_name in $test_list; do
		let i=i+1

		# alias?
		match=$(grep -c ^$test_name: "${OVE_PROJECT_DIR}"/systests)
		if [ $match -eq 1 ]; then
			test_name=$(grep ^$test_name: "${OVE_PROJECT_DIR}"/systests | \
				cut -d: -f2)
		else
			match=$(grep -c -w ^$test_name "${OVE_PROJECT_DIR}"/systests)
			if [ $match -eq 0 ]; then
				ove_echo_error_noprefix "$FUNCNAME:can not find '$test_name'"
				continue
			elif [ $match -gt 1 ]; then
				ove_echo_error_noprefix "$FUNCNAME:$match match(es) for '$test_name'"
				grep ^$test_name "${OVE_PROJECT_DIR}"/systests
				continue
			fi
		fi

		systest_row=($(grep -w ^$test_name "${OVE_PROJECT_DIR}"/systests))
		test_name=${systest_row[0]}
		systest_timeout=${systest_row[1]}
		systest_type=${systest_row[2]}
		systest_path=${OVE_BASE_DIR}/${systest_row[3]//\"}
		systest_cmd=${systest_row[*]:4}
		systest_cmd=${systest_cmd//\"}

		if ! [ -d "$systest_path" ]; then
			ove_echo_error_noprefix "'$systest_path' is not a valid path for systest: '$test_name'"
			continue
		fi

		pushd "$systest_path" &> /dev/null
		shift
		printf "$FUNCNAME:[%03d/%03d    ]:$test_name\n" $i $nbr_tests

		OVE_SYSTEST_ACTIVE_TEST_CASE=$test_name
		OVE_SYSTEST_ITERATION=$i
		OVE_SYSTEST_NBR_TESTS=$nbr_tests
		export OVE_SYSTEST_ACTIVE_TEST_CASE
		export OVE_SYSTEST_ITERATION
		export OVE_SYSTEST_NBR_TESTS

		if [ "${OVE_DRY_RUN}" -eq 1 ]; then
			# dry run
			result=$(printf "$FUNCNAME:[%03d/%03d ${ove_green}OK${ove_blank}]:$test_name" $i $nbr_tests)
		else
			if timeout --foreground --kill-after 30s $systest_timeout $systest_cmd; then
				# test passed
				result=$(printf "$FUNCNAME:[%03d/%03d ${ove_green}OK${ove_blank}]:$test_name" $i $nbr_tests)
			else
				systest_exit_code=$?

				if [ $systest_exit_code -eq 124 ]; then
					exit_status="TIMEOUT"
				elif [ $systest_exit_code -eq 126 ]; then
					exit_status="PERMISSION_DENIED"
				elif [ $systest_exit_code -eq 127 ]; then
					exit_status="CAN_NOT_FIND_CMD"
				elif [ $systest_exit_code -gt 128 ] && [ $systest_exit_code -lt 166 ]; then
					exit_status="SIG$(kill -l $systest_exit_code)"
				elif [ -e /usr/include/sysexits.h ] && \
					grep -P -q "#define EX_[A-Z]+\s+${systest_exit_code}" /usr/include/sysexits.h; then
					exit_status=$(grep -P "#define EX_[A-Z]+\s${systest_exit_code}" /usr/include/sysexits.h | \
						grep -o -P 'EX_[A-Z]+')
				elif [ -e ${OVE_PROJECT_DIR}/${OVE_PROJECT_NAME}-sysexits.h ] && \
					grep -P -q "#define [A-Z0-9_]+\s+${systest_exit_code}$" ${OVE_PROJECT_DIR}/${OVE_PROJECT_NAME}-sysexits.h; then
					exit_status=$(grep -P "#define [A-Z0-9_]+\s+${systest_exit_code}$" ${OVE_PROJECT_DIR}/${OVE_PROJECT_NAME}-sysexits.h | \
						cut -f1 | \
						cut -d' ' -f2)
				else
					exit_status="$systest_exit_code"
				fi

				# test failed
				result=$(printf "$FUNCNAME:[%03d/%03d ${ove_yellow}NOK${ove_blank} $exit_status]:$test_name"  $i $nbr_tests)

				# type 1 systest or SIGINT => stop loop
				if [ $systest_type -eq 1 ] || [ $exit_status == "SIGINT" ] ; then
					echo $result
					summary+="$result\n"
					popd &> /dev/null
					break
				fi
			fi
		fi

		summary+="$result\n"
		echo -e $summary
		popd &> /dev/null
	done
	echo
	if [ $nbr_tests -gt 1 ]; then
		echo $FUNCNAME:Summary:
		echo -e $summary
	fi
	echo "OVE log: $OVE_LAST_COMMAND"

	return $systest_exit_code
}

# helper function for a few revtab functions below
function ove_revtab_sanity_check {
	if [ $# -ne 2 ]; then
		ove_echo_error_noprefix "please provide two revisions for '${OVE_PROJECT_DIR}'"
		return 1
	fi

	if [ "$1" == "$2" ]; then
		ove_echo_error_noprefix "please provide two different revisions for '${OVE_PROJECT_DIR}'"
		return 2
	fi

	if ! git -C "${OVE_PROJECT_DIR}" cat-file -e "$1" &> /dev/null; then
		ove_echo_error_noprefix "'$1' is not a valid revision"
		return 3
	fi

	if ! git -C "${OVE_PROJECT_DIR}" cat-file -e "$2" &> /dev/null; then
		ove_echo_error_noprefix "'$2' is not a valid revision"
		return 4
	fi
}

# revtab-diff:<rev> <rev>:print changes between two '$OVE_PROJECT_NAME' revisions
function ove-revtab-diff {
	local a
	local b
	local r
	local sha_1
	local sha_2

	ove_revtab_sanity_check $* || return $?

	# save revtab for rev A and rev B
	a=$(git -C "${OVE_PROJECT_DIR}" --no-pager show $1:revtab | \
		grep -v \# | \
		xargs -n4)
	b=$(git -C "${OVE_PROJECT_DIR}" --no-pager show $2:revtab | \
		grep -v \# | \
		xargs -n4)

	# extract repo/push/pull
	printf "$a" | \
		awk '{print $1,$2,$3}' | \
		sort > ${OVE_PROJECT_TMP_DIR}/repos_A
	printf "$b" | \
		awk '{print $1,$2,$3}' | \
		sort > ${OVE_PROJECT_TMP_DIR}/repos_B

	# extract repo/rev
	printf "$a" | \
		awk '{print $1,$4}' | \
		sort > ${OVE_PROJECT_TMP_DIR}/rev_A
	printf "$b" | \
		awk '{print $1,$4}' | \
		sort  > ${OVE_PROJECT_TMP_DIR}/rev_B

	# for repos common for A and B
	for r in $(comm -1 -2 ${OVE_PROJECT_TMP_DIR}/repos_A ${OVE_PROJECT_TMP_DIR}/repos_B | awk '{print $1}'); do
		sha_1=$(grep -w $r ${OVE_PROJECT_TMP_DIR}/rev_A | \
			awk '{print $2}')
		sha_2=$(grep -w $r ${OVE_PROJECT_TMP_DIR}/rev_B | \
			awk '{print $2}')
		[ "$sha_1" == "$sha_2" ] && continue
		echo $r $sha_1 $sha_2
	done | column -t

	# cleanup
	rm ${OVE_PROJECT_TMP_DIR}/repos_A \
		${OVE_PROJECT_TMP_DIR}/repos_B \
		${OVE_PROJECT_TMP_DIR}/rev_A \
		${OVE_PROJECT_TMP_DIR}/rev_B
}

# diff-project:<rev> <rev>:git diff the '$OVE_PROJECT_NAME' project
function ove-diff-project {
	local cmd
	local diff
	local line
	local repo
	local sha_1
	local sha_2

	ove_revtab_sanity_check $* || return $?

	cmd="git -C ${OVE_PROJECT_DIR} diff --color=always $1 $2"
	diff=$($cmd)
	if [ "$diff" != "" ]; then
		echo -e "$diff" | ${OVE_PAGER} -Ps"$OVE_PROJECT_NAME\:$(echo $cmd | sed -e 's/\./\\./g')"
	fi

	while IFS= read -r line; do
		[ "$line" == "" ] && break
		repo=$(echo $line | awk '{print $1}')
		sha_1=$(echo $line | awk '{print $2}')
		sha_2=$(echo $line | awk '{print $3}')
		cmd="git -C $OVE_BASE_DIR/$repo diff --color=always ${sha_1} ${sha_2}"
		diff=$($cmd)
		if [ "$diff" != "" ]; then
			echo -e "$diff" | ${OVE_PAGER} -Ps"$repo\:$(echo $cmd | sed -e 's/\./\\./g')"
		fi
	done <<<"$(ove-revtab-diff "$1" "$2")"
}

# log-project:<rev> <rev>:git log the project '$OVE_PROJECT_NAME'
function ove-log-project {
	local diff
	local line
	local repo
	local sha_1
	local sha_2

	ove_revtab_sanity_check $* || return $?

	diff=$(git --no-pager -C "${OVE_PROJECT_DIR}" log --oneline --pretty="    %C(auto)%h %s" "$1".."$2")
	if [ "$diff" != "" ]; then
		ove_echo_yellow_noprefix "  ${OVE_PROJECT_NAME}:"
		echo -e "$diff"
		echo
	fi

	while IFS= read -r line; do
		[ "$line" == "" ] && break
		repo=$(echo $line | awk '{print $1}')
		sha_1=$(echo $line | awk '{print $2}')
		sha_2=$(echo $line | awk '{print $3}')
		diff=$(git --no-pager -C $OVE_BASE_DIR/$repo log --oneline --pretty="    %C(auto)%h %s" ${sha_1}..${sha_2})
		if [ "$diff" != "" ]; then
			ove_echo_yellow_noprefix "  ${repo}:"
			echo -e "$diff"
			echo
		fi
	done <<<"$(ove-revtab-diff "$1" "$2")"
}

# shortlog-project:<rev> <rev>:git shortlog the project '$OVE_PROJECT_NAME'
function ove-shortlog-project {
	local diff
	local line
	local repo
	local sha_1
	local sha_2

	ove_revtab_sanity_check $* || return $?

	diff=$(git --no-pager -C "${OVE_PROJECT_DIR}" shortlog --oneline "$1".."$2")
	if [ "$diff" != "" ]; then
		ove_echo_yellow_noprefix ${OVE_PROJECT_NAME}:
		echo -e "$diff"
		echo
	fi

	while IFS= read -r line; do
		[ "$line" == "" ] && break
		repo=$(echo $line | awk '{print $1}')
		sha_1=$(echo $line | awk '{print $2}')
		sha_2=$(echo $line | awk '{print $3}')
		diff=$(git --no-pager -C $OVE_BASE_DIR/$repo shortlog --oneline ${sha_1}..${sha_2})
		if [ "$diff" != "" ]; then
			ove_echo_yellow_noprefix "${repo}:"
			echo -e "$diff"
			echo
		fi
	done <<<"$(ove-revtab-diff "$1" "$2")"
}

# help function that will print OVE project info
#
# $1 = path to OVE project directory
function ove_locate_print {
	local num_projs
	local num_repos
	local ove_dir

	ove_dir=$1

	! [ -d $ove_dir ] && return

	num_repos=$(awk '{print $1}' $ove_dir/revtab | \
		sed -e 's/#.*$//' -e '/^$/d' | \
		wc -l)
	OVE_PROJECT_DIR=$ove_dir num_projs=$(ove_list_projects | \
		wc -w)
	dirname $ove_dir
	[ -e "$ove_dir/SETUP" ] && echo "  $(cat $ove_dir/SETUP)"
	echo "  repos [$num_repos]: $(awk '{print $1}' $ove_dir/revtab | \
		sed -e 's/#.*$//' -e '/^$/d' | \
		tr '\n' ' ')"
	OVE_PROJECT_DIR=$ove_dir echo "  projs [$num_projs]: $(ove_list_projects)"
	echo
}

# setup: :print how to set this project up
function ove-setup {
	[ -e "${OVE_PROJECT_DIR}/SETUP" ] && cat "${OVE_PROJECT_DIR}/SETUP"
}

# refresh: :refresh projects found by ove-locate
function ove-refresh {
	local i
	local projs
	local str

	i=0
	projs=($(ove-locate | grep -v '^\s'))
	while ((i < ${#projs[@]})); do
		str+=$(printf "
			echo '$ # %s'
			echo '$ cd %s'
			cd %s
			ove_init
			echo '$ ove fetch'
			ove fetch
			if ove news > /dev/null; then
				ove news
				while true; do
					read -p '%s [c,d,n,p,q,x,?]? ' -r -n1
					echo
					if [[ \$REPLY =~ ^[Pp]$ ]]; then
						echo '$ ove pull'
						ove pull
						echo
					elif [[ \$REPLY =~ ^[Cc]$ ]]; then
						echo '$ ove checkout'
						ove checkout
						echo '$ ove status'
						ove status
						echo
					elif [[ \$REPLY =~ ^[Dd]$ ]]; then
						echo '$ ove diff'
						ove diff
						echo
						echo '$ ove status'
						ove status
						echo
					elif [[ \$REPLY =~ ^[Xx]$ ]]; then
						echo '$ ove pull'
						if ove pull; then
							break
						fi
						echo
					elif [[ \$REPLY =~ ^[Qq]$ ]]; then
						return
					elif [[ \$REPLY =~ ^[Nn]$ ]]; then
						break
					elif [[ \$REPLY =~ ^[?]$ ]]; then
						echo 'c - checkout'
						echo 'd - diff'
						echo 'n - next'
						echo 'p - pull'
						echo 'q - quit'
						echo 'x - pull and next'
						echo '? - this help'
						continue
					fi
				done
			fi
			echo" $(ove_echo_green_noprefix $(basename ${projs[i]})) ${projs[i]} ${projs[i]} $(ove_echo_green_noprefix $(basename ${projs[i]})))
		let i+=1
	done
	eval "$str"
}

function ove_locate_owels {
	local a
	local b
	local diff
	local invalidate_cache
	local o
	local owels

	if [ -e "${OVE_GLOBAL_STATE_DIR}/owel.cache" ]; then
		a=$(stat --format '%Y' "${OVE_GLOBAL_STATE_DIR}/owel.cache")
		b=$(date +%s)
		if [ $((b-a)) -lt 600 ]; then
			for o in $(cat "${OVE_GLOBAL_STATE_DIR}/owel.cache"); do
				if ! [ -d $o ]; then
					invalidate_cache=true
				fi

			done

			if ! [ "$invalidate_cache" = true ]; then
				cat "${OVE_GLOBAL_STATE_DIR}/owel.cache"
				return
			fi
		fi
	fi

	if command -v locate > /dev/null; then
		owels=$(locate -e -r '\.owel$')
	else
		owels=$(find $OVE_LOCATE_SEARCH_DIR -type l -name .owel 2> /dev/null)
	fi

	if [ "$owels" == "" ]; then
		return 1
	fi

	echo $owels | \
		xargs -n1 | \
		tee "${OVE_GLOBAL_STATE_DIR}/owel.cache"
}

# locate: :print OVE workspaces owned by '$USER' on this host using either 'locate' or 'find $OVE_LOCATE_SEARCH_DIR'
function ove-locate {
	local owel
	local owels

	owels=$(ove_locate_owels)

	if [ "$owels" == "" ]; then
		ove_echo_error_noprefix "no OVE projects found"
		return 1
	fi

	for owel in $owels; do
		if [ "$(stat -c %u $owel)" == "$(id -u)" ]; then
			ove_locate_print $owel
		fi
	done
}

# locate-all: :print OVE workspaces on this host using either 'locate' or 'find $OVE_LOCATE_SEARCH_DIR'
function ove-locate-all {
	local owel
	local owels

	owels=$(ove_locate_owels)

	if [ "$owels" == "" ]; then
		ove_echo_error_noprefix "no OVE project(s) found"
		return 1
	fi

	for owel in $owels; do
		ove_locate_print $owel
	done
}

# switch:[PATTERN]:switch to another OVE project
function ove-switch {
	local i
	local projs

	i=0
	projs=($(ove-locate | grep -v '^\s'))
	if [ $# -eq 0 ]; then
		while ((i < ${#projs[@]})); do
			printf "%d: %s # %s\n" $((i + 1)) ${projs[i]} $(ove_echo_green_noprefix $(basename ${projs[i]}))
			let i+=1
		done | column -t -s#

		echo
		read -p "Proj: "
		if ! [[ "${REPLY}" =~ ^[0-9]+$ ]]; then
			[ "${REPLY}" != "" ] && \
				echo "error: just numbers"
			return 1
		fi

		if [ $REPLY -gt ${#projs[@]} ] || [ $REPLY -eq 0 ]; then
			echo "error: out of bounds"
			return 2
		fi

		eval $(printf "cd %s; . ove > /dev/null\n" ${projs[$((REPLY - 1))]})
	elif [ $# -eq 1 ]; then
		while ((i < ${#projs[@]})); do
			if basename ${projs[i]} | grep -i -q $1; then
				eval $(printf "cd %s; . ove > /dev/null\n" ${projs[i]})
				return
			fi
			let i+=1
		done

		echo "error: project '$1' not found"
		return 1
	fi
}

# branch:[GIT...]:git branch -v for all/specified git repositories
function ove-branch {
	local cmd

	cmd='ove_echo_yellow_noprefix $PWD && git --no-pager branch -v'

	if [ $# -eq 0 ]; then
		ove_revtab_forall "$cmd"
	else
		ove_revtab_forsome "$cmd" "$*"
	fi
}

# remote:[GIT...]:git remote -v for all/specified git repositories
function ove-remote {
	local cmd

	cmd='ove_echo_yellow_noprefix $PWD && git --no-pager remote -v'

	if [ $# -eq 0 ]; then
		ove_revtab_forall "$cmd"
	else
		ove_revtab_forsome "$cmd" "$*"
	fi
}

# remote-check: :sanity check that all remotes are online
function ove-remote-check {
	local count

	count=0
	while ((count < ove_revtab_num_repositories)); do
		if ! git ls-remote ${ove_revtab_fetch_url[$count]} HEAD > /dev/null; then
			return 1
		fi

		let count+=1
	done
}

function ove_dirty_repos {
	local repo

	for repo in $(ove_revtab_forall_parallel 'test -z "$(git --no-pager status --porcelain -uno)" || echo $PWD'); do
		ove_git2shortpath $repo
	done
}

function ove_stashed_repos {
	local repo

	for repo in $(ove_revtab_forall_parallel 'test -z "$(git --no-pager stash show 2> /dev/null)" || echo $PWD'); do
		ove_git2shortpath $repo
	done
}

# $1: drop or pop
function ove_stash_forsome {
	local cmd

	! [ -f ${OVE_PROJECT_STATE_DIR}/ove-stashed-repos ] && return
	cmd="git stash $1 -q"
	ove_revtab_forsome "$cmd" "$(cat ${OVE_PROJECT_STATE_DIR}/ove-stashed-repos | sed "s|$OVE_BASE_DIR/||g" | xargs)"
	rm ${OVE_PROJECT_STATE_DIR}/ove-stashed-repos
}

function ove_stash_pop {
	ove_stash_forsome pop
}

function ove_stash_drop {
	ove_stash_forsome drop
}

function ove_stash_save {
	local cmd
	local dirty_repos
	local git
	local now

	[ -f ${OVE_PROJECT_STATE_DIR}/ove-stashed-repos ] && return

	dirty_repos=$(ove_dirty_repos)
	[ "$dirty_repos" == "" ] && return

	> ${OVE_PROJECT_STATE_DIR}/ove-stashed-repos
	now=$(date '+%Y%m%d-%H%M%S')
	cmd="git stash save -q stashed by OVE@$now && echo \$git >> ${OVE_PROJECT_STATE_DIR}/ove-stashed-repos"

	for git in $dirty_repos; do
		ove_revtab_forsome "$cmd" "$git"
	done
}

function ove_stash_inspect {
	local cmd
	local stashed_repos

	stashed_repos=$(ove_stashed_repos)
	[ "$stashed_repos" == "" ] && return

	cmd="git --no-pager stash"
	if [ "$1" == "show" ]; then
		cmd+=" show -p"
	elif [ "$1" == "list" ]; then
		cmd+=" list"
	else
		return
	fi

	ove_revtab_forsome "ove_echo_yellow_noprefix \$PWD: && $cmd" "$stashed_repos"
}

function ove_stash_show {
	ove_stash_inspect show
}

function ove_stash_list {
	ove_stash_inspect list
}

# stash:[drop|list|pop|show]:git stash [drop|list|pop|show] for all git repositories
function ove-stash {
	if [ "$1" == "pop" ] ||
		[ "$1" == "list" ] ||
		[ "$1" == "show" ] ||
		[ "$1" == "drop" ]; then
		ove_stash_$1
	elif [ $# -eq 0 ]; then
		ove_stash_save
	else
		ove-help '^stash '
	fi
}

# diff:[GIT...]:git diff for all/specified git repositories
function ove-diff {
	local cmd
	local git

	cmd="git --no-pager diff-files --quiet || \
		(ove_echo_yellow_noprefix \$PWD && \
		git --no-pager diff --color=always $OVE_DIFF_OPTIONS)"

	if [ $# -eq 0 ]; then
		for git in $(ove_dirty_repos); do
			ove_revtab_forsome "$cmd" "$git"
		done | ${OVE_PAGER}
	else
		ove_revtab_forsome "$cmd" "$*" | ${OVE_PAGER}
	fi
}

# wdiff:[GIT...]:git diff (word diff) for all/specified git repositories
function ove-wdiff {
	local OVE_DIFF_OPTIONS

	OVE_DIFF_OPTIONS="--color-words=."
	ove-diff $*
}

# diff-cached:[GIT...]:git diff --cached for all/specified repositories
function ove-diff-cached {
	local cmd
	local git

	cmd="git --no-pager diff-index --quiet --cached HEAD -- || \
		(ove_echo_yellow_noprefix \$PWD && \
		git --no-pager diff --color=always --cached)"

	if [ $# -eq 0 ]; then
		for git in $(ove_dirty_repos); do
			ove_revtab_forsome "$cmd" "$git"
		done | ${OVE_PAGER}
	else
		ove_revtab_forsome "$cmd" "$*" | ${OVE_PAGER}
	fi
}

# reset:[GIT...]:git reset -p for all/specified repositories
function ove-reset {
	local cmd

	cmd='git --no-pager diff-index --quiet --cached HEAD -- || \
		(ove_echo_yellow_noprefix $PWD && git reset -p)'

	if [ $# -eq 0 ]; then
		ove_revtab_forall "$cmd"
	else
		ove_revtab_forsome "$cmd" "$*"
	fi
}

# add:[GIT...]:git add -p for all/specified repositories
function ove-add {
	local cmd
	local git

	cmd='git --no-pager diff-files --quiet || \
		(ove_echo_yellow_noprefix $PWD && git --no-pager add -p)'

	if [ $# -eq 0 ]; then
		for git in $(ove_dirty_repos); do
			ove_revtab_forsome "$cmd" "$git"
		done
	else
		ove_revtab_forsome "$cmd" "$*"
	fi
}

# commit:[GIT...]:git commit for all/specified git repositories
function ove-commit {
	local cmd
	local git

	cmd="git --no-pager diff --cached --quiet || \
		(ove_echo_yellow_noprefix \$PWD && git commit -t <(echo; echo \# git: \$git; echo \#; git diff --cached -U0 | sed 's/^/# /g'))"

	if [ $# -eq 0 ]; then
		for git in $(ove_dirty_repos); do
			ove_revtab_forsome "$cmd" "$git"
		done
	else
		ove_revtab_forsome "$cmd" "$*"
	fi
}

# $1 = proj
function ove_get_deps_recursive {
	local dep
	local index

	index=${ove_projects_name2index[$1]}
	for dep in ${ove_projects_deps[$index]}; do
		echo -n "$dep "
		ove_get_deps_recursive $dep
	done
}

# $1 = proj
function ove_get_paths_recursive {
	local dep
	local index

	if [ $# -ne 1 ]; then
		ove_echo_error_noprefix "$FUNCNAME: need one arg"
		return 1
	fi

	index=${ove_projects_name2index[$1]}
	if [ "${ove_projects_deps[$index]}" == "" ]; then
		echo -n "$OVE_BASE_DIR/${ove_projects_path[$index]} "
		return
	fi

	for dep in ${ove_projects_deps[$index]}; do
		echo -n "$OVE_BASE_DIR/${ove_projects_path[$index]} "
		ove_get_paths_recursive $dep
	done
}

function ove_validate_revtab {
	local doublets

	doublets="$(grep -E -v '^$|^#' ${OVE_PROJECT_DIR}/revtab | \
		awk -F, 'a[$1]++{print NR ":", $1}')"

	# check for doublets
	if [ "$doublets" != "" ]; then
		ove_echo_error_noprefix "Found repo doublet(s) in '${OVE_PROJECT_DIR}/revtab':"

		echo "$doublets"
		return 1
	fi
}

function ove_validate_projs {
	local i

	i=0
	while ((i < ove_number_of_projects)); do
		if [ "${ove_projects_deps[$i]}" != "" ]; then
			for d in ${ove_projects_deps[$i]}; do
				echo "${ove_projects_name[$i]} $d"
			done
		fi
		let i+=1
	done | tsort > /dev/null

	if [ $? -ne 0 ]; then
		ove_echo_error_noprefix "circular dependency in '${OVE_PROJECT_DIR}/projs', see output from 'tsort' above"
		return 1
	fi
}

# $*: a list of packages
function ove_install_packages {
	local cmd
	local missing_packages
	local missing_packages_sorted

	missing_packages=$(ove_packages_not_installed $*)

	# no missing packages?
	[ "$missing_packages" == "" ] && return

	# sort the list
	missing_packages_sorted="$(echo $missing_packages | \
		xargs -n1 "$OVE_ECHO" | \
		sort -u | \
		xargs "$OVE_ECHO")"

	if [ "${OVE_DRY_RUN}" -eq 1 ]; then
		ove_echo_yellow "Would prompt to install this/these package(s):"
		echo "$(echo $missing_packages_sorted | xargs -n1)"
		return
	fi

	if [ "$OVE_OS_PACKAGE_MANAGER" == "unknown" ]; then
		ove_echo_error_noprefix "$FUNCNAME: fatal: package manager is not set"
		return 1
	fi

	if ! command -v $OVE_OS_PACKAGE_MANAGER > /dev/null; then
		ove_echo_error_noprefix "$FUNCNAME: fatal: '$OVE_OS_PACKAGE_MANAGER' not found"
		return 2
	fi

	cmd="$OVE_OS_PACKAGE_MANAGER $OVE_OS_PACKAGE_MANAGER_ARGS $missing_packages_sorted"

	echo "missing package(s):"
	echo
	echo "To fix this, run the following command:"
	echo
	echo -e "\t$cmd"
	echo
	return 1
}

# export:[PROJECT...]:export project(s)
function ove-export {
	local attr
	local b
	local deps
	local index
	local paths
	local projs
	local tmp_var

	mkdir -p ${OVE_PROJECT_TMP_DIR}/export ${OVE_PROJECT_TMP_DIR}/export/projects
	> ${OVE_PROJECT_TMP_DIR}/export/revtab
	> ${OVE_PROJECT_TMP_DIR}/export/projs
	[ -d ${OVE_PROJECT_TMP_DIR}/export/projects ] && rm -rf ${OVE_PROJECT_TMP_DIR}/export/projects

	while true; do
		if [ $# -ge 1 ]; then
			if ! [[ -v ove_projects_name2index[$1] ]]; then
				ove_echo_error_noprefix "unknown project '$1'"
				shift
				[ $# -eq 0 ] && break
				continue
			fi

			deps=$(ove_get_deps_recursive $1)
		fi

		for b in $(echo $OVE_BUILD_ORDER | xargs -n1 | sort); do
			if [ "$#" -ge 1 ]; then
				re=\\b$b\\b
				if ! [[ "$deps" =~ $re ]] && [ "$b" != "$1" ]; then
					continue
				fi
			fi

			# already exported?
			if grep -q ^${b}: ${OVE_PROJECT_TMP_DIR}/export/projs; then
				continue
			fi

			projs+="${b} "
			str+="${b}:\n"
			index=${ove_projects_name2index[$b]}
			for attr in $(ove_projects_attributes); do
				tmp_var="ove_projects_$attr[$index]"
				[ "${!tmp_var}" != "" ] && \
					str+="  $attr:\n$(echo ${!tmp_var} | \
					tr ' ' '\n' | \
					sort -u | \
					sed -e 's|^|    |g')\n"

				paths+="$OVE_BASE_DIR/${ove_projects_path[$index]} "
			done
			str+="\n"
		done

		printf "$str" | sed '$ d' > ${OVE_PROJECT_TMP_DIR}/export/projs

		for b in $projs; do
			mkdir -p ${OVE_PROJECT_TMP_DIR}/export/projects/${b}
			if find ${OVE_PROJECT_DIR}/projects/${b} -mindepth 1 -print -quit 2> /dev/null | grep -q .; then
				cp -ar ${OVE_PROJECT_DIR}/projects/${b}/* ${OVE_PROJECT_TMP_DIR}/export/projects/${b}
			fi
		done

		shift
		[ $# -eq 0 ] && break
	done

	! [ -s ${OVE_PROJECT_TMP_DIR}/export/projs ] && return 1

	# YAML header
	sed -i '1i ---' ${OVE_PROJECT_TMP_DIR}/export/projs

	for b in $(echo $paths | tr ' ' '\n' | sort -u); do
		while true; do
			[ "$b" == "" ] && break
			if echo $OVE_REPO_LIST | xargs -n 1 2> /dev/null | grep -q ^$b$; then
				ove-list-repositories | grep "^$(ove_git2shortpath $b) " >> ${OVE_PROJECT_TMP_DIR}/export/revtab
				break
			fi
			b="${b%/*}"
		done
	done
	LC_ALL="C" sort -u -o ${OVE_PROJECT_TMP_DIR}/export/revtab ${OVE_PROJECT_TMP_DIR}/export/revtab

	tree ${OVE_PROJECT_TMP_DIR}/export
	tar -C "${OVE_PROJECT_TMP_DIR}/export" -cjf "${OVE_PROJECT_TMP_DIR}/export.tar.bz2" .
	echo
	echo "${OVE_PROJECT_TMP_DIR}/export.tar.bz2"

	return 0
}

# import:[file]:import project(s), see export
function ove-import {
	local f

	if [ $# -eq 0 ]; then
		f="${OVE_PROJECT_TMP_DIR}/export.tar.bz2"
	elif [ $# -eq 1 ]; then
		f="$1"
	else
		echo "error: too many args"
		return 1
	fi

	if ! [ -s "$f" ]; then
		echo "error: file '$f' is not found or file size is 0"
		return 2
	fi

	tar -C "${OVE_PROJECT_DIR}" -xf "$f"
}

function ove_build_pre {
	local missing_repos
	local p
	local paths
	local q

	if [ $# -eq 0 ]; then
		paths=$(ove_list_projects_paths)
	else
		while true; do
			p+="$(ove_get_paths_recursive $1) "
			shift
			[ $# -eq 0 ] && break
		done

		paths="$(echo $p | xargs -n1 | sort -u | xargs)"
	fi

	for p in $paths; do
		for q in $OVE_REPO_LIST; do
			if [[ $p == *"$q"* ]] && ! [ -d "$q" ]; then
				missing_repos+="$(ove_git2shortpath $q) "
			fi
		done
	done

	if [ "$missing_repos" != "" ]; then
		missing_repos=$(echo $missing_repos | xargs -n1 | sort -u | xargs)
		ove_echo_error_noprefix "repo(s) '$missing_repos' is not yet fetched, try:"
		echo
		echo -e "\t$ ove fetch $missing_repos"
		echo
		return 1
	fi

	# create stage/archive directories if needed
	[ ! -d "$OVE_STAGE_DIR" ] && mkdir -p "$OVE_STAGE_DIR"
	[ ! -d "$OVE_ARCHIVE_DIR" ] && mkdir -p "$OVE_ARCHIVE_DIR"

	return 0
}

# buildme:[PROJECT]:build projects from scratch (=bootstrap, configure, build, install)
function ove-buildme {
	local b
	local deps
	local index
	local n
	local pack_list

	if [ $# -eq 1 ]; then
		if ! [[ -v ove_projects_name2index[$1] ]]; then
			ove_echo_error_noprefix "unknown project '$1'"
			return 1
		fi

		deps=$(ove_get_deps_recursive $1)
	fi

	if ! ove_build_pre $*; then
		return 1
	fi

	for b in $OVE_BUILD_ORDER; do
		if [ "$#" -eq 1 ]; then
			re=\\b$b\\b
			if ! [[ "$deps" =~ $re ]] && [ "$b" != "$1" ]; then
				continue
			fi
		fi

		index=${ove_projects_name2index[$b]}
		for n in ${ove_projects_needs[$index]}; do
			pack_list+="$n "
		done
	done

	# install packages
	if [ "$pack_list" != "" ]; then
		if ! ove_install_packages $pack_list; then
			ove_echo_error_noprefix "$FUNCNAME: missing package(s)"
			return 1
		fi
	fi

	# bootstrap
	for b in $OVE_BUILD_ORDER; do
		if [ "$#" -eq 1 ]; then
			re=\\b$b\\b
			if ! [[ "$deps" =~ $re ]] && [ "$b" != "$1" ]; then
				continue
			fi
		fi

		! [ -e "${OVE_PROJECT_DIR}/projects/$b/bootstrap" ] && continue

		if [ "$(type -t ove-bootstrap)" == "function" ] && \
			! eval ove-bootstrap $b $OVE_REDIRECT_OUTPUT; then
			ove_echo_error_noprefix "$FUNCNAME: bootstrap $b failed"
			return 1
		fi
	done

	for b in $OVE_BUILD_ORDER; do
		if [ "$#" -eq 1 ]; then
			re=\\b$b\\b
			if ! [[ "$deps" =~ $re ]] && [ "$b" != "$1" ]; then
				continue
			fi
		fi

		if [ "$(type -t ove-configure)" == "function" ] && \
			! eval ove-configure $b $OVE_REDIRECT_OUTPUT; then
			ove_echo_error_noprefix "$FUNCNAME: configure ${b} failed"
			return 1
		fi

		if ! eval ove-make "$b"-nodeps $OVE_REDIRECT_OUTPUT; then
			ove_echo_error_noprefix "$FUNCNAME: make ${b}-nodeps failed"
			return 1
		fi

		if [ "$(type -t ove-install)" == "function" ] && \
			! eval ove-install $b $OVE_REDIRECT_OUTPUT; then
			ove_echo_error_noprefix "$FUNCNAME: install ${b} failed"
			return 1
		fi

		if [ "$#" -eq 1 ]; then
			[ "$b" == "$1" ] && return 0
		fi
	done

	return 0
}

# buildme-parallel:[PROJECT]:build projects from scratch (=bootstrap, configure, build, install)
function ove-buildme-parallel {
	local b
	local dep
	local inotify_max_user_instances
	local n
	local p
	local pack_list
	local pid
	local pids
	local project_index
	local project_dependency
	local wait_for_deps

	if ! ove_build_pre $*; then
		return 1
	fi

	if [ $# -eq 1 ]; then
		if ! [[ -v ove_projects_name2index[$1] ]]; then
			ove_echo_error_noprefix "unknown project '$1'"
			return 1
		fi

		project_dependency=$(ove_get_deps_recursive $1)
	fi

	for b in $OVE_BUILD_ORDER; do
		if [ "$#" -eq 1 ]; then
			re=\\b$b\\b
			if ! [[ "$project_dependency" =~ $re ]] && [ "$b" != "$1" ]; then
				continue
			fi
		fi

		index=${ove_projects_name2index[$b]}
		for n in ${ove_projects_needs[$index]}; do
			pack_list+="$n "
		done
	done

	# install packages
	if [ "$pack_list" != "" ]; then
		if ! ove_install_packages $pack_list; then
			ove_echo_error_noprefix "$FUNCNAME: missing package(s)"
			return 1
		fi
	fi

	# bootstrap
	for b in $OVE_BUILD_ORDER; do
		if [ "$#" -eq 1 ]; then
			re=\\b$b\\b
			if ! [[ "$project_dependency" =~ $re ]] && [ "$b" != "$1" ]; then
				continue
			fi
		fi

		! [ -e "${OVE_PROJECT_DIR}/projects/$b/bootstrap" ] && continue

		{
			if [ "$(type -t ove-bootstrap)" == "function" ] && \
				! eval ove-bootstrap $b $OVE_REDIRECT_OUTPUT; then
				ove_echo_error_noprefix "$FUNCNAME: bootstrap $b failed"
				kill -USR1 $$
			fi
		} &
		pids+="$! "
	done

	wait $pids
	pids=""

	# pids db
	declare -A pids_db=()

	let project_index=1

	inotify_max_user_instances=$(($(cat /proc/sys/fs/inotify/max_user_instances) - 20))
	for b in $OVE_BUILD_ORDER; do
		let project_index+=1

		if [ "$#" -eq 1 ]; then
			re=\\b$b\\b
			if ! [[ "$project_dependency" =~ $re ]] && [ "$b" != "$1" ]; then
				continue
			fi
		fi

		wait_for_deps=""
		for dep in $(ove_get_deps_recursive $b); do
			if ! [ -e /proc/${pids_db[$dep]} ]; then
				pids_db[$dep]=""
				continue
			fi

			wait_for_deps+="${pids_db[$dep]} "
		done

		{
			for p in $wait_for_deps; do
				tail -s 0.01 --pid=$p -f /dev/null &
			done
			[ "$wait_for_deps" != "" ] && wait

			if [ "$(type -t ove-configure)" == "function" ] && \
				! eval ove-configure $b $OVE_REDIRECT_OUTPUT; then
				ove_echo_error_noprefix "$FUNCNAME: configure ${b} failed"
					kill -USR1 $$
			fi

			if ! eval ove-make "$b"-nodeps $OVE_REDIRECT_OUTPUT; then
				ove_echo_error_noprefix "$FUNCNAME: make ${b}-nodeps failed"
				kill -USR1 $$
			fi

			if [ "$(type -t ove-install)" == "function" ] && \
				! eval ove-install $b $OVE_REDIRECT_OUTPUT; then
				ove_echo_error_noprefix "$FUNCNAME: install ${b} failed"
				kill -USR1 $$
			fi

			if [ "$#" -eq 1 ]; then
				[ "$b" == "$1" ] && return 101
			fi
		} &
		pid=$!
		pids_db[$b]=$pid
		pids+=" $pid"

		while true; do
			if [ $(pgrep -f tail | wc -l) -gt $inotify_max_user_instances ]; then
				sleep 0.1
				continue
			fi
			break
		done
	done

	wait $pids
	return 0
}

# diff-check:[OPTIONS]:git diff --check [OPTIONS]
function ove-diff-check {
	local cmd

	cmd="echo \$PWD; git --no-pager diff --check $* -- \$(git diff --name-only)"
	ove_revtab_forall "$cmd"
}

# list-repositories: :list all git repositories
function ove-list-repositories {
	ove_revtab_list
}

# env:[PATTERN]:show OVE env
function ove-env {
	local e
	local str
	local v

	if [ $# -eq 0 ]; then
		v=$(compgen -A variable | grep OVE_)
	else
		v=$(compgen -A variable | grep OVE_ | grep -i $1)
	fi

	for e in $v; do
		str+="$e:${!e}\n"
	done

	printf "$str" | \
		sort | \
		column -t -s:
}

# status:[GIT...]:git status -zbs -uno for all/specified repositories
function ove-status {
	# turn off monitor mode to get rid of "Done" messages
	set +m

	ove_revtab_status $* | \
		grep -v '^\['

	# turn on monitor mode
	set -m
}

# news:[GIT...]:list upstream changes for all/specified repositories
function ove-news {
	ove_revtab_status_parse behind $* | tee ${OVE_PROJECT_STATE_DIR}/revtab-news
}

# ahead:[GIT...]:list local commits not yet published for all/specified repositories
function ove-ahead {
	ove_revtab_status_parse ahead $* | tee ${OVE_PROJECT_STATE_DIR}/revtab-ahead
}

# pull:[GIT...]:git pull --rebase for all/specified repositories
function ove-pull {
	local git
	local repos

	# turn off monitor mode to get rid of "Done" messages
	set +m

	if [ $# -ge 1 ]; then
		repos=$(ove_validate_repo_list $*)
	elif [ -e ${OVE_PROJECT_STATE_DIR}/revtab-status ] && grep -q 'behind.*]' ${OVE_PROJECT_STATE_DIR}/revtab-status; then
		repos=$(grep 'behind.*]' ${OVE_PROJECT_STATE_DIR}/revtab-status | \
			cut -d: -f1 | \
			xargs)
	else
		repos=$OVE_REPO_LIST
	fi

	for git in $repos; do
		ove_revtab_pull_one $git | grep -v '^\['

		# product repo?
		if [ "${git##*/}" == "$OVE_PROJECT_NAME" ]; then
			ove_revtab_check
		fi
	done

	if [ "$repos" != "" ]; then
		ove_revtab_status | grep -v '^\['
	fi

	# turn on monitor mode
	set -m
}

# apply:PATCH:apply one OVE patch
function ove-apply {
	local git_basename
	local p
	local q

	if [ $# -ne 1 ]; then
		ove-help '^apply '
		return 1
	fi

	if ! command -v csplit > /dev/null; then
		ove_echo_error_noprefix "command 'csplit' not found"
		return 1
	fi

	if ! [ -e "$1" ]; then
		ove_echo_error_noprefix "'$1' patch file not found"
		return 1
	fi

	cp -a "$1" "${OVE_PROJECT_TMP_DIR}"
	cd ${OVE_PROJECT_TMP_DIR}
	p="${OVE_PROJECT_TMP_DIR}/$(basename $1)"

	# remove color codes
	sed -i \
		-r \
		-e "s/\x1b\[1;3[1,3]m//g" \
		-e "s/\x1b\[[0-9]+m//g" \
		-e "s/\x1b\[m//g" ${p}

	if ! file "${p}" | grep -q "unified diff"; then
		ove_echo_error_noprefix "'${p}' is not a unified diff"
		return 1
	fi

	# remove any old patch file(s)
	find -maxdepth 1 -name 'ove-apply-patch*' -exec rm {} \;

	# one patch per git
	if ! csplit -s -z --prefix ove-apply-patch ${p} /^\// {*}; then
		ove_echo_error_noprefix "ops, csplit failed"
		return 1
	fi

	for p in $(find $PWD -maxdepth 1 -name 'ove-apply-patch*' | sort); do
		git_basename=$(basename $(head -1 -q $p))
		git_fullpath=$(ove_git2fullpath $git_basename)
		if [ "$git_fullpath" == "" ] || ! [ -d "$git_fullpath" ]; then
			ove_echo_error_noprefix "'$git_basename': unknown git, next..."
			continue
		fi

		# rename the patch
		q="${OVE_PROJECT_TMP_DIR}/ove-apply-$git_basename.patch"
		mv $p $q
		if [ -d "$git_fullpath" ] && \
			[ -d $git_fullpath/.git ]; then
			# Run 'git apply --check' and if ok, apply the patch
			if ! git -C "$git_fullpath" apply --check $q 2> /dev/null; then
				ove_echo_yellow_noprefix "$git_basename: patch '${ove_yellow}$q${ove_blank}' does not apply without errors"
				continue
			fi

			# apply the patch
			git -C "$git_fullpath" apply $q
		fi
	done

	return 0
}

function ove_patch_repositories {
	! [ -d ${OVE_PROJECT_DIR}/patches ] && return

	ove_revtab_forall '[ -d ${OVE_PROJECT_DIR}/patches/$git_basename ] && \
		git -C $git apply ${OVE_PROJECT_DIR}/patches/$git_basename/*.patch &> /dev/null || :'
}

# do:GIT:run a command within GIT
function ove-do {
	local cmd
	local git

	git=$1
	cmd="${*:2}"

	cd $OVE_BASE_DIR/$git && eval "$cmd"
}

# fetch:[GIT...]:git fetch --all for all/specified repositories, ends with ove status
function ove-fetch {
	local repos

	if [ $# -ne 0 ]; then
		repos=$(ove_validate_repo_list $*)
		[ "$repos" == "" ] && return 1
	fi

	ove_revtab_fetch $repos

	[ $# -eq 0 ] && ove_patch_repositories

	ove-status $repos
}

# tag: :list all project tags
function ove-tag {
	git -C "${OVE_PROJECT_DIR}" log --tags --simplify-by-decoration --pretty="format:%ai %D"
}

# log: :project '$OVE_PROJECT_NAME' commit log for branch '$OVE_PROJECT_CI_BRANCH'
function ove-log {
	git -C "${OVE_PROJECT_DIR}" log --decorate $OVE_PROJECT_CI_BRANCH
}

# checkout:[rev[ [purge|autostash]]]:git checkout -p for all git repositories OR checkout a new project revision, use 'purge' with care
function ove-checkout {
	local cmd
	local dirty_repos
	local git
	local proj
	local repo
	local rev

	rev="$1"

	if [ $# -eq 0 ]; then
		for git in $(ove_dirty_repos); do
			cmd='git diff --quiet || (echo $PWD; git checkout -p)'
			ove_revtab_forsome "$cmd" "$git"
		done
	elif [ "$#" -eq 1 ] || [ "$#" -eq 2 ]; then
		if [ "$2" == "purge" ]; then
			cmd='git reset; git checkout .'

			read -p "Proceed to run '$cmd' for all git repositories? (y/N) " -r
			echo
			if [[ $REPLY =~ ^[Yy]$ ]]; then
				read -p "Are you really sure? (y/N) " -r
				echo
				if [[ $REPLY =~ ^[Yy]$ ]]; then
					ove_revtab_forall "$cmd"
				fi
			fi
		elif [ "$2" == "autostash" ]; then
			dirty_repos=$(ove_dirty_repos)

			for repo in $dirty_repos; do
				git -C "$repo" stash save -q "stashed by ove-checkout"
			done
		else
			dirty_repos=$(ove_dirty_repos)

			if [ "$dirty_repos" != "" ]; then
				ove_echo_error_noprefix "You have staged/unstaged changes in the following repositories:"
				ove-status "$dirty_repos"
				return 1
			fi
		fi

		git -C "${OVE_PROJECT_DIR}" fetch --all

		if ! git -C "${OVE_PROJECT_DIR}" -c advice.detachedHead=false checkout "$rev"; then
			ove_echo_error_noprefix "git checkout '$rev' failed"
			echo
			echo "available tags:"
			git -C "${OVE_PROJECT_DIR}" tag
			echo
			echo "available branches:"
			git -C "${OVE_PROJECT_DIR}" branch --no-color --all | grep -v detached

			# cleanup
			if [ "$2" == "autostash" ]; then
				for repo in $dirty_repos; do
					git -C "$repo" stash pop -q
				done
			fi

			return 1
		fi

		# init everything
		ove_init

		# clone and checkout
		ove_revtab_clone_and_checkout

		# validate revtab revision
		ove_revtab_check

		if [ "$2" == "autostash" ]; then
			for repo in $dirty_repos; do
				git -C "$repo" stash pop -q
			done
		fi

		ove_patch_repositories
	fi
}

# list-commands: :list commands
function ove-list-commands {
	local a
	local b

	a=$(grep -B1 "^function ove-" "$OVE_BASE_DIR"/ove | \
		grep '\#' | \
		cut -b3-| \
		sort | \
		envsubst)
	b=$(set | \
		grep helptext | \
		grep -v '\$'| \
		cut -d'"' -f2)

	printf "$a\n$b" | \
		sort | \
		column -s: -t
}

# help:[PATTERN]:OVE help
function ove-help {
	local h
	local longest_argument
	local longest_function
	local longest_function_project
	local nbr_of_hypens

	if [ $# -ne 0 ]; then
		for h in $*; do
			ove-help | grep -E --color=always "$h"
		done
		return 0
	fi

	longest_function=$(grep -B1 "^function ove-" ${OVE_SELF} | \
		grep '\#' | \
		cut -b3- | \
		cut -d: -f1 | \
		wc -L)
	longest_function_project=$(set | \
		grep helptext | \
		grep -v '\$' | \
		cut -d'"' -f2 | \
		cut -d: -f1 | \
		wc -L)
	longest_argument=$(grep -B1 "^function ove-" ${OVE_SELF} | \
		grep '\#' | \
		cut -b3- | \
		cut -d: -f2 | \
		wc -L)
	longest_argument_project=$(set | \
		grep helptext | \
		grep -v '\$' | \
		cut -d'"' -f2 | \
		cut -d: -f2 | \
		wc -L)
	longest=$longest_function
	longest_a=$longest_argument
	[ $longest_function_project -gt $longest_function ] && longest=$longest_function_project
	[ $longest_argument_project -gt $longest_argument ] && longest_a=$longest_argument_project
	nbr_of_hypens=$((longest + longest_a + 15))
	printf "%-"$((longest + 2))"s%-"$((longest_a + 2))"s%7s%s\n" "Command" "Arguments" "Description"
	printf "%0.s-" $(eval echo {1..$nbr_of_hypens})
	echo
	ove-list-commands
	echo
	cat <<EOF

Examples
=====

Build
-----
# Do the initial build
#
# Steps performed for each project: bootstrap, configure, build, install

	$ ove buildme

# Build all projects in order. 'clean' will be performed if needed.
#
# Steps performed for each project: [clean], build, install

	$ ove make

# Build a specific project and all project dependencies. 'clean' will be performed if needed.
#
# Steps performed for each project: [clean], make, make install

	$ ove make projA

# Clean all projects.
#
# Steps performed for each project: clean

	$ ove clean

# Properly remove all files for all git repositories.
#
# Steps performed for each repository: git clean -dffx

	$ ove mrproper

Source control
--------------
# Status of all git repositories
#
# Steps performed for each repository: git status -zbs -uno

	$ ove status

# Synchronize with the outside world
#
# Steps performed for each repository: git fetch --all

	$ ove fetch

# Curious mind? List patches your friends have upstreamed since your last pull.

	$ ove news

# Checkout revision

	$ ove checkout 1.0.2

# Search all git repositories
#
# Steps performed for each repository: git grep

	$ ove grep DEADBEEF
EOF

	# Project specific help text
	if [ -e "${OVE_PROJECT_DIR}"/help ]; then
		echo
		echo "Project '$OVE_PROJECT_NAME' help"
		printf "%0.s-" $(eval echo {1..$(($(echo $OVE_PROJECT_NAME | wc -L) + 15))})
		echo
		cat "${OVE_PROJECT_DIR}/help"
	fi
}

# ag:PATTERN:search OVE workspace using The Silver Searcher
function ove-ag {
	if ! command -v ag > /dev/null; then
		echo "https://duckduckgo.com/?q=the+silver+searcher"
		return 1
	fi

	[ $# -eq 0 ] && echo "No pattern, try again" && return 1

	ove_revtab_forall_parallel 'ag --color "'"$*"'" | sed -e 's@^@\$PWD/@g''
}

# grep:PATTERN:grep OVE workspace
function ove-grep {
	[ $# -eq 0 ] && echo "No pattern, try again" && return 1

	ove_revtab_forall_parallel 'git --no-pager grep --color=always "'"$*"'" | sed -e 's@^@\$PWD/@g''
}

# blame-history:PATTERN:git log -S for all git repositories
function ove-blame-history {
	[ $# -eq 0 ] && echo "No pattern, try again" && return 1
	ove_revtab_forall 'git --no-pager log --color=always -p -S "'"$*"'"'
}

# blame:PATTERN:git grep-blame-log combo
function ove-blame {
	local file
	local git
	local i
	local line
	local res
	local s
	local sha
	local str

	[ $# -eq 0 ] && ove_echo_error_noprefix "no pattern, try again" && return 1

	s="$*"

	if [ "$OVE_REPO_LIST" == "" ]; then
		echo "run 'ove fetch' first!"
		return 1
	fi

	for git in $OVE_REPO_LIST; do
		! [ -d "$git" ] && continue
		res=($(git -C "$git" --no-pager grep --no-color -I -n "$s" | cut -d: -f1,2))

		for i in "${res[@]}"; do
			file=$(echo "$i" | cut -d: -f1)
			line=$(echo "$i" | cut -d: -f2)
			sha=$(git -C "$git" --no-pager blame -L"$line","$line" "$file" | cut -d' ' -f1)
			str="$git/$file:$line"
			if [ "$sha" == "00000000" ]; then
				str+=" [ Not Committed Yet ]"
			fi
			if [ "$sha" != "00000000" ]; then
				git -C "$git" --no-pager log --color=always -1 "$sha"
			fi
			echo
			head -"$line" "$git"/"$file" | \
				tail -1 | \
				grep --color=always "$s" | \
				sed -e 's/^/    /g'
			echo
			echo "    File: $str"
			echo
		done
	done
}

# config:[CONFIG]:show or manipulate .oveconfig
function ove-config {
	local cfg
	local cfg_diff
	local d
	local grep_pattern
	local var

	if [ -e "$HOME/.oveconfig" ]; then
		cfg=$HOME/.oveconfig
		cfg_diff="$(diff -y --suppress-common-lines $HOME/.oveconfig <(git -C ${OVE_PROJECT_DIR} show HEAD:.oveconfig) \
			| awk '{print $1}')"
	elif [ -e "${OVE_PROJECT_DIR}/.oveconfig" ]; then
		cfg=${OVE_PROJECT_DIR}/.oveconfig
		cfg_diff="$(git -C ${OVE_PROJECT_DIR} diff --no-color -U1 --raw ${OVE_PROJECT_DIR}/.oveconfig | \
			grep '^+[A-Z]\+'| \
			cut -b2- | \
			awk '{print $1}')"
	else
		return
	fi

	grep_pattern="$"
	for d in $cfg_diff; do
		grep_pattern+="|$d "
	done

	if [ $# -eq 0 ]; then
			grep -v '^#' $cfg | \
				grep -v '^$' | \
				sort | \
				grep -E --color "${grep_pattern}"
	elif [ $# -eq 1 ]; then
		if ! grep -q -i $1 $cfg; then
			echo "error: config '$1' not found"
		else
			grep_pattern+="|$1"
			grep -v '^#' $cfg | \
				grep -v '^$' | \
				grep -i $1 | \
				grep -E --color "${grep_pattern}"
		fi
	elif [ $# -gt 1 ]; then
		var=$1
		shift
		if grep -q -w $var $cfg; then
			sed -i -e "s|\(^$var\s\+\).*|\1$*|g" $cfg
			ove-config $var
		else
			echo "error: config '$var' not found"
		fi
	fi
}

# ls-files:[PATTERN]:git ls-files for all git repositories
function ove-ls-files {
	local cmd

	if [ $# -eq 0 ]; then
		cmd='git ls-files | while read line; do echo -e $PWD/$line; done'
	else
		cmd="re="$*"; git ls-files | while read line; do [[ \$PWD/\$line =~ \$re ]] && echo -e \$PWD/\$line; done"
	fi

	ove_revtab_forall "$cmd"
}

# list-modified-files: :list modified files
function ove-list-modified-files {
	local cmd
	local git

	cmd='git --no-pager diff-index --quiet HEAD || git diff --name-only HEAD | sed -e "s|^|$git/|g"'

	for git in $(ove_dirty_repos); do
		ove_revtab_forsome "$cmd" "$git"
	done | sort -u
}

# list-committed-files:[DAYS]:list committed files within 7 or DAYS day(s) {
function ove-list-committed-files {
	local cmd
	local days

	[ $# -eq 1 ] && days="$1" || days=7

	cmd='git --no-pager -C $git log --no-merges --author="$(git config --get user.name)" --name-only --pretty=format:"" --since="'$days' days" | while read line; do [ -f $PWD/$line ] && echo -e $PWD/$line; done'

	ove_revtab_forall "$cmd" | sort -u
}

function ove_edit {
	local editor
	local f
	local files
	local files_by_epoch

	files=$(ove-list-modified-files)

	[ "$files" == "" ] && return

	editor="$1"
	shift

	# sanity check
	if ! command -v ${editor} > /dev/null; then
		ove_echo_stderr_noprefix "${editor} is not installed?"
		return 1
	fi

	# stat every file
	files_by_epoch=$(for f in $files; do echo $(stat --format '%Y' $f):$f; done | \
		sort -r | \
		cut -d: -f2)

	if [ $# -eq 1 ]; then
		files_by_epoch=$(printf "$files_by_epoch" | \
			sed -e "s|$OVE_BASE_DIR/||g" | \
			grep -i $1 | \
			sed -e "s|^|$OVE_BASE_DIR/|g")
	fi

	if [ "$files_by_epoch" != "" ]; then
		if [ "${editor}" == "vi" ]; then
			vi -o $files_by_epoch -c "wincmd H"
		elif [ "${editor}" == "emacs" ]; then
			emacs $files_by_epoch
		else
			ove_echo_stderr_noprefix "unknown editor"
		fi
	fi
}

# emacs:[PATTERN]:open modified files in emacs
function ove-emacs {
	ove_edit emacs $*
}

# vi:[PATTERN]:open modified files in vi
function ove-vi {
	ove_edit vi $*
}

# mrproper:[y|Y]:remove untracked files AND removes '$OVE_STAGE_DIR/*' AND removes '$OVE_ARCHIVE_DIR/*'
function ove-mrproper {
	local archive_dir_size
	local directories
	local directories_uniq
	local nbr_untracked_files
	local o
	local objects
	local repo_sub_dirs
	local stage_dir_size

	nbr_untracked_files=$(ove_revtab_forall_parallel 'git clean -dffxn'| wc -l)
	stage_dir_size="$(tree $OVE_STAGE_DIR | tail -1)"
	archive_dir_size="$(tree $OVE_ARCHIVE_DIR | tail -1)"

	if [ "$1" == "y" ] || [ "$1" == "Y" ]; then
		ove_revtab_forall 'git --no-pager clean -dffx > /dev/null'
		! [ "${OVE_STAGE_DIR}" == "" ] && rm -rf $OVE_STAGE_DIR/*
		! [ "${OVE_ARCHIVE_DIR}" == "" ] && rm -rf $OVE_ARCHIVE_DIR/*

		if [ "$1" == "Y" ]; then
			# untracked directories

			# list of sub directories where we have git repositories
			sub_dirs=$(for a in $OVE_REPO_LIST; do echo $a | \
				sed -e "s|$OVE_BASE_DIR/||g"; done | \
				grep '/')

			if [ "$sub_dirs" != "" ]; then
				repo_sub_dirs=$(echo $sub_dirs | \
					xargs -n1 dirname | \
					sort -u | \
					sed -e "s|^|$OVE_BASE_DIR/|g")
			fi

			# find some directories
			directories=$(find $(readlink -f $OVE_BASE_DIR) $repo_sub_dirs -maxdepth 1 -mindepth 1 -type d | \
				sort)


			if [ "$sub_dirs" == "" ]; then
				directories_uniq=$(find $(readlink -f $OVE_BASE_DIR) -maxdepth 1 -mindepth 1 -type d | sort)
			else
				# remove common paths
				directories_uniq=$(comm -3 \
					<(printf "%s\n" $repo_sub_dirs) \
					<(printf "%s\n" $directories) | \
					xargs -n1)
			fi

			# now we can start to identify directories that can be removed
			for o in $(comm -3 \
				<(echo $OVE_REPO_LIST | tr ' ' '\n' | xargs readlink -f | sort) \
				<(printf "%s\n" $directories_uniq) | \
				grep -Ev "archives$|stage$|$OVE_DIR"); do
				[ -d $o ] && objects+="$o "
			done

			# untracked files
			for o in $(find $(readlink -f $OVE_BASE_DIR) $repo_sub_dirs -maxdepth 1 -mindepth 1 -type f); do
				objects+="$o "
			done

			if [ "$objects" != "" ]; then
				echo $objects | \
					tr ' ' '\n' | \
					sort | \
					xargs file
				echo
				read -p "Proceed to remove $(echo $objects | wc -w) files/directories (list above) using 'rm -rf'? (y/N) " -r
				echo
				if [[ $REPLY =~ ^[Yy]$ ]]; then
					read -p "Are you really sure? (y/N) " -r
					echo
					if [[ $REPLY =~ ^[Yy]$ ]]; then
						rm -rfv $objects
					fi
				fi
			fi
		fi

		return
	fi

	if [ "$nbr_untracked_files" -ne 0 ]; then
		# dry-run first
		ove_revtab_forall 'ove_echo_yellow_noprefix $PWD: && git --no-pager clean -dffxn'
		echo
		read -p "Proceed to remove ${nbr_untracked_files} untracked files and directories (list above) using 'git clean -dffx'? (y/N) " -r
		echo
		if [[ $REPLY =~ ^[Yy]$ ]]; then
			read -p "Are you really sure? (y/N) " -r
			echo
			if [[ $REPLY =~ ^[Yy]$ ]]; then
				ove_revtab_forall 'git --no-pager clean -dffx'
			fi
		fi
	fi

	if [ "$stage_dir_size" != "0 directories, 0 files" ]; then
		# all but the last line
		tree -C $OVE_STAGE_DIR | head -n -1

		read -p "Proceed to remove ${stage_dir_size} (list above) from '$OVE_STAGE_DIR' using 'rm -rf'? (y/N) " -r
		echo
		if [[ $REPLY =~ ^[Yy]$ ]]; then
			echo "$ rm -rf $OVE_STAGE_DIR/*"
			echo
			read -p "Are you really sure you want to run the above command? (y/N) " -r
			echo
			if [[ $REPLY =~ ^[Yy]$ ]]; then
				if ! [ "${OVE_STAGE_DIR}" == "" ]; then
					rm -rf $OVE_STAGE_DIR/*
				fi
			fi
		fi
	fi

	if [ "$archive_dir_size" != "0 directories, 0 files" ]; then
		# all but the last line
		tree -C $OVE_ARCHIVE_DIR | head -n -1

		read -p "Proceed to remove ${archive_dir_size} (list above) from '$OVE_ARCHIVE_DIR' using 'rm -rf'? (y/N) " -r
		echo
		if [[ $REPLY =~ ^[Yy]$ ]]; then
			echo "$ rm -rf $OVE_ARCHIVE_DIR/*"
			echo
			read -p "Are you really sure you want to run the above command? (y/N) " -r
			echo
			if [[ $REPLY =~ ^[Yy]$ ]]; then
				if ! [ "${OVE_ARCHIVE_DIR}" == "" ]; then
					rm -rf $OVE_ARCHIVE_DIR/*
				fi
			fi
		fi
	fi
}

# !: :view last command in pager (=${OVE_PAGER})
function ove-! {
	[ -f "$OVE_LAST_COMMAND" ] && ${OVE_PAGER} $OVE_LAST_COMMAND
}

# describe:[GIT...]:git describe+log+status combo for all/specified git repositories
function ove-describe {
	local func

	func=ove_revtab_forall_parallel

	[ $# -gt 0 ] && func=ove_revtab_forsome

	$func 'echo $(echo $git | sed -e "s|$OVE_BASE_DIR/||g")@$(git describe --tags --always --dirty --long)@"$(git log --format="%<(20,trunc)%s" -1)"@"$(git -c color.status=never status -s -uno | tr "\n" " ")"' $* |\
		column -t -s'@' | \
		sort
}

# list-heads:[GIT...]:git log for all/specified git repositories
function ove-list-heads {
	local cmd
	local f

	cmd='echo $(echo -n "$(echo $git | sed -e "s|$OVE_BASE_DIR/||g")?" && git --no-pager log -1 --no-merges --format=%h?%ar?%ae?%s)'
	f="${OVE_PROJECT_TMP_DIR}/$FUNCNAME.tmp"

	> $f
	if [ $# -eq 0 ]; then
		ove_revtab_forall_parallel "$cmd" > $f
	else
		ove_revtab_forsome "$cmd" "$*" > $f
	fi
	sort $f | \
		column -t -s? 2> /dev/null

	rm $f
}

# ls-remote: :git ls-remote <URL> HEAD for all git repositories
function ove-ls-remote {
	local count
	local git
	local sha
	local str
	local url

	count=0
	while ((count < ove_revtab_num_repositories)); do
		git="${ove_revtab_git_name[$count]}"
		url="${ove_revtab_fetch_url[$count]}"

		sha=$(git ls-remote $url HEAD | awk {'print $1'})
		str+="$git:$sha\n"
		let count+=1
	done

	url=$(git -C "${OVE_PROJECT_DIR}" config --get remote.origin.url)
	sha=$(git -C "${OVE_PROJECT_DIR}" ls-remote $url HEAD | awk {'print $1'})
	git=$OVE_PROJECT_NAME
	str+="$git:$sha\n"

	printf "$str" | \
		sort | \
		column -t -s:
}

# heads2revtab:[GIT...]:update '${OVE_PROJECT_DIR}/revtab' with current SHA-1
function ove-heads2revtab {
	local git
	local repos

	if [ $# -eq 0 ]; then
		repos=$(ove_revtab_list_basename)
	else
		repos=$*
	fi

	for git in $repos; do
		SHA1=$(git -C "$OVE_BASE_DIR"/$git rev-parse HEAD)
		sed -i -e 's|^'$git'\(\s\+.*\s\+.*\s\+\)\(.*\)$|'$git'\1'$SHA1'|g' "${OVE_PROJECT_DIR}"/revtab
	done

	git --no-pager -C "${OVE_PROJECT_DIR}" diff revtab
}

# what-is:DIRECTORY...:classify files using 'file' within a directory
function ove-what-is {
	local dir

	for dir in "$@"; do
		[ ! -d "$dir" ] && continue
		echo "$dir":
		find "$dir" -not -path '*.git*' -print0 | \
			xargs -0 -P"$(nproc)" file | \
			awk '{$1=""; print $0}' | \
			sort | \
			uniq -c | \
			sort -nr
	done
}

# show:[revision...]:ove list-heads or search for 'revision' within all git repositories. If found run 'git show SHA-1|TAG'
function ove-show {
	local SHA

	if [ $# -eq 0 ]; then
		ove-list-heads
		return
	fi

	for SHA in "$@"; do
		# remove dirty tags
		SHA=${SHA%-dirty}
		ove_revtab_forall 'git --no-pager show '"$SHA"' -- &> /dev/null && \
			ove_echo_yellow_noprefix $PWD && \
			git show --color=always '"$SHA"' -- && \
			echo'
	done
}

# cd: :helper for 'cd $OVE_BASE_DIR'
function ove-cd {
	cd "$OVE_BASE_DIR"
}

# version: :print OVE version
function ove-version {
	echo "OVE [SHA-1: $OVE_SHA @ $OVE_OS $OVE_OS_VER]"
}

# loglevel:[LEVEL] :show or change loglevel [0-4]
function ove-loglevel {
	set +x
	if [ $# -eq 1 ] && ! [[ "${1}" =~ ^[0-4]$ ]]; then
		echo "error: try 0-4"
		return 1
	elif [ $# -eq 1 ]; then
		OVE_LOGLEVEL=$1
		ove-config OVE_LOGLEVEL $1 > /dev/null
	fi

	while true; do
		echo "0: silence is golden"
		echo "1: normal"
		echo "2: debug"
		echo "3: execve time analysis"
		echo "4: connect analysis"
		break
	done | grep -E --color "$|$OVE_LOGLEVEL"

	if [ $# -eq 1 ]; then
		OVE_LOGLEVEL=$1
		OVE_REDIRECT_OUTPUT=""
		if [ $1 -eq 0 ]; then
			OVE_REDIRECT_OUTPUT="> /dev/null"
		elif [ $1 -eq 1 ]; then
			set +x
		elif [ $1 -eq 2 ]; then
			set -x
		fi
	fi
}

# dry-run:[0|1]:toggle or set OVE_DRY_RUN
function ove-dry-run {
	if [ $# -eq 1 ] && ! [[ "$1" =~ ^[0-1]$ ]]; then
		echo "usage:"
		ove-help ^${FUNCNAME/ove-/}
		return 1
	fi

	if [ $# -eq 0 ]; then
		OVE_DRY_RUN=$((OVE_DRY_RUN ^= 1))
	else
		OVE_DRY_RUN=$1
	fi

	ove-env | grep ^OVE_DRY_RUN
}

# lastlog:[cmin]:list logs created within last 60 min or cmin min
function ove-lastlog {
	local cmin

	[ "$#" -eq 1 ] && cmin=$1 || cmin=60

	find $OVE_LOG_DIR -type f -cmin -$cmin -print0 | \
		xargs -0 stat --format '%Y:%n' | \
		sort -nr | \
		cut -d: -f2 | \
		grep -v $FUNCNAME | \
		sed "s/\(^.*-ove-\(.*\)-$(hostname)-\(.*\).log\)/\3@\2@\1/g" | \
		column -t -s@
}

# authors: :list author summary for all git repositories
function ove-authors {
	local git

	declare -A urls

	if [ "$OVE_REPO_LIST" == "" ]; then
		echo "run 'ove fetch' first!"
		return 1
	fi

	for git in $OVE_REPO_LIST; do
		if [ ! -d "$git" ] || [ "$git" == "$OVE_DIR" ]; then
			continue
		fi

		# Try to avoid that a git is counted more than one time
		url=$(git --no-pager -C "$git" remote -v | \
			grep fetch | \
			cut -f2 | \
			cut -d' ' -f1 | \
			uniq | \
			sed -e 's/[^a-zA-Z0-9\-]/_/g' | \
			sed -e 's/_git$//g')
		if test "${urls["$url"]+isset}"; then
			continue
		fi
		urls["$url"]=1

		git --no-pager -C "$git" log --pretty="%ae"
	done | \
		sort | \
		uniq -c | \
		sort -nr
}

# domains: :list email domain summary for all git repositories
function ove-domains {
	ove-authors | grep '@' | cut -d@ -f2 | sort | uniq -c | sort -nr
}

function ove_bash_complete {
	local cmd
	local cur
	local opts
	local size
	local subcommand
	local wordlist

	COMPREPLY=()

	cur="${COMP_WORDS[COMP_CWORD]}"
	subcommand="${COMP_WORDS[1]}"
	size=$((${#COMP_WORDS[@]} - 1))

	# project commands
	for cmd in $OVE_PROJECT_COMMANDS; do
		if [ "${cmd}" == "${subcommand}" ] ||
			[ "${cmd}-parallel" == "${subcommand}" ]; then
			if [ $size -ge 2 ]; then
				COMPREPLY=( $(compgen -W "$OVE_PROJECT_LIST" -- "${cur}") )
				return
			fi
		fi
	done

	# scripts
	for cmd in $OVE_SCRIPTS_LIST; do
		if [ "${cmd}" == "${subcommand}" ] && [ -e "${ove_scripts_name2path[${cmd}]}/${cmd}.complete" ]; then
			source "${ove_scripts_name2path[${cmd}]}/${cmd}.complete"
			return
		fi
	done

	# commands without arguments: do nothing
	if [ $size -eq 2 ]; then
		if echo $OVE_BUILT_INS_WITHOUT_ARGS | tr ' ' '\n' | grep -q ^$subcommand$; then
			return
		fi
	fi

	wordlist=""
	if [ "${subcommand}" == "make" ] ||
		[ "${subcommand}" == "buildme-parallel" ] ||
		[ "${subcommand}" == "buildme" ]; then
		if [ $size -eq 2 ]; then
			wordlist=$OVE_PROJECT_LIST
		elif [ $size -gt 2 ]; then
			return
		fi
	elif [ "${subcommand}" == "checkout" ]; then
		if [ $size -eq 2 ]; then
			wordlist=$(ove_project_tags_and_branches)
		elif [ $size -eq 3 ]; then
			wordlist="purge autostash"
		else
			return
		fi
	elif [ "${subcommand}" == "stash" ]; then
		if [ $size -eq 2 ]; then
			wordlist="drop list pop show"
		else
			return
		fi
	elif [ "${subcommand}" == "show" ]; then
		if [ $size -ge 2 ]; then
			wordlist="$(ove_revtab_forall_parallel 'git tag') HEAD FETCH_HEAD ORIG_HEAD MERGE_HEAD CHERRY_PICK_HEAD"
			wordlist+=" $(ove-list-heads | awk '{print $2}')"
			if [ -e ${OVE_PROJECT_STATE_DIR}/revtab-news ]; then
				wordlist+=" $(grep -o '^[a-f0-9]\+' ${OVE_PROJECT_STATE_DIR}/revtab-news)"
			fi
			if [ -e ${OVE_PROJECT_STATE_DIR}/revtab-ahead ]; then
				wordlist+=" $(grep -o '^[a-f0-9]\+' ${OVE_PROJECT_STATE_DIR}/revtab-ahead)"
			fi
		fi
	elif [ "${subcommand}" == "diff-project" ] ||
		[ "${subcommand}" == "log-project" ] ||
		[ "${subcommand}" == "shortlog-project" ]; then
		if [ $size -lt 4 ]; then
			wordlist=$(ove_project_tags_and_branches)
		else
			return
		fi
	elif [ "${subcommand}" == "do" ]; then
		if [ $size -eq 2 ]; then
			wordlist=$(ove_revtab_list_basename)
		elif [ $size -gt 2 ]; then
			return
		fi
	elif [ "${subcommand}" == "switch" ]; then
		if [ $size -eq 2 ]; then
			wordlist=$(ove-locate | \
				grep -v '^\s' | \
				xargs -n1 basename)
		elif [ $size -gt 2 ]; then
			return
		fi
	elif [ "${subcommand}" == "vi" ] ||
		[ "${subcommand}" == "emacs" ]; then
		if [ $size -eq 2 ]; then
			wordlist=$(ove-list-modified-files | \
				xargs -n1 basename)
		elif [ $size -gt 2 ]; then
			return
		fi
	elif [ "${subcommand}" == "config" ]; then
		if [ $size -eq 2 ]; then
			wordlist=$(ove-config | awk '{print $1}')
		elif [ $size -gt 2 ]; then
			return
		fi
	elif [ "${subcommand}" == "add" ] ||
		[ "${subcommand}" == "branch" ] ||
		[ "${subcommand}" == "describe" ] ||
		[ "${subcommand}" == "diff" ] ||
		[ "${subcommand}" == "diff-cached" ] ||
		[ "${subcommand}" == "heads2revtab" ] ||
		[ "${subcommand}" == "list-stash" ] ||
		[ "${subcommand}" == "remote" ] ||
		[ "${subcommand}" == "reset" ] ||
		[ "${subcommand}" == "wdiff" ]; then
		if [ $size -ge 2 ]; then
			wordlist=$(ove_revtab_list_basename)
			wordlist+=" $OVE_PROJECT_NAME"
		fi
	elif [ "${subcommand}" == "news" ] ||
		[ "${subcommand}" == "pull" ]; then
		if [ -e ${OVE_PROJECT_STATE_DIR}/revtab-status ] && grep -q 'behind.*]' ${OVE_PROJECT_STATE_DIR}/revtab-status; then
			wordlist=$(grep 'behind.*]' ${OVE_PROJECT_STATE_DIR}/revtab-status | \
				cut -d: -f1 | \
				xargs)
		else
			wordlist=$(ove_revtab_list_basename)
			wordlist+=" $OVE_PROJECT_NAME"
		fi
	elif [ "${subcommand}" == "ahead" ] ||
		[ "${subcommand}" == "pull" ]; then
		if [ -e ${OVE_PROJECT_STATE_DIR}/revtab-status ] && grep -q "${subcommand}.*]" ${OVE_PROJECT_STATE_DIR}/revtab-status; then
			wordlist=$(grep "${subcommand}.*]" ${OVE_PROJECT_STATE_DIR}/revtab-status | \
				cut -d: -f1 | \
				xargs)
		else
			wordlist=$(ove_revtab_list_basename)
			wordlist+=" $OVE_PROJECT_NAME"
		fi
	elif [ "${subcommand}" == "fetch" ] ||
		[ "${subcommand}" == "list-heads" ] ||
		[ "${subcommand}" == "status" ]; then
		wordlist=$(ove_revtab_list_basename)
		wordlist+=" $OVE_PROJECT_NAME"
	elif [ "${subcommand}" == "systest" ] ||
		[ "${subcommand}" == "systest-parallel" ]; then
		if [ $size -ge 2 ]; then
			wordlist=$(ove-list-systests)
		fi
	elif [ "${subcommand}" == "export" ]; then
		if [ $size -ge 2 ]; then
			wordlist=$OVE_PROJECT_LIST
		fi
	elif [ "${subcommand}" == "apply" ]; then
		if [ $size -ge 2 ]; then
			return
		fi
	elif [ "${subcommand}" == "env" ]; then
		if [ $size -eq 2 ]; then
			wordlist=$(compgen -A variable | grep OVE_)
		else
			return
		fi
	elif [ "${subcommand}" == "unittest" ]; then
		if [ $size -ge 2 ]; then
			wordlist=$(find $OVE_DIR/tests -maxdepth 1 -mindepth 1 -name "t*" -type f -exec basename {} \;)
		fi
	elif [ "${subcommand}" == "what-is" ]; then
		if [ $size -ge 2 ]; then
			wordlist=$(find $(readlink -f $PWD) -maxdepth 1 -mindepth 1 -not -path '*.git' -type d -exec basename {} \;)
		fi
	elif [ "${subcommand}" == "select-configuration" ]; then
		if [ $size -eq 2 ]; then
			wordlist="default $(find "${OVE_PROJECT_DIR}/projects" -name "configure-*" -type l -exec basename {} \; | sed 's/configure-//g')"
		else
			return
		fi
	fi

	if [ "$wordlist" != "" ]; then
		COMPREPLY=( $(compgen -W "$wordlist" -- ${cur}) )
	else
		opts="$OVE_ALL_COMMANDS"
		if compgen -W "${opts}" -- "${cur}" &> /dev/null; then
			COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
		fi
	fi
}

function ove_update_tab_complete {
	local cmd

	OVE_BUILT_INS_WITHOUT_ARGS=$(grep -B1 '^function ove-' ${OVE_SELF} | \
		grep ': :' | \
		cut -b3- | \
		cut -d: -f1 | \
		sort | \
		tr '\n' ' ' | \
		xargs "$OVE_ECHO")

	OVE_BUILT_INS=$(grep -o '^function ove-.* ' ${OVE_SELF} | \
		sed -e ':a;N;$!ba;s/function ove-//g' | \
		sort | \
		tr '\n' ' ' | \
		xargs "$OVE_ECHO")

	# project commands
	OVE_ALL_COMMANDS=$OVE_PROJECT_COMMANDS

	# built-in functions
	OVE_ALL_COMMANDS+=" $OVE_BUILT_INS"

	# scripts
	if [ "$OVE_SCRIPTS_LIST" != "" ];then
		OVE_ALL_COMMANDS+=" $OVE_SCRIPTS_LIST"
	fi

	# parallel project commands
	for cmd in $OVE_PROJECT_COMMANDS; do
		OVE_ALL_COMMANDS+=" ${cmd}-parallel"
	done

	OVE_ALL_COMMANDS=$(echo $OVE_ALL_COMMANDS | xargs -n1 | sort | xargs)

	export OVE_ALL_COMMANDS

	complete -o bashdefault -o default -F ove_bash_complete ove
	for cmd in $(ove_project_commands_list); do
		complete -W "$OVE_PROJECT_LIST" "ove-$cmd"
	done
}

function ove_add_script_func {
	local htext
	local script
	local script_dir

	script_dir=$1
	script=$2

	ove_scripts_name2path[$script]=$script_dir

	if [ -f $script_dir/$script.help ]; then
		htext=$(<$script_dir/$script.help)
		eval "ove-$script() {
		local helptext=\"$htext\"
		\"$script_dir\"/$script \$*
		}"
	else
		eval "ove-$script() {
		local helptext=\"$script: :run '$script_dir/$script'\"
		\"$script_dir\"/$script \$*
		}"
	fi
}

function ove_scripts_init {
	local array
	local oldIFS
	local repo
	local script
	local script_list
	declare -A -g ove_scripts_name2path

	# project scripts
	if [ -d "${OVE_PROJECT_DIR}/scripts" ]; then
		script_list=$(find ${OVE_PROJECT_DIR}/scripts -perm -u=x -not -name '*.help' -type f)
		for script in $script_list; do
			ove_add_script_func ${OVE_PROJECT_DIR}/scripts ${script##*/}
			OVE_SCRIPTS_LIST+="${script##*/} "
		done
	fi

	# OVE scripts
	if [ -d "$OVE_DIR/scripts" ]; then
		script_list=$(find $OVE_DIR/scripts -perm -u=x -not -name '*.help' -type f)
		for script in $script_list; do
			ove_add_script_func $OVE_DIR/scripts ${script##*/}
			OVE_SCRIPTS_LIST+="${script##*/} "
		done
	fi

	# repo scripts
	for repo in $(ove_revtab_list_fullpath); do
		! [ -d "$repo/.ove/scripts" ] && continue
		script_list=$(find -L $repo/.ove/scripts -perm -u=x -not -name '*.help' -type f)
		for script in $script_list; do
			ove_add_script_func $repo/.ove/scripts ${script##*/}
			OVE_SCRIPTS_LIST+="${script##*/} "
		done
	done

	array=($OVE_SCRIPTS_LIST)
	oldIFS=$IFS
	IFS=$'\n' OVE_SCRIPTS_LIST=$(xargs "$OVE_ECHO" <<<$(sort <<<"${array[*]}"))
	IFS=$oldIFS
}

# show-configuration: :show current build configuration for each project
function ove-show-configuration {
	[ -d "${OVE_PROJECT_DIR}/projects" ] && \
		tree -l -P 'configure' -I 'configure-*' ${OVE_PROJECT_DIR}/projects
}

# select-configuration:[PATTERN|default]:select build configuration for each project
function ove-select-configuration {
	local c
	local configs
	local iter
	local nbr_of_configs
	local p
	local projects

	# list of projects
	projects=$OVE_PROJECT_LIST
	iter=1
	for p in $projects; do
		# ignore projects without a project directory
		[ ! -d "${OVE_PROJECT_DIR}/projects/$p" ] && continue

		# multiple configurations, ask which one to select
		configs=$(find "${OVE_PROJECT_DIR}/projects/$p" -name "configure-*" -type l)
		nbr_of_configs=$(find "${OVE_PROJECT_DIR}/projects/$p" -name "configure-*" -type l| wc -l)
		if [ "$nbr_of_configs" -gt 1 ]; then
			# pattern, select config
			if [ $# -eq 1 ]; then
				# use the default configuration
				if [ $1 == "default" ]; then
					git -C ${OVE_PROJECT_DIR} checkout ${OVE_PROJECT_DIR}/projects/$p/configure
					continue
				fi

				for c in $configs; do
					if basename $c | grep -w -q configure-$1; then
						ove_echo_green_noprefix $p:
						pushd ${OVE_PROJECT_DIR}/projects/$p &>/dev/null
						ln -sfv configure-$1 configure
						popd &>/dev/null
						break
					fi
				done
				continue
			fi

			# no pattern, ask user
			ove_echo_green_noprefix $p:
			echo "0: default"
			let iter=1
			for c in $configs; do
				echo -n "$iter: "
				basename $(echo $c | sed 's/configure-//g')
				let iter+=1
			done
			echo
			read -p "Select configuration? " -r
			echo
			if [[ $REPLY =~ ^[0-9]+$ ]] && [[ $REPLY -le $nbr_of_configs ]]; then
				if [[ $REPLY == 0 ]]; then
					git -C ${OVE_PROJECT_DIR} checkout ${OVE_PROJECT_DIR}/projects/$p/configure
				else
					cfg=$(echo $configs | cut -d' ' -f$REPLY)
					cfg_basename=$(basename $cfg)
					pushd ${OVE_PROJECT_DIR}/projects/$p &>/dev/null
					ln -sfv $cfg_basename configure
					popd &>/dev/null
				fi
			fi
		fi
	done

	ove-show-configuration
}

# init:initialize OVE project
function ove_init {
	OVE_ECHO=$(which echo)
	OVE_BASE_DIR="$(ove_get_base_dir)"
	OVE_PROJECT_DIR=$(readlink -f $OVE_BASE_DIR/.owel)
	OVE_PROJECT_LIST=$(ove_list_projects)
	OVE_PROJECT_COMMANDS=$(ove_project_commands_list)
	OVE_DIR="$(cd "$(dirname "$(readlink -f ${BASH_SOURCE[0]})")"; pwd -P)"
	OVE_BASENAME="$(basename $(readlink -f ${BASH_SOURCE[0]}))"
	OVE_SELF="${OVE_DIR}/${OVE_BASENAME}"

	# own config has precedence over project config
	if [ -e $HOME/.oveconfig ]; then
		ove_read_config $HOME/.oveconfig
	elif [ -e ${OVE_PROJECT_DIR}/.oveconfig ]; then
		ove_read_config ${OVE_PROJECT_DIR}/.oveconfig
	fi

	ove_revtab_init
	ove_revtab_parse ${OVE_PROJECT_DIR}/revtab
	ove_projects_init
	ove_projects_parse ${OVE_PROJECT_DIR}/projs
	ove_scripts_init

	if [ "${OVE_LOGLEVEL}" == "2" ]; then
		set -x
	fi

	[ "$1" == "quick" ] && return 0

	if grep ^function ${OVE_SELF} | grep -q -v 'function ove'; then
		ove_echo_error_noprefix "functions need to start with 'ove-' or 'ove_'"
		grep ^function ${OVE_SELF} | grep -v 'function ove'
		return 1
	fi

	if ! ove_validate_projs; then
		return 1
	fi

	if ! ove_validate_revtab; then
		return 1
	fi

	ove_update_tab_complete

	if [ -z "${OVE_DRY_RUN+x}" ]; then
		OVE_DRY_RUN=0
		export OVE_DRY_RUN
	fi
	if [ -z "${OVE_LOCATE_SEARCH_DIR+x}" ]; then
		OVE_LOCATE_SEARCH_DIR=$(readlink -f $(dirname $HOME))
		export OVE_LOCATE_SEARCH_DIR
	fi
	if [ -z "${OVE_PROJECT_CI_BRANCH+x}" ]; then
		OVE_PROJECT_CI_BRANCH="origin/master"
		export OVE_PROJECT_CI_BRANCH
	fi
	if [ -z "${OVE_LOGLEVEL+x}" ]; then
		OVE_LOGLEVEL=1
		OVE_REDIRECT_OUTPUT="> /dev/null"
		export OVE_REDIRECT_OUTPUT
		export OVE_LOGLEVEL
	fi
	if [ -z "${OVE_AUTOCORRECT+x}" ]; then
		OVE_AUTOCORRECT=0
		export OVE_AUTOCORRECT
	fi
	OVE_REPO_LIST=$(ove_revtab_list_fullpath)
	export OVE_REPO_LIST
	OVE_BUILD_ORDER="$(ove-build-order)"
	export OVE_ECHO
	export OVE_BUILD_ORDER
	export OVE_BASE_DIR
	export OVE_PROJECT_DIR
	export OVE_PROJECT_LIST
	export OVE_PROJECT_COMMANDS
	export OVE_DIR
	export OVE_BASENAME
	export OVE_SELF

	OVE_PROJECT_NAME=${OVE_PROJECT_DIR##*/}
	export OVE_PROJECT_NAME

	[ -d /var/tmp ] && OVE_GLOBAL_STATE_DIR=/var${OVE_TMP} || OVE_GLOBAL_STATE_DIR=${OVE_TMP}
	export OVE_GLOBAL_STATE_DIR

	local OVE_STATE_LINK_NAME="${OVE_BASE_DIR}/.ove.state"
	local OVE_TMP_LINK_NAME="${OVE_BASE_DIR}/.ove.tmp"
	if ! [ -h ${OVE_STATE_LINK_NAME} ]; then
		OVE_PROJECT_STATE_DIR=$(mktemp -u -d -p ${OVE_GLOBAL_STATE_DIR}/${OVE_PROJECT_NAME} state-XXXXXXXXXX)

		mkdir -p ${OVE_PROJECT_STATE_DIR}
		ln -s ${OVE_PROJECT_STATE_DIR} ${OVE_STATE_LINK_NAME}

		# always re-create tmp link
		[ -h ${OVE_TMP_LINK_NAME} ] && rm ${OVE_TMP_LINK_NAME}
	else
		OVE_PROJECT_STATE_DIR=$(readlink ${OVE_STATE_LINK_NAME})
		! [ -e "${OVE_STATE_LINK_NAME}" ] && mkdir -p ${OVE_PROJECT_STATE_DIR}
	fi
	export OVE_PROJECT_STATE_DIR

	if ! [ -h ${OVE_TMP_LINK_NAME} ]; then
		# re-use last 10 characters from OVE_PROJECT_STATE_DIR
		OVE_PROJECT_TMP_DIR="${OVE_TMP}/${OVE_PROJECT_NAME}/tmp-${OVE_PROJECT_STATE_DIR: -10}"
		mkdir -p ${OVE_PROJECT_TMP_DIR}
		ln -s ${OVE_PROJECT_TMP_DIR} ${OVE_TMP_LINK_NAME}
	else
		OVE_PROJECT_TMP_DIR=$(readlink ${OVE_TMP_LINK_NAME})
		! [ -e "${OVE_TMP_LINK_NAME}" ] && mkdir -p ${OVE_PROJECT_TMP_DIR}
	fi
	export OVE_PROJECT_TMP_DIR

	OVE_LOG_DIR="${OVE_GLOBAL_STATE_DIR}/logs"
	export OVE_LOG_DIR
	! [ -d "$OVE_LOG_DIR" ] && mkdir -p "$OVE_LOG_DIR"

	OVE_STAGE_DIR=$OVE_BASE_DIR/stage
	export OVE_STAGE_DIR
	OVE_ARCHIVE_DIR=$OVE_BASE_DIR/archives
	export OVE_ARCHIVE_DIR
	OVE_PREFIX="/usr"
	export OVE_PREFIX
	OVE_LDFLAGS=" -L${OVE_STAGE_DIR}${OVE_PREFIX}/lib -Wl,-rpath-link=${OVE_STAGE_DIR}${OVE_PREFIX}/lib"
	export OVE_LDFLAGS
	OVE_CPPFLAGS=" -I${OVE_STAGE_DIR}${OVE_PREFIX}/include"
	export OVE_CPPFLAGS
	OVE_SHA=$(git -C $OVE_DIR rev-parse --short HEAD)
	export OVE_SHA
	OVE_LAST_COMMAND=
	export OVE_LAST_COMMAND
	OVE_INIT_STRING='eval source $OVE_BASE_DIR/ove; ove_init quick'
	export OVE_INIT_STRING
	OVE_PAGER="less -R"
	export OVE_PAGER

	# Update executable and run-time library paths
	PATH=$PATH:${OVE_STAGE_DIR}${OVE_PREFIX}/bin
	export PATH

	LD_LIBRARY_PATH=${OVE_STAGE_DIR}${OVE_PREFIX}/lib
	export LD_LIBRARY_PATH

	return 0
}

function ove_post_checks {
	local corrupt_repos
	local doublets
	local script

	# check for systest doublets
	if [ -e ${OVE_PROJECT_DIR}/systests ]; then
		# yes, this is ugly
		doublets=$(grep -E -v '#|^$' ${OVE_PROJECT_DIR}/systests | \
			awk '{print $1}' | \
			cut -d: -f1 | \
			sort | \
			uniq -c -d)
		if [ "$doublets" != "" ]; then
			echo
			ove_echo_red_noprefix "error: doublet systests identified in '${OVE_PROJECT_DIR}/systests':"
			ove_echo_red_noprefix $doublets
		fi
	fi

	# inform the user if .oveconfig was updated within the project
	if [ -e $HOME/.oveconfig ] && [ -e ${OVE_PROJECT_DIR}/.oveconfig ]; then
		res=$(comm -3 <(grep -E -v '(^#.*$)|(^$)' $HOME/.oveconfig | awk '{ print $1 }' | sort) \
			<(grep -E -v '(^#.*$)|(^$)' ${OVE_PROJECT_DIR}/.oveconfig | awk '{ print $1 }' | sort))
		if [ "$res" != "" ]; then
			echo
			echo "--->"
			ove_echo_yellow_noprefix "warning: the two files:"
			echo
			echo "$HOME/.oveconfig"
			echo "${OVE_PROJECT_DIR}/.oveconfig"
			echo
			echo "...are different. Do a merge!?"
			echo
			diff <(grep -E -v '(^#.*$)|(^$)' $HOME/.oveconfig | awk '{ print $1 }' | sort) \
				<(grep -E -v '(^#.*$)|(^$)' ${OVE_PROJECT_DIR}/.oveconfig | awk '{ print $1 }' | sort)
			echo "<---"
		fi
	fi

	# check for script doublets
	doublets=$(for script in $(ove-list-scripts); do echo ${script##*/}; done | \
		sort | \
		uniq -d)
	if [ "$doublets" != "" ]; then
		echo
		ove_echo_yellow_noprefix "warning: found script duplicates:"
		for script in $doublets; do
			ove-list-scripts| grep -w "${script}$"
		done
	fi

	# check for repos without a '.git' directory
	corrupt_repos=$(ove_revtab_forall_parallel '[ -d .git ] || ove_git2shortpath $(pwd)' | xargs)
	if [ "$corrupt_repos" != "" ]; then
		echo
		ove_echo_error_noprefix "corrupt repo(s): $corrupt_repos"
		echo
		ove_echo_red_noprefix "Fix this by running the following two commands:"
		echo
		echo -e "\t$ rm -rf $corrupt_repos"
		echo -e "\t$ ove fetch $corrupt_repos"
		echo
	fi

	# vaidate revtab revision
	ove_revtab_check
}

# create a '.owel/revtab' file from current directory
function ove_crawl {
	local fetch_url
	local git
	local name
	local push_url
	local rev
	local str

	str=""
	for git in $(find -type d -name .git 2>/dev/null); do
		if ! git -C $git log -1 --oneline &> /dev/null; then
			continue
		fi
		name=$(dirname "$git" | cut -b3-)
		fetch_url=$(git -C "$git" remote -v | \
			grep fetch | \
			awk '{print $2}' | \
			tr -d '\n')
		push_url=$(git -C "$git" remote -v | \
			grep push | \
			awk '{print $2}' | \
			tr -d '\n')
		if git -C "$git" branch | grep -q detached; then
			rev=$(git -C "$git" rev-parse --short HEAD| tr -d '\n')
		else
			rev=$(git -C "$git" branch | \
				cut -d' ' -f2 | \
				tr -d '\n')
		fi

		str+="$name $fetch_url $push_url $rev\n"
	done
	mkdir -vp .owel
	printf "$str" | \
		column -t | \
		sort > .owel/revtab

	echo "Created '.owel/revtab' and populated the file with $(wc -l .owel/revtab) repositories, run 'source ove' again"
}

# $1: command
function ove_command_to_package {
	local package

	# column
	if [ "$1" == "column" ]; then
		if [[ $OVE_OS == *"Ubuntu"* ]] || \
			[[ $OVE_OS == *"Debian"* ]]; then
			package="bsdmainutils"
		elif [[ $OVE_OS == *"Alpine"* ]] || \
			[[ $OVE_OS == *"Fedora"* ]]; then
			package="util-linux"
		elif [[ $OVE_OS == *"Gentoo"* ]] || \
			[[ $OVE_OS == *"CentOS"* ]]; then
			package=""
		else
			package="$1"
		fi
	# envsubst
	elif [ "$1" == "envsubst" ]; then
		if [[ $OVE_OS == *"Ubuntu"* ]] || \
			[[ $OVE_OS == *"Debian"* ]]; then
			package="gettext-base"
		else
			package="gettext"
		fi
	# file
	elif [ "$1" == "file" ]; then
		package="$1"
	# git
	elif [ "$1" == "git" ]; then
		if [[ $OVE_OS == *"Alpine"* ]]; then
			package="git git-perl"
		elif [[ $OVE_OS == *"Gentoo"* ]]; then
			package="dev-vcs/git"
		else
			package="git"
		fi
	# hostname
	elif [ "$1" == "hostname" ]; then
		if [[ $OVE_OS == *"Alpine"* ]]; then
			package="net-tools"
		else
			package="hostname"
		fi
	# locate
	elif [ "$1" == "locate" ]; then
		package="mlocate"
	# pgrep
	elif [ "$1" == "pgrep" ]; then
		if [[ $OVE_OS == *"Ubuntu"* ]] || \
			[[ $OVE_OS == *"Debian"* ]]; then
			package="procps"
		fi
	# script
	elif [ "$1" == "script" ]; then
		if [[ $OVE_OS == *"Ubuntu"* ]] || \
			[[ $OVE_OS == *"Debian"* ]]; then
			package="bsdutils"
		elif [[ $OVE_OS == *"Gentoo"* ]]; then
			package="sys-apps/util-linux"
		fi
	# tree
	elif [ "$1" == "tree" ]; then
		if [[ $OVE_OS == *"Gentoo"* ]]; then
			package="app-text/tree"
		fi
	# tsort
	elif [ "$1" == "tsort" ]; then
		package="coreutils"
	# xz
	elif [ "$1" == "xz" ]; then
		if [[ $OVE_OS == *"Ubuntu"* ]] || \
			[[ $OVE_OS == *"Debian"* ]]; then
			package="xz-utils"
		elif [[ $OVE_OS == *"Gentoo"* ]]; then
			package="app-arch/xz"
		else
			package="xz"
		fi
	fi

	[ "$package" != "" ] && echo $package || echo $1
}

function ove_deps {
	local dep
	local deps
	local pack
	local str_cmds
	local str_packs

	str_packs=""
	str_cmds=""

	deps=()
	deps+=('column')
	deps+=('file')
	deps+=('envsubst')
	deps+=('git')
	deps+=('hostname')
	deps+=('pgrep')
	deps+=('script')
	deps+=('tree')
	deps+=('tsort')

	for dep in "${deps[@]}"; do
		if ! command -v $dep > /dev/null; then
			str_cmds+="$dep "
			pack=$(ove_command_to_package $dep)
			if [ "$pack" != "" ]; then
				str_packs+="$pack "
			fi
		fi
	done

	if [ "$str_cmds" != "" ]; then
		ove_echo_error_noprefix "missing command(s):"
		echo
		for dep in $str_cmds; do
			echo -e "\t$dep"
		done | sort
		echo
		echo "To fix this, run the following command:"
		echo
		echo -e "\t$OVE_OS_PACKAGE_MANAGER $OVE_OS_PACKAGE_MANAGER_ARGS $str_packs"
		echo
		return 1
	fi
}

# $*: list of packages
# returns a list of packages NOT installed
function ove_packages_not_installed {
	[ $# -eq 0 ] && return

	if [[ $OVE_OS == *"Arch Linux"* ]]; then
		comm -2 -3 <(echo $* | xargs -n1 | sort) <(pacman -Q | awk '{print $1}')
	elif [[ $OVE_OS == *"Alpine"* ]]; then
		comm -2 -3 <(echo $* | xargs -n1 | sort) <(apk info | sort)
	elif [[ $OVE_OS == *"CentOS"* ]] || \
		[[ $OVE_OS == *"Fedora"* ]] || \
		[[ $OVE_OS == *"RedHatEnterpriseServer"* ]]; then
		comm -2 -3 <(echo $* | xargs -n1 | sort) <(rpm -qa --qf "%{NAME}\n"| sort)
	elif [[ $OVE_OS == *"Debian"* ]] || \
		[[ $OVE_OS == *"Raspbian"* ]] || \
		[[ $OVE_OS == *"Ubuntu"* ]]; then
		dpkg-query -W -f='${Package}:${Status}\n' $* 2>&1 | \
			grep -v ":install ok installed" | \
			sed -e 's/dpkg-query: no packages found matching //g' -e 's/:.*//g' | \
			xargs
	else
		ove_echo_error_noprefix "function '$FUNCNAME' is not implemented for $OVE_OS"
	fi
}

function ove_determine_dist_version_and_pack_manager {
	if [ -e /etc/os-release ]; then
		OVE_OS=$(source /etc/os-release; echo $NAME)
		OVE_OS_VER=$(source /etc/os-release; echo $VERSION_ID)
	elif command -v lsb_release > /dev/null; then
		OVE_OS=$(lsb_release --id --short)
		OVE_OS_VER=$(lsb_release --release --short)
	else
		ove_echo_warning_noprefix "unable to determine distro"
		OVE_OS=$(uname -s)
		OVE_OS_VER=$(uname -r)
	fi


	if [[ $OVE_OS == *"Alpine"* ]]; then
		OVE_OS_PACKAGE_MANAGER="apk"
		OVE_OS_PACKAGE_MANAGER_ARGS="add"
	elif [[ $OVE_OS == *"Arch Linux"* ]]; then
		OVE_OS_PACKAGE_MANAGER="pacman"
		OVE_OS_PACKAGE_MANAGER_ARGS="-S"
	elif [[ $OVE_OS == *"CentOS"* ]]; then
		OVE_OS_PACKAGE_MANAGER="yum"
		OVE_OS_PACKAGE_MANAGER_ARGS="install"
	elif [[ $OVE_OS == *"Debian"* ]] || \
		[[ $OVE_OS == *"Raspbian"* ]] || \
		[[ $OVE_OS == *"Ubuntu"* ]]; then
		OVE_OS_PACKAGE_MANAGER="apt"
		OVE_OS_PACKAGE_MANAGER_ARGS="install"
	elif [[ $OVE_OS == *"Fedora"* ]] || \
		[[ $OVE_OS == *"RedHatEnterpriseServer"* ]]; then
		OVE_OS_PACKAGE_MANAGER="dnf"
		OVE_OS_PACKAGE_MANAGER_ARGS="install"
	elif [[ $OVE_OS == *"Gentoo"* ]]; then
		OVE_OS_PACKAGE_MANAGER="emerge"
		OVE_OS_PACKAGE_MANAGER_ARGS=""
	else
		OVE_OS_PACKAGE_MANAGER="unknown"
		OVE_OS_PACKAGE_MANAGER_ARGS=""
	fi

	export OVE_OS
	export OVE_OS_VER
	export OVE_OS_PACKAGE_MANAGER
	export OVE_OS_PACKAGE_MANAGER_ARGS
}

# replicate:HOST:replicate OVE workspace on HOST
function ove-replicate {
	local d
	local host
	local p
	local s

	if [ $# -ne 1 ]; then
		ove_echo_error_noprefix "usage:"
		ove-help ^${FUNCNAME/ove-/}
		return 1
	fi

	s="$(ove-setup)"
	if [ "$s" == "" ]; then
		ove_echo_error_noprefix "'${OVE_PROJECT_DIR}/SETUP' file not found"
		return 2
	fi

	host="$1"
	if ! ssh -q $host exit; then
		ove_echo_error_noprefix "'$host' is not reachable via ssh"
		return 3
	fi

	# remote directory
	d=$(ssh $host mktemp -d)

	# only diffs relative to the index is included (for now)
	p=$(mktemp -p ${OVE_PROJECT_TMP_DIR})
	ove-diff > $p
	if [ -s "$p" ]; then
		p_remote="$d/$OVE_PROJECT_NAME.patch"
		if ! scp -q $p $host:$p_remote; then
			ove_echo_error_noprefix "not possible to transfer patch file to '$host'"
			rm $p
			return 4
		fi
	fi

	if ! ssh $host "
		echo $ ssh $host;
		echo $ cd $d; cd $d;
		echo $ '$s'; eval $s;
		cd *;
		echo $ pwd; pwd;
		echo $ source ove; source ove;
		ove_init;
		echo $ ove fetch; ove-fetch;
		[ -e $p_remote ] && echo '$ ove apply $p_remote' && ove-apply $p_remote;
		echo $ ove status; ove-status"; then
		ove_echo_error_noprefix "trying to replicate OVE workspace on '$host'"
	else
		echo
		echo "OVE workspace has been replicated to '$host:$d'"
	fi

	rm $p
}

function ove_unittest_preparations {
	local nbr_of_files
	local nbr_of_projs
	local nbr_of_repos
	local nbr_of_systests
	local unittest_path

	nbr_of_files=$1
	nbr_of_projs=$2
	nbr_of_repos=$3
	nbr_of_systests=$4

	unittest_dir="${OVE_PROJECT_TMP_DIR}/unittest"

	echo -n "Preparing $unittest_dir..."
	[ -d $unittest_dir ] && \
		rm -rf $unittest_dir
	mkdir -p $unittest_dir/.ove

	cd $unittest_dir
	ln -s ${OVE_SELF} ove
	ln -s $OVE_DIR/tests

	# remotes
	mkdir -p remotes

	# create some remote bare repos
	for a in $(seq 1 $nbr_of_repos) top; do
		mkdir -p $unittest_dir/remotes/git-$a
		if ! [ -d .git ]; then
			git init -q --bare $unittest_dir/remotes/git-$a
			echo -n .
		fi
	done

	# clone all repositories
	mkdir -p testing/src
	for a in $(seq 1 $nbr_of_repos); do
		if [ $((a%2)) -eq 0 ]; then
			git clone -q remotes/git-$a $unittest_dir/testing/src/git-$a &> /dev/null
		else
			git clone -q remotes/git-$a $unittest_dir/git-$a &> /dev/null
		fi
		echo -n .
	done
	git clone -q $unittest_dir/remotes/git-top &> /dev/null
	ln -s git-top .owel

	# add some files
	for a in $(seq 1 $nbr_of_repos); do
		if [ $((a%2)) -eq 0 ]; then
			cd $unittest_dir/testing/src/git-$a
		else
			cd $unittest_dir/git-$a
		fi

		for i in $(seq 1 $nbr_of_files); do
			echo -n .
			filename=$(head /dev/urandom | tr -dc A-Za-z0-9 | head -c 13 ; echo '')
			touch $filename
			git add $filename
			git commit -q -m "$filename"
			git tag 0.0.$i
			git push -q origin master
			git push -q --tags
		done
	done

	# create revtab
	for a in $(seq 1 $nbr_of_repos); do
		if [ $((a%2)) -eq 0 ]; then
			echo "testing/src/git-$a $unittest_dir/remotes/git-1 $unittest_dir/remotes/git-1 master" >> $unittest_dir/git-top/revtab
		else
			echo "git-$a $unittest_dir/remotes/git-1 $unittest_dir/remotes/git-1 master" >> $unittest_dir/git-top/revtab
		fi
	done

	# create projs
	for a in $(seq 1 $nbr_of_projs); do
		echo "p$a:" >> $unittest_dir/git-top/projs
		echo "  path: .owel" >> $unittest_dir/git-top/projs
		if [ $a -lt $nbr_of_projs ]; then
			echo "  deps: p$((a+1))" >> $unittest_dir/git-top/projs
		fi
		echo >> $unittest_dir/git-top/projs
		mkdir -p $unittest_dir/git-top/projects/p$a
		for b in bootstrap configure build install; do
			echo "echo $b p$a" > $unittest_dir/git-top/projects/p$a/$b
			chmod +x $unittest_dir/git-top/projects/p$a/$b
		done
	done

	# create systests
	for a in $(seq 1 $nbr_of_systests); do
		echo "ok$a 10 0 \"\" true" >> $unittest_dir/git-top/systests
		echo "nok$a 10 0 \"\" false" >> $unittest_dir/git-top/systests
	done
	# create systests-groups
	echo "all:" >> $unittest_dir/git-top/systests-groups
	for a in $(seq 1 $nbr_of_systests); do
		echo "- ok$a" >> $unittest_dir/git-top/systests-groups
		echo "- nok$a" >> $unittest_dir/git-top/systests-groups
	done

	# commit and push
	git -C $unittest_dir/git-top add .
	git -C $unittest_dir/git-top commit -q -m "test"
	git -C $unittest_dir/git-top push -q origin master

	echo -n "..done"
	echo
}

# unittest:[TEST...]:run all/specific unit tests
function ove-unittest {
	local a
	local b
	local do_preparations
	local i
	local nbr_of_files
	local nbr_of_projs
	local nbr_of_repos
	local nbr_of_systests
	local tests

	if ! command -v shelltest > /dev/null; then
		echo "shelltestrunner is not found. Version 1.9 or greater is needed"
		return 1
	fi

	nbr_of_files=3
	nbr_of_projs=400
	nbr_of_repos=100
	nbr_of_systests=3

	do_preparations="1"
	if [ -t 1 ] && [ -d ${OVE_PROJECT_TMP_DIR}/unittest ]; then
		read -p "Setup? (y/N) " -r
		echo
		if ! [[ $REPLY =~ ^[Yy]$ ]]; then
			do_preparations="0"
		fi
	fi

	[ "$do_preparations" == "1" ] && \
		ove_unittest_preparations $nbr_of_files $nbr_of_projs $nbr_of_repos $nbr_of_systests

	# launch shelltestrunner
	if [ $# -eq 0 ]; then
		tests="tests/t*"
	else
		for a in $*; do
			tests+="tests/$a "
		done
	fi

	cd ${OVE_PROJECT_TMP_DIR}/unittest
	shelltest=$(command -v shelltest)
	if [ $OVE_LOGLEVEL -eq 2 ]; then
		shelltest_opts=" --debug "
	fi

	env -i - HOME=$HOME USER=$USER \
		$shelltest $tests \
		$shelltest_opts \
		--color \
		-j $(nproc) \
		--diff \
		-DOVE_TEST_STRING="source ove > /dev/null; ove_init > /dev/null" \
		-Dnbr_of_systests=$(((nbr_of_systests * 2) + 1)) \
		-Dnbr_of_repos=$((nbr_of_repos + 1 )) \
		-Dnbr_of_files=$((nbr_of_files * nbr_of_repos + (4 * nbr_of_projs) + 4)) \
		-DOVE_TEST_BASE="$(echo ${OVE_PROJECT_TMP_DIR}/unittest| sed -e 's|/|\\/|g')"
}

# generate-doc: :generate OVE documentation (e.g. $OVE_DIR/ove-cmd-list.md)
function ove-generate-doc {
	local a
	local b
	local header
	local sorted

	a=$(grep -B1 "^function ove-" "${OVE_BASE_DIR}"/ove | \
		grep '\#' | \
		cut -b3-)
	b=$(set | \
		grep helptext | \
		grep -v '\$'| \
		cut -d'"' -f2 | \
		grep -v -f<(echo $OVE_SCRIPTS_LIST | xargs -n1))

	header="| Command:| Arguments:| Description: |"
	sorted=$(printf "${a}\n${b}" | \
		sed \
		-e 's/|/@/g' \
		-e 's/:/ :| /g' \
		-e 's/^/| /g' \
		-e 's/$/: |/g' | \
		LC_ALL="C" sort)

	printf "${header}\n|-|-|-|\n${sorted}\n" | \
		column -s: -t | \
		sed -e 's/\@/\\|/g' \
		> $OVE_DIR/ove-cmd-list.md

	return 0
}

ove_main "$@"
