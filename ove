#!/usr/bin/env bash
# SPDX-License-Identifier: MIT
#
# MIT License
#
# Copyright (c) 2019 Ericsson
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is furnished
# to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice (including the next
# paragraph) shall be included in all copies or substantial portions of the
# Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
# FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS
# OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
# OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

i=0
case $- in
	*i*) i=1;;
esac
if [ "${i}" -eq 1 ]; then
	# shellcheck disable=SC2009
	p=$(\ps | \grep -w $$ | \grep -v grep)
	if [ "${p#*bash}" = "$p" ]; then
		echo 'error: run this in bash'
		unset i
		unset p
		return 1
	fi
	unset p
fi
unset i

function ove_version_check_early {
	local ret=0

	if command -v dpkg > /dev/null; then
		if ! \dpkg --compare-versions ${BASH_VERSINFO[0]}.${BASH_VERSINFO[1]} ge 4.3; then
			ret=1
		fi
	else
		if [ ${BASH_VERSINFO[0]} -lt 4 ]; then
			ret=1
		elif [ ${BASH_VERSINFO[0]} -eq 4 ] && [ ${BASH_VERSINFO[1]} -lt 3 ]; then
			ret=1
		fi
	fi

	if [ ${ret} -ne 0 ]; then
		echo "error: bash ${BASH_VERSINFO[0]}.${BASH_VERSINFO[1]} is too old. I need bash>=4.3"
	fi

	return ${ret}
}

if ! ove_version_check_early; then
	return 1
fi

function ove_read_config_validate_name {
	local re="^[a-zA-Z_]{1,}[a-zA-Z0-9_]{0,}$"
	local var="$1"

	if ! [[ "${var}" =~ ${re} ]]; then
		return 1
	fi

	return 0
}

# remember and set duplicate configs
function ove_read_config_pre {
	local f
	local p
	local p_arr
	local val
	local var
	declare -A a_hash

	if [ "x${OVE_CONFIG_DUPLICATES}" != "x" ]; then
		unset OVE_CONFIG_DUPLICATES
	fi

	for f in "$@"; do
		[ -e "${f}" ] || continue

		while read -r p; do
			# ignore comments and empty lines
			if [[ ${p} == \#* ]] || [[ ${p} == '' ]]; then
				continue
			fi
			p_arr=( ${p} )
			var=${p_arr[0]}
			if test "${a_hash["${var}"]+isset}"; then
				val=${p_arr[*]:1}
				# escape all "
				val=${val//\"/\\\"}
				if ! eval ${var}=\"${val}\" 2> /dev/null; then
					echo "warning: config '${var}' could not be set:" 1>&2
					${ove_cmd2pathname["grep"]:?} -w ^${var} -H -n ${1} 1>&2
					continue
				fi
				# shellcheck disable=SC2163
				export ${var}

				# remember duplicates
				if [ "x${OVE_CONFIG_DUPLICATES}" = "x" ]; then
					OVE_CONFIG_DUPLICATES="$var"
				else
					OVE_CONFIG_DUPLICATES+=" $var"
				fi
				export OVE_CONFIG_DUPLICATES

				# remember configs
				if [ "x${OVE_CONFIG_ALL}" = "x" ]; then
					OVE_CONFIG_ALL="$var"
				else
					OVE_CONFIG_ALL+=" $var"
				fi
				export OVE_CONFIG_ALL
			fi
			a_hash["${var}"]=1
		done<${f}
	done
}

function ove_read_config {
	local p
	local p_arr
	local re
	local val
	local var
	declare -A c

	[ -s "$1" ] || return 1

	while read -r p; do
		# ignore comments and empty lines
		if [[ ${p} == \#* ]] || [[ ${p} == '' ]]; then
			continue
		fi
		p_arr=( ${p} )
		var=${p_arr[0]}

		if [ $# -eq 1 ] && ! ove_read_config_validate_name ${var}; then
			echo "error: config name '${var}' is not allowed:" 1>&2
			${ove_cmd2pathname["grep"]:?} -w ^${var} -H -n ${1} 1>&2
			continue
		fi

		if [ "$2" == "clean" ]; then
			unset ${var} 2> /dev/null
			continue
		fi

		# duplicates within one config file
		if [ -v c[${var}] ]; then
			ove_echo_yellow_noprefix "warning: found config '$var' duplicate in '$1'"
			echo "$var=${p_arr[*]:1} (ignored)"
			continue
		fi
		c[$var]=1

		# duplicates across config files
		re=\\b${var}\\b
		if [[ "${OVE_CONFIG_DUPLICATES}" =~ ${re} ]]; then
			continue
		fi

		val=${p_arr[*]:1}
		# escape all "
		val=${val//\"/\\\"}
		if ! eval ${var}=\"${val}\" 2> /dev/null; then
			echo "warning: config '${var}' could not be set:" 1>&2
			${ove_cmd2pathname["grep"]:?} -w ^${var} -H -n ${1} 1>&2
			continue
		fi
		# shellcheck disable=SC2163
		export ${var}

		# remember configs
		if [ "x${OVE_CONFIG_ALL}" == "x" ]; then
			OVE_CONFIG_ALL="$var"
		else
			OVE_CONFIG_ALL+=" $var"
		fi
		export OVE_CONFIG_ALL
	done <$1
}

function ove_unsource_user_env {
	# cleanup PATH
	if [ "${OVE_STAGE_DIR}" != "" ] && \
		[[ ${PATH} == *"${OVE_STAGE_DIR}"* ]]; then
		PATH=${PATH/${OVE_STAGE_DIR}${OVE_PREFIX}\/bin:/}
		PATH=${PATH/${OVE_STAGE_DIR}${OVE_PREFIX}\/sbin:/}
	fi

	# cleanup LD_LIBRARY_PATH
	if [ -n "${LD_LIBRARY_PATH}" ] && [ -n "${OVE_LD_LIBRARY_PATH}" ]; then
		LD_LIBRARY_PATH=${LD_LIBRARY_PATH/${OVE_LD_LIBRARY_PATH}/}
		if [ "${LD_LIBRARY_PATH}" == "" ]; then
			unset LD_LIBRARY_PATH
		elif [ ${LD_LIBRARY_PATH:0:1} == ":" ]; then
			LD_LIBRARY_PATH=${LD_LIBRARY_PATH:1}
		fi
	fi

	# cleanup PKG_CONFIG_PATH
	if [ -n "${PKG_CONFIG_PATH}" ] && [ -n "${OVE_PKG_CONFIG_PATH}" ]; then
		PKG_CONFIG_PATH=${PKG_CONFIG_PATH/${OVE_PKG_CONFIG_PATH}/}
		if [ "${PKG_CONFIG_PATH}" == "" ]; then
			unset PKG_CONFIG_PATH
		elif [ ${PKG_CONFIG_PATH:0:1} == ":" ]; then
			PKG_CONFIG_PATH=${PKG_CONFIG_PATH:1}
		fi
	fi

	# cleanup MAKEFLAGS
	if [ -n "${MAKEFLAGS}" ] && \
		[[ ${MAKEFLAGS} == *"${OVE_MAKEFLAGS}"* ]]; then
		MAKEFLAGS=${MAKEFLAGS/${OVE_MAKEFLAGS}/}
		if [ "${MAKEFLAGS}" == "" ]; then
			unset MAKEFLAGS
		elif [ "${MAKEFLAGS: -1}" = " " ]; then
			MAKEFLAGS=${MAKEFLAGS::-1}
		fi
	fi
}

function ove_unsource {
	local f

	ove_unsource_user_env

	# clean config variables
	for f in ${OVE_CONFIG_FILES_ALL}; do
		if [ -e "${f}" ]; then
			ove_read_config ${f} clean
		fi
	done

	# unset old ove[-_] functions
	unset -f $(compgen -A function | \
		\grep -E '^ove($|[-_])' | \
		\grep -E -v "ove_read_config|ove-unsource|${FUNCNAME[0]}|ove_version_check_early" | \
		\awk '{print $1}')

	# unset old ove_/OVE_ variables
	unset $(set -o posix ; set | \
		\grep -i ^ove_ | \
		\cut -d= -f1)

	# unset completion for ove
	if complete -p | \grep -q ' ove$'; then
		complete -r ove
	fi
}

# unsource: :clean up all OVE vars/funcs from this shell:CORE
function ove-unsource {
	ove_entry || return

	ove_unsource
	# unset leftovers and myself
	unset -f $(compgen -A function | \
		\grep -E '^ove($|[-_])' | \
		\awk '{print $1}') \
		${FUNCNAME[0]}
}

# interactive shell? clean up
if [[ $- == *i* ]]; then
	ove_unsource
fi

function ove_welcome_msg {
	local script_ver

	ove-version
	if ! [ -e "${HOME}/.ove.bash" ]; then
		echo
		echo "Do you want to skip the initial 'source ove' step? Run this:"
		echo " cp -a ${OVE_DIR}/ove.bash ${HOME}/.ove.bash && echo '[ -f ~/.ove.bash ] && source ~/.ove.bash' >> ${HOME}/.bashrc"
	fi

	# shellcheck disable=SC2016
	script_ver=$(${ove_cmd2pathname["script"]:?} --version | \
		${ove_cmd2pathname["awk"]:?} '{print $NF}')
	if [[ ${script_ver} =~ ^2.3[12] ]]; then
		echo
		ove_echo_note_noprefix "due to a bug in ${ove_cmd2pathname["script"]:?} 2.31/2.32 (you have ${script_ver}), it's not possible to Ctrl-C any OVE command. Upgrade package: '$(ove_command_to_package script)'."
	fi
}

function ove_version_check {
	local ret=0
	local git_arr
	local git_ver
	local git_opts
	local major
	local minor
	local patch

	git_ver=$(${ove_cmd2pathname["git"]:?} --version)
	git_ver=${git_ver/git version /}
	IFS='.' read -r -a git_arr <<< "${git_ver}"

	major=${git_arr[0]}
	minor=${git_arr[1]}
	patch=${git_arr[2]}

	if command -v dpkg > /dev/null; then
		\dpkg --compare-versions ${major}.${minor}.${patch} ge 1.8.5 || ret=1
	elif [ ${major} -lt 2 ]; then
		if [ ${major} -eq 1 ] && [ ${minor} -lt 8 ]; then
			ret=1
		elif [ ${major} -eq 1 ] && [ ${minor} -eq 8 ] && [ ${patch} -lt 5 ]; then
			ret=1
		elif [ ${major} -eq 0 ]; then
			ret=1
		fi
	fi

	if [ ${ret} -ne 0 ]; then
		ove_echo_error_noprefix "git ${git_ver} is too old. I need >=1.8.5"
		return ${ret}
	fi

	# --no-optional-locks was introduced in 2.15.0
	if command -v dpkg > /dev/null; then
		if \dpkg --compare-versions ${major}.${minor}.${patch} ge 2.15.0; then
			git_opts="--no-optional-locks"
		fi
	elif [ ${major} -ge 3 ]; then
		git_opts="--no-optional-locks"
	elif [ ${major} -eq 2 ] && [ ${minor} -lt 15 ]; then
		:
	elif [ ${major} -lt 2 ]; then
		:
	else
		git_opts="--no-optional-locks"
	fi

	OVE_GIT_OPTIONS="${git_opts}"
	export OVE_GIT_OPTIONS

	return ${ret}
}

function ove_main {
	ove_externals_init

	# some error messages use colors. I.e. keep this early
	export OVE_COLOR_GREEN="\033[0;32;7m"
	export OVE_COLOR_CYAN="\033[0;36;7m"
	export OVE_COLOR_BLUE="\033[0;34;7m"
	export OVE_COLOR_YELLOW_X="0;33;7m"
	export OVE_COLOR_YELLOW="\033[${OVE_COLOR_YELLOW_X}"
	export OVE_COLOR_RED="\033[0;31;7m"
	export OVE_COLOR_BLANK="\033[0m"

	# set OVE_OS_* variables ('ove_deps' need them)
	ove_determine_dist_version_and_pack_manager

	# dependency checks
	if ! ove_deps; then
		ove-unsource
		return 1
	fi

	# OVE_USER:the user that runs OVE commands
	OVE_USER=
	if [ "x${USER}" != "x" ]; then
		OVE_USER="${USER}"
	elif [ "x${LOGNAME}" != "x" ]; then
		OVE_USER="${LOGNAME}"
	elif command -v whoami > /dev/null; then
		OVE_USER="$(${ove_cmd2pathname["whoami"]:?})"
	else
		OVE_USER="ove"
	fi
	export OVE_USER

	# OVE_TMP:temporary directory for all OVE workspaces (per user)
	OVE_TMP=/tmp/${OVE_USER}/ove
	export OVE_TMP
	if ! [ -d "${OVE_TMP}" ]; then
		if ! ${ove_cmd2pathname["mkdir"]:?} -p "${OVE_TMP}" 2> /dev/null; then
			if ! OVE_TMP="$(${ove_cmd2pathname["mktemp"]:?} -d)"; then
				ove_echo_error_noprefix "weird! '/tmp' is missing/none-writable and 'mktemp -d' fails"
				ove-unsource
				return 1
			fi
		fi
	fi

	# run 'ove init' if this is not a workspace (interactive shells)
	if [[ $- == *i* ]]; then
		# turn off monitor mode to get rid of "Done" messages
		set +m

		if [ -e ".owel" ] && [ -e ove ]; then
			:
		else
			ove-init
		fi
	fi

	# init workspace
	if ! ove_init; then
		ove-unsource
		return 1
	fi

	# welcome and post checks (interactive shells)
	if [[ $- == *i* ]]; then
		if [ ${OVE_LOGLEVEL} -eq 0 ] || [[ "$*" == *"hush"* ]]; then
			:
		else
			ove_welcome_msg
		fi

		ove_post_checks

		# turn on monitor mode
		set -m
	fi
}

# $1: pid
function ove_strace_execve_one_pid {
	local cmd
	local exit_code
	local line
	local syscall
	local t0

	cmd=
	pid=$1
	while read -r line; do
		if [ "x${line}" = "x" ]; then
			continue
		fi
		syscall=${line#* }
		syscall=${syscall%%(*}

		if [ "${syscall}" == "execve" ]; then
			[[ "${line}" == *"ENOENT"* ]] && continue
			# for slow string substitution in bash
			if [ ${#line} -gt 1000 ]; then
				cmd=$(echo $line | ${ove_cmd2pathname["cut"]:?} -d'[' -f2 | \
					${ove_cmd2pathname["cut"]:?} -d']' -f1 | \
					${ove_cmd2pathname["sed"]:?} -e 's,"\, ", ,g' )
				cmd=${cmd:1:-1}
			else
				cmd=${line##* [\"}
				cmd=${cmd%%\"]*}
				cmd=${cmd//\", \"/ }
			fi
			t0=$(ove_strace_get_t0 ${pid})
			if [ "x${cmd}" = "x" ]; then
				continue
			fi
			exit_code=$(ove_strace_get_exit_code ${pid})
			if [ ${OVE_LOGLEVEL} -eq 3 ]; then
				echo "${t0}:${pid}:${exit_code}:${cmd}"
			elif [ ${OVE_LOGLEVEL} -eq 4 ]; then
				echo "$(ove_strace_get_duration_s ${pid}):${pid}:${exit_code}:${cmd}"
			fi
			continue
		fi
	done <<< "${all_files[$1]}"
}

# $1: directory with strace pid files
function ove_analyze_strace_execve_timing {
	local all_files
	local f
	local pid

	! [ -d "$1" ] && return 1

	declare -A all_files
	while true; do
		for f in $(${ove_cmd2pathname["find"]:?} $1 -type f); do
			pid=${f##*.}
			all_files[${pid}]="$(<${f})"
			ove_strace_execve_one_pid ${pid} &
		done
		wait
		break
	done | LC_ALL="C" ${ove_cmd2pathname["sort"]:?} -n$([ ${OVE_LOGLEVEL} -eq 4 ] && echo r)
}

function ove_line2ipv4 {
	${ove_cmd2pathname["grep"]:?} -E -o '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}' <<<"$@"
}

# $1: IPv4 address
function ove_ip2host {
	local ip
	local ip_lookup

	if ! command -v dig > /dev/null; then
		ove_command_not_found "dig"
		return 1
	fi

	if ! command -v whois > /dev/null; then
		ove_command_not_found "whois"
		return 1
	fi

	ip=${1}

	if [[ ${ip} == 127* ]]; then
		ip_lookup="localhost"
	else
		ip_lookup=$(\dig +short -x ${ip} | \
			${ove_cmd2pathname["tr"]:?} '\n' ' ' | \
			${ove_cmd2pathname["xargs"]:?})

		if [ "${ip_lookup}" == "" ]; then
			ip_lookup="NA"
		else
			ip_lookup=${ip_lookup::-1}
		fi
	fi

	echo ${ip_lookup}
}

# $1: IPv4 address
function ove_ip2org {
	local ip
	local org

	if ! command -v whois > /dev/null; then
		ove_command_not_found "whois"
		return 1
	fi

	ip=${1}

	if [[ ${ip} == 127* ]]; then
		org="NA"
	else
		org=$(${ove_cmd2pathname["timeout"]:?} 3 whois ${ip} 2> /dev/null | \
			${ove_cmd2pathname["grep"]:?} -E -i 'netrange:|netname|parent')
		[ "${org}" == "" ] && return
	fi

	printf "${org}"
}

# $1: port
function ove_port2service {
	local port
	local port_service

	port=${1}

	if [ -e /etc/services ]; then
		# shellcheck disable=SC2016
		port_service=$(${ove_cmd2pathname["grep"]:?} -m1 -w ${port} /etc/services | \
			${ove_cmd2pathname["awk"]:?} '{print $1}')
	fi

	[ "${port_service}" == "" ] && port_service="NA"
	echo "${port_service}"
}

# $1: pid
function ove_strace_connect_one_pid {
	local cmd
	local ip
	local ip_lookup
	local line
	local port
	local port_service
	local ret
	local sa_family
	local str
	local sun_path
	local syscall

	cmd=
	pid=$1
	while read -r line; do
		[ "${line}" == "" ] && continue
		syscall=${line#* }
		syscall=${syscall%%(*}

		if [ "${syscall}" == "bind" ] ||
			[ "${syscall}" == "connect" ]; then
			sa_family=${line##*sa_family=}
			sa_family=${sa_family%%,*}
			t0=${line%% *}

			ret=${line##* =}
			ret=${ret% <*}
			if [[ "${ret}" == " -1"* ]] && ! [[ "${ret}" != "EINPROGRESS"* ]]; then
				continue
			fi

			if [ "${sa_family}" == "AF_LOCAL" ] || \
				[ "${sa_family}" = "AF_UNIX" ]; then
				sun_path=${line#*\"}
				sun_path=${sun_path%\"*}

				# abstract sockets
				[[ "${line}" == *"=@"* ]] && sun_path="@${sun_path}"

				cmd=$(ove_strace_get_execve ${pid})

				str+="${t0}:${syscall}:${sa_family}:${sun_path}:${cmd}\n"
			elif [ "${sa_family}" == "AF_INET" ]; then
				ip=$(ove_line2ipv4 ${line})
				port=$(${ove_cmd2pathname["cut"]:?} -d'(' -f3- <<<"${line}" | \
					${ove_cmd2pathname["cut"]:?} -d')' -f1)

				ip_lookup=${ove_ip2host_db["${ip}"]}
				port_service=${ove_port2service_db["${port}"]}
				cmd=$(ove_strace_get_execve ${pid})

				str+="${t0}:${syscall}:${sa_family}:${ip}:${ip_lookup}:${port}:${port_service}:${cmd}\n"
			fi
		fi
	done <<< "${all_files[${pid}]}"

	[ "${str}" != "" ] && printf "${str}"
}

function ove_read_connect_cache {
	local line

	unset ove_ip2host_db
	unset ove_ip2org_db
	unset ove_port2service_db

	declare -A -g ove_ip2host_db
	declare -A -g ove_ip2org_db
	declare -A -g ove_port2service_db

	if [ -e ${OVE_GLOBAL_STATE_DIR}/ip2host.cache ]; then
		for line in $(${ove_cmd2pathname["cat"]:?} ${OVE_GLOBAL_STATE_DIR}/ip2host.cache); do
			ove_ip2host_db["${line%%:*}"]="${line##*:}"
		done
	fi

	if [ -e ${OVE_GLOBAL_STATE_DIR}/port2service.cache ]; then
		for line in $(${ove_cmd2pathname["cat"]:?} ${OVE_GLOBAL_STATE_DIR}/port2service.cache); do
			ove_port2service_db["${line%%:*}"]="${line##*:}"
		done
	fi

	if [ -e ${OVE_GLOBAL_STATE_DIR}/ip2org.cache ]; then
		while read -r line; do
			ove_ip2org_db["${line%%:*}"]="$(${ove_cmd2pathname["tr"]:?} '@' '\n' <<<"${line#*:}")"
		done < <(${ove_cmd2pathname["cat"]:?} ${OVE_GLOBAL_STATE_DIR}/ip2org.cache)
	fi
}

# $1: directory with strace pid files
function ove_update_connect_db {
	local host
	local f
	local ip
	local line
	local org
	local port
	local service

	ove_read_connect_cache

	if command -v ag > /dev/null; then
		${ove_cmd2pathname["ag"]:?} --nobreak --nofilename -o --nonumbers 'AF_INET,.* =' $1 | \
			LC_ALL="C" ${ove_cmd2pathname["sort"]:?} -u > ${OVE_OWEL_TMP_DIR}/af_inet
	else
		${ove_cmd2pathname["grep"]:?} -E -R -o -h 'AF_INET,.* =' $1 | \
			LC_ALL="C" ${ove_cmd2pathname["sort"]:?} -u > ${OVE_OWEL_TMP_DIR}/af_inet
	fi

	if ! [ -s "${OVE_OWEL_TMP_DIR}/af_inet" ]; then
		${ove_cmd2pathname["rm"]:?} ${OVE_OWEL_TMP_DIR}/af_inet
		return
	fi

	while read -r line; do
		ip=$(ove_line2ipv4 ${line})
		if [ "x${ip}" = "x" ]; then
			continue
		fi
		port=$(${ove_cmd2pathname["cut"]:?} -d'(' -f2- <<<"${line} |" \
			${ove_cmd2pathname["cut"]:?} -d')' -f1)
		if [ "x${port}" = "x" ]; then
			continue
		fi

		if ! test "${ove_ip2host_db["${ip}"]+isset}"; then
			host="$(ove_ip2host ${ip})"
			if [ "x${host}" != "x" ]; then
				ove_ip2host_db["${ip}"]="${host}"
				echo "${ip}:${host}" >> ${OVE_GLOBAL_STATE_DIR}/ip2host.cache
			fi
		fi

		if ! test "${ove_ip2org_db["${ip}"]+isset}"; then
			org="$(ove_ip2org ${ip} | ${ove_cmd2pathname["tr"]:?} '\n' '@')"
			if [ "x${org}" != "x" ]; then
				ove_ip2org_db["${ip}"]="$(echo ${org} | ${ove_cmd2pathname["tr"]:?} '@' '\n')"
				echo "${ip}:${org}" >> ${OVE_GLOBAL_STATE_DIR}/ip2org.cache
			fi
		fi

		if ! test "${ove_port2service_db["${port}"]+isset}"; then
			service="$(ove_port2service ${port})"
			if [ "x${service}" != "x" ]; then
				ove_port2service_db["${port}"]=${service}
				echo "${port}:${service}" >> ${OVE_GLOBAL_STATE_DIR}/port2service.cache
			fi
		fi
	done <${OVE_OWEL_TMP_DIR}/af_inet

	${ove_cmd2pathname["rm"]:?} ${OVE_OWEL_TMP_DIR}/af_inet

	for f in ${OVE_GLOBAL_STATE_DIR}/{ip2host,ip2org,port2service}.cache; do
		if [ ! -s "$f" ]; then
			continue
		fi
		LC_ALL="C" ${ove_cmd2pathname["sort"]:?} -V -o ${f} ${f} &
	done
	wait
}

# $1: directory with strace pid files
function ove_analyze_strace_connect {
	local all_files
	local f
	local pid

	! [ -d "$1" ] && return 1

	declare -A all_files
	ove_update_connect_db $1
	while true; do
		for f in $(${ove_cmd2pathname["find"]:?} $1 -type f); do
			pid=${f##*.}
			all_files[${pid}]="$(<${f})"
			ove_strace_connect_one_pid ${pid} &
		done
		wait
		break
	done | LC_ALL="C" ${ove_cmd2pathname["sort"]:?} -n
}

# $1: pid
function ove_strace_get_exit_code {
	local exit_code
	local strace_file

	strace_file=${all_files[$1]}
	exit_code=${strace_file##*$'\n'}
	if [[ "${exit_code}" == *"killed by"* ]]; then
		exit_code=${exit_code##* killed by }
		exit_code=${exit_code%% +++}
	elif [[ "${exit_code}" == *"exited with"* ]]; then
		exit_code=${exit_code##* exited with }
		exit_code=${exit_code%% +++}
	else
		exit_code="alive"
	fi

	echo ${exit_code}
}

# $1: pid
function ove_strace_get_duration_s {
	local diff
	local strace_file
	local t0
	local t1

	strace_file=${all_files[$1]}
	t0=${strace_file%% *}
	t1=${strace_file##*$'\n'}
	t1=${t1%% *}

	[ "${t0}" == "${t1}" ] && echo "0.000000" && return

	# shellcheck disable=SC2016
	diff=$(${ove_cmd2pathname["awk"]:?} "BEGIN{printf \"%.6f\n\", (${t1} - ${t0})}")
	echo ${diff}
}

# $1: pid
function ove_strace_get_duration_ms {
	local diff
	local strace_file
	local t0
	local t1

	strace_file=${all_files[$1]}
	t0=${strace_file%% *}
	t1=${strace_file##*$'\n'}
	t1=${t1%% *}

	[ "${t0}" == "${t1}" ] && echo "0" && return

	# shellcheck disable=SC2016
	diff=$(${ove_cmd2pathname["awk"]:?} "BEGIN{printf \"%.0f\n\", (${t1} - ${t0}) * 1000}")
	echo ${diff}
}

# $1: pid
function ove_strace_get_t0 {
	local strace_file
	local t0

	strace_file=${all_files[$1]}
	t0=${strace_file%% *}
	echo ${t0}
}

# $1: pid
function ove_strace_get_execve {
	local cmd
	local line
	local syscall

	while read -r line; do
		[ "${line}" == "" ] && continue
		syscall=${line#* }
		syscall=${syscall%%(*}

		[ "${syscall}" != "execve" ] && continue
		[[ "${line}" == *"ENOENT"* ]] && continue
		# for slow string substitution in bash
		if [ ${#line} -gt 1000 ]; then
			cmd=$(echo $line | \
				${ove_cmd2pathname["cut"]:?} -d'[' -f2 | \
				${ove_cmd2pathname["cut"]:?} -d']' -f1 | \
				${ove_cmd2pathname["sed"]:?} -e 's,"\, ", ,g' )
			cmd=${cmd:1:-1}
		else
			cmd=${line##* [\"}
			cmd=${cmd%%\"]*}
			cmd=${cmd//\", \"/ }
		fi
	done <<< "${all_files[$1]}"

	[ "${cmd}" == "" ] && cmd="NA"
	echo -e "${cmd}"
}

# $1: pid
function ove_strace_one_pid {
	local cmd
	local duration_ms
	local duration_s
	local ip
	local ip_lookup
	local ip_org
	local key
	local line
	local out_1
	local out_2
	local p
	local pid
	local port
	local port_service
	local ret
	local sa_family
	local suffix
	local sun_path
	local t

	pid=$1

	duration_ms=$(ove_strace_get_duration_ms ${pid})
	duration_s=$(ove_strace_get_duration_s ${pid})
	t=$(ove_strace_get_t0 ${pid})

	# label START
	out_1="    ${pid} [label=\"p: ${pid}\l\nt: ${t}\l\nd: ${duration_ms} ms (${duration_s} s)\l\n"

	# exit code
	exit_code=$(ove_strace_get_exit_code ${pid})
	if [[ "${exit_code}" =~ ^[0-9]+$ ]]; then
		if [ ${exit_code} -ne 0 ]; then
			out_1+="e: ${exit_code}\l\n"
			border_color='"red"'
		else
			border_color='"green"'
		fi
	elif [ "${exit_code}" == "alive" ]; then
		border_color='"blue"'
	else
		out_1+="e: ${exit_code}\l\n"
		border_color='"black"'
	fi

	cmd=
	out_2=
	declare -A ip_port_cnt
	while read -r line; do
		[ "${line}" == "" ] && continue
		syscall=${line#* }
		syscall=${syscall%%(*}
		! [[ "${syscall}" =~ ^[a-z]+$ ]] && continue

		echo "${t}:${syscall}:${pid}:${duration_ms}:${duration_s}" >> ${OVE_OWEL_TMP_DIR}/timing
		if [ "${syscall}" == "clone" ] ||
			[ "${syscall}" == "fork" ] ||
			[ "${syscall}" == "vfork" ]; then
			p=${line##* = }
			p=${p%% *}
			! [[ "${p}" =~ ^[0-9]+$ ]] && continue
			out_2+="    ${pid} -> ${p} [label=${syscall}];"
			continue
		elif [ "${syscall}" == "execve" ]; then
			[[ "${line}" == *"ENOENT"* ]] && continue
			# for slow string substitution in bash
			if [ ${#line} -gt 1000 ]; then
				cmd=$(echo $line | \
					${ove_cmd2pathname["cut"]:?} -d'[' -f2 | \
					${ove_cmd2pathname["cut"]:?} -d']' -f1 | \
					${ove_cmd2pathname["sed"]:?} -e 's,"\, ", ,g' )
				cmd=${cmd:1:-1}
			else
				cmd=${line##* [\"}
				cmd=${cmd%%\"]*}
				cmd=${cmd//\", \"/ }
			fi
			continue
		elif [ "${syscall}" == "bind" ] ||
			[ "${syscall}" == "connect" ]; then
			sa_family=${line##*sa_family=}
			sa_family=${sa_family%%,*}

			ret=${line##* =}
			ret=${ret% <*}
			if [[ "${ret}" == " -1"* ]] && ! [[ "${ret}" != "EINPROGRESS"* ]]; then
				continue
			fi

			if [ "${sa_family}" == "AF_LOCAL" ] || \
				[ "${sa_family}" = "AF_UNIX" ]; then
				sun_path=${line#*\"}
				sun_path=${sun_path%\"*}

				# abstract sockets
				[[ "${line}" == *"=@"* ]] && sun_path="@${sun_path}"

				out_2+="    \"${sun_path}\" [label=\"${sun_path}\l\n\" shape=box3d,fontsize=20,style=filled,fillcolor=\"cyan\"];"
				out_2+="    ${pid} -> \"${sun_path}\" [label=\"${syscall}\"];"
			elif [ "${sa_family}" == "AF_INET" ]; then
				ip=$(ove_line2ipv4 ${line})
				[ "${ip}" == "" ] && continue
				port=$(${ove_cmd2pathname["cut"]:?} -d'(' -f3- <<<"${line}" | \
					${ove_cmd2pathname["cut"]:?} -d')' -f1)
				[ "${port}" == "" ] && continue

				if test "${ip_port_cnt["${ip}:${port}"]+isset}"; then
					ip_port_cnt["${ip}:${port}"]=$((${ip_port_cnt["${ip}:${port}"]} + 1))
				else
					ip_port_cnt["${ip}:${port}"]=1
				fi

				ip_lookup=${ove_ip2host_db["${ip}"]}
				ip_org=${ove_ip2org_db["${ip}"]}
				port_service=${ove_port2service_db["${port}"]}

				org=$(${ove_cmd2pathname["sed"]:?} -e 's/$/ \\l\\n/g' <<<"${ip_org}" | \
					${ove_cmd2pathname["tr"]:?} '\n' ' ' | \
					${ove_cmd2pathname["tr"]:?} \" \')

				out_2+="    \"${ip}\" [label=\"t: ${t}\l\nIP: ${ip}\l\n${ip_lookup}\l\n${org}\l\n\" shape=box3d,fontsize=20,style=filled, fillcolor=\"yellow\"];"
				out_2+="    ${pid} -> \"${ip}\" [label=\"${syscall} ${port} ${port_service["${port}"]}\"];"
			else
				continue
			fi
		fi
	done <<< "${all_files[$1]}"

	for key in "${!ip_port_cnt[@]}"; do
		ip=${key%%:*}
		port=${key##*:}
		ip_lookup="${ove_ip2host_db["${ip}"]}"
		port_service=${ove_port2service_db["${port}"]}
		if [ ${ip_port_cnt[${ip}:${port}]} -gt 1 ]; then
			suffix="(repeated ${ip_port_cnt[${ip}:${port}]} time(s))"
		fi
		out_1+="c: ${ip}|${ip_lookup}|${port}|${port_service} ${suffix}\l\n"
	done

	# penwidth based on duration
	penwidth=${duration_ms}
	if [ ${duration_ms} -gt 20 ]; then
		penwidth=20
	elif [ ${duration_ms} -eq 0 ]; then
		penwidth=1
	fi

	[ "${cmd}" != "" ] && \
		out_1+="x: $(echo -e ${cmd} | \
		${ove_cmd2pathname["fold"]:?} -w 80 -s | \
		${ove_cmd2pathname["sed"]:?} -e 's/$/ \\l\\n/g' | \
		${ove_cmd2pathname["tr"]:?} '\n' ' ' | \
		${ove_cmd2pathname["tr"]:?} \" \')"

	# label END
	out_1+="\",color=${border_color},penwidth=${penwidth},fontsize=14,fontcolor=black];"

	echo "${out_1}"
	[ "${out_2}" != "" ] && echo "${out_2}"
}

function ove_command_usage {
	local a
	local description
	local cmd=${FUNCNAME[1]/ove-/}
	local opt

	a=$(${ove_cmd2pathname["grep"]:?} -B1 "^function ove-${cmd} " ${OVE_SELF} | \
		${ove_cmd2pathname["head"]:?} -1)
	opt=$(${ove_cmd2pathname["cut"]:?} -d: -f2 <<<"${a}")
	description=$(${ove_cmd2pathname["cut"]:?} -d: -f3- <<<"${a}")
	echo -e "usage: ove ${cmd} ${opt}\t# ${description}"
}

# strace-graph:dir:run strace graph analysis:DEBUG
function ove-strace-graph {
	ove_entry || return

	if [ $# -ne 1 ]; then
		ove_command_usage
		return 1
	fi

	ove_strace_create_graph $1 ${1##*/}
}

# strace-execve-timeline:dir:run strace execve timeline analysis:DEBUG
function ove-strace-execve-timeline {
	ove_entry || return

	if [ $# -ne 1 ]; then
		ove_command_usage
		return 1
	fi

	OVE_LOGLEVEL=3 ove_analyze_strace_execve_timing $1

}

# strace-execve-time:dir:run strace execve time analysis:DEBUG
function ove-strace-execve-time {
	ove_entry || return

	if [ $# -ne 1 ]; then
		ove_command_usage
		return 1
	fi

	OVE_LOGLEVEL=4 ove_analyze_strace_execve_timing $1
}

# strace-connect:dir:run strace connect time analysis:DEBUG
function ove-strace-connect {
	ove_entry || return

	if [ $# -ne 1 ]; then
		ove_command_usage
		return 1
	fi

	ove_analyze_strace_connect $1
}

# $1: directory with strace pid files
# $2: append string to output files
function ove_strace_create_graph {
	local all_files
	local f
	local o_base
	local o_dot
	local o_svg
	local o_timing
	local pid

	! [ -d "$1" ] && return 1
	[ $# -ne 2 ] && return 1

	o_base="${OVE_OWEL_TMP_DIR}/strace-${2}"
	o_dot=${o_base}.dot
	o_svg=${o_base}.svg
	o_timing=${o_base}.timing

	echo "strict digraph $(${ove_cmd2pathname["tr"]:?} '-' '_' <<<"${OVE_OWEL_NAME}" | \
		${ove_cmd2pathname["tr"]:?} -d '.') {" > ${o_dot}
	echo "    nodesep=2" >> ${o_dot}
	echo "    ranksep=5" >> ${o_dot}
	echo "    node [margin=1,shape=octagon,nodesep=10];" >> ${o_dot}

	# remove leftovers
	${ove_cmd2pathname["find"]:?} ${OVE_OWEL_TMP_DIR} -name "strace-${2}.dot.*" -print0 | \
		${ove_cmd2pathname["xargs"]:?} -0 rm &> /dev/null

	declare -A all_files
	true > ${OVE_OWEL_TMP_DIR}/timing
	ove_update_connect_db $1
	for f in $(${ove_cmd2pathname["find"]:?} $1 -type f); do
		pid=${f##*.}
		all_files[${pid}]="$(<${f})"
		ove_strace_one_pid ${pid} >> ${o_dot}.${pid} &
	done
	wait

	# merge all files into one
	${ove_cmd2pathname["find"]:?} ${OVE_OWEL_TMP_DIR} -name "strace-${2}.dot.*" -print0 | \
		${ove_cmd2pathname["xargs"]:?} -0 cat >> ${o_dot}
	${ove_cmd2pathname["find"]:?} ${OVE_OWEL_TMP_DIR} -name "strace-${2}.dot.*" -print0 | \
		${ove_cmd2pathname["xargs"]:?} -0 rm

	echo "}" >> ${o_dot}

	LC_ALL="C" ${ove_cmd2pathname["sort"]:?} -u ${OVE_OWEL_TMP_DIR}/timing > ${o_timing}
	${ove_cmd2pathname["rm"]:?} ${OVE_OWEL_TMP_DIR}/timing

	${ove_cmd2pathname["du"]:?} -sh ${o_dot}
	if command -v dot > /dev/null; then
		if ! \dot -Tsvg ${o_dot} > ${o_svg}; then
			return 1
		fi
		${ove_cmd2pathname["du"]:?} -sh ${o_svg}
	fi
}

# helper for tmux related commands
function ove_sanity_check_tmux {
	local tmux_default_shell
	local tmux_socket

	if [ -z "${TMUX}" ]; then
		return 1
	fi
	tmux_socket=${TMUX%%,*}
	if [ "x$tmux_socket" = "x" ]; then
		ove_echo_fatal_noprefix "variable TMUX=$TMUX does not contain a valid socket"
		return 1
	elif [ ! -w "$tmux_socket" ]; then
		ove_echo_error_noprefix "tmux socket '$tmux_socket' is not writable by '$OVE_USER'"
		return 1
	elif ! tmux_default_shell=$(${ove_cmd2pathname["tmux"]:?} show-options -gv default-shell); then
		return 1
	elif ! [[ "${tmux_default_shell}" == *bash* ]]; then
		ove_echo_error_noprefix "tmux default shell '${tmux_default_shell}' is not bash"
		return 1
	fi

	return 0
}

# $1: timeout in seconds
# $2: files to watch. Passed on to inotifywait --fromfile
function ove_inotifywait {
	local ret

	! [ -e ${2} ] && return 1
	[ $(${ove_cmd2pathname["wc"]:?} -l < ${2}) -eq 0 ] && return 1

	${ove_cmd2pathname["sleep"]:?} 0.01
	${ove_cmd2pathname["inotifywait"]:?} \
		-t ${1} \
		-qq \
		--event modify \
		--event delete_self \
		--event create \
		--event delete \
		--fromfile ${2}
	ret=$?

	${ove_cmd2pathname["sleep"]:?} 0.01
	[ ${ret} -eq 1 ] && return 1 || return 0
}

function ove_inotify_cleanup {
	${ove_cmd2pathname["find"]:?} ${OVE_OWEL_TMP_DIR}/ -name "inotifywait-*-${1}*" -exec rm {} \;
}

# $1  : timeout in sec
# $2  : use inotifywait (0 or 1)
# $3  : max count
# $4..: command
function ove_loop_command {
	local all_files
	local cmd
	local f
	local f_early
	local f_early_all
	local f_stderr
	local files_modified_by_command
	local i
	local j
	local max_count
	local prefix
	local read_args
	local inotifywait_pid
	local s
	local sed_expr
	local _timeout
	local use_inotify

	[ $# -lt 4 ] && return 1

	_timeout=$1
	use_inotify=$2
	max_count=$3
	shift 3
	(( i=0 ))
	while true; do
		if ! ove_verify_checksums && ! ove_reinit; then
			read -r -p "" -t 3
			continue
		fi
		(( i+=1 ))
		[ ${max_count} -ne 0 ] && [ ${i} -gt ${max_count} ] && break
		clear
		if [ "${OVE_TMUX_PANE_HEADER}" == "wide" ]; then
			ove_echo_cyan_error "${OVE_OWEL_NAME}:ove-${*} [c:${i} t:${_timeout} i:${use_inotify} m:${max_count}]"
		elif [ "${OVE_TMUX_PANE_HEADER}" == "short" ]; then
			ove_echo_cyan_error_noprefix "$(${ove_cmd2pathname["date"]:?} '+%Y-%m-%d %H:%M:%S'):ove-${*}"
		elif [ "${OVE_TMUX_PANE_HEADER}" == "off" ]; then
			:
		fi

		# inotify: first iteration?
		if [ ${use_inotify} -eq 1 ] && [ ${i} -eq 1 ]; then
			all_files=$(${ove_cmd2pathname["mktemp"]:?} -u -p ${OVE_OWEL_TMP_DIR} inotifywait-fromfile-XXXXXXXXXX)

			# trap to be able to cleanup files
			# shellcheck disable=SC2064
			trap "ove_inotify_cleanup ${all_files: -10}" EXIT

			# start inotifywait in monitor mode in the background
			# monitor all files (for now)
			# shellcheck disable=SC2016
			cmd='for f in $(ove_repo_cmd ${repo} ls-files); do [ -f ${f} ] && echo ${PWD}/${f}; done; [ -e ${PWD}/.git ] && echo ${PWD}/.git'
			ove_revtab_forall_parallel "${cmd}" > ${all_files}

			# extra files/directories to monitor?
			if [ "x${OVE_LOOP_INOTIFY_EXTRA}" != "x" ]; then
				${ove_cmd2pathname["find"]:?} ${OVE_LOOP_INOTIFY_EXTRA//;/ } -type f >> ${all_files}
			fi

			cmd="${1%% *}"
			files_modified_by_command="${OVE_OWEL_TMP_DIR}/inotifywait-${cmd}-${all_files: -10}"
			f_stderr="${files_modified_by_command}-stderr"
			true > ${f_stderr}
			if [ -e /proc/sys/fs/inotify/max_user_watches ] && [ $(${ove_cmd2pathname["cat"]:?} /proc/sys/fs/inotify/max_user_watches) -lt $(${ove_cmd2pathname["wc"]:?} -l < ${all_files}) ]; then
				ove_echo_error_noprefix "you need to increase the number of inotify user watches. Try:"
				echo
				[ ${EUID} != 0 ] && prefix="sudo"
				echo "$ ${prefix} ${ove_cmd2pathname["bash"]:?} -c 'echo $(${ove_cmd2pathname["wc"]:?} -l < ${all_files}) > /proc/sys/fs/inotify/max_user_watches'"
				if ove_sanity_check_tmux 2> /dev/null; then
					read -r -p ""
				fi
				return 1
			fi

			# retrieve the lock
			exec {fd}>${OVE_OWEL_TMP_DIR}/.inotify.lock
			${ove_cmd2pathname["flock"]:?} ${OVE_FLOCK_OPTIONS} ${fd}

			# try to check that no other process is accessing our file watch list
			j=0
			f_early="${files_modified_by_command}-early-check"
			f_early_all="${files_modified_by_command}-early-check-all"
			while true; do
				if [ ${j} -eq 10 ]; then
					ove_echo_cyan_noprefix "some other process is accessing the file watch list, if possible stop that and try again"
					echo "File(s):"
					echo "$ ove head-tail ${f_early_all}"
					${ove_cmd2pathname["sort"]:?} -u -o ${f_early_all} ${f_early_all}
					ove-head-tail ${f_early_all}
					if ove_sanity_check_tmux 2> /dev/null; then
						read -r -p "" -t 3
					fi
					# release the lock and try again
					${ove_cmd2pathname["flock"]:?} -u ${fd}
					i=0
					continue 2
				fi
				${ove_cmd2pathname["inotifywait"]:?} -t 1 -q --format '%w%f' --fromfile ${all_files} > ${f_early}
				if ! [ -s ${f_early} ]; then
					break
				fi

				# ignore first 5 iterations
				if [ ${j} -ge 5 ]; then
					${ove_cmd2pathname["cat"]:?} ${f_early} >> ${f_early_all}
				fi
				((j++))
			done

			${ove_cmd2pathname["inotifywait"]:?} \
				-m \
				--format '%w%f' \
				--fromfile ${all_files} > ${files_modified_by_command} 2>> ${f_stderr} &
			inotifywait_pid=${!}

			# wait for inotifywait
			# shellcheck disable=SC2002
			${ove_cmd2pathname["timeout"]:?} 30 tail -f ${f_stderr} | \
				${ove_cmd2pathname["grep"]:?} -E -q "Watches established.|Failed to watch" | \
				{ ${ove_cmd2pathname["cat"]:?}; echo >> ${f_stderr}; }
			if [ ${PIPESTATUS[0]} -eq 124 ]; then
				[ -s "${f_stderr}" ] && ${ove_cmd2pathname["cat"]:?} ${f_stderr}
				ove_echo_error_noprefix "inotifywait did not established watches within 30 sec"
				if ove_sanity_check_tmux 2> /dev/null; then
					read -r -p ""
				fi
				${ove_cmd2pathname["flock"]:?} -u ${fd}
				return 1
			fi

			if ${ove_cmd2pathname["grep"]:?} -q "Failed to watch" ${f_stderr}; then
				[ -s "${f_stderr}" ] && ${ove_cmd2pathname["cat"]:?} ${f_stderr}
				ove_echo_error_noprefix "inotifywait did not established watches"
				if ove_sanity_check_tmux 2> /dev/null; then
					read -r -p ""
				fi
				${ove_cmd2pathname["flock"]:?} -u ${fd}
				return 1
			fi

			# still running?
			if ! kill -0 ${inotifywait_pid} > /dev/null 2>&1; then
				${ove_cmd2pathname["flock"]:?} -u ${fd}
				return 1
			fi
		fi

		# run the command
		OVE_PAGER="${ove_cmd2pathname["tee"]:?} /dev/null" ove-${1} ${*:2}

		if [ ${use_inotify} -eq 1 ]; then
			# first iteration?
			if [ ${i} -eq 1 ]; then
				${ove_cmd2pathname["sleep"]:?} 1
				kill -9 ${inotifywait_pid} &> /dev/null
				wait &> /dev/null
				${ove_cmd2pathname["rm"]:?} ${all_files}

				# remove doublets and only regular files
				for f in $(LC_ALL="C" ${ove_cmd2pathname["sort"]:?} -u ${files_modified_by_command}); do
					[ -f ${f} ] && echo ${f};
				done > ${files_modified_by_command}.uniq
				${ove_cmd2pathname["rm"]:?} ${files_modified_by_command}
				if [ $(${ove_cmd2pathname["wc"]:?} -l < ${files_modified_by_command}.uniq) -eq 0 ]; then
					use_inotify=0
					echo "no files accessed, not using inotify"
				fi

				# sleep before relasing lock
				${ove_cmd2pathname["sleep"]:?} 1

				# release lock
				${ove_cmd2pathname["flock"]:?} -u ${fd}
			fi

			# inotify was disabled above?
			if [ ${use_inotify} -eq 1 ]; then
				# allow user to change the file watch list
				echo
				if [ ${i} -lt 3 ]; then
					echo "press 'm' to modify the file watch list (=$(${ove_cmd2pathname["wc"]:?} -l < ${files_modified_by_command}.uniq) files)"
				fi
				read -n 1 -s -r -t 0.1
				if [[ ${REPLY} =~ ^[Mm]$ ]]; then
					echo "file watch list: ${files_modified_by_command}.uniq"
					while true; do
						read -n 1 -s -r -p "press 'p' to proceeed (time-out in 1 min)" -t 60
						[ ${?} -gt 128 ] && break
						if [[ ${REPLY} =~ ^[Pp]$ ]]; then
							${ove_cmd2pathname["sync"]:?} ${files_modified_by_command}.uniq
							while read -r line; do
								[ -e ${line} ] && continue
								echo
								echo "'${line}' does not exist, try again"
								continue 2
							done <${files_modified_by_command}.uniq
							break
						fi
					done
					if [ $(${ove_cmd2pathname["wc"]:?} -l <${files_modified_by_command}.uniq) -eq 0 ]; then
						echo
						ove_echo_error_noprefix "no files to watch, disable inotify"
						use_inotify=0
						if ove_sanity_check_tmux 2> /dev/null; then
							read -r -p ""
						fi
						continue
					fi
				fi

				echo
			fi
		fi

		echo -
		if [ ${use_inotify} -eq 1 ]; then
			s=${SECONDS}

			# sanity check that files exist
			# filenames sent to inotifywait (--fromfile) that begin with @ are excluded
			i=0
			j=
			s=
			while read -r line; do
				((i++))
				if [[ "$line" == @* ]] && [ -e "${line:1}" ]; then
					# masked and file exists => unmask
					s+=" $i"
				elif [[ "$line" == @* ]] && [ ! -e "${line:1}" ]; then
					# masked and file still does not exit => do nothing
					true
				elif [ ! -e "${line}" ]; then
					# not masked and file still does not exit => mask it
					j+=" $i"
				fi
			done <${files_modified_by_command}.uniq

			# mask files
			if [ "x$j" != "x" ]; then
				sed_expr=
				for i in $j; do
					sed_expr+=" -e '${i}s,^,@,'"
				done
				eval ${ove_cmd2pathname["sed"]:?} -i $sed_expr ${files_modified_by_command}.uniq
			fi

			# unmask files
			if [ "x$s" != "x" ]; then
				sed_expr=
				for i in $s; do
					sed_expr+=" -e '${i}s,^.,,'"
				done
				eval ${ove_cmd2pathname["sed"]:?} -i $sed_expr ${files_modified_by_command}.uniq
			fi

			if ! ove_inotifywait ${_timeout} ${files_modified_by_command}.uniq; then
				ove_echo_error_noprefix "inotifywait failed"
				echo
				read -r -p "press ENTER to proceed (time-out in 30 sec) " -t 30
				continue
			fi

			# first iteration and if inotify returned within 3 seconds? sleep at least 3 secs
			if [ ${i} -eq 1 ] && [ $((SECONDS - s)) -lt 3 ]; then
				${ove_cmd2pathname["sleep"]:?} $((RANDOM%3 + 3))
			fi
		else
			[ "${_timeout}" == "0" ] || read_args="-t ${_timeout}"
			# shellcheck disable=SC2229
			read -n 1 -s -r -p '' ${read_args}
			[[ ${REPLY} =~ ^[Qq]$ ]] && break
		fi
	done
}

# ide:[close|reopen]:launch one or more 'loop'-commands specified by OVE_IDE_LOOP_ARGS (tmux only):UTIL
function ove-ide {
	ove_entry || return

	local i
	local line
	local loop_args

	if [ $# -gt 1 ] || ! ove_sanity_check_tmux; then
		ove_command_usage
		return 1
	fi

	if [ $# -eq 1 ]; then
		if [ "$1" == "close" ]; then
			ove-loop-close
			return 0
		elif [ "$1" == "reopen" ]; then
			ove-loop-close
			ove-ide
			return 0
		fi
		ove_command_usage
		return 1
	fi

	if [ "x${OVE_IDE_LOOP_ARGS}" == "x" ]; then
		ove_echo_error_noprefix "'OVE_IDE_LOOP_ARGS' is empty or not set"
		ove_command_usage
		return 1
	fi

	mapfile -t loop_args <<<"$(echo -e "${OVE_IDE_LOOP_ARGS//;/\\n}")"
	i=0
	while ((i < ${#loop_args[@]})); do
		ove-loop ${loop_args[i]}
		(( i+=1 ))
		${ove_cmd2pathname["sleep"]:?} ${OVE_IDE_SLEEP_BETWEEN_COMMANDS:=0.5}
	done
}

# run-parallel:t0 c0 [t1 c1 t2 c2...]:run OVE commands in parallel (tmux only):UTIL
function ove-run-parallel {
	ove_entry || return

	local n=$#
	local t

	if [ $# -eq 0 ] || [ $((n%2)) -ne 0 ] || ! ove_sanity_check_tmux; then
		ove_command_usage
		return 1
	fi

	while true; do
		t=$1
		shift
		ove-run ${t} "${@:1:1}"
		shift
		[ $# -eq 0 ] && break
	done
}

function ove_validate_int_float {
	if ! [[ "${1}" =~ ^[0-9.,]+$ ]]; then
		return 1
	elif [[ "${1}" =~ [.,][0-9]+$ ]]; then
		# shellcheck disable=SC2001
		read -r -t $(${ove_cmd2pathname["sed"]:?} -e 's|[0-9]\+\([,.]\)[0-9]\+|\101|g' -e 's|\([,.]\)[0-9]\+|\101|g' <<<"${1}") 2> /dev/null
		[ $? -lt 128 ] && return 1
	fi

	return 0
}

# run:|t c:run one OVE command 'c' in terminal/tmux with timeout 't' (0=no timeout):UTIL
function ove-run {
	ove_entry || return

	local _cmd
	local cmd
	local header
	local read_args
	local _timeout

	if [ $# -eq 1 ]; then
		ove_command_usage
		return 1
	fi

	if [ $# -eq 0 ]; then
		read -r -p "command timeout in sec (default 0 = no timeout): "
		[ "${REPLY}" == "" ] && _timeout=0 || _timeout=${REPLY}
		read -r -p "command: "
		[ "${REPLY}" == "" ] && return || cmd=${REPLY}
	else
		_timeout=$1
		shift
		cmd=$*
	fi

	if ! ove_validate_int_float "${_timeout}"; then
		ove_command_usage
		echo "error: format issues '${_timeout}'"
		return 1
	fi

	cmd=${cmd#ove }
	cmd=${cmd#ove-}
	_cmd=$(${ove_cmd2pathname["cut"]:?} -d' ' -f1 <<<"${cmd}")
	if [ "$(type -t ove-"${_cmd}")" != "function" ]; then
		ove_echo_red_noprefix "error: '${_cmd}' unknown command"
		return 1
	fi

	# turn off monitor mode to get rid of "Done" messages
	set +m
	[ "${_timeout}" == "0" ] || read_args="-t ${_timeout}"

	if ove_sanity_check_tmux 2> /dev/null; then
		if [ "${OVE_TMUX_PANE_HEADER}" == "wide" ]; then
			header="ove_echo_cyan_error ${OVE_OWEL_NAME}:ove-${cmd} [t:${_timeout}]"
		elif [ "${OVE_TMUX_PANE_HEADER}" == "short" ]; then
			header="ove_echo_cyan_error_noprefix $(${ove_cmd2pathname["date"]:?} '+%Y-%m-%d %H:%M:%S'):ove-${cmd}"
		elif [ "${OVE_TMUX_PANE_HEADER}" == "off" ]; then
			header="true"
		fi

		${ove_cmd2pathname["tmux"]:?} split-window -h "\
			source ${OVE_BASE_DIR}/ove; \
			ove_init; \
			${header}; \
			OVE_PAGER='${ove_cmd2pathname[tee]:?} /dev/null' ove-${cmd}; \
			echo -; \
			read -n 1 -s -r -p '' ${read_args}"

		${ove_cmd2pathname["tmux"]:?} select-layout ${OVE_TMUX_LAYOUT}
		${ove_cmd2pathname["tmux"]:?} select-pane -t 0
	else
		ove_echo_cyan_error "ove-${cmd}"
		OVE_PAGER="${ove_cmd2pathname[tee]:?} /dev/null" ove-${cmd}
		echo -
		# shellcheck disable=SC2229
		read -n 1 -s -r -p '' ${read_args}
	fi

	# turn on monitor mode
	set -m
}

# kill processes
#
# $1   : 0 = prefix 'kill' with 'sudo'
#      : 1 = kill as user
# $2   : duration between signal
# $3...: pids...
function ove_kill_procs {
	local n
	local pid
	local prefix
	local sig

	[ $# -lt 3 ] && return 1

	if [ $1 -eq 0 ] && [ ${EUID} -ne 0 ]; then
		prefix="sudo"
	fi

	n="$2"
	shift 2
	pids="$*"

	for pid in "$@"; do
		if [ $pid -eq $BASHPID ]; then
			continue
		elif ${prefix} kill -0 ${pid} > /dev/null 2>&1; then
			for sig in SIGTERM SIGINT SIGKILL; do
				${prefix} kill -${sig} ${pid} 2> /dev/null
				${ove_cmd2pathname["sleep"]:?} ${n}
				${prefix} kill -0 ${pid} 2> /dev/null || break
			done
		fi
	done
}

# loop-close: :close all 'loop'-panes (tmux only):UTIL
function ove-loop-close {
	ove_entry || return

	if [ $# -gt 0 ] || ! ove_sanity_check_tmux; then
		ove_command_usage
		return 1
	fi

	ove_kill_procs 1 0.2 $(${ove_cmd2pathname["pgrep"]:?} -f ove_loop_command)
	ove_kill_procs 1 0.2 $(${ove_cmd2pathname["pgrep"]:?} -f "inotifywait.*${OVE_OWEL_TMP_DIR}")
}

# loop:|[timeout|x] [inotify|x] [max-count|x] command]:loop one OVE command:UTIL
function ove-loop {
	ove_entry || return

	local _cmd
	local cmd
	local max_count
	local _timeout
	local use_inotify

	if [ $# -gt 0 ] && [ $# -lt 4 ]; then
		ove_command_usage
		return 1
	fi

	if [ $# -eq 0 ]; then
		read -r -p "command timeout in sec (default 0 = no timeout): "
		[ "${REPLY}" == "" ] && _timeout=0 || _timeout=${REPLY}
		read -r -p "inotify 0=no 1=yes (default 0): "
		[ "${REPLY}" == "" ] && use_inotify=0 || use_inotify=${REPLY}
		read -r -p "max count: (default 0 = forever): "
		[ "${REPLY}" == "" ] && max_count=0 || max_count=${REPLY}
		read -r -p "command: "
		[ "${REPLY}" == "" ] && return || cmd=${REPLY}
	else
		if [ "${1,}" == "x" ]; then
			read -r -p "command timeout in sec (0=no timeout): "
			[ "${REPLY}" == "" ] && _timeout=0 || _timeout=${REPLY}
		else
			_timeout=$1
		fi

		if [ "${2,}" == "x" ]; then
			read -r -p "inotify 0=no 1=yes (default 0): "
			[ "${REPLY}" == "" ] && use_inotify=0 || use_inotify=${REPLY}
		else
			use_inotify=$2
		fi

		if [ "${3,}" == "x" ]; then
			read -r -p "max count: (default 0 = forever): "
			[ "${REPLY}" == "" ] && max_count=0 || max_count=${REPLY}
		else
			max_count=$3
		fi

		shift 3
		cmd=$*
	fi

	if ! ove_validate_int_float "${_timeout}"; then
		ove_command_usage
		echo "error: format issues '${_timeout}'"
		return 1
	fi

	if ! [[ "${use_inotify}" =~ ^[0-1]$ ]]; then
		echo "error: inotify: 0 or 1"
		ove_command_usage
		return 1
	fi

	if [ "${use_inotify}" -eq 1 ] && ! command -v inotifywait > /dev/null; then
		ove_command_not_found "inotifywait"
		return 1
	fi

	if ! [[ "${max_count}" =~ ^[0-9]+$ ]]; then
		echo "error: max count: just numbers"
		ove_command_usage
		return 1
	fi

	cmd=${cmd#ove }
	cmd=${cmd#ove-}
	_cmd=$(${ove_cmd2pathname["cut"]:?} -d' ' -f1 <<<"${cmd}")
	if [ "$(type -t ove-"${_cmd}")" != "function" ]; then
		ove_echo_red_noprefix "error: '${_cmd}' unknown command"
		return 1
	fi

	if ove_sanity_check_tmux 2> /dev/null; then
		${ove_cmd2pathname["tmux"]:?} split-window -h "\
			source ${OVE_BASE_DIR}/ove; \
			ove_init; \
			ove_loop_command ${_timeout} ${use_inotify} ${max_count} '${cmd}'"

		${ove_cmd2pathname["tmux"]:?} select-layout ${OVE_TMUX_LAYOUT}
		${ove_cmd2pathname["tmux"]:?} select-pane -t 0
	else
		ove_loop_command ${_timeout} ${use_inotify} ${max_count} "${cmd}"
	fi
}

# fix broken vars
function ove_sanitise_vars {
	local corrupt

	# corrupt OVE_LOGLEVEL?
	if [ -n "${OVE_LOGLEVEL}" ]; then
		corrupt=0
		if ! [ "${OVE_LOGLEVEL}" -eq "${OVE_LOGLEVEL}" ] 2> /dev/null; then
			corrupt=1
		elif ! [[ "${OVE_LOGLEVEL}" =~ ^[0-9]$ ]]; then
			corrupt=1
		fi

		[ ${corrupt} -eq 1 ] && ove-loglevel 1 > /dev/null
	fi

	return 0
}

function ove_setup_trace {
	local bcc_tool
	local strace_expression

	if [ ${OVE_LOGLEVEL} -lt 3 ]; then
		unset OVE_TRACE_CMD
		return 0
	fi

	[ -e ${OVE_OWEL_TMP_DIR}/trace-${cmd} ] && \
		${ove_cmd2pathname["rm"]:?} -rf ${OVE_OWEL_TMP_DIR}/trace-${cmd}
	${ove_cmd2pathname["mkdir"]:?} -p ${OVE_OWEL_TMP_DIR}/trace-${cmd}

	if [ ${OVE_LOGLEVEL} -eq 5 ]; then
		strace_expression="connect,bind,execve"
	elif [ ${OVE_LOGLEVEL} -eq 6 ]; then
		strace_expression="execve,clone,fork,vfork,connect,bind"
	else
		strace_expression="execve"
	fi

	if [ ${OVE_LOGLEVEL} -ge 7 ] && [ ${OVE_LOGLEVEL} -lt 10 ]; then
		if [ ${OVE_LOGLEVEL} -eq 7 ]; then
			bcc_tool="execsnoop"
		elif [ ${OVE_LOGLEVEL} -eq 8 ]; then
			bcc_tool="tcpconnect"
		elif [ ${OVE_LOGLEVEL} -eq 9 ]; then
			bcc_tool="opensnoop"
		fi

		if [ ${EUID} != 0 ]; then
			if ! sudo -n true; then
				if ! sudo true; then
					ove_echo_error_noprefix "'${bcc_tool}' need non-interactive 'sudo'"
					return 1
				fi
			fi
			OVE_TRACE_CMD="sudo "
		fi
		OVE_TRACE_CMD+="python3 /usr/share/bcc/tools/${bcc_tool} "
		if [ ${OVE_LOGLEVEL} -eq 9 ]; then
			OVE_TRACE_CMD+="-T "
		else
			OVE_TRACE_CMD+="-t "
		fi
		OVE_TRACE_CMD+="-u ${EUID} "
		OVE_TRACE_CMD+="> ${OVE_OWEL_TMP_DIR}/trace-${cmd}/trace-${cmd} "
		OVE_TRACE_CMD+="2> /dev/null"
		OVE_TRACE_CMD+="& echo \$! > ${OVE_OWEL_TMP_DIR}/trace.pid 2> /dev/null"
	else
		OVE_TRACE_CMD="strace "
		OVE_TRACE_CMD+="-s 1024 "
		OVE_TRACE_CMD+="-q "
		OVE_TRACE_CMD+="-o ${OVE_OWEL_TMP_DIR}/trace-${cmd}/trace-${cmd} "
		OVE_TRACE_CMD+="-ff "
		OVE_TRACE_CMD+="-T "
		OVE_TRACE_CMD+="-e ${strace_expression} "
		OVE_TRACE_CMD+="-ttt "
	fi
	export OVE_TRACE_CMD
	[ -e ${OVE_OWEL_TMP_DIR}/bash.pid ] && \
		${ove_cmd2pathname["rm"]:?} ${OVE_OWEL_TMP_DIR}/bash.pid
	[ -e ${OVE_OWEL_TMP_DIR}/trace.pid ] && \
		${ove_cmd2pathname["rm"]:?} ${OVE_OWEL_TMP_DIR}/trace.pid
	[ -e ${OVE_OWEL_TMP_DIR}/trace.cont ] && \
		${ove_cmd2pathname["rm"]:?} ${OVE_OWEL_TMP_DIR}/trace.cont

	{
		while true; do [ -e ${OVE_OWEL_TMP_DIR}/bash.pid ] && break; done

		# launch trace in background and let it start up
		if [ ${OVE_LOGLEVEL} -ge 7 ] && [ ${OVE_LOGLEVEL} -lt 10 ]; then
			(eval ${OVE_TRACE_CMD})
			${ove_cmd2pathname["sleep"]:?} 2
		else
			(${OVE_TRACE_CMD} -p $(${ove_cmd2pathname["cat"]:?} ${OVE_OWEL_TMP_DIR}/bash.pid) & echo $! > ${OVE_OWEL_TMP_DIR}/trace.pid)
			${ove_cmd2pathname["sleep"]:?} 1
		fi
		true > ${OVE_OWEL_TMP_DIR}/trace.cont
	} &
}

function ove_setup_trace_post {
	local pid

	if [ -n "${OVE_TRACE_CMD+x}" ]; then
		pid=$(${ove_cmd2pathname["cat"]:?} ${OVE_OWEL_TMP_DIR}/trace.pid)
		if [ ${OVE_LOGLEVEL} -ge 7 ] && [ ${OVE_LOGLEVEL} -lt 10 ]; then
			ove_kill_procs 0 1 ${pid}
		else
			ove_kill_procs 1 1 ${pid}
		fi

		[ -e ${OVE_OWEL_TMP_DIR}/bash.pid ] && \
			${ove_cmd2pathname["rm"]:?} ${OVE_OWEL_TMP_DIR}/bash.pid
		[ -e ${OVE_OWEL_TMP_DIR}/trace.cont ] && \
			${ove_cmd2pathname["rm"]:?} ${OVE_OWEL_TMP_DIR}/trace.cont
		[ -e ${OVE_OWEL_TMP_DIR}/trace.pid ] && \
			${ove_cmd2pathname["rm"]:?} ${OVE_OWEL_TMP_DIR}/trace.pid

		while true; do
			if [ ${OVE_LOGLEVEL} -eq 3 ] || [ ${OVE_LOGLEVEL} -eq 4 ]; then
				ove_analyze_strace_execve_timing ${OVE_OWEL_TMP_DIR}/trace-${cmd}
			elif [ ${OVE_LOGLEVEL} -eq 5 ]; then
				ove_analyze_strace_connect ${OVE_OWEL_TMP_DIR}/trace-${cmd}
			elif [ ${OVE_LOGLEVEL} -eq 6 ]; then
				ove_strace_create_graph ${OVE_OWEL_TMP_DIR}/trace-${cmd} ${cmd}
			elif [ ${OVE_LOGLEVEL} -ge 7 ] && [ ${OVE_LOGLEVEL} -lt 10 ]; then
				${ove_cmd2pathname["head"]:?} -n -1 ${OVE_OWEL_TMP_DIR}/trace-${cmd}/trace-${cmd}
			fi
			break
		done | ${ove_cmd2pathname["tee"]:?} -a ${OVE_LAST_COMMAND}

		unset OVE_TRACE_CMD
	fi
}

function ove_batch_helper {
	local a
	local f
	local h
	local id

	id="$1"

	# create a on finish script
	f="${OVE_GLOBAL_STATE_DIR}/ove-ts-onfinish"
	${ove_cmd2pathname["cat"]:?} > "${f}" << EOF
#!/usr/bin/env bash

# rename ts output to OVE_LAST_COMMAND
if [ -s \$3 ]; then
	\mv -v "\$3" \$OVE_LAST_COMMAND
fi

# cleanup onfinish files that contains an id
if [ "\$TS_ONFINISH" != "${f}" ]; then
	rm -v \$TS_ONFINISH
fi
EOF

	a=0
	# append any post hooks
	if [ -v ove_hooks_post[${cmd}] ]; then
		for h in ${ove_hooks_post[${cmd}]}; do
			if [ -s "$h" ] && [ -x "$h" ]; then
				if [ "${a}" -eq 0 ]; then
					a="${OVE_GLOBAL_STATE_DIR}/${id}-ove-ts-onfinish"
					if ! ${ove_cmd2pathname["cp"]:?} -a $f ${a}; then
						return 1
					fi
					f="${a}"
					a=1
				fi

				# append it
				echo "$h |& ${ove_cmd2pathname["tee"]:?} -a \$OVE_LAST_COMMAND" >> ${f}
			fi
		done
	fi

	if [ ! -x "${f}" ]; then
		# make the script executable
		if ! ${ove_cmd2pathname["chmod"]:?} +x "${f}"; then
			return 1
		fi
	fi

	echo $f
}

function ove {
	local candidates
	local cmd
	local cmd_and_args
	local h
	local id
	local log_cmd
	local on_finish
	local re
	local ret

	cmd="$1"

	# keep this as early as possible
	if [ "${cmd}" == "cd" ] \
		|| [ "${cmd}" == "init" ] \
		|| [ "${cmd}" == "l" ] \
		|| [ "${cmd}" == "setup" ]; then
		ove-${cmd} "${@:2}"
		return $?
	fi

	# sanity check
	if ! ove_get_base_dir > /dev/null; then
		return 1
	fi

	ove_sanitise_vars

	if ! ove_verify_checksums && ! ove_reinit; then
		return 1
	fi

	ove_update_terminal_stats

	if [ $# -eq 0 ]; then
		ove-help
		return $?
	elif [ "$(type -t ove-"${cmd}")" != "function" ]; then
		re=\\b${cmd}
		if ! [[ "${OVE_ALL_COMMANDS}" =~ ${re} ]]; then
			ove_echo_red_noprefix "error: '${cmd}' unknown command"
			return 1
		fi

		candidates=$(ove-list-commands ^${cmd} | \
			${ove_cmd2pathname["grep"]:?} -E -v "^cmd|^---")
		if [ "x${candidates}" != "x" ] && \
			[ ${OVE_AUTO_CORRECT} -eq 1 ] && \
			[ $(${ove_cmd2pathname["wc"]:?} -l <<<"${candidates}") -eq 1 ]; then
			cmd=$(${ove_cmd2pathname["tail"]:?} -1 <<<"${candidates}")
			cmd=${cmd%% *}
			ove ${cmd} "${@:2}"
			return $?
		fi

		ove_echo_red_noprefix "error: '${cmd}' unknown command"
		if [ "x${candidates}" != "x" ]; then
			echo
			echo "Did you mean?"
			echo "${candidates}"
		fi

		return 1
	fi

	if [ -n "${OVE_LOCAL_ECHO+x}" ] && [ "${OVE_LOCAL_ECHO}" -eq 1 ]; then
		if [ ${EUID} -eq 0 ]; then
			echo -n "# " 1>&2
		else
			echo -n "$ " 1>&2
		fi
		echo "ove ${cmd} ${*:2}" 1>&2
	fi

	# do not log commands that:
	# * affect the user's shell
	# * 'complex' commands (e.g. vi/emacs)
	if [ "${cmd}" == "add-config" ] || \
		[ "${cmd}" == "config" ] || \
		[ "${cmd}" == "checkout" ] || \
		[ "${cmd}" == "dry-run" ] || \
		[ "${cmd}" == "echo" ] || \
		[ "${cmd}" == "emacs" ] || \
		[ "${cmd}" == "lastlog" ] || \
		[ "${cmd}" == "lastlog-replay" ] || \
		[ "${cmd}" == "lastlog-summary" ] || \
		[ "${cmd}" == "less-lastlog" ] || \
		[ "${cmd}" == "loglevel" ] || \
		[ "${cmd}" == "revtab-check" ] || \
		[ "${cmd}" == "tail-lastlog" ] || \
		[ "${cmd}" == "ts" ] || \
		[ "${cmd}" == "unsource" ] || \
		[ "${cmd}" == "update-revtab" ] || \
		[ "${cmd}" == "vi" ]; then
		ove-${cmd} "${@:2}"
		return $?
	fi

	# setup log file
	${ove_cmd2pathname["mkdir"]:?} -p ${OVE_LOG_DIR}/${OVE_SHA}
	(cd ${OVE_LOG_DIR} && ${ove_cmd2pathname["ln"]:?} -sfn ${OVE_SHA} current)
	id=$(${ove_cmd2pathname["date"]:?} '+%Y%m%d-%H%M%S%N')
	OVE_LAST_COMMAND="${OVE_LOG_DIR}/${OVE_SHA}/${id}-ove-${cmd}-${HOSTNAME}-${OVE_OWEL_NAME}.log"

	# terminals and parallel project commands use 'script', everything else use 'tee'
	log_cmd="tee"
	if [ -t 1 ]; then
		log_cmd="script"
	elif [[ ${cmd} = *-parallel ]]; then
		re=\\b${cmd/-parallel/}\\b
		if [[ "${OVE_PROJECT_COMMANDS} buildme" =~ ${re} ]]; then
			log_cmd="script"
		fi
	fi

	# batch the command?
	if [ "x$OVE_BATCH_IT" != "x0" ]; then
		log_cmd="tsp"
		if ! command -v $log_cmd > /dev/null; then
			ove_command_not_found "$log_cmd"
			return 1
		elif ! on_finish=$(ove_batch_helper $id); then
			return 1
		fi

		OVE_BATCH_IT=0
	fi

	if [ ${EUID} -eq 0 ]; then
		cmd_and_args="#"
	else
		cmd_and_args="$"
	fi

	if [ $# -gt 1 ]; then
		cmd_and_args+=" ove ${cmd} ${*:2}"
	else
		cmd_and_args+=" ove ${cmd}"
	fi

	# pre hooks?
	if [ -v ove_hooks_pre[${cmd}] ]; then
		for h in ${ove_hooks_pre[${cmd}]}; do
			if [ -s "$h" ] && [ -x "$h" ]; then
				$h
				ret=$?
				if [ $ret -ne 0 ]; then
					ove_echo_red_noprefix "error: pre hook '$h' failed with exit code $ret"
					return $ret
				fi
			fi
		done
	fi

	# do not create the 'ongo' symlink for tsp
	if [ "x${log_cmd}" != "xtsp" ]; then
		${ove_cmd2pathname["ln"]:?} -s -f ${OVE_LAST_COMMAND} ${OVE_LOG_DIR}/ongo
	fi

	if [ "x${log_cmd}" = "xscript" ]; then
		# trace hook
		if ! ove_setup_trace; then
			return 1
		fi

		# turn off monitor mode to get rid of "Done" messages
		set +m

		# run the command
		SHELL=${ove_cmd2pathname["bash"]:?} \
			${ove_cmd2pathname["script"]:?} ${OVE_SCRIPT_OPTIONS} -t${OVE_LAST_COMMAND/.log}.timing -c "source ${OVE_BASE_DIR}/ove; OVE_LAST_COMMAND=$OVE_LAST_COMMAND; ove-${cmd}$([ $# -gt 1 ] && printf -- ' "%s"' "${@:2}")" \
			${OVE_LAST_COMMAND}
		ret=$?

		# trace post hook
		ove_setup_trace_post

		# remove CR, NULL bytes and insert command+args at line 2
		${ove_cmd2pathname["sed"]:?} -i -e 's/\r$//' -e 's/\x0//' -e "2i${cmd_and_args}" ${OVE_LAST_COMMAND}

		# compensate timing file for command, args and linefeed
		${ove_cmd2pathname["sed"]:?} -i -e "1i0 $((${#cmd_and_args}+1))" ${OVE_LAST_COMMAND/.log}.timing

		# turn on monitor mode
		set -m
	elif [ "x${log_cmd}" = "xtsp" ]; then
		# run the command using Task Spooler
		TS_SOCKET=$OVE_TMP/ts-socket.$EUID \
			TS_ONFINISH="${on_finish}" \
			${ove_cmd2pathname["tsp"]:?} \
			${ove_cmd2pathname["bash"]:?} \
			-c "source ${OVE_BASE_DIR}/ove; OVE_LAST_COMMAND=$OVE_LAST_COMMAND; ove-${cmd}$([ $# -gt 1 ] && printf -- ' "%s"' "${@:2}")"
	else
		# none-terminal => use tee

		if command -v setsid > /dev/null && [ "$OVE_COMMAND_SETSID" -eq 1 ]; then
			# we have 'setsid' AND we want to run the command in a separate session
			${ove_cmd2pathname["setsid"]:?} \
				-w \
				${ove_cmd2pathname["bash"]:?} \
				-c "ove-${cmd} ${*:2}" 2>&1 | ${ove_cmd2pathname["tee"]:?} -i ${OVE_LAST_COMMAND}
		else
			{
				ove-${cmd} "${@:2}"
			} 2>&1 | ${ove_cmd2pathname["tee"]:?} -i ${OVE_LAST_COMMAND}
		fi
		ret=${PIPESTATUS[0]}

		# remove NULL bytes AND insert command, args and exit code at line 1
		if [ -s "${OVE_LAST_COMMAND}" ]; then
			${ove_cmd2pathname["sed"]:?} -i -e 's/\x0//g' -e "1i${cmd_and_args} # exit code: ${ret}" ${OVE_LAST_COMMAND}
		else
			echo "${cmd_and_args} # exit code: ${ret}" > ${OVE_LAST_COMMAND}
		fi
	fi

	if [ "x${log_cmd}" != "xtsp" ]; then
		if [ -n "${OVE_ANONYMIZE_LOGS+x}" ] && [ "${OVE_ANONYMIZE_LOGS}" -eq 1 ]; then
			${ove_cmd2pathname["sed"]:?} -i \
				-e "s,$OVE_BASE_DIR,\$OVE_BASE_DIR,g" \
				-e "s,$OVE_USER,\$OVE_USER,g" \
				-e "s,$HOSTNAME,\$HOSTNAME,g" ${OVE_LAST_COMMAND}
		fi

		${ove_cmd2pathname["ln"]:?} -s -f ${OVE_LAST_COMMAND} ${OVE_LOG_DIR}/last
	fi

	# auto remove old logs?
	if [ -n "${OVE_AUTO_RM_LOGS+x}" ] && [ ${OVE_AUTO_RM_LOGS} -gt 0 ] && [ "${cmd}" != "rm-logs" ]; then
		ove-rm-logs ${OVE_AUTO_RM_LOGS} y
	fi

	# post hooks?
	if [ "x${log_cmd}" != "xtsp" ] && [ -v ove_hooks_post[${cmd}] ]; then
		for h in ${ove_hooks_post[${cmd}]}; do
			if [ -s "$h" ] && [ -x "$h" ]; then
				# run the hook
				$h
				ret=$?
				if [ $ret -ne 0 ]; then
					ove_echo_red_noprefix "error: post hook '$h' failed with exit code $ret"
					return $ret
				fi
			fi
		done
	fi

	return ${ret}
}

# task:[task args]:check task man pages, taskwarrior [duckduckgo.com/?q=taskwarrior]:UTIL
function ove-task {
	ove_entry || return

	local ret

	if ! command -v task > /dev/null; then
		ove_command_not_found "task"
		return 1
	fi

	if [ ! -s $OVE_OWEL_DIR/.taskrc ]; then
		echo 'verbose=0' > $OVE_OWEL_DIR/.taskrc
	fi

	TASKDATA=$OVE_OWEL_DIR/.task \
		TASKRC=$OVE_OWEL_DIR/.taskrc \
		${ove_cmd2pathname["task"]:?} "$@"
}

# ts:[ts/tsp args]:check ts/tsp man pages:CORE
function ove-ts {
	ove_entry || return

	if ! command -v tsp > /dev/null; then
		ove_command_not_found "tsp"
		return 1
	fi

	if [ $# -eq 0 ]; then
		TS_SOCKET=$OVE_TMP/ts-socket.$EUID ${ove_cmd2pathname["tsp"]:?} | \
			${ove_cmd2pathname["sed"]:?} \
			-e '/^ID/d' \
			-e "s,${ove_cmd2pathname["bash"]:?}.*OVE_LAST_COMMAND=,,g" \
			-e 's,\([0-9]\+.*finished.*\)/tmp/ts-out\.[a-zA-Z0-9]\+.* \(/.*log\);,\1 \2,g' \
			-e "s,\(.*\)\($OVE_LOG_DIR/${OVE_SHA}/2.*.log\)\(.*\),\1\3@\2,g" | \
			${ove_cmd2pathname["column"]:?} -t -s@ | \
			${ove_cmd2pathname["tac"]:?}
	else
		TS_SOCKET=$OVE_TMP/ts-socket.$EUID \
			${ove_cmd2pathname["tsp"]:?} "$@"
	fi
}

# fzf:[loop]:OVE fzf [duckduckgo.com/?q=fzf]:UTIL
function ove-fzf {
	ove_entry || return

	local args
	local cmd
	local shell

	if ! command -v fzf > /dev/null; then
		return 1
	fi

	# sanity check
	if ! ove_get_base_dir > /dev/null; then
		return 1
	fi

	if [ $# -gt 1 ]; then
		ove_command_usage
		return 1
	fi

	shell=${ove_cmd2pathname["bash"]:?}
	while true; do
		# shellcheck disable=SC2016
		cmd=$(${ove_cmd2pathname["xargs"]:?} -n 1 <<<"${OVE_ALL_COMMANDS}" | \
			${ove_cmd2pathname["grep"]:?} -v '!' | \
			OVE_LOCAL_ECHO=0 SHELL=${shell} ${ove_cmd2pathname["fzf"]:?} \
			--cycle \
			--preview "ove-list-commands ^{1} | grep '^{1} '" \
			--preview-window=down:1 \
		)
		[ "${cmd}" == "" ] && break

		if ${ove_cmd2pathname["tr"]:?} ' ' '\n' <<<"${OVE_BUILT_INS_WITHOUT_ARGS}" | \
			${ove_cmd2pathname["grep"]:?} -q ^${cmd}$; then
			if [ "$1" == "loop" ]; then
				echo "$ ove-loop x x x ${cmd}"
				ove-loop x x x ${cmd}
				echo -
			else
				ove-run 0 ${cmd}
			fi
			continue
		fi

		COMP_WORDS=(ove ${cmd} ' ')
		COMP_LINE="ove ${cmd}"
		COMP_CWORD=3
		COMP_POINT=${#COMP_LINE}
		ove_bash_complete
		if [ ${#COMPREPLY[@]} -eq 0 ]; then
			if [ $1 == "loop" ]; then
				echo "$ ove-loop x x x ${cmd}"
				ove-loop x x x ${cmd}
				echo -
			else
				ove-run 0 ${cmd}
			fi
		else
			args=$(printf '%s\n' "${COMPREPLY[@]}" | \
				LC_ALL="C" ${ove_cmd2pathname["sort"]:?} -u | \
				SHELL=${shell} ${ove_cmd2pathname["fzf"]:?} \
					--cycle \
					--preview "echo ESC\|CTRL+C to skip args $ ove ${cmd} {}" \
					--preview-window=down:1)

			if [ "$1" == "loop" ]; then
				echo "$ ove-loop x x x ${cmd} ${args}"
				ove-loop x x x ${cmd} ${args}
				echo -
			else
				ove-run 0 ${cmd} ${args}
			fi
		fi
	done
}

# not really a complete YAML parser
function ove_parse_yaml {
	local line

	# shellcheck disable=SC2016
	while IFS=: read -r line; do
		${ove_cmd2pathname["sed"]:?} -e 's/: /:/g' -e "s/\([a-zA-Z0-9_]\+\):/\" ove_${line%%:*}_\1=\"/g" -e "s/$/\"/g" -e "s/^\" //g" -e "s/ \"/\"/g" <<<"${line#*: }" &
	done < <(${ove_cmd2pathname["sed"]:?} -e '1{/^---$/d;}' -e 's/^\([a-zA-Z0-9_]\+:$\)/\n\1/g' -e 's/#.*//g' -e 's,^//.*,,g' -e '/^$/d' $1 | \
		${ove_cmd2pathname["awk"]:?} NF=NF RS= OFS=' ')
	wait
}

function ove_project_commands_list {
	local a

	# for each project, look for executable files, ignore files with hyphen-minus, underscore and number sign
	a=$(LC_ALL="C" ${ove_cmd2pathname["sort"]:?} -u <(
		for f in $(cd ${OVE_OWEL_DIR} && ${ove_cmd2pathname["find"]:?} -L projects/*/ -perm -u=x -type f \
			-not -name '*-*' \
			-not -name '*_*' \
			-not -name '*#*' 2> /dev/null); do
			echo ${f##*/};
		done))

	if [ "x${a}" != "x" ]; then
		echo ${a}
	fi
}

# $1: dir (optional)
function ove_list_tags_and_branches {
	local d

	[ $# -eq 0 ] && d=${OVE_OWEL_DIR} || d=$1
	! [ -d ${d} ] && return

	(
	ove_repo_cmd "${d}" tag
	ove_repo_cmd "${d}" branch --no-color --all --list | \
		${ove_cmd2pathname["grep"]:?} -v HEAD | \
		${ove_cmd2pathname["tr"]:?} -d '*' | \
		${ove_cmd2pathname["xargs"]:?} | \
		${ove_cmd2pathname["tr"]:?} ' ' '\n'
	) | LC_ALL="C" ${ove_cmd2pathname["sort"]:?} -V
}

# iterate through projects
function ove_projects_init {
	local i
	local m
	local name
	local needs_distro_version_found
	local os_version
	local projects
	local tmp_var

	unset ove_projects_name
	unset ove_projects_deps
	unset ove_projects_path
	unset ove_projects_needs
	unset ove_projects_version
	unset ove_projects_name2index
	unset ove_projects_tags
	ove_number_of_projects=0

	if [ ! -s "${OVE_OWEL_DIR}/projs" ] || [ "x${OVE_PROJECT_LIST}" = "x" ]; then
		return
	fi

	if ! eval $(ove_parse_yaml "${OVE_OWEL_DIR}/projs") 2> /dev/null; then
		ove_echo_error_noprefix "possible format error(s) in '${OVE_OWEL_DIR}/projs'"
		if command -v yamllint > /dev/null; then
			${ove_cmd2pathname["yamllint"]:?} "${OVE_OWEL_DIR}/projs"
		fi
		return 1
	fi

	declare -a -g ove_projects_name
	declare -a -g ove_projects_deps
	declare -a -g ove_projects_path
	declare -a -g ove_projects_needs
	declare -a -g ove_projects_version
	declare -A -g ove_projects_name2index
	declare -A -g ove_projects_tags

	# create ove-functions for all project commands
	for m in ${OVE_PROJECT_COMMANDS}; do
		eval "ove-${m}() {
			ove_entry || return

			local i
			local ove_plugin_helptext=\"${m}:[project...|tag...]:run the '${m}' step for all or individual projects:BUILD\"
			local p
			local proj_list

			if ! ove_build_pre \$*; then
				return 1
			fi

			# common .pre
			if [ -e \${OVE_OWEL_DIR}/projects/common/${m}.pre ]; then
				source \${OVE_OWEL_DIR}/projects/common/${m}.pre
			fi

			if [ \$# -eq 0 ]; then
				i=0
				while ((i < ove_number_of_projects)); do
					if ! ove_projects_cmd "\${ove_projects_name[\${i}]}" ${m}; then
						return 1
					fi
					(( i+=1 ))
				done
			else
				if ! proj_list=\$(ove_validate_project_list \"\$@\"); then
					return 1
				fi

				for p in \$proj_list; do
					if ! ove_projects_cmd \${p} ${m}; then
						return 1
					fi
				done
			fi

			# common .post
			if [ -e \${OVE_OWEL_DIR}/projects/common/${m}.post ]; then
				source \${OVE_OWEL_DIR}/projects/common/${m}.post
			fi
		}"
	done

	# create parallel ove-functions for all project commands
	for m in ${OVE_PROJECT_COMMANDS}; do
		eval "ove-${m}-parallel() {
			ove_entry || return

			local i
			local ove_plugin_helptext=\"${m}-parallel:[project...|tag...]:run the '${m}' step for all or individual projects (in parallel):BUILD\"
			local p
			local proj_list

			if ! ove_build_pre \$*; then
				return 1
			fi

			# common .pre
			if [ -e \${OVE_OWEL_DIR}/projects/common/${m}.pre ]; then
				source \${OVE_OWEL_DIR}/projects/common/${m}.pre
			fi

			if [ \$# -eq 0 ]; then
				i=0
				while ((i < ove_number_of_projects)); do
					{
						if ! ove_projects_cmd "\${ove_projects_name[\${i}]}" ${m}; then
							kill -USR1 \$\$
						fi
					} &
					(( i+=1 ))
				done
			else
				if ! proj_list=\$(ove_validate_project_list \"\$@\"); then
					return 1
				fi

				for p in \$proj_list; do
					{
						if ! ove_projects_cmd \${p} ${m}; then
							kill -USR1 \$\$
						fi
					} &
				done
			fi

			wait

			# common .post
			if [ -e \${OVE_OWEL_DIR}/projects/common/${m}.post ]; then
				source \${OVE_OWEL_DIR}/projects/common/${m}.post
			fi
		}"
	done

	read -a projects -r <<<"${OVE_PROJECT_LIST}"
	ove_number_of_projects=${#projects[@]}

	# bash does not like variables with hyphen-minus and dots
	os_version="${OVE_OS_VER//[.-]/_}"
	# set projects deps|name|path|needs|version
	i=0
	while ((i < ove_number_of_projects)); do
		# name
		name=${projects[${i}]}
		ove_projects_name[${i}]=${name}
		unset ove_${name}

		# index
		ove_projects_name2index[${name}]=${i}

		# deps
		tmp_var="ove_${name}_deps"
		ove_projects_deps[${i}]=${!tmp_var}
		unset ${tmp_var}

		# path
		tmp_var="ove_${name}_path"
		if [ "${!tmp_var:0:1}" = "/" ]; then
			ove_projects_path[${i}]="${!tmp_var}"
		else
			ove_projects_path[${i}]="${OVE_BASE_DIR}/${!tmp_var}"
		fi
		unset ${tmp_var}

		# needs
		tmp_var="ove_${name}_needs"
		ove_projects_needs[${i}]=${!tmp_var}
		unset ${tmp_var}

		# tags
		tmp_var="ove_${name}_tags"
		for t in ${!tmp_var};  do
			if [ "x${ove_projects_tags[${t}]}" = "x" ]; then
				ove_projects_tags[${t}]="${name}"
			else
				ove_projects_tags[${t}]+=" ${name}"
			fi
		done
		unset ${tmp_var}

		# distro needs
		needs_distro_version_found=0
		for m in ${OVE_OS_ID} ${OVE_OS_ID_LIKE}; do
			tmp_var="ove_${name}_needs_${m//-/_}_${os_version}"
			if [ "${!tmp_var}" != "" ]; then
				needs_distro_version_found=1
				if [ "x${ove_projects_needs[${i}]}" = "x" ]; then
					ove_projects_needs[${i}]="${!tmp_var}"
				else
					ove_projects_needs[${i}]+=" ${!tmp_var}"
				fi
				unset ${tmp_var}
			elif [ $needs_distro_version_found -eq 0 ] && tmp_var="ove_${name}_needs_${m//-/_}" && [ "${!tmp_var}" != "" ]; then
				if [ "x${ove_projects_needs[${i}]}" = "x" ]; then
					ove_projects_needs[${i}]="${!tmp_var}"
				else
					ove_projects_needs[${i}]+=" ${!tmp_var}"
				fi
				unset ${tmp_var}
			fi
		done

		# version
		tmp_var="ove_${name}_version"
		ove_projects_version[${i}]=${!tmp_var}
		unset ${tmp_var}

		(( i+=1 ))
	done

	# unset any distro needs laying around
	unset $(set -o posix; set | \
		${ove_cmd2pathname["grep"]:?} '^ove_.*_needs.*=' | \
		${ove_cmd2pathname["grep"]:?} -v '^ove_projects_needs=' | \
		${ove_cmd2pathname["cut"]:?} -d= -f1)

	if ! ove_validate_projs; then
		return 1
	fi

	# OVE_BUILD_ORDER:project build order
	OVE_BUILD_ORDER="$(ove-build-order)"
	export OVE_BUILD_ORDER
}

function ove_list_projects_without_deps {
	local i

	i=0
	while ((i < ove_number_of_projects)); do
		if [ "${ove_projects_deps[${i}]}" == "" ]; then
			echo -n "${ove_projects_name[${i}]} "
		fi
		(( i+=1 ))
	done
}

function ove_list_projects_with_deps {
	local i

	i=0
	while ((i < ove_number_of_projects)); do
		if [ "${ove_projects_deps[${i}]}" != "" ]; then
			echo -n "${ove_projects_name[${i}]} "
		fi
		(( i+=1 ))
	done
}

# helper for ove_projects_cmd
function ove_projects_cmd_execute {
	local e
	local ret=0

	# common for this command?
	if [ -e "${OVE_OWEL_DIR}/projects/common/${proj_command}" ]; then
		# shellcheck disable=SC1090
		OVE_ACTIVE_PROJECT_NAME="${proj_name}" \
			OVE_ACTIVE_PROJECT_COMMAND="${proj_command}" \
			OVE_ACTIVE_PROJECT_VERSION=${ove_projects_version[${i}]} \
			source "${OVE_OWEL_DIR}/projects/common/${proj_command}"
		# preserve return code
		ret="$?"
	fi

	if [ ${ret} -eq 0 ]; then
		# "$1"/$2 is no longer needed
		shift 2

		if [ ${OVE_DRY_RUN} -eq 0 ]; then
			e="${proj_name}_version=${ove_projects_version[${i}]}"
			e+=" OVE_ACTIVE_PROJECT_NAME=${proj_name}"
			e+=" OVE_ACTIVE_PROJECT_COMMAND=${proj_command}"
			e+=" OVE_ACTIVE_PROJECT_VERSION=${ove_projects_version[${i}]}"
			if [ ${OVE_TAINT_USER_ENV} -eq 0 ]; then
				e+=" LD_LIBRARY_PATH=${OVE_LD_LIBRARY_PATH}:${LD_LIBRARY_PATH}"
				e+=" MAKEFLAGS=\"\${OVE_MAKEFLAGS}\""
				e+=" PATH=${OVE_STAGE_DIR}${OVE_PREFIX}/sbin:${OVE_STAGE_DIR}${OVE_PREFIX}/bin:${PATH}"
				e+=" PKG_CONFIG_PATH=${OVE_PKG_CONFIG_PATH}"
			fi

			# run it
			eval "${e} \
				${OVE_OWEL_DIR}/projects/${proj_name}/${proj_command} \
				${OVE_REDIRECT_OUTPUT}"
		else
			# dry: print the command
			ove_echo_stderr_noprefix "cd ${path} && ${OVE_OWEL_DIR}/projects/${proj_name}/${proj_command}"
		fi

		# preserve return code
		ret="$?"
	fi

	if [ "${ret}" -ne 0 ]; then
		ove_echo_error "${proj_name}: ${proj_command}"
	else
		if [ ${OVE_LOGLEVEL} -ne 0 ]; then
			ove_echo_cyan_error "${proj_name}: ${proj_command}: done"
		fi
	fi

	return $ret
}

# $1: project name
# $2: project command
function ove_projects_cmd {
	local i
	local path
	local proj_command
	local proj_name
	local re
	local ret
	local with_flock=0

	proj_name=$1
	proj_command=$2
	ret=0

	# sanity check
	if ! [ -e "${OVE_OWEL_DIR}/projects/${proj_name}/${proj_command}" ]; then
		return
	fi

	i=${ove_projects_name2index[${proj_name}]}
	path="${ove_projects_path[${i}]}"

	# create dir if needed
	if [ ! -d "${path}" ]; then
		if ! ${ove_cmd2pathname["mkdir"]:?} -vp "${path}"; then
			ove_echo_warning_noprefix "${proj_name}: ${proj_command}: 'mkdir -vp ${path}' failed"
		fi
	fi

	if [ "${OVE_DRY_RUN}" -eq 0 ]; then
		if ! pushd "${path}" &>/dev/null; then
			ove_echo_error_noprefix "${proj_name}: ${proj_command}: pushd '${path}' failed"
			return 1
		fi
	fi

	if [ ${OVE_LOGLEVEL} -ne 0 ]; then
		ove_echo_cyan_error "${proj_name}: ${proj_command}"
	fi

	if [ "x${OVE_FORCE_SERIALIZE_COMMANDS}" != "x" ]; then
		re=\\b${proj_command}\\b
		if [[ "${OVE_FORCE_SERIALIZE_COMMANDS}" =~ ${re} ]]; then
			with_flock=1
		fi
	fi

	if [ ${with_flock} -eq 1 ]; then
		(
			${ove_cmd2pathname["flock"]:?} ${fd}
			ove_projects_cmd_execute "$@"
			exit $?
		) {fd}>${OVE_OWEL_TMP_DIR}/.${proj_command}.lock
		ret=$?
	else
		ove_projects_cmd_execute "$@"
		ret=$?
	fi

	if [ "${OVE_DRY_RUN}" -eq 0 ]; then
		if ! popd &>/dev/null; then
			ove_echo_warning_noprefix "${proj_name}: ${proj_command}: popd failed"
		fi
	fi

	return "${ret}"
}

function ove_git_command_options_init {
	local k

	unset ove_revtab_git_cmd_opts
	declare -A -g ove_revtab_git_cmd_opts

	# default git command options
	ove_read_git_command_options

	# remember the default values
	unset ove_revtab_git_cmd_opts_default
	declare -A -g ove_revtab_git_cmd_opts_default
	for k in "${!ove_revtab_git_cmd_opts[@]}"; do
		ove_revtab_git_cmd_opts_default[$k]=${ove_revtab_git_cmd_opts[$k]}
	done

	# overrides?
	if [ "${OVE_GIT_COMMAND_OPTIONS_OVERRIDE}" != "x" ]; then
		OVE_GIT_COMMAND_OPTIONS_DEFAULT="${OVE_GIT_COMMAND_OPTIONS_OVERRIDE}" ove_read_git_command_options
	fi

	return 0
}

function ove_read_git_command_options {
	local cmd
	local cmd_opt
	local i
	local o
	local re
	local re_cmd
	local repo
	declare -A pattern
	declare -a opt

	if [ "x${OVE_GIT_COMMAND_OPTIONS_DEFAULT}" != "x" ]; then
		while IFS=';' read -a opt -r; do
			for o in "${opt[@]}"; do
				if [[ ! $o == *:* ]] || [[ ! $o == *@* ]]; then
					ove_echo_error_noprefix "format error: '$o'"
					continue
				fi
				re=${o%%:*}
				re=${re%@*}

				if [ "$re" = ".*" ]; then
					cmd=${o%%:*}
					cmd=${cmd#*@}
					cmd_opt=${o#*:}
					ove_revtab_git_cmd_opts["*:${cmd}"]="${cmd_opt}"
					continue
				fi
				re=\\b$re\\b

				if [[ ! "${ove_revtab_git_name[*]} $OVE_OWEL_NAME" =~ $re ]]; then
					continue
				fi

				# at least one repo match this pattern, remember the pattern
				cmd=${o%%:*}
				cmd=${cmd#*@}
				cmd_opt=${o#*:}
				pattern["$re:$cmd"]="$cmd_opt"
			done
		done <<<"${OVE_GIT_COMMAND_OPTIONS_DEFAULT}"

		for re_cmd in "${!pattern[@]}"; do
			for repo in ${ove_revtab_git_name[*]} $OVE_OWEL_NAME; do
				re=${re_cmd%%:*}
				if [[ ! $repo =~ $re ]]; then
					continue
				fi
				cmd=${re_cmd#*:}
				cmd_opt=${pattern[$re_cmd]}
				if [ "x${cmd_opt}" = "x" ]; then
					continue
				fi
				ove_revtab_git_cmd_opts["${repo//\./}:${cmd}"]="${cmd_opt}"
			done
		done
	fi
}

# list-git-command-options: :list git command options (d=default, o=override):CORE
function ove-list-git-command-options {
	ove_entry || return

	local k
	local s

	for k in ${!ove_revtab_git_cmd_opts[*]}; do
		s="d"
		if [ "${ove_revtab_git_cmd_opts[$k]}" != "${ove_revtab_git_cmd_opts_default[$k]}" ]; then
			s="o"
		fi
		echo "${s}:${k}:${ove_revtab_git_cmd_opts[$k]}"
	done | ${ove_cmd2pathname["column"]:?} -t -s: | \
		LC_ALL="C" ${ove_cmd2pathname["sort"]:?}
}

function ove_revtab_init {
	local array
	local line
	local lineno=0

	unset ove_revtab_fetch_url
	unset ove_revtab_push_url
	unset ove_revtab_rev
	unset ove_revtab_git_name
	unset ove_revtab_name2index
	ove_revtab_num_repositories=0

	if [ ! -e "${OVE_OWEL_DIR}/revtab" ]; then
		OVE_REPO_LIST="${OVE_OWEL_DIR}"
		OVE_REPO_LIST_WIDTH="${#OVE_OWEL_NAME}"
		((OVE_REPO_LIST_WIDTH+=2))
		return
	fi

	if ! ove_revtab_validate; then
		return 1
	fi

	declare -a -g ove_revtab_fetch_url
	declare -a -g ove_revtab_push_url
	declare -a -g ove_revtab_rev
	declare -a -g ove_revtab_git_name
	declare -A -g ove_revtab_name2index

	OVE_REPO_LIST_WIDTH="${#OVE_OWEL_NAME}"
	while read -r line; do
		(( lineno+=1 ))
		# skip comments and blank lines
		[ "${line:0:1}" == "#" ] && continue
		[ "${line}" == "" ] && continue

		read -a array -r <<<"${line}"

		if [ "${array[1]}" == "" ] || [ "${array[2]}" == "" ] || [ "${array[3]}" == "" ] || [ "${#array[*]}" -gt 4 ]; then
			ove_echo_warning_noprefix "${OVE_OWEL_DIR}/revtab:${lineno} format error"
			continue
		fi

		if [ "${array[0]}" == "${OVE_OWEL_NAME}" ]; then
			ove_echo_error_noprefix "${OVE_OWEL_DIR}/revtab:${lineno}: name violation"
			return 1
		fi

		ove_revtab_git_name[${ove_revtab_num_repositories}]=${array[0]}
		ove_revtab_fetch_url[${ove_revtab_num_repositories}]=${array[1]}
		ove_revtab_push_url[${ove_revtab_num_repositories}]=${array[2]}
		ove_revtab_rev[${ove_revtab_num_repositories}]=${array[3]}
		ove_revtab_name2index[${array[0]}]=${ove_revtab_num_repositories}
		if ! [ -e "${OVE_OWEL_TMP_DIR}/.${ove_revtab_num_repositories}.lock" ]; then
			true > "${OVE_OWEL_TMP_DIR}/.${ove_revtab_num_repositories}.lock"
		fi

		if [ $OVE_REPO_LIST_WIDTH -lt ${#ove_revtab_git_name[${ove_revtab_num_repositories}]} ]; then
			OVE_REPO_LIST_WIDTH=${#ove_revtab_git_name[${ove_revtab_num_repositories}]}
		fi
		(( ove_revtab_num_repositories+=1 ))
	done < "${OVE_OWEL_DIR}/revtab"
	((OVE_REPO_LIST_WIDTH+=2))

	if ! [ -e "${OVE_OWEL_TMP_DIR}/.owel.lock" ]; then
		true > "${OVE_OWEL_TMP_DIR}/.owel.lock"
	fi

	# OVE_REPO_LIST:space separated list of all git repositories for one OVE workspace
	OVE_REPO_LIST=$(ove_revtab_list_fullpath)
	export OVE_REPO_LIST
}

# $1: repo name (either 'name' or '${OVE_BASE_DIR}/'name')
function ove_repo2fullpath {
	local i
	local name
	local repo_fullpath

	name=${1/${OVE_BASE_DIR}\/}
	if [ "${name}" == "${OVE_OWEL_NAME}" ]; then
		repo_fullpath="${OVE_BASE_DIR}/${OVE_OWEL_NAME}"
	elif [ -v ove_revtab_name2index[${name}] ]; then
		i=${ove_revtab_name2index[${name}]}
		repo_fullpath="${OVE_BASE_DIR}/${ove_revtab_git_name[${i}]}"
	fi

	echo ${repo_fullpath}
}

# $1: repo name (either 'name' or '${OVE_BASE_DIR}/'name')
function ove_repo2shortpath {
	local i
	local name
	local repo_shortpath

	[ $# -ne 1 ] && return 1

	name=${1/${OVE_BASE_DIR}\/}
	if [ "${name}" == "${OVE_OWEL_NAME}" ]; then
		repo_shortpath="${OVE_OWEL_NAME}"
	elif [ -v ove_revtab_name2index[${name}] ]; then
		i=${ove_revtab_name2index[${name}]}
		repo_shortpath="${ove_revtab_git_name[${i}]}"
	fi

	echo ${repo_shortpath}
}

# $1: repo name (either 'name' or '${OVE_BASE_DIR}/'name')
function ove_repo2index {
	local i
	local name

	[ $# -ne 1 ] && return 1

	name=${1/${OVE_BASE_DIR}\/}
	if [ "${name}" == "${OVE_OWEL_NAME}" ]; then
		echo "${OVE_OWEL_NAME}"
	elif [ -v ove_revtab_name2index[${name}] ]; then
		i=${ove_revtab_name2index[${name}]}
		echo ${i}
	fi
}

# $1: repo
function ove_status_one_repo {
	local git_opt
	local i
	local len
	local m
	local override=0
	local repo_fullpath
	local repo_shortpath
	local revision
	local s

	[ $# -ne 1 ] && return 1

	repo_fullpath=$(ove_repo2fullpath $1)
	if [ "${repo_fullpath}" == "" ] || ! [ -d "${repo_fullpath}" ] || ! [ -e "${repo_fullpath}"/.git ]; then
		return
	fi

	repo_shortpath="$(ove_repo2shortpath $1)"

	if [ "${repo_shortpath}" == "${OVE_OWEL_NAME}" ]; then
		revision="$(ove_repo_cmd "${OVE_OWEL_DIR}" "describe" --tags --always 2> /dev/null)"
		[ -n "${revision}" ] || revision=" "
	else
		i=${ove_revtab_name2index[${repo_shortpath}]}
		revision="${ove_revtab_rev[${i}]}"
	fi

	# only allow overrides from 'ove-status'
	if [ ${FUNCNAME[-1]} = "ove-status" ]; then
		override=1
	elif [ ! -v ove_revtab_git_cmd_opts_default ]; then
		git_opt="-bs -uno"
	else
		git_opt=${ove_revtab_git_cmd_opts_default['*:status']}
	fi

	if ! s=$(ALLOW_OVERRIDE=${override} ove_repo_cmd "${repo_fullpath}" "${OVE_GIT_OPTIONS} -c color.status=always status" ${git_opt} 2> /dev/null); then
		s="$(ove_echo_red_noprefix '??')"
	else
		len=${#s}
		if [ ${OVE_STATUS_TRUNC:?} -eq 1 ] && [ "x$OVE_COLUMNS" != "x" ] && [ ${len} -gt $((OVE_COLUMNS*OVE_LINES)) ]; then
			m="$((OVE_COLUMNS*$((OVE_LINES/2 - 1))))"
			s="${s:0:${m}} $(ove_echo_yellow_noprefix ...truncated $((len-m*2)) chars...) ${s: -${m}}"
		fi
	fi
	printf "$(printf "%-$((OVE_REPO_LIST_WIDTH-2))s" ${repo_shortpath}):${revision}:$(printf "%s " $s)\n"
}

function ove_validate_repo_list {
	local out
	local repos

	while true; do
		[ $# -eq 0 ] && break
		if [[ "$1" == *[[:space:]]* ]]; then
			:
		elif [ "$1" == "${OVE_OWEL_NAME}" ] || [ -v ove_revtab_name2index[${1}] ]; then
			repos+="$(ove_repo2shortpath $1) "
		fi
		shift
	done

	if [ "x${repos}" = "x" ]; then
		return
	fi

	out=$(LC_ALL="C" ${ove_cmd2pathname["sort"]:?} -u < <(printf "%s\n" ${repos}))
	if [ "x${out}" != "x" ]; then
		echo ${out}
	fi
}

function ove_revtab_status {
	local f
	local files
	local i
	local repo
	local repos
	local o
	local p

	if [ $# -ge 1 ]; then
		repos=$(ove_validate_repo_list "$@")
	else
		repos=${OVE_REPO_LIST}
	fi

	if [ "x${repos}" = "x" ]; then
		return
	fi

	if [ -w "${OVE_OWEL_STATE_DIR}" ]; then
		f="${OVE_OWEL_STATE_DIR}"
	else
		f="${OVE_TMP}"
	fi
	o=${f}

	f+="/$(${ove_cmd2pathname["date"]:?} '+%Y%m%d-%H%M%S%N')-revtab-status"

	for repo in ${repos}; do
		i=${ove_revtab_name2index[${repo/${OVE_BASE_DIR}\//}]}
		ove_status_one_repo ${repo} > ${f}.${i} &
	done
	wait

	files=
	for repo in ${repos}; do
		i=${ove_revtab_name2index[${repo/${OVE_BASE_DIR}\//}]}
		files+="${f}.$i "
	done
	${ove_cmd2pathname["cat"]:?} ${files} > ${f}
	${ove_cmd2pathname["rm"]:?} ${files}

	LC_ALL="C" ${ove_cmd2pathname["sort"]:?} -o ${f} ${f}
	if [ "${OVE_COLUMN_WRAP_BUG}" -eq 1 ]; then
		${ove_cmd2pathname["column"]:?} -t -s: <<<"$(${ove_cmd2pathname["fold"]:?} -w 2048 -s ${f})"
	else
		${ove_cmd2pathname["column"]:?} -t -s: <${f}
	fi

	${ove_cmd2pathname["mv"]:?} "${f}" "${o}/revtab-status"
}

# $1: ahead|behind
function ove_revtab_status_parse_one {
	local branch_status
	local git_args
	local git_fmt
	local repo_fullpath
	local i
	local nbr_commits
	local tense

	tense=$1
	shift

	git_fmt='%<(15,trunc)%h?%<(15,trunc)%ar?%<(40,mtrunc)%ae?%s'
	repo_fullpath=$(ove_repo2fullpath $1)

	if [ "${repo_fullpath}" == "" ] || ! [ -d "${repo_fullpath}" ]; then
		return
	fi

	branch_status=$(ove_repo_cmd "${repo_fullpath}" "${OVE_GIT_OPTIONS} branch" -v | ${ove_cmd2pathname["grep"]:?} '^\*')
	nbr_commits=0

	# keep 'ahead X, behind Y'
	branch_status=${branch_status#*[}
	branch_status=${branch_status%%]*}

	if [[ "${branch_status}" == *"${tense}"* ]]; then
		if [ "${tense}" == "ahead" ]; then
			branch_status=${branch_status%%,*}
			nbr_commits=${branch_status##${tense} }
		elif [ "${tense}" == "behind" ]; then
			if ! ove_repo_cmd "${repo_fullpath}" "cat-file" -e "FETCH_HEAD" 2> /dev/null; then
				return 1
			fi
			nbr_commits=${branch_status##*${tense} }
			git_args="FETCH_HEAD"
		else
			return 1
		fi

		ove_echo_yellow_noprefix "$(ove_repo2shortpath $1): ${nbr_commits} new commit(s):"
		ove_repo_cmd "${repo_fullpath}" "--no-pager log" ${git_args} -n ${nbr_commits} --format="${git_fmt}" | \
			${ove_cmd2pathname["column"]:?} -t -s?
		echo
	fi
}

# $1   : ahead|behind
# $2...: optional list of repositories
function ove_revtab_status_parse {
	local repo
	local repos
	local tense

	[ $# -eq 0 ] && return 1

	tense="$1"
	shift

	# turn off monitor mode to get rid of "Done" messages
	set +m

	if [ $# -ge 1 ]; then
		repos=$(ove_validate_repo_list "$@")
	elif ove_any_repo ${tense}; then
		repos=$(ove_list_repositories ${tense})
	else
		return 0
	fi

	for repo in ${repos}; do
		ove_revtab_status_parse_one ${tense} ${repo}
	done | ${ove_cmd2pathname["head"]:?} -n -1

	# turn on monitor mode
	set -m
}

function ove_revtab_sanity {
	if [ "${ove_revtab_num_repositories}" -eq 0 ]; then
		return 1
	fi
}

function ove_repos_fetched {
	local f=0
	local repo

	for repo in ${OVE_REPO_LIST}; do
		[ -e ${repo}/.git ] && (( f+=1 ))
	done

	echo ${f}
}

function ove_verify_checksums {
	local cfgs
	local md5

	ove_externals_init

	# OVE_BASE_DIR got lost? keep this as early as possible
	if [ -z "${OVE_BASE_DIR+x}" ]; then
		return 1
	fi

	if [ ${OVE_REVTAB_CHECK} -eq 1 ]; then
		md5=$(ove_repos_fingerprint)
		# got updated?
		if [ -n "${OVE_REPOS_MD5+x}" ] && [ "${md5}" != "${OVE_REPOS_MD5}" ]; then
			return 1
		fi
	fi

	if [ -e "${OVE_OWEL_DIR}/revtab" ]; then
		md5=$(${ove_cmd2pathname["md5sum"]:?} ${OVE_OWEL_DIR}/revtab)
		md5=${md5%% *}
		# got updated?
		if [ -n "${OVE_REVTAB_MD5+x}" ] && [ "${md5}" != "${OVE_REVTAB_MD5}" ]; then
			return 1
		# just created?
		elif [ -z "${OVE_REVTAB_MD5+x}" ]; then
			return 1
		fi
	elif [ -n "${OVE_REVTAB_MD5+x}" ]; then
		# got removed?
		unset OVE_REVTAB_MD5
		return 1
	fi

	if [ -e "${OVE_OWEL_DIR}/projs" ]; then
		md5=$(${ove_cmd2pathname["md5sum"]:?} ${OVE_OWEL_DIR}/projs)
		md5=${md5%% *}
		# got updated?
		if [ -n "${OVE_PROJS_MD5+x}" ] && [ "${md5}" != "${OVE_PROJS_MD5}" ]; then
			return 1
		# just created?
		elif [ -z "${OVE_PROJS_MD5+x}" ]; then
			return 1
		fi
	elif [ -n "${OVE_PROJS_MD5+x}" ]; then
		# got removed?
		unset OVE_PROJS_MD5
		return 1
	fi

	read -r -a cfgs < <(ove_list_oveconfig_files_all)
	if [ "${#cfgs[@]}" -ne 0 ]; then
		md5=$(ove_file_fingerprint "${cfgs[@]}")
		# got updated?
		if [ -n "${OVE_CONFIG_MD5+x}" ] && [ "${md5}" != "${OVE_CONFIG_MD5}" ]; then
			return 1
		# just created?
		elif [ -z "${OVE_CONFIG_MD5+x}" ]; then
			return 1
		fi
	elif [ -n "${OVE_CONFIG_MD5+x}" ]; then
		# got removed?
		unset OVE_CONFIG_MD5
		return 1
	fi

	# ignore large files laying around in the scripts directories
	md5=$(HASH_SIZE_THRESHOLD=$OVE_HASH_SIZE_THRESHOLD_IN_BYTES ove_file_fingerprint $(ove_list_scripts_directories))
	# got updated?
	if [ -n "${OVE_SCRIPTS_CONTENT_MD5+x}" ] && [ "${md5}" != "${OVE_SCRIPTS_CONTENT_MD5}" ]; then
		return 1
	fi

	md5=$(ove-list-scripts | ${ove_cmd2pathname["md5sum"]:?})
	md5=${md5%% *}
	# got updated?
	if [ -n "${OVE_SCRIPTS_NAMES_MD5+x}" ] && [ "${md5}" != "${OVE_SCRIPTS_NAMES_MD5}" ]; then
		return 1
	fi

	md5=$(ove-list-hooks | ${ove_cmd2pathname["md5sum"]:?})
	md5=${md5%% *}
	# got updated?
	if [ -n "${OVE_HOOKS_NAMES_MD5+x}" ] && [ "${md5}" != "${OVE_HOOKS_NAMES_MD5}" ]; then
		return 1
	fi

	if [ "${OVE_REPOS_FETCHED}" != "" ] && [ $(ove_repos_fetched) -ne ${OVE_REPOS_FETCHED} ]; then
		return 1
	fi

	return 0
}

function ove_update_checksum_config {
	local cfgs

	read -r -a cfgs < <(ove_list_oveconfig_files_all)
	if [ ${#cfgs[@]} -ne 0 ]; then
		OVE_CONFIG_MD5=$(ove_file_fingerprint "${cfgs[@]}")
		export OVE_CONFIG_MD5
	fi
}

function ove_repos_fingerprint {
	local md5

	md5=$(ove-forall-parallel ${ove_cmd2pathname["stat"]:?} --format '%Y' .git/HEAD 2> /dev/null | LC_ALL="C" ${ove_cmd2pathname["sort"]:?} | ${ove_cmd2pathname["md5sum"]:?})
	md5=${md5%% *}
	echo "${md5}"
}

function ove_update_checksum {
	local md5

	if [ -e "${OVE_OWEL_DIR}/revtab" ]; then
		md5=$(${ove_cmd2pathname["md5sum"]:?} ${OVE_OWEL_DIR}/revtab)
		md5=${md5%% *}
		OVE_REVTAB_MD5=${md5}
		export OVE_REVTAB_MD5
	fi

	if [ -e "${OVE_OWEL_DIR}/projs" ]; then
		md5=$(${ove_cmd2pathname["md5sum"]:?} ${OVE_OWEL_DIR}/projs)
		md5=${md5%% *}
		OVE_PROJS_MD5=${md5}
		export OVE_PROJS_MD5
	fi

	ove_update_checksum_config

	if [ ${OVE_REVTAB_CHECK} -eq 1 ]; then
		OVE_REPOS_MD5=$(ove_repos_fingerprint)
		export OVE_REPOS_MD5
	fi

	# ignore large files laying around in the scripts directories
	OVE_SCRIPTS_CONTENT_MD5=$(HASH_SIZE_THRESHOLD=$OVE_HASH_SIZE_THRESHOLD_IN_BYTES ove_file_fingerprint "${!ove_scripts_paths[@]}")
	export OVE_SCRIPTS_CONTENT_MD5

	OVE_SCRIPTS_NAMES_MD5=$(ove-list-scripts | ${ove_cmd2pathname["md5sum"]:?})
	OVE_SCRIPTS_NAMES_MD5=${OVE_SCRIPTS_NAMES_MD5%% *}
	export OVE_SCRIPTS_NAMES_MD5

	OVE_HOOKS_NAMES_MD5=$(ove-list-hooks | ${ove_cmd2pathname["md5sum"]:?})
	OVE_HOOKS_NAMES_MD5=${OVE_HOOKS_NAMES_MD5%% *}
	export OVE_HOOKS_NAMES_MD5

	OVE_REPOS_FETCHED=$(ove_repos_fetched)
	export OVE_REPOS_FETCHED
}

# $1: name
# $2: fetch url
# $3: push url
function ove_revtab_check_fetch_push {
	local name
	local remote
	local remote_url
	local revtab_url

	name=$1
	[ -e "${OVE_BASE_DIR}/${name}/.git" ] || return

	# skip multiple remotes (for now)
	if [ $(ove_get_nbr_of_remotes "${OVE_BASE_DIR}/${name}") -gt 1 ]; then
		return
	elif ! remote=$(${ove_cmd2pathname["git"]:?} -C "${OVE_BASE_DIR}/${name}" remote 2> /dev/null); then
		return
	fi

	# fetch URL
	if ! remote_url=$(${ove_cmd2pathname["git"]:?} -C "${OVE_BASE_DIR}/${name}" "remote" get-url "${remote}" 2> /dev/null); then
		return
	fi
	revtab_url="$2"
	if [ "${remote_url}" != "${revtab_url}" ]; then
		ove_repo_cmd "${OVE_BASE_DIR}/${name}" "remote" set-url "${remote}" "${revtab_url}"
	fi

	# push URL
	if ! remote_url=$(${ove_cmd2pathname["git"]:?} -C "${OVE_BASE_DIR}/${name}" "remote" get-url --push "${remote}" 2> /dev/null); then
		return
	fi
	revtab_url="$3"
	if [ "${remote_url}" != "${revtab_url}" ]; then
		ove_repo_cmd "${OVE_BASE_DIR}/${name}" "remote" set-url --push "${remote}" "${revtab_url}"
	fi
}

# $1: name
# $2: fetch url
# $3: push url
# $4: rev
function ove_revtab_check_one {
	local branch_name
	local co=0
	local detached=0
	local name
	local rev_is_branch=0
	local revision
	local sha_a
	local sha_b

	name=$1
	[ -e "${OVE_BASE_DIR}/${name}/.git" ] || return

	revision=$4
	sha_a=$(${ove_cmd2pathname["git"]:?} -C ${OVE_BASE_DIR}/${name} rev-list -n 1 --abbrev-commit HEAD --)
	if ! sha_b=$(${ove_cmd2pathname["git"]:?} -C ${OVE_BASE_DIR}/${name} rev-list -n 1 --abbrev-commit ${revision} -- 2> /dev/null); then
		sha_b=""
	fi

	if [ "${sha_a}" != "${sha_b}" ]; then
		# diff => checkout
		co=1
	else
		if ! ${ove_cmd2pathname["git"]:?} -C "${OVE_BASE_DIR}/${name}" symbolic-ref -q HEAD > /dev/null; then
			detached=1
		fi

		if ${ove_cmd2pathname["git"]:?} -C ${OVE_BASE_DIR}/${name} show-ref -q --heads $revision; then
			rev_is_branch=1
		fi

		# detached and rev is a branch => checkout
		if [ ${detached} -eq 1 ] && [ ${rev_is_branch} -eq 1 ]; then
			co=1
		# not detached and rev is not a branch => checkout
		elif [ ${detached} -eq 0 ] && [ ${rev_is_branch} -eq 0 ]; then
			co=1
		# switched branch?
		elif [ ${detached} -eq 0 ] && [ ${rev_is_branch} -eq 1 ]; then
			branch_name=$(${ove_cmd2pathname["git"]:?} -C ${OVE_BASE_DIR}/${name} rev-parse --abbrev-ref HEAD)
			if [ "${branch_name}" != "${revision}" ]; then
				co=1
			fi
		fi
	fi

	if [ ${co} -eq 1 ]; then
		if ove_repo_is_dirty ${OVE_BASE_DIR}/${name}; then
			ove_echo_error_noprefix "${name}: cannot checkout '${revision}' as repo is dirty"
		else
			ove_revtab_checkout ${name}
		fi
	fi

	ove_revtab_check_fetch_push "$1" "$2" "$3"
}

# revtab-sync:[git...]:sync all/specified git repositories with 'revtab' (ignore OVE_REVTAB_CHECK):CORE
function ove-revtab-sync {
	ove_entry || return
	ove_revtab_sanity || return

	local i
	local r
	local repos

	if [ $# -eq 0 ]; then
		repos="${OVE_REPO_LIST}"
	else
		repos=$(ove_validate_repo_list "$@")
		if [ "x${repos}" = "x" ]; then
			echo "error: invalid repo name: '${*}'"
			return 1
		fi
	fi

	for r in ${repos}; do
		i=$(ove_repo2index ${r})
		if [ "$i" = "${OVE_OWEL_NAME}" ]; then
			continue
		fi
		ove_revtab_check_one \
			${ove_revtab_git_name[${i}]} \
			${ove_revtab_fetch_url[${i}]} \
			${ove_revtab_push_url[${i}]} \
			${ove_revtab_rev[${i}]} &
	done | ${ove_cmd2pathname["grep"]:?} -v '^\[' || true
	wait
}

function ove_revtab_check {
	ove_revtab_sanity || return

	local i
	local n=${FUNCNAME^^}

	[ -n "${!n}" ] && [ "${!n}" -eq 0 ] && return

	# turn off monitor mode to get rid of "Done" messages
	set +m

	i=0
	while ((i < ove_revtab_num_repositories)); do
		ove_revtab_check_one \
			${ove_revtab_git_name[${i}]} \
			${ove_revtab_fetch_url[${i}]} \
			${ove_revtab_push_url[${i}]} \
			${ove_revtab_rev[${i}]} &
		(( i+=1 ))
	done | ${ove_cmd2pathname["grep"]:?} -v '^\[' || true
	wait

	# turn on monitor mode
	set -m
}

function ove_revtab_list_fullpath {
	local repo
	local s

	for repo in "${ove_revtab_git_name[@]}"; do
		s+="${OVE_BASE_DIR}/${repo} "
	done
	s+="${OVE_OWEL_DIR}"

	echo ${s}
}

function ove_revtab_list_basename {
	local repo
	local s

	for repo in "${ove_revtab_git_name[@]}" ${OVE_OWEL_NAME}; do
		s+="${repo} "
	done

	echo ${s}
}

function ove_revtab_forall {
	local repo
	local repo_basename

	for repo in ${OVE_REPO_LIST}; do
		! [ -d "${repo}" ] && continue
		repo_basename=${repo/${OVE_BASE_DIR}\/}
		eval "pushd ${repo} &>/dev/null && $1; popd&>/dev/null"
	done
}

function ove_cap_jobs {
	local job_list

	if [ $# -ne 1 ] || [ $1 -eq 0 ]; then
		return
	fi

	mapfile -t job_list < <(jobs -p -r)
	[ "${#job_list[@]}" -ge "${1}" ] && wait -n
}

# $1: max_parallel
# $2: command
# $3: args
function ove_git_cmd_forall_parallel {
	(
	local cmd
	local max_parallel
	local repo
	local repo_basename

	max_parallel=$1
	shift
	cmd=$1
	shift

	for repo in ${OVE_REPO_LIST}; do
		! [ -d "${repo}" ] && continue
		repo_basename=${repo/${OVE_BASE_DIR}\/}
		ove_repo_cmd "$repo" "$cmd" "$@" | ${ove_cmd2pathname["sed"]:?} -e "s,^,${repo}/,g" &
		ove_cap_jobs ${max_parallel}
	done
	wait
	)
}

# $1: command
# $2: max number of jobs
function ove_revtab_forall_parallel {
	(
	local max_parallel=0
	local repo
	local repo_basename

	[ $# -eq 2 ] && max_parallel=$2

	for repo in ${OVE_REPO_LIST}; do
		! [ -d "${repo}" ] && continue
		repo_basename=${repo/${OVE_BASE_DIR}\/}
		pushd "${repo}" &>/dev/null && eval "$1" &
		ove_cap_jobs ${max_parallel}
	done
	wait
	)
}

function ove_revtab_forsome {
	local i
	local repo
	local repo_basename

	for i in ${*:2}; do
		for repo in ${OVE_REPO_LIST}; do
			! [ -d "${repo}" ] && continue
			if [ "${repo}" == "${OVE_BASE_DIR}/${i}" ]; then
				repo_basename=${repo/${OVE_BASE_DIR}\/}
				eval "pushd ${repo} &>/dev/null && $1; popd&>/dev/null"
			fi
		done
	done
}

# $1  : cmd
# $2  : max jobs
# $3..: repos
function ove_revtab_forsome_parallel {
	(
	local repo
	local i

	for i in ${*:3}; do
		for repo in ${OVE_REPO_LIST}; do
			! [ -d "${repo}" ] && continue
			if [ "${repo}" == "${OVE_BASE_DIR}/${i}" ]; then
				eval "pushd ${repo} &>/dev/null; $1; popd&>/dev/null" &
				ove_cap_jobs ${2}
			fi
		done
	done
	wait
	)
}

function ove_revtab_clone_and_checkout_one {
	local fetch_url
	local i=$1
	local name
	local push_url

	fetch_url="${ove_revtab_fetch_url[${i}]}"
	push_url="${ove_revtab_push_url[${i}]}"
	name="${ove_revtab_git_name[${i}]}"

	while true; do
		if ! ALLOW_OVERRIDE=1 ove_repo_cmd "${OVE_BASE_DIR}/${name}" clone "${fetch_url}" "${OVE_BASE_DIR}/${name}"; then
			return 1
		fi
		break
	done |& ${ove_cmd2pathname["sed"]:?} "s|^|$(printf "%-${OVE_REPO_LIST_WIDTH}s" ${name})|g"

	if [ ${PIPESTATUS[0]} -ne 0 ]; then
		ove_echo_error_noprefix "'git clone ${fetch_url} ${OVE_BASE_DIR}/${name}' failed"
		return 1
	fi

	ove_revtab_checkout "${name}"
	ove_revtab_check_fetch_push "${name}" "${fetch_url}" "${push_url}"
	ove_patch_repos ${name}

	if [ -e "${OVE_BASE_DIR}/${name}/.gitmodules" ]; then
		if [ ${OVE_FETCH_SUBMODULES} -eq 1 ]; then
			if ! ove-import-submodules ${name}; then
				return 1
			fi
		else
			printf "%-${OVE_REPO_LIST_WIDTH}s%s\n" ${name} "$(ove_echo_note_noprefix "run 'ove import-submodules ${name}' to import $(${ove_cmd2pathname["grep"]:?} -c '\[submodule' "${OVE_BASE_DIR}/${name}/.gitmodules") git submodule(s)")"
		fi
	fi

	return 0
}

# $*: optional list of repositories
function ove_revtab_clone_and_checkout {
	(
	ove_revtab_sanity || return

	local i
	local repo
	local repos

	if [ $# -gt 0 ]; then
		repos=$(ove_validate_repo_list "$@")
		[ "${repos}" == "" ] && return 1
		for repo in ${repos}; do
			if [ ! -d "${OVE_BASE_DIR}/${repo}" ] || \
				[ "x$(${ove_cmd2pathname["find"]:?} "${OVE_BASE_DIR}/${repo}/" -mindepth 1 -maxdepth 1)" = "x" ]; then
				i=${ove_revtab_name2index[${repo}]}
				ove_revtab_clone_and_checkout_one ${i} &
				ove_cap_jobs ${OVE_CLONE_MAX_PARALLEL}
			fi
		done
	else
		i=0
		while ((i < ove_revtab_num_repositories)); do
			if [ ! -d "${OVE_BASE_DIR}/${ove_revtab_git_name[${i}]}" ] || \
				[ "x$(${ove_cmd2pathname["find"]:?} "${OVE_BASE_DIR}/${ove_revtab_git_name[${i}]}/" -mindepth 1 -maxdepth 1)" = "x" ]; then

				ove_revtab_clone_and_checkout_one ${i} &
				ove_cap_jobs ${OVE_CLONE_MAX_PARALLEL}
			fi
			(( i+=1 ))
		done
	fi

	wait
	)
}

function ove_revtab_checkout_one {
	local name
	local revision

	name=${ove_revtab_git_name[${1}]}
	revision=${ove_revtab_rev[${1}]}
	while true; do
		if ! ove_repo_cmd "${OVE_BASE_DIR}/${name}" "-c advice.detachedHead=false checkout" "${revision}" "--"; then
			ove_echo_error_noprefix "checkout '${revision}' failed"
			return 1
		fi
		break
	done |& ${ove_cmd2pathname["sed"]:?} -e "s|^|$(printf "%-${OVE_REPO_LIST_WIDTH}s" ${name})|g"
}

# $*: optional list of repositories
function ove_revtab_checkout {
	(
	local i
	local repo
	local repos

	if [ $# -gt 0 ]; then
		repos=$(ove_validate_repo_list "$@")
		[ "${repos}" == "" ] && return 1
		for repo in ${repos}; do
			i=${ove_revtab_name2index[${repo}]}
			ove_revtab_checkout_one ${i} &
		done
	else
		i=0
		while ((i < ove_revtab_num_repositories)); do
			ove_revtab_checkout_one ${i} &
			(( i+=1 ))
		done
	fi

	wait
	)
}

# helper that will return 1 if git config email or name is not set
function ove_git_config_check {
	if [ "x$(${ove_cmd2pathname["git"]:?} config --global user.email)" = "x" ] || \
		[ "x$(${ove_cmd2pathname["git"]:?} config --global user.name)" = "x" ]; then
		return 1
	else
		return 0
	fi
}

function ove_revtab_pull_one {
	local base
	local loc
	local remote
	local repo
	local repo_fullpath
	local upstream

	repo="$1"
	upstream="@{u}"

	repo_fullpath=$(ove_repo2fullpath $1)
	if [ "${repo_fullpath}" == "" ] || ! [ -d "${repo_fullpath}" ]; then
		return
	fi

	# check if detached
	if ! ove_repo_cmd "${repo_fullpath}" "rev-parse" -q "${upstream}" &> /dev/null; then
		return
	fi

	loc=$(ove_repo_cmd "${repo_fullpath}" rev-parse @)
	remote=$(ove_repo_cmd "${repo_fullpath}" rev-parse "${upstream}")
	base=$(ove_repo_cmd "${repo_fullpath}" merge-base @ "${upstream}")

	if [ "${loc}" = "${remote}" ]; then
		# up-to-date
		:
	elif [ "${remote}" = "${base}" ]; then
		# need to push
		:
	else
		if [ "x$(ove_revtab_status_parse_one ahead ${repo})" != "x" ] && ! ove_git_config_check; then
			ove_echo_error_noprefix "not possible to 'git pull ${repo}' as git config user.email/user.name is not set"
			return 1
		fi

		ove_echo_yellow_noprefix "${repo}"
		if ! ALLOW_OVERRIDE=1 ove_repo_cmd ${repo_fullpath} pull; then
			ove_echo_error_noprefix "git -C ${repo_fullpath} pull failed"
		fi
	fi
}

# $1  : repo
# $2  : command
# $3..: arg
function ove_repo_cmd {
	local cmd
	local git_cmd
	local git_cmd_opt
	local name
	local i
	local repo

	repo=$1
	if [ "$2" != "clone" ] && [ "$2" != "ls-remote" ] && [ ! -e ${repo}/.git ]; then
		return 1
	fi

	i=$(ove_repo2index ${repo})
	shift
	git_cmd="${1##* }"

	if [ "x${ALLOW_OVERRIDE}" != "x" ] && [ "${ALLOW_OVERRIDE}" = "1" ]; then
		if [ "$i" = "${OVE_OWEL_NAME}" ]; then
			# get rid of some dots
			name=${OVE_OWEL_NAME//\./}
		else
			name=${ove_revtab_git_name[${i}]}
		fi

		if declare -p ove_revtab_git_cmd_opts &>/dev/null; then
			if [ "x${ove_revtab_git_cmd_opts["${name}:${git_cmd}"]}" != "x" ]; then
				git_cmd_opt="${ove_revtab_git_cmd_opts["${name}:${git_cmd}"]}"
			elif [ "x${ove_revtab_git_cmd_opts["*:${git_cmd}"]}" != "x" ]; then
				git_cmd_opt="${ove_revtab_git_cmd_opts["*:${git_cmd}"]}"
			fi
		fi
	fi

	# construct the git command
	if [ "${git_cmd}" = "clone" ] || [ "${git_cmd}" = "ls-remote" ]; then
		cmd="${ove_cmd2pathname["git"]:?} $1 ${git_cmd_opt}"
	else
		cmd="${ove_cmd2pathname["git"]:?} -C ${repo} $1 ${git_cmd_opt}"
	fi
	shift

	# run the git command
	if [ $# -eq 0 ]; then
		GIT_CEILING_DIRECTORIES="${OVE_BASE_DIR}" ${ove_cmd2pathname["flock"]:?} ${OVE_FLOCK_OPTIONS} -x "${OVE_OWEL_TMP_DIR}/.${i}.lock" -c "${cmd}"
	else
		GIT_CEILING_DIRECTORIES="${OVE_BASE_DIR}" ${ove_cmd2pathname["flock"]:?} ${OVE_FLOCK_OPTIONS} -x "${OVE_OWEL_TMP_DIR}/.${i}.lock" -c "${cmd} $(printf -- ' "%s"' "${@}")"
	fi
	return $?
}

# $*: optional list of repositories
function ove_revtab_fetch {
	local co_list
	local i
	local m

	if [ $# -ge 1 ]; then
		ove_revtab_clone_and_checkout "$@"
		m=${OVE_REPO_LIST_WIDTH}
		ove_revtab_forsome_parallel "ALLOW_OVERRIDE=1 ove_repo_cmd \${repo} fetch |& ${ove_cmd2pathname["sed"]:?} -e \"s|^|\${i}\$(printf \"%0.s \" \$(eval echo {1..\$((${m} - \${#i}))}))|g\"" ${OVE_FETCH_MAX_PARALLEL} "$@"
		return $?
	fi

	i=0
	while ((i < ove_revtab_num_repositories)); do
		if [ ! -e "${OVE_BASE_DIR}/${ove_revtab_git_name[${i}]}/.git" ]; then
			co_list+="${ove_revtab_git_name[${i}]} "
		fi
		(( i+=1 ))
	done

	if [ "x${co_list}" != "x" ]; then
		ove_revtab_clone_and_checkout ${co_list}
	fi

	m=${OVE_REPO_LIST_WIDTH}
	ove_revtab_forall_parallel "ALLOW_OVERRIDE=1 ove_repo_cmd \${repo} fetch |& ${ove_cmd2pathname["sed"]:?} -e \"s|^|\${repo_basename}\$(printf \"%0.s \" \$(eval echo {1..\$((${m} - \${#repo_basename}))}))|g\"" ${OVE_FETCH_MAX_PARALLEL}
	return $?
}

# $1: dir
function ove_is_base_dir {
	if [[ -L ${1}/ove && -L ${1}/.owel ]]; then
		return 0
	else
		return 1
	fi
}

function ove_get_base_dir {
	local s

	if ! pushd . > /dev/null; then
		return 1
	elif ! s=$(pwd -P); then
		return 1
	fi

	while [ "${s}" != "" ]; do
		if ove_is_base_dir "${s}"; then
			echo "${s}"
			break
		fi
		s=${s%/*}
	done

	if ! popd > /dev/null; then
		return 1
	fi

	# base directory found?
	if [ "${s}" == "" ]; then
		ove_echo_error_noprefix "not in an OVE workspace. Try 'ove cd'"
		return 1

	# First time? Do nothing
	elif [ -z "${OVE_BASE_DIR+x}" ]; then
		:

	# Have we moved to another OVE workspace? source that project
	elif [ "${s}" != "${OVE_BASE_DIR}" ] && [[ $- == *i* ]]; then
		if ! cd ${s}; then
			return 1
		elif ! . ove > /dev/null; then
			return 1
		elif ! cd -; then
			return 1
		fi
	fi
}

function ove_list_projects {
	local p

	if [ -f "${OVE_OWEL_DIR}"/projs ]; then
		p=$(printf '%s ' $(${ove_cmd2pathname["grep"]:?} -o '^[a-zA-Z0-9_]\+' ${OVE_OWEL_DIR}/projs | \
			LC_ALL="C" ${ove_cmd2pathname["sort"]:?}))
		echo ${p::-1}
	fi
}

# $*: file(s)
function ove_file_md5sum {
	local args

	if [ $# -eq 0 ]; then
		return 1
	elif command -v md5deep > /dev/null; then
		if [ "x${HASH_SIZE_THRESHOLD}" != "x" ]; then
			args="-i ${HASH_SIZE_THRESHOLD}b"
		fi

		${ove_cmd2pathname["md5deep"]:?} ${args} -s -o f -r "${@}"
	else
		if [ "x${HASH_SIZE_THRESHOLD}" != "x" ]; then
			args="-size ${HASH_SIZE_THRESHOLD}c"
		fi

		${ove_cmd2pathname["find"]:?} "${@}" ${args} -type f -print0 | ${ove_cmd2pathname["xargs"]:?} -0 ${ove_cmd2pathname["md5sum"]:?}
	fi
}

# $*: file(s)
function ove_file_fingerprint {
	local md5

	[ $# -eq 0 ] && return 1

	if [ -n "${OVE_DRY_RUN+x}" ] && [ "${OVE_DRY_RUN}" -eq 1 ]; then
		echo
		return
	fi

	# shellcheck disable=SC2016
	md5=$(ove_file_md5sum "${@}" | \
		${ove_cmd2pathname["awk"]:?} '{print $1}' | \
		LC_ALL="C" ${ove_cmd2pathname["sort"]:?} | \
		${ove_cmd2pathname["md5sum"]:?})
	echo ${md5%% *}
}

# make:[project[-nodeps]]:build project(s):BUILD
function ove-make {
	ove_entry || return

	local fingerprint_a
	local fingerprint_b
	local i
	local proj
	local stage_dir_updated_by
	local target

	if [ $# -gt 1 ]; then
		ove_command_usage
		return 1
	fi

	target="$1"
	if [[ "$(caller 0)" != *"ove-make"* ]]; then
		if ! ove_build_pre ${target%-nodeps}; then
			return 1
		fi
		trap ove_build_post EXIT
	fi

	# build all?
	if [ $# -eq 0 ]; then
		for proj in ${OVE_BUILD_ORDER}; do
			i=${ove_projects_name2index[${proj}]}

			# does proj have any dependencies?
			if [ "${ove_projects_deps[${i}]}" != "" ]; then
				# check if some of the deps has modified the stage dir
				for dep in ${ove_projects_deps[${i}]}; do
					if [[ "${stage_dir_updated_by}" == *"${dep}"* ]]; then
						if ! ove_projects_cmd "${proj}" clean; then
							return 1
						fi
						break
					fi
				done
			fi

			if [ -e "${OVE_OWEL_DIR}/projects/${proj}/build" ]; then
				if ! ove_projects_cmd "${proj}" build; then
					return 1
				fi
			fi

			if [ -e "${OVE_OWEL_DIR}/projects/${proj}/install" ]; then
				fingerprint_a=$(ove_file_fingerprint ${OVE_STAGE_DIR})
				if ! ove_projects_cmd "${proj}" install; then
					return 1
				fi
				fingerprint_b=$(ove_file_fingerprint ${OVE_STAGE_DIR})

				# remember if project modified the stage dir
				if [ "${fingerprint_a}" != "${fingerprint_b}" ]; then
					stage_dir_updated_by+="${proj} "
				fi
			fi
		done

		return 0
	elif [[ ${target} == *-nodeps ]]; then
		target=${target%-nodeps}
		if ! ove_projects_cmd "${target}" build; then
			return 1
		fi

		if ! ove_projects_cmd "${target}" install; then
			return 1
		fi

		return 0
	fi

	if [[ "$(caller 0)" != *"ove-make"* ]]; then
		# keep track of projects built
		_ove_projects_built=""
	fi

	if ! [[ -v ove_projects_name2index[${target}] ]]; then
		ove_echo_error_noprefix "unknown target '${target}'"
		return 1
	fi

	i=${ove_projects_name2index[${target}]}
	# has deps?
	if [ "${ove_projects_deps[${i}]}" != "" ]; then
		if [ -e "${OVE_OWEL_DIR}/projects/${target}/clean" ]; then
			fingerprint_a=$(ove_file_fingerprint ${OVE_STAGE_DIR})
		fi

		for dep in ${ove_projects_deps[${i}]}; do
			if ! [[ -v ove_projects_name2index[${dep}] ]]; then
				ove_echo_yellow_noprefix "warning: project '${dep}' not found, skipping"
				continue
			fi

			# already built? next!
			if [[ "${_ove_projects_built}" == *"${dep}"* ]]; then
				continue
			fi

			if ! ove-make "${dep}"; then
				return 1
			fi
		done

		if [ -e "${OVE_OWEL_DIR}/projects/${target}/clean" ]; then
			fingerprint_b=$(ove_file_fingerprint ${OVE_STAGE_DIR})
			# clean the project if OVE_STAGE_DIR was updated
			if [ "${fingerprint_a}" != "${fingerprint_b}" ]; then
				if ! ove_projects_cmd "${target}" clean; then
					return 1
				fi
			fi
		fi
	fi

	if ! ove_projects_cmd "${target}" build; then
		return 1
	fi

	if ! ove_projects_cmd "${target}" install; then
		return 1
	fi

	# remember projects built
	_ove_projects_built+="${target} "

	# cleanup
	if [[ "$(caller 0)" != *"ove-make"* ]]; then
		unset _ove_projects_built
	fi
}

# list-projects:[project...|tag...]:list projects:CORE
function ove-list-projects {
	ove_entry || return

	local f_basename
	local f
	local p
	local proj_list
	local projects

	if [ $# -eq 0 ]; then
		if [ "x${OVE_PROJECT_LIST}" != "x" ]; then
			printf "%s\n" ${OVE_PROJECT_LIST}
		fi
		return 0
	fi

	if ! proj_list=$(ove_validate_project_list "$@"); then
		return 1
	fi

	projects="$(ove_get_build_list ${proj_list})"
	for p in ${projects}; do
		# ignore projects without a project directory
		[ ! -d "${OVE_OWEL_DIR}"/projects/${p} ] && continue

		ove_echo_cyan_noprefix "${p}"
		for f in bootstrap configure build install clean; do
			[ -x ${OVE_OWEL_DIR}/projects/${p}/${f} ] || continue
			echo -e "\t${f}"
			${ove_cmd2pathname["sed"]:?} -e 's|^|\t\t|g' <${OVE_OWEL_DIR}/projects/${p}/${f}
		done

		while read -r line; do
			f_basename=${line##*/}
			[[ "bootstrap configure build install clean" =~ ${f_basename} ]] && continue
			echo -e "\t${f_basename}"
			${ove_cmd2pathname["sed"]:?} -e 's|^|\t\t|g' <${OVE_OWEL_DIR}/projects/${p}/${f_basename}
		done < <(${ove_cmd2pathname["find"]:?} "${OVE_OWEL_DIR}"/projects/${p} -perm -u=x -type f)
		echo
	done | ${ove_cmd2pathname["head"]:?} -n -1

	return 0
}

# digraph: :create a DOT directed graph for all projects:CORE
function ove-digraph {
	ove_entry || return

	local i

	[ ${ove_number_of_projects} -eq 0 ] && return

	echo "digraph $(${ove_cmd2pathname["tr"]:?} '-' '_' <<<"${OVE_OWEL_NAME}") {"

	i=0
	while ((i < ove_number_of_projects)); do
		if [ "${ove_projects_deps[${i}]}" != "" ]; then
			for d in ${ove_projects_deps[${i}]}; do
				echo "    ${ove_projects_name[${i}]} -> ${d};"
			done
		else
			echo "    ${ove_projects_name[${i}]};"
		fi
		(( i+=1 ))
	done

	echo "}"
}

function ove_build_topology {
	local i

	i=0
	while ((i < ove_number_of_projects)); do
		if [ "${ove_projects_deps[${i}]}" != "" ]; then
			for d in ${ove_projects_deps[${i}]}; do
				[[ -v ove_projects_name2index[${d}] ]] || continue
				echo "${ove_projects_name[${i}]} ${d}"
			done
		fi
		(( i+=1 ))
	done | ${ove_cmd2pathname["tsort"]:?} | ${ove_cmd2pathname["tac"]:?} | ${ove_cmd2pathname["xargs"]:?}
}

# build-order: :show build order:BUILD
function ove-build-order {
	ove_entry || return

	local autonomous_projs
	local topology

	[ ${ove_number_of_projects} -eq 0 ] && return

	# just a bunch of projects without deps?
	if [ "$(ove_list_projects_with_deps)" == "" ]; then
		ove_list_projects_without_deps
		return
	fi

	topology=$(ove_build_topology)
	autonomous_projs=$(LC_ALL="C" ${ove_cmd2pathname["comm"]:?} -3 \
		<(printf "%s\n" ${OVE_PROJECT_LIST}) \
		<(${ove_cmd2pathname["tr"]:?} ' ' '\n' <<<"${topology}" | LC_ALL="C" ${ove_cmd2pathname["sort"]:?}))

	echo ${autonomous_projs} ${topology}
}

# forowel:command:run 'command' for all OVE workspaces on this host:CORE
function ove-forowel {
	ove_entry || return

	local cmd
	local i
	local projs

	if [ $# -eq 0 ]; then
		ove_command_usage
		return 1
	fi

	i=0
	mapfile -t projs < <(ove_list_workspaces_full)
	while ((i < ${#projs[@]})); do
		cmd+=$(printf "
			echo '# %s'
			cd %s
			ove_init
			$*
			" $(ove_echo_green_noprefix ${projs[i]##*/}) ${projs[i]})
		(( i+=1 ))
	done
	eval "${cmd}"
}

# forowel-parallel:command:run 'command' in parallel for all OVE workspaces on this host:CORE
function ove-forowel-parallel {
	ove_entry || return

	local cmd
	local i
	local projs

	if [ $# -eq 0 ]; then
		ove_command_usage
		return 1
	fi

	i=0
	mapfile -t projs < <(ove_list_workspaces_full)
	while ((i < ${#projs[@]})); do
		cmd=$(printf "
			cd %s
			ove_init
			$*
			" ${projs[i]})
		(( i+=1 ))
		{
			eval "${cmd}"
		} &
	done
	wait
}

# forall:command:run 'command' for all git repositories:CORE
function ove-forall {
	ove_entry || return

	if [ $# -eq 0 ]; then
		ove_command_usage
		return 1
	fi

	ove_revtab_forall "$*"
}

# forall-parallel:command:run 'command' in parallel for all git repositories:CORE
function ove-forall-parallel {
	ove_entry || return

	if [ $# -eq 0 ]; then
		ove_command_usage
		return 1
	fi

	ove_revtab_forall_parallel "$*"
}

# list systest groups helper
function ove_list_systests_groups {
	if [ -e ${OVE_OWEL_DIR}/systests-groups ]; then
		${ove_cmd2pathname["grep"]:?} : "${OVE_OWEL_DIR}"/systests-groups | \
			${ove_cmd2pathname["sed"]:?} -e 's,[[:space:]],,g' -e 's,^-,,g' -e 's,:$,,g'
	fi
}

# list-systests: :list available system tests:TEST
function ove-list-systests {
	ove_entry || return

	! [ -e ${OVE_OWEL_DIR}/systests ] && return
	(
	# shellcheck disable=SC2016
	${ove_cmd2pathname["grep"]:?} -E -v '^$|^\s*#|.*:|^#.*' "${OVE_OWEL_DIR}"/systests | \
		${ove_cmd2pathname["awk"]:?} '{print $1}'
	ove-list-systests-aliases
	ove_list_systests_groups
	) | LC_ALL="C" ${ove_cmd2pathname["sort"]:?}
}

# list-systests-aliases: :list available system test aliases:TEST
function ove-list-systests-aliases {
	ove_entry || return

	! [ -e ${OVE_OWEL_DIR}/systests ] && return

	# shellcheck disable=SC2016
	${ove_cmd2pathname["awk"]:?} '{print $1}' "${OVE_OWEL_DIR}"/systests | \
		${ove_cmd2pathname["grep"]:?} : | \
		${ove_cmd2pathname["grep"]:?} -v '#' | \
		${ove_cmd2pathname["cut"]:?} -d: -f1 | \
		LC_ALL="C" ${ove_cmd2pathname["sort"]:?}
}

# list-hooks: :list available hooks:CORE
function ove-list-hooks {
	ove_entry || return

	local p
	local repo

	# project hooks
	if [ -d "${OVE_OWEL_DIR}/hooks" ]; then
		p+="${OVE_OWEL_DIR}/hooks "
	fi

	# repo hooks
	for repo in $(ove_revtab_list_fullpath); do
		if ! [ -d "${repo}/.ove/hooks" ]; then
			continue
		fi
		p+="${repo}/.ove/hooks "
	done

	if [ "${p}" != "" ]; then
		${ove_cmd2pathname["find"]:?} -L ${p} -perm -u=x -type f -not -size 0 | LC_ALL="C" ${ove_cmd2pathname["sort"]:?}
	fi

	return 0
}

# list-scripts: :list available scripts:CORE
function ove-list-scripts {
	ove_entry || return

	local p
	local repo

	while true; do
		# project scripts
		if [ -d "${OVE_OWEL_DIR}/scripts" ]; then
			${ove_cmd2pathname["find"]:?} ${OVE_OWEL_DIR}/scripts -perm -u=x -not -name '*.help' -type f
		fi

		# OVE scripts
		if [ -d "${OVE_DIR}/scripts" ]; then
			${ove_cmd2pathname["find"]:?} ${OVE_DIR}/scripts -perm -u=x -not -name '*.help' -type f
		fi

		# repo scripts
		for repo in $(ove_revtab_list_fullpath); do
			! [ -d "${repo}/.ove/scripts" ] && continue
			p+="${repo}/.ove/scripts "
		done
		[ "${p}" != "" ] && \
			${ove_cmd2pathname["find"]:?} -L ${p} -perm -u=x -not -name '*.help' -type f

		break
	done | LC_ALL="C" ${ove_cmd2pathname["sort"]:?}

	return 0
}

function ove_list_scripts_directories {
	local d
	local repo

	# project scripts
	[ -d "${OVE_OWEL_DIR}/scripts" ] && d+="${OVE_OWEL_DIR}/scripts "
	# OVE scripts
	[ -d "${OVE_DIR}/scripts" ] && d+="${OVE_DIR}/scripts "
	# repo scripts
	for repo in ${OVE_REPO_LIST}; do
		[ -d "${repo}/.ove/scripts" ] || continue
		d+="${repo}/.ove/scripts "
	done

	if [ "x${d}" = "x" ]; then
		return
	fi

	${ove_cmd2pathname["find"]:?} -L ${d} -perm -u=x -not -name '*.help' -type f -print0 | \
		${ove_cmd2pathname["xargs"]:?} -0 dirname | \
		LC_ALL="C" ${ove_cmd2pathname["sort"]:?} -u
}

function ove_echo {
	local diff
	local diff_ns
	local diff_s
	local now
	local now_ns
	local now_s

	diff="00:00:00"
	diff_ns="000000000"

	now=$(${ove_cmd2pathname["date"]:?} +%s:%N)
	now_s=${now%:*}
	now_ns=${now#*:}
	# remove leading zeros
	now_ns=$((10#${now_ns}))

	if [ "${OVE_PREV_S}" != "" ]; then
		diff_ns="$((now_ns - OVE_PREV_NS))"
		diff_s=$((now_s - OVE_PREV_S))
		if [ "${diff_ns}" -lt 0 ]; then
			(( diff_s-=1 )) || true
			diff_ns="$((1000000000 + diff_ns))"
		fi

		# shellcheck disable=SC2016
		diff="$(${ove_cmd2pathname["awk"]:?} '{printf "%02d:%02d:%02d\n", int($1/3600),int(($1%3600)/60),int($1%60)}' <<<"${diff_s}")"
	fi

	echo -e "$(${ove_cmd2pathname["date"]:?} -d @${now_s} +'%Y-%m-%d %H:%M:%S').$(printf "%09d" ${now_ns}) (+${diff}:$(printf "%09d" ${diff_ns})):$*"

	OVE_PREV_S=${now_s}
	OVE_PREV_NS=${now_ns}
}

# echo:[green|cyan|yellow|red|error] txt:prefix echo with date and time diff:CORE
function ove-echo {
	ove_entry || return

	local f

	if [ $# -eq 0 ]; then
		ove_command_usage
		return 1
	fi

	if [ "$(type -t ove_echo_$1)" == "function" ]; then
		if [ $# -eq 1 ]; then
			ove_command_usage
			return 1
		fi
		f="ove_echo_$1"
		shift
		$f "$@"
	else
		ove_echo "$@"
	fi
}

# list-colors: :list OVE colors:CORE
function ove-list-colors {
	local c
	local j
	local s
	local v

	for c in green yellow red cyan blue; do
		v="OVE_COLOR_${c^^}"
		echo "$c ${!v}"
		s=
		for j in $(${ove_cmd2pathname["seq"]:?} 1 $((OVE_COLUMNS/2))); do
			if [ $((j%3)) -eq 0 ]; then
				s+="E "
			elif [ $((j%3)) -eq 1 ]; then
				s+="O "
			elif [ $((j%3)) -eq 2 ]; then
				s+="V "
			fi
		done
		ove_echo_${c}_noprefix "$s"
	done
}

function ove_echo_cyan {
	ove_echo "${OVE_COLOR_CYAN}""$*""${OVE_COLOR_BLANK}"
}

function ove_echo_cyan_error {
	ove_echo "${OVE_COLOR_CYAN}""$*""${OVE_COLOR_BLANK}" 1>&2;
}

function ove_echo_cyan_error_noprefix {
	echo -e "${OVE_COLOR_CYAN}""$*""${OVE_COLOR_BLANK}" 1>&2;
}

function ove_echo_yellow {
	ove_echo "${OVE_COLOR_YELLOW}""$*""${OVE_COLOR_BLANK}"
}

function ove_echo_blue {
	ove_echo "${OVE_COLOR_BLUE}""$*""${OVE_COLOR_BLANK}"
}

function ove_echo_green {
	ove_echo "${OVE_COLOR_GREEN}""$*""${OVE_COLOR_BLANK}"
}

function ove_echo_green_noprefix {
	echo -e "${OVE_COLOR_GREEN}""$*""${OVE_COLOR_BLANK}"
}

function ove_echo_red {
	ove_echo "${OVE_COLOR_RED}""$*""${OVE_COLOR_BLANK}"
}

function ove_echo_red_noprefix {
	echo -e "${OVE_COLOR_RED}""$*""${OVE_COLOR_BLANK}"
}

function ove_echo_yellow_noprefix {
	echo -e "${OVE_COLOR_YELLOW}""$*""${OVE_COLOR_BLANK}"
}

function ove_echo_blue_noprefix {
	echo -e "${OVE_COLOR_BLUE}""$*""${OVE_COLOR_BLANK}"
}

function ove_echo_warning {
	ove_echo_yellow "warning: $*" 1>&2;
}

function ove_echo_cyan_noprefix {
	echo -e "${OVE_COLOR_CYAN}""$*""${OVE_COLOR_BLANK}"
}

function ove_echo_note_noprefix {
	echo -e "${OVE_COLOR_CYAN}NOTE:${OVE_COLOR_BLANK} $*"
}

function ove_echo_error {
	ove_echo_red "error: $*" 1>&2;
}

function ove_echo_error_noprefix {
	ove_echo_red_noprefix "error: $*" 1>&2;
}

function ove_echo_fatal_noprefix {
	ove_echo_red_noprefix "fatal: $*" 1>&2;
}

function ove_echo_warning_noprefix {
	ove_echo_yellow_noprefix "warning: $*" 1>&2;
}

function ove_echo_stderr {
	ove_echo "$@" 1>&2;
}

function ove_echo_stderr_noprefix {
	echo "$@" 1>&2;
}

function ove_command_not_found {
	local msg="command '$1' not found"

	[ $# -eq 2 ] && msg+=". $2"
	ove_echo_error_noprefix "${msg}"
}

function ove_systest_get_exit_status {
	local e

	if [ $# -eq 0 ]; then
		e="NA"
	elif [ ${1} -eq 124 ]; then
		e="TIMEOUT"
	elif [ ${1} -eq 126 ]; then
		e="PERMISSION_DENIED"
	elif [ ${1} -eq 127 ]; then
		e="CAN_NOT_FIND_CMD"
	elif [ ${1} -gt 128 ] && [ ${1} -lt 166 ]; then
		e="SIG$(kill -l ${1})"
	elif [ -e /usr/include/sysexits.h ] && \
		${ove_cmd2pathname["grep"]:?} -q "#define EX_[A-Z]\+.*\b${1}\b" /usr/include/sysexits.h; then
		e=$(${ove_cmd2pathname["grep"]:?} "#define EX_[A-Z]\+.*\b${1}\b" /usr/include/sysexits.h | \
			${ove_cmd2pathname["grep"]:?} -o 'EX_[A-Z]\+')
	elif [ -e ${OVE_OWEL_DIR}/${OVE_OWEL_NAME}-sysexits.h ] && \
		${ove_cmd2pathname["grep"]:?} -q "#define [A-Z0-9_]\+.*\b${1}$" ${OVE_OWEL_DIR}/${OVE_OWEL_NAME}-sysexits.h; then
		e=$(${ove_cmd2pathname["grep"]:?} "#define [A-Z0-9_]\+.*\b${1}$" ${OVE_OWEL_DIR}/${OVE_OWEL_NAME}-sysexits.h | \
			${ove_cmd2pathname["cut"]:?} -f1 | \
			${ove_cmd2pathname["cut"]:?} -d' ' -f2)

	else
		e="${1}"
	fi

	echo "${e}"
}

function ove_systest_cleanup {
	${ove_cmd2pathname["ps"]:?} -o pid= -s $$ | \
		${ove_cmd2pathname["grep"]:?} -v "$$" > $OVE_TMP/systest-pids
	if [ -s $OVE_TMP/systest-pids ]; then
		ove_kill_procs 1 0.1 $(${ove_cmd2pathname["cat"]:?} $OVE_TMP/systest-pids)
	fi
	${ove_cmd2pathname["rm"]:?} $OVE_TMP/systest-pids
}

function ove_systest_print_summary {
	local str
	local t

	for t in ${!systest2exit[*]}; do
		if [ ${systest2exit[$t]} -eq -3 ]; then
			printf "ove-systest:[%03d/%03d ${OVE_COLOR_RED}ABT${OVE_COLOR_BLANK}]:${systest2name[$t]}\n" ${t} ${nbr_of_systests}
		elif [ ${systest2exit[$t]} -eq -2 ]; then
			printf "ove-systest:[%03d/%03d ${OVE_COLOR_YELLOW}NOK${OVE_COLOR_BLANK} ENV]:${systest2name[$t]}\n" ${t} ${nbr_of_systests}
		elif [ ${systest2exit[$t]} -eq -1 ]; then
			printf "ove-systest:[%03d/%03d ${OVE_COLOR_BLUE}BG${OVE_COLOR_BLANK}]:${systest2name[$t]}\n" ${t} ${nbr_of_systests}
		elif [ ${systest2exit[$t]} -eq 0 ]; then
			printf "ove-systest:[%03d/%03d ${OVE_COLOR_GREEN}OK${OVE_COLOR_BLANK}]:${systest2name[$t]}\n" ${t} ${nbr_of_systests}
		else
			str=$(ove_systest_get_exit_status ${systest2exit[$t]})
			printf "ove-systest:[%03d/%03d ${OVE_COLOR_YELLOW}NOK${OVE_COLOR_BLANK} ${str}]:${systest2name[$t]}\n" ${t} ${nbr_of_systests}
		fi
	done | LC_ALL="C" ${ove_cmd2pathname["sort"]:?} -n
	echo
}

# systest:[test|group...]:run one or more system tests/groups described in ${OVE_OWEL_DIR}/systests-groups and ${OVE_OWEL_DIR}/systests:TEST
function ove-systest {
	ove_entry || return

	local all_done
	local exit_status
	local groups
	local i
	local match
	local nbr_of_systests
	local q
	local systest_alias
	local systest_bg
	local systest_cmd
	local systest_list
	local systest_list_tmp
	local systest_name
	local systest_path
	local systest_row
	local systest_timeout
	local systest_type
	local t
	local timeout_cmd
	local u

	[ -e ${OVE_OWEL_DIR}/systests ] || return 1

	if [ $# -eq 0 ]; then
		ove_command_usage
		return 1
	fi

	if ! [ -e ${OVE_OWEL_DIR}/systests-groups ]; then
		systest_list="$*"
	else
		groups=$(ove_list_systests_groups | LC_ALL="C" ${ove_cmd2pathname["sort"]:?})

		if [ "${groups}" == "" ]; then
			systest_list="$*"
		elif ! command -v python3 > /dev/null; then
			ove_echo_yellow_noprefix "python3 not found, not possible to launch 'yex'"
			systest_list="$*"
		else
			for systest_name in "$@"; do
				if ${ove_cmd2pathname["grep"]:?} -w -q ${systest_name} <<<"${groups}"; then
					systest_list+=" $(${OVE_DIR}/yex ${OVE_OWEL_DIR}/systests-groups -s -r --groups "${systest_name}")"
				else
					systest_list+=" ${systest_name}"
				fi
			done
		fi
	fi

	if [ "x${systest_list}" = "x" ]; then
		echo "error: no tests found"
		return 1
	fi

	# repeat?
	if [ -n "${OVE_SYSTEST_REPEAT+x}" ] && \
		[ "${OVE_SYSTEST_REPEAT}" -gt 1 ]; then

		for systest_name in ${systest_list}; do
			for q in $(${ove_cmd2pathname["seq"]:?} 1 ${OVE_SYSTEST_REPEAT}); do
				systest_list_tmp+=" ${systest_name}"
			done
		done

		systest_list=${systest_list_tmp}
	fi

	# skip tests
	if [ -n "${OVE_SYSTEST_SKIP+x}" ]; then
		# skip every X:th test?
		if [[ "${OVE_SYSTEST_SKIP}" =~ ^[0-9]+$ ]]; then
			if [ "${OVE_SYSTEST_SKIP}" -gt 1 ]; then
				i=0
				for systest_name in ${systest_list}; do
					if (( i % OVE_SYSTEST_SKIP == 0 )); then
						systest_list_tmp+=" ${systest_name}"
					fi
					(( i=i+1 ))
				done

				systest_list=${systest_list_tmp}
			fi
		else
			# skip specific tests
			systest_list=$(printf "%s\n" ${systest_list} | \
				${ove_cmd2pathname["grep"]:?} -v -f <(printf "%s\n" $OVE_SYSTEST_SKIP))
			if [ "x${systest_list}" = "x" ]; then
				echo "error: everything skipped, check config 'OVE_SYSTEST_SKIP'"
				return 1
			fi
		fi
	fi

	nbr_of_systests=$(${ove_cmd2pathname["wc"]:?} -w <<<"${systest_list}")
	if [ ${nbr_of_systests} -gt 1 ]; then
		echo "${FUNCNAME[0]}:Will run ${nbr_of_systests} test cases:"
		i=0
		for systest_name in ${systest_list}; do
			(( i=i+1 ))
			printf "${FUNCNAME[0]}:[%03d/%03d   ]:${systest_name}\n" ${i} ${nbr_of_systests}
		done
		echo
	fi

	# trap SIGINT to allow user to press CTRL+C
	trap true SIGINT

	i=0
	declare -A pids_db=()
	declare -a systest2name=()
	declare -a systest2abort=()
	declare -A systest2exit=()
	for systest_name in ${systest_list}; do
		(( i=i+1 ))

		# alias?
		match=$(${ove_cmd2pathname["grep"]:?} -c ^${systest_name}: "${OVE_OWEL_DIR}"/systests)
		if [ ${match} -eq 1 ]; then
			systest_alias="${systest_name}"
			systest_name=$(${ove_cmd2pathname["grep"]:?} ^${systest_name}: "${OVE_OWEL_DIR}"/systests | \
				${ove_cmd2pathname["cut"]:?} -d: -f2)

			if [ "x${systest_name}" = "x" ]; then
				ove_echo_error_noprefix "${FUNCNAME[0]}:alias '${systest_alias}' points to an empty systest"
				systest2exit[$i]=-2
				continue
			fi
		fi

		match=$(${ove_cmd2pathname["grep"]:?} -c -w ^${systest_name} "${OVE_OWEL_DIR}"/systests)
		if [ ${match} -eq 0 ]; then
			ove_echo_error_noprefix "${FUNCNAME[0]}:can not find systest '${systest_name}'"
			systest2exit[$i]=-2
			continue
		elif [ ${match} -gt 1 ]; then
			ove_echo_error_noprefix "${FUNCNAME[0]}:${match} match(es) for '${systest_name}'"
			${ove_cmd2pathname["grep"]:?} ^${systest_name} "${OVE_OWEL_DIR}"/systests
			systest2exit[$i]=-2
			continue
		fi

		read -r -a systest_row <<<"$(${ove_cmd2pathname["grep"]:?} -w ^${systest_name} "${OVE_OWEL_DIR}"/systests)"
		systest_name=${systest_row[0]}
		systest_timeout=${systest_row[1]}
		systest_type=${systest_row[2]}
		systest2name[$i]="${systest_name}"
		systest2abort[$i]=$(((systest_type & 0x1) != 0))
		systest_bg=$(((systest_type & 0x2) != 0))

		systest_path=${systest_row[3]//\"}
		systest_path=$(eval echo ${systest_path})
		if [ "x${systest_path}" = "x" ]; then
			ove_echo_error_noprefix "none valid path for systest '${systest_name}'"
			systest2exit[$i]=-2
			continue
		fi

		if [ "${systest_path:0:1}" = "/" ]; then
			# abs path
			if ! [ -d "${systest_path}" ]; then
				ove_echo_error_noprefix "path '${systest_path}' not found for systest '${systest_name}'"
				systest2exit[$i]=-2
				continue
			fi
		else
			# rel path
			if ! [ -d "${OVE_BASE_DIR}/${systest_path}" ]; then
				ove_echo_error_noprefix "path '${OVE_BASE_DIR}/${systest_path}' not found for systest '${systest_name}'"
				systest2exit[$i]=-2
				continue
			fi
			systest_path="${OVE_BASE_DIR}/${systest_path}"
		fi
		systest_cmd=${systest_row[*]:4}
		systest_cmd=${systest_cmd//\"}

		if ! pushd "${systest_path}" &> /dev/null; then
			ove_echo_error_noprefix "'pushd ${systest_path}' failed for systest '${systest_name}'"
			systest2exit[$i]=-2
			continue
		fi

		if [ "x${OVE_SYSTEST_HEADER}" = "xshort" ]; then
			printf "${FUNCNAME[0]}:[%03d/%03d   ]:${systest_name}\n" ${i} ${nbr_of_systests}
		elif [ "x${OVE_SYSTEST_HEADER}" = "xdetailed" ]; then
			printf "%s:[%03d/%03d   ]:name: %s timeout: %s type: %s path: %s cmd: %s\n" \
				"${FUNCNAME[0]}" \
				"${i}" \
				"${nbr_of_systests}" \
				"${systest_name}" \
				"${systest_timeout}" \
				"${systest_type}" \
				"${systest_path}" \
				"${systest_cmd}"
		elif [ "x${OVE_SYSTEST_HEADER}" = "xoff" ]; then
			true
		else
			ove_echo_error_noprefix "invalid value for OVE_SYSTEST_HEADER, try: $(ove_config_get_allowed OVE_SYSTEST_HEADER)"
			return 1
		fi

		OVE_SYSTEST_ACTIVE_TEST_CASE=${systest_name}
		export OVE_SYSTEST_ACTIVE_TEST_CASE

		OVE_SYSTEST_ITERATION=${i}
		export OVE_SYSTEST_ITERATION

		OVE_SYSTEST_NBR_TESTS=${nbr_of_systests}
		export OVE_SYSTEST_NBR_TESTS

		if [ "${OVE_DRY_RUN}" -eq 1 ]; then
			# dry run
			systest2exit[$i]=0
		else
			if [ ${systest_timeout} -eq 0 ]; then
				timeout_cmd=""
			else
				timeout_cmd="timeout --foreground --kill-after 30s ${systest_timeout}"
			fi

			# run the systest as a background job
			if [ ${systest_bg} -eq 1 ]; then
				${timeout_cmd} ${ove_cmd2pathname["bash"]:?} -c "{ ${systest_cmd}; }" &
				pids_db[${i}]=${!}
				systest2exit[$i]=-1
			# run in fg
			elif ${timeout_cmd} ${ove_cmd2pathname["bash"]:?} -c "{ ${systest_cmd}; }"; then
				# test passed
				systest2exit[$i]=0
			else
				systest2exit[$i]=${?}
				# type 1 systest or SIGINT => stop loop
				if [ ${systest_type} -eq 1 ] || [ ${systest2exit[$i]} -eq 130 ]; then
					if ! popd &> /dev/null; then
						ove_echo_fatal_noprefix "'popd' failed"
						return 1
					fi
					break
				fi
			fi

			if [ $OVE_SYSTEST_CLEANUP -eq 1 ] && command -v ps > /dev/null; then
				ove_systest_cleanup
			fi
		fi

		ove_systest_print_summary
		if ! popd &> /dev/null; then
			ove_echo_fatal_noprefix "'popd' failed"
			return 1
		fi
	done

	while true; do
		all_done=1
		for t in ${!pids_db[*]}; do
			if [ ${pids_db[$t]} -eq 0 ]; then
				continue
			elif kill -0 ${pids_db[$t]} 2> /dev/null; then
				all_done=0
			else
				# get and remember the exit status
				wait ${pids_db[$t]}
				systest2exit[$t]=${?}

				# abort on errors?
				if [ ${systest2exit[$t]} -ne 0 ] && [ ${systest2abort[$t]} -eq 1 ]; then
					if command -v ps > /dev/null; then
						ove_systest_cleanup
					fi
					for u in ${!systest2exit[*]}; do
						# mark BG jobs as ABT
						if [ ${systest2exit[$u]} -eq -1 ]; then
							systest2exit[$u]=-3
						fi
					done
					break 2
				fi
				ove_systest_print_summary
				pids_db[$t]=0
			fi
		done

		if [ $all_done -eq 1 ]; then
			break
		fi

		${ove_cmd2pathname["sleep"]:?} 0.1
	done

	echo
	if [ ${nbr_of_systests} -gt 1 ]; then
		echo ${FUNCNAME[0]}:Summary:
		ove_systest_print_summary
	fi

	if [ "x${OVE_LAST_COMMAND}" != "x" ]; then
		echo "OVE log: ${OVE_LAST_COMMAND}"
	fi

	# last failed test => exit status
	exit_status=0
	for u in ${!systest2exit[*]}; do
		if [ ${systest2exit[$u]} != 0 ]; then
			exit_status=${systest2exit[$u]}
		fi
	done

	return ${exit_status}
}

# helper function for a few revtab functions below
function ove_revtab_sanity_check {
	if [ $# -ne 2 ]; then
		ove_echo_error_noprefix "please provide two revisions for '${OVE_OWEL_DIR}'"
		return 1
	fi

	if [ "$1" == "$2" ]; then
		ove_echo_error_noprefix "please provide two different revisions for '${OVE_OWEL_DIR}'"
		return 1
	fi

	if ! ove_repo_cmd "${OVE_OWEL_DIR}" cat-file -e "$1" &> /dev/null; then
		ove_echo_error_noprefix "'$1' is not a valid revision"
		return 1
	fi

	if ! ove_repo_cmd "${OVE_OWEL_DIR}" cat-file -e "$2" &> /dev/null; then
		ove_echo_error_noprefix "'$2' is not a valid revision"
		return 1
	fi

	if ! ove_repo_cmd "${OVE_OWEL_DIR}" " --no-pager show" $1:revtab &> /dev/null; then
		ove_echo_error_noprefix "revtab for '$1' is not available"
		return 1
	fi

	if ! ove_repo_cmd "${OVE_OWEL_DIR}" "--no-pager show" $2:revtab &> /dev/null; then
		ove_echo_error_noprefix "revtab for '$2' is not available"
		return 1
	fi
}

# revtab-diff:<rev> <rev>:print changes between two project revisions:CORE
function ove-revtab-diff {
	ove_entry || return

	local a
	local b
	local r
	local sha_1
	local sha_2

	if ! ove_revtab_sanity_check "$@"; then
		ove_command_usage
		return 1
	fi

	# save revtab for rev A and rev B
	a=$(ove_repo_cmd "${OVE_OWEL_DIR}" "--no-pager show" $1:revtab | \
		${ove_cmd2pathname["grep"]:?} -v \# | \
		${ove_cmd2pathname["xargs"]:?} -n4)
	b=$(ove_repo_cmd "${OVE_OWEL_DIR}" "--no-pager show" $2:revtab | \
		${ove_cmd2pathname["grep"]:?} -v \# | \
		${ove_cmd2pathname["xargs"]:?} -n4)

	# extract repo
	# shellcheck disable=SC2016
	printf "${a}" | \
		${ove_cmd2pathname["awk"]:?} '{print $1}' | \
		LC_ALL="C" ${ove_cmd2pathname["sort"]:?} > ${OVE_OWEL_TMP_DIR}/repos_A
	# shellcheck disable=SC2016
	printf "${b}" | \
		${ove_cmd2pathname["awk"]:?} '{print $1}' | \
		LC_ALL="C" ${ove_cmd2pathname["sort"]:?} > ${OVE_OWEL_TMP_DIR}/repos_B

	# extract repo/rev
	# shellcheck disable=SC2016
	printf "${a}" | \
		${ove_cmd2pathname["awk"]:?} '{print $1,$4}' | \
		LC_ALL="C" ${ove_cmd2pathname["sort"]:?} > ${OVE_OWEL_TMP_DIR}/rev_A
	# shellcheck disable=SC2016
	printf "${b}" | \
		${ove_cmd2pathname["awk"]:?} '{print $1,$4}' | \
		LC_ALL="C" ${ove_cmd2pathname["sort"]:?}  > ${OVE_OWEL_TMP_DIR}/rev_B

	while true; do
		# repos only in A
		for r in $(LC_ALL="C" ${ove_cmd2pathname["comm"]:?} -2 -3 ${OVE_OWEL_TMP_DIR}/repos_A ${OVE_OWEL_TMP_DIR}/repos_B); do
			${ove_cmd2pathname["grep"]:?} "^${r} " ${OVE_OWEL_TMP_DIR}/rev_A | ${ove_cmd2pathname["sed"]:?} -e 's/^/a /g'
		done

		# repos only in B
		for r in $(LC_ALL="C" ${ove_cmd2pathname["comm"]:?} -1 -3 ${OVE_OWEL_TMP_DIR}/repos_A ${OVE_OWEL_TMP_DIR}/repos_B); do
			${ove_cmd2pathname["grep"]:?} "^${r} " ${OVE_OWEL_TMP_DIR}/rev_B | ${ove_cmd2pathname["sed"]:?} -e 's/^/b /g'
		done

		# repos common for A and B
		for r in $(LC_ALL="C" ${ove_cmd2pathname["comm"]:?} -1 -2 ${OVE_OWEL_TMP_DIR}/repos_A ${OVE_OWEL_TMP_DIR}/repos_B); do
			# shellcheck disable=SC2016
			sha_1=$(${ove_cmd2pathname["grep"]:?} "^${r} " ${OVE_OWEL_TMP_DIR}/rev_A | \
				${ove_cmd2pathname["awk"]:?} '{print $2}')
			# shellcheck disable=SC2016
			sha_2=$(${ove_cmd2pathname["grep"]:?} "^${r} " ${OVE_OWEL_TMP_DIR}/rev_B | \
				${ove_cmd2pathname["awk"]:?} '{print $2}')
			[ "${sha_1}" == "${sha_2}" ] && continue
			echo c ${r} ${sha_1} ${sha_2}
		done

		break
	done | ${ove_cmd2pathname["column"]:?} -t

	# cleanup
	${ove_cmd2pathname["rm"]:?} ${OVE_OWEL_TMP_DIR}/repos_A \
		${OVE_OWEL_TMP_DIR}/repos_B \
		${OVE_OWEL_TMP_DIR}/rev_A \
		${OVE_OWEL_TMP_DIR}/rev_B
}

# helper function for diff/log/shortlog-owel functions
function ove_extract_only_a {
	local line=${*}
	local repo
	local sha_1

	# shellcheck disable=SC2016
	repo=$(${ove_cmd2pathname["awk"]:?} '{print $2}' <<<"${line}")
	# shellcheck disable=SC2016
	sha_1=$(${ove_cmd2pathname["awk"]:?} '{print $3}' <<<"${line}")
	if [ -d ${OVE_BASE_DIR}/${repo} ] && [ -e ${OVE_BASE_DIR}/${repo}/.git ]; then
		only_a+="  ${repo}|$(ove_repo_cmd ${OVE_BASE_DIR}/${repo} log -1 --oneline --pretty="  %C(auto)%h|%s" ${sha_1})\n"
	else
		only_a+="${line:1}\n"
	fi
}

# helper function for diff/log/shortlog-owel functions
function ove_extract_only_b {
	local line=${*}
	local repo
	local sha_1

	# shellcheck disable=SC2016
	repo=$(${ove_cmd2pathname["awk"]:?} '{print $2}' <<<"${line}")
	# shellcheck disable=SC2016
	sha_1=$(${ove_cmd2pathname["awk"]:?} '{print $3}' <<<"${line}")
	if [ -d ${OVE_BASE_DIR}/${repo} ] && [ -e ${OVE_BASE_DIR}/${repo}/.git ]; then
		only_b+="  ${repo}|$(ove_repo_cmd ${OVE_BASE_DIR}/${repo} log -1 --oneline --pretty="  %C(auto)%h|%s" ${sha_1})\n"
	else
		only_b+="${line:1}\n"
	fi
}

# helper function for diff/log/shortlog-owel functions
function ove_print_only_a_and_b {
	if [ "${only_a}" != "" ]; then
		echo
		ove_echo_yellow_noprefix "only in '$1':"
		printf "${only_a}" | ${ove_cmd2pathname["column"]:?} -t -s'|'
	fi

	if [ "${only_b}" != "" ]; then
		echo
		ove_echo_yellow_noprefix "only in '$2':"
		printf "${only_b}" | ${ove_cmd2pathname["column"]:?} -t -s'|'
	fi
}

# $1: repo
# $2: rev
function ove_validate_rev {
	local repo="$1"
	local revision="$2"

	if [ ! -d "${OVE_BASE_DIR}/${repo}" ]; then
		echo
		ove_echo_yellow_noprefix "${repo}: not yet fetched" 1>&2
		return 1
	fi

	if ! ove_repo_cmd "${OVE_BASE_DIR}/${repo}" cat-file -e "${revision}" &> /dev/null; then
		ove_echo_error_noprefix "${repo}: '${revision}' is not a valid revision"
		return 1
	fi
}

# helper function for diff/log/shortlog-owel functions
function ove_extract_repo_and_sha {
	local line=${*}

	# shellcheck disable=SC2016
	repo=$(${ove_cmd2pathname["awk"]:?} '{print $2}' <<<"${line}")
	# shellcheck disable=SC2016
	sha_1=$(${ove_cmd2pathname["awk"]:?} '{print $3}' <<<"${line}")
	if ! ove_validate_rev ${repo} ${sha_1}; then
		return 1
	fi
	# shellcheck disable=SC2016
	sha_2=$(${ove_cmd2pathname["awk"]:?} '{print $4}' <<<"${line}")
	if ! ove_validate_rev ${repo} ${sha_2}; then
		return 1
	fi
}

# diff-owel:<rev> <rev>:diff two OWEL revisions:CORE
function ove-diff-owel {
	ove_entry || return

	local cmd
	local diff
	local line
	local only_a
	local only_b
	local repo
	local sha_1
	local sha_2

	if ! ove_revtab_sanity_check "$@"; then
		ove_command_usage
		return 1
	fi

	cmd="ove_repo_cmd ${OVE_OWEL_DIR} diff --color=always $1 $2"
	diff=$(eval ${cmd})
	cmd="${ove_cmd2pathname["git"]:?} -C ${OVE_OWEL_DIR} diff --color=always $1 $2"
	if [ "${diff}" != "" ]; then
		if [ ${OVE_LESS_MORE_OPTIONS} -eq 1 ]; then
			echo -e "${diff}" | ${OVE_PAGER} -Ps"${OVE_OWEL_NAME}\:${cmd//./\\.}"
		else
			echo -e "${diff}" | ${OVE_PAGER}
		fi
	fi

	while IFS= read -r line; do
		[ "${line}" == "" ] && break
		if [ ${line:0:1} == "a" ]; then
			ove_extract_only_a ${line}
		elif [ ${line:0:1} == "b" ]; then
			ove_extract_only_b ${line}
		elif [ ${line:0:1} == "c" ]; then
			ove_extract_repo_and_sha ${line} || continue
			cmd="ove_repo_cmd ${OVE_BASE_DIR}/${repo} diff --color=always ${sha_1} ${sha_2}"
			diff=$(eval ${cmd})
			cmd="${ove_cmd2pathname["git"]:?} -C ${OVE_BASE_DIR}/${repo} diff --color=always ${sha_1} ${sha_2}"
			if [ "${diff}" != "" ]; then
				if [ ${OVE_LESS_MORE_OPTIONS} -eq 1 ]; then
					echo -e "${diff}" | ${OVE_PAGER} -Ps"${repo}\:${cmd//./\\.}"
				else
					echo -e "${diff}" | ${OVE_PAGER}
				fi
			fi
		fi
	done <<<"$(ove-revtab-diff "$1" "$2")"

	ove_print_only_a_and_b $1 $2
}

# log-owel:<rev> <rev>:list commits between two OWEL revisions:CORE
function ove-log-owel {
	ove_entry || return

	local diff
	local line
	local only_a
	local only_b
	local repo
	local sha_1
	local sha_2

	if ! ove_revtab_sanity_check "$@"; then
		ove_command_usage
		return 1
	fi

	diff=$(ove_repo_cmd "${OVE_OWEL_DIR}" "--no-pager log" --oneline --pretty="  %C(auto)%h %s" "$1".."$2")
	if [ "${diff}" != "" ]; then
		ove_echo_yellow_noprefix "${OVE_OWEL_NAME}:"
		echo -e "${diff}"
	fi

	while IFS= read -r line; do
		[ "${line}" == "" ] && break
		if [ ${line:0:1} == "a" ]; then
			ove_extract_only_a ${line}
		elif [ ${line:0:1} == "b" ]; then
			ove_extract_only_b ${line}
		elif [ ${line:0:1} == "c" ]; then
			ove_extract_repo_and_sha ${line} || continue
			diff=$(ove_repo_cmd ${OVE_BASE_DIR}/${repo} "--no-pager log" --oneline --pretty="  %C(auto)%h %s" ${sha_1}..${sha_2})
			if [ "${diff}" != "" ]; then
				echo
				ove_echo_yellow_noprefix "${repo}:"
				echo -e "${diff}"
			fi
		fi
	done <<<"$(ove-revtab-diff "$1" "$2")"

	ove_print_only_a_and_b $1 $2
}

# shortlog-owel:<rev> <rev>:shortlog two OWEL revisions:CORE
function ove-shortlog-owel {
	ove_entry || return

	local diff
	local line
	local only_a
	local only_b
	local repo
	local sha_1
	local sha_2

	if ! ove_revtab_sanity_check "$@"; then
		ove_command_usage
		return 1
	fi

	diff=$(ove_repo_cmd "${OVE_OWEL_DIR}" "--no-pager shortlog" --email --oneline "$1".."$2")
	if [ "${diff}" != "" ]; then
		ove_echo_yellow_noprefix ${OVE_OWEL_NAME}:
		echo -e "${diff}"
		echo
	fi

	while IFS= read -r line; do
		[ "${line}" == "" ] && break
		if [ ${line:0:1} == "a" ]; then
			ove_extract_only_a ${line}
		elif [ ${line:0:1} == "b" ]; then
			ove_extract_only_b ${line}
		elif [ ${line:0:1} == "c" ]; then
			ove_extract_repo_and_sha ${line} || continue
			diff=$(ove_repo_cmd ${OVE_BASE_DIR}/${repo} "--no-pager shortlog" --email --oneline ${sha_1}..${sha_2} | ${ove_cmd2pathname["sed"]:?} -e 's/^/  /g')
			if [ "${diff}" != "" ]; then
				ove_echo_yellow_noprefix "${repo}:"
				echo -e "${diff}"
				echo
			fi
		fi
	done <<<"$(ove-revtab-diff "$1" "$2")"

	ove_print_only_a_and_b $1 $2
}

# help function that will print OVE workspace info
#
# $1 = path to OVE workspace directory
function ove_locate_print {
	local num_projs
	local num_repos
	local ove_dir

	ove_dir="$1/.owel"

	! [ -d ${ove_dir} ] && return

	# shellcheck disable=SC2016
	num_repos=$(${ove_cmd2pathname["awk"]:?} '{print $1}' ${ove_dir}/revtab | \
		${ove_cmd2pathname["sed"]:?} -e 's/#.*$//' -e '/^$/d' | \
		${ove_cmd2pathname["wc"]:?} -l)
	OVE_OWEL_DIR=${ove_dir} num_projs=$(ove_list_projects | \
		${ove_cmd2pathname["wc"]:?} -w)
	${ove_cmd2pathname["dirname"]:?} ${ove_dir}
	[ -e "${ove_dir}/SETUP" ] && echo "  $(${ove_cmd2pathname["cat"]:?} ${ove_dir}/SETUP)"
	# shellcheck disable=SC2016
	echo "  repos [${num_repos}]: $(${ove_cmd2pathname["awk"]:?} '{print $1}' ${ove_dir}/revtab | \
		${ove_cmd2pathname["sed"]:?} -e 's/#.*$//' -e '/^$/d' | \
		${ove_cmd2pathname["tr"]:?} '\n' ' ')"
	OVE_OWEL_DIR=${ove_dir} echo "  projs [${num_projs}]: $(ove_list_projects)"
	echo
}

# setup:[dir]:print or execute ${OVE_OWEL_DIR}/SETUP:CORE
function ove-setup {
	local p

	if [ ! -s "${OVE_OWEL_DIR}/SETUP" ]; then
		return 0
	elif [ ! -x "${OVE_OWEL_DIR}/SETUP" ]; then
		${ove_cmd2pathname["cat"]:?} "${OVE_OWEL_DIR}/SETUP"
		return 0
	fi

	if [ $# -eq 1 ]; then
		if [ ${EUID} -eq 0 ]; then
			p="#"
		else
			p="$"
		fi

		if ! echo "$p mkdir -p $1"; then
			return 1
		elif ! ${ove_cmd2pathname["mkdir"]:?} -p "$1"; then
			return 1
		elif ! echo "$p cd $1"; then
			return 1
		elif ! cd "$1"; then
			return 1
		fi
	fi

	if ! ${ove_cmd2pathname["bash"]:?} "${OVE_OWEL_DIR}/SETUP"; then
		return 1
	fi

	return 0
}

# refresh:[pattern...]:refresh OVE workspaces on this host:UTIL
function ove-refresh {
	ove_entry || return

	local i
	local p
	local proj_base
	local proj_list
	local projs
	local str

	mapfile -t projs < <(ove_list_workspaces_full)
	if [ $# -eq 0 ]; then
		proj_list="$(${ove_cmd2pathname["seq"]:?} 0 $((${#projs[@]} - 1)))"
	else
		i=0
		while ((i < ${#projs[@]})); do
			proj_base=${projs[i]##*/}
			for p in "$@"; do
				[[ "${proj_base,,}" =~ ${p,,} ]] && proj_list+="$i "
			done
			(( i+=1 ))
		done
	fi

	for i in ${proj_list}; do
		str+=$(printf "
			echo '$ # %s'
			echo '$ cd %s'
			cd %s
			ove_init
			echo '$ ove fetch-fetched'
			ove fetch-fetched
			if ove news > /dev/null; then
				ove news
				while true; do
					read -p '%s [?,a,A,b,B,c,d,l,n,p,q,s,S,x]? ' -r -n1
					echo
					if [[ \${REPLY} =~ ^[Pp]$ ]]; then
						echo '$ ove pull'
						ove pull
						echo
					elif [[ \${REPLY} =~ ^[a]$ ]]; then
						echo '$ ove ahead'
						ove ahead
						echo
					elif [[ \${REPLY} =~ ^[A]$ ]]; then
						echo '$ ove show-ahead'
						ove show-ahead
						echo
					elif [[ \${REPLY} =~ ^[b]$ ]]; then
						echo '$ ove behind'
						ove behind
						echo
					elif [[ \${REPLY} =~ ^[B]$ ]]; then
						echo '$ ove show-behind'
						ove show-behind
						echo
					elif [[ \${REPLY} =~ ^[Cc]$ ]]; then
						echo '$ ove checkout'
						ove checkout
						echo
					elif [[ \${REPLY} =~ ^[Dd]$ ]]; then
						echo '$ ove diff'
						ove diff
						echo
					elif [[ \${REPLY} =~ ^[Xx]$ ]]; then
						echo '$ ove pull'
						if ove pull; then
							break
						fi
						echo
					elif [[ \${REPLY} =~ ^[Ll]$ ]]; then
						echo '$ ove log'
						ove log
						echo
					elif [[ \${REPLY} =~ ^[s]$ ]]; then
						echo '$ ove status'
						ove status
						echo
					elif [[ \${REPLY} =~ ^[S]$ ]]; then
						echo '$ ove show-news'
						ove show-news
						echo
					elif [[ \${REPLY} =~ ^[Qq]$ ]]; then
						return
					elif [[ \${REPLY} =~ ^[Nn]$ ]]; then
						break
					elif [[ \${REPLY} =~ ^[?]$ ]]; then
						echo 'a - ahead'
						echo 'A - show-ahead'
						echo 'b - behind'
						echo 'B - show-behind'
						echo 'c - checkout'
						echo 'd - diff'
						echo 'l - log'
						echo 'n - next'
						echo 'p - pull'
						echo 'q - quit'
						echo 's - status'
						echo 'S - show-news'
						echo 'x - pull and next'
						echo '? - this help'
						continue
					fi
				done
			fi
			echo" $(ove_echo_green_noprefix ${projs[i]##*/}) ${projs[i]} ${projs[i]} $(ove_echo_green_noprefix ${projs[i]##*/}))
	done
	eval "${str}"
}

function ove_locate_owels {
	local a
	local b
	local diff
	local invalidate_cache
	local o
	local owels

	if [ -e "${OVE_GLOBAL_STATE_DIR}/owel.cache" ]; then
		a=$(${ove_cmd2pathname["stat"]:?} --format '%Y' "${OVE_GLOBAL_STATE_DIR}/owel.cache")
		b=$(${ove_cmd2pathname["date"]:?} +%s)
		if [ $((b-a)) -lt ${OVE_LOCATE_LIFESPAN_TIME_IN_SEC} ]; then
			for o in $(${ove_cmd2pathname["cat"]:?} "${OVE_GLOBAL_STATE_DIR}/owel.cache"); do
				if ! [ -d ${o} ]; then
					invalidate_cache=true
				fi
			done

			if ! [ "${invalidate_cache}" = true ]; then
				${ove_cmd2pathname["cat"]:?} "${OVE_GLOBAL_STATE_DIR}/owel.cache"
				return
			fi
		fi
	fi

	if command -v locate > /dev/null; then
		owels=$(${ove_cmd2pathname["locate"]:?} -e -r '\.owel$')
	else
		owels=$(${ove_cmd2pathname["find"]:?} ${OVE_LOCATE_SEARCH_DIR} -type l -name .owel 2> /dev/null)
	fi

	if [ "${owels}" == "" ]; then
		return 1
	fi

	for o in ${owels}; do
		if ! [ -e ${o}/revtab ]; then
			owels=${owels/${o}/}
		fi
	done

	owels=${owels//\/.owel/}

	printf "%s\n" ${owels} | \
		${ove_cmd2pathname["tee"]:?} "${OVE_GLOBAL_STATE_DIR}/owel.cache"
}

function ove_list_workspaces_full {
	local owel
	local owels

	owels=$(ove_locate_owels)

	if [ "${owels}" == "" ]; then
		ove_echo_error_noprefix "no OVE workspace(s) found"
		return 1
	fi

	for owel in ${owels}; do
		[ -O ${owel}/ove ] && echo ${owel}
	done | LC_ALL="C" ${ove_cmd2pathname["sort"]:?}
}

function ove_list_workspaces_base {
	local owel

	for owel in $(ove_list_workspaces_full); do
		echo ${owel##*/}
	done | LC_ALL="C" ${ove_cmd2pathname["sort"]:?}
}

# locate: :print OVE workspaces owned by you on this host:CORE
function ove-locate {
	ove_entry || return

	local owel
	local owels

	owels=$(ove_list_workspaces_full)
	for owel in ${owels}; do
		ove_locate_print ${owel}
	done | ${ove_cmd2pathname["head"]:?} -n -1
}

# locate-all: :print all OVE workspaces on this host:CORE
function ove-locate-all {
	ove_entry || return

	local owel
	local owels

	owels=$(ove_locate_owels)
	if [ "${owels}" == "" ]; then
		ove_echo_error_noprefix "no OVE workspace(s) found"
		return 1
	fi

	for owel in ${owels}; do
		ove_locate_print ${owel}
	done | ${ove_cmd2pathname["head"]:?} -n -1
}

# helper function for ove_set_workspace
function ove_set_workspaces_helper {
	local i=0

	[ -z ${projs+x} ] && return 1
	[ ${#projs[@]} -eq 0 ] && return 1
	while ((i < ${#projs[@]})); do
		printf "%d # %s # %s\n" $((i + 1)) $(ove_echo_green_noprefix ${projs[i]##*/}) ${projs[i]}
		# shellcheck disable=SC2030
		(( i+=1 ))
	done | ${ove_cmd2pathname["column"]:?} -t -s#
}

# move to a specific OVE workspace
# $1: PATTERN
function ove_set_workspace {
	local i=0
	local p
	local projs

	mapfile -t projs < <(ove_list_workspaces_full)
	[ ${#projs[@]} -eq 0 ] && return 1
	if [ $# -eq 0 ]; then
		ove_set_workspaces_helper
		echo
		read -r -p "Workspace#: "
		if ! [[ "${REPLY}" =~ ^[0-9]+$ ]]; then
			[ "${REPLY}" != "" ] && \
				echo "error: just numbers"
			return 1
		fi

		if [ ${REPLY} -gt ${#projs[@]} ] || [ ${REPLY} -eq 0 ]; then
			echo "error: out of bounds"
			return 1
		fi

		eval $(printf "cd %s; . ove > /dev/null\n" ${projs[$((REPLY - 1))]})
	elif [ $# -eq 1 ]; then
		while ((i < ${#projs[@]})); do
			p=${projs[i]##*/}
			if [[ "${p,,}" =~ ${1,,} ]]; then
				eval $(printf "cd %s; . ove > /dev/null\n" ${projs[i]})
				return
			fi
			(( i+=1 ))
		done

		echo "error: workspace '$1' not found"
		echo "Your OVE workspace(s) on this host:"
		ove_set_workspaces_helper
		return 1
	fi
}

# update-revtab:git rev:update 'revtab' with a another (existing) 'rev' for the repository named 'git':CORE
function ove-update-revtab {
	ove_entry || return

	local i
	local repo
	local revision

	if [ ${#} -ne 2 ]; then
		ove_command_usage
		return 1
	fi

	ove_revtab_sanity || return

	# validate repo
	repo=$(ove_validate_repo_list ${1})
	if [ "${repo}" == "" ]; then
		ove_echo_error_noprefix "repo '${1}' is not valid repo name"
		ove_command_usage
		return 1
	fi

	# validate revision
	revision="$2"
	if ! ove_validate_rev ${repo} ${revision}; then
		ove_command_usage
		return 1
	fi

	# update revtab
	i=${ove_revtab_name2index[${repo}]}
	${ove_cmd2pathname["sed"]:?} -i "s|^\(${repo} .*\)${ove_revtab_rev[${i}]}|\1${revision}|g" "${OVE_OWEL_DIR}/revtab"

	# reinit
	ove_reinit
}

# branch:[git...]|[git... name]:list branch(es) or create-and-checkout 'name' branch for 'git...' and update 'revtab' accordingly:CORE
function ove-branch {
	ove_entry || return
	ove_revtab_sanity || return

	local a
	local args
	local branch_name
	local branch_start_point
	local cmd
	local i
	local r
	local repos
	local ret=0

	if [ $# -lt 2 ]; then
		# shellcheck disable=SC2016
		cmd='ALLOW_OVERRIDE=1 ove_repo_cmd ${repo} "--no-pager branch" | ${ove_cmd2pathname["sed"]:?} "s|^|$(printf "%-${OVE_REPO_LIST_WIDTH}s" ${repo_basename})|g"'
		if [ $# -eq 0 ]; then
		        ove_revtab_forall "${cmd}"
		else
		        ove_revtab_forsome "${cmd}" "$@"
		fi

		return 0
	fi

	read -r -a a <<<"$*"
	# all but last arg
	args=${a[*]:0:${#a[*]}-1}
	branch_name=${a[*]: -1}
	repos=$(ove_validate_repo_list ${args})
	if [ "${repos}" == "" ]; then
		echo "error: invalid repo name: '${args}'"
		return 1
	fi

	for r in ${repos}; do
		if ! [ -d "${OVE_BASE_DIR}/${r}" ]; then
			echo "error: repo '${r}' is not yet fetched"
			continue
		fi

		while true; do
			read -r -p "${r}: starting point for branch '${branch_name}'? (leave empty to create branch from current HEAD): "
			[ "${REPLY}" == "" ] && break
			if ! ove_repo_cmd "${OVE_BASE_DIR}/${r}" cat-file -e "${REPLY}" &> /dev/null; then
				ove_echo_error_noprefix "'${REPLY}' is not a valid revision for ${r}, try again"
				continue
			fi
			branch_start_point=${REPLY}
			break
		done

		# checkout branch
		ove_repo_cmd "${OVE_BASE_DIR}/${r}" checkout -b ${branch_name} ${branch_start_point} |& ${ove_cmd2pathname["sed"]:?} "s|^|${r}: |g"
		if [ ${PIPESTATUS[0]} -ne 0 ]; then
			((ret++))
			continue
		fi

		if [ ! -e "${OVE_OWEL_DIR}/revtab" ]; then
			continue
		elif [ "${OVE_OWEL_NAME}" == "${r}" ]; then
			continue
		fi

		ove-update-revtab ${r} ${branch_name}
	done

	return ${ret}
}

# remote:[git...]:git remote -v for all/specified git repositories:CORE
function ove-remote {
	ove_entry || return

	local cmd

	# shellcheck disable=SC2016
	cmd='ove_echo_yellow_noprefix ${repo_basename} && ove_repo_cmd ${repo} "--no-pager remote" -v'

	if [ $# -eq 0 ]; then
		ove_revtab_forall "${cmd}"
	else
		ove_revtab_forsome "${cmd}" "$@"
	fi
}

# remote-set-url:url [git...]:change the URL of 'origin' remote for all/specified repositories:CORE
function ove-remote-set-url {
	ove_entry || return

	local cmd
	local url

	if [ $# -eq 0 ]; then
		ove_command_usage
		return 1
	fi
	url=$1
	shift

	# shellcheck disable=SC2016
	cmd='ove_echo_yellow_noprefix ${repo_basename} && ove_repo_cmd ${repo} "--no-pager remote" set-url origin ${url}/${repo_basename} && ove_repo_cmd ${repo} "--no-pager remote" -v'

	if [ $# -eq 0 ]; then
		ove_revtab_forall "${cmd}"
	else
		ove_revtab_forsome "${cmd}" "$@"
	fi
}

# remote-check: :sanity check that all remotes are online:CORE
function ove-remote-check {
	ove_entry || return

	local i
	local url

	i=0
	while ((i < ove_revtab_num_repositories)); do
		url="${ove_revtab_fetch_url[${i}]}"
		if [ "${url}" == "noremote" ]; then
			(( i+=1 ))
			continue
		fi

		if ! ${ove_cmd2pathname["git"]:?} ls-remote ${url} HEAD > /dev/null; then
			return 1
		fi

		(( i+=1 ))
	done
}

function ove_repo_is_dirty {
	if test -z "$(ove_repo_cmd ${1} "${OVE_GIT_OPTIONS} --no-pager status" --porcelain -uno)"; then
		return 1
	else
		return 0
	fi
}

# $1: repo
# $2: 1 = index or 2 = worktree
function ove_repo_is_dirty_helper {
	local s

	s="$(ove_repo_cmd ${1} "${OVE_GIT_OPTIONS} --no-pager status" --porcelain -uno)"
	if [ "x${s}" = "x" ]; then
		return 1
	fi
	s=$(${ove_cmd2pathname["cut"]:?} -b${2} <<<"$s")
	s=${s//$'\n'/}
	s=${s//[[:space:]]/}
	if [ "x${s}" = "x" ]; then
		return 1
	else
		return 0
	fi
}

function ove_repo_is_dirty_index {
	ove_repo_is_dirty_helper "${1}" 1
	return $?
}

function ove_repo_is_dirty_worktree {
	ove_repo_is_dirty_helper "${1}" 2
	return $?
}

function ove_list_dirty_repos {
	local repo

	# shellcheck disable=SC2016
	for repo in $(ove_revtab_forall_parallel 'ove_repo_is_dirty ${repo} && echo ${PWD}'); do
		ove_repo2shortpath ${repo}
	done | LC_ALL="C" ${ove_cmd2pathname["sort"]:?}
}

function ove_list_dirty_repos_index {
	local repo

	# shellcheck disable=SC2016
	for repo in $(ove_revtab_forall_parallel 'ove_repo_is_dirty_index ${repo} && echo ${PWD}'); do
		ove_repo2shortpath ${repo}
	done | LC_ALL="C" ${ove_cmd2pathname["sort"]:?}
}

function ove_list_dirty_repos_worktree {
	local repo

	# shellcheck disable=SC2016
	for repo in $(ove_revtab_forall_parallel 'ove_repo_is_dirty_worktree ${repo} && echo ${PWD}'); do
		ove_repo2shortpath ${repo}
	done | LC_ALL="C" ${ove_cmd2pathname["sort"]:?}
}

function ove_stashed_repos {
	# shellcheck disable=SC2016
	ove_revtab_forall_parallel 'ove_repo_cmd ${repo} "--no-pager stash" list | ${ove_cmd2pathname["grep"]:?} -q "stashed by OVE" && echo ${repo}'
}

# $1: drop or pop
# $2: [pattern]
function ove_stash_forsome {
	local repo
	local s
	local t

	for repo in $(ove_stashed_repos); do
		s=$(ove_repo_cmd ${repo} stash list | \
			${ove_cmd2pathname["grep"]:?} "stashed by OVE")

		if [ $# -eq 2 ] && [[ ${s} != *"$2"* ]]; then
			continue
		fi

		if [ $# -eq 1 ]; then
			t=$(echo "$s" | \
				${ove_cmd2pathname["head"]:?} -1 | \
				${ove_cmd2pathname["cut"]:?} -d: -f1)
			ove_repo_cmd ${repo} stash $1 -q ${t}
		else
			while true; do
				s=$(ove_repo_cmd ${repo} stash list | \
					${ove_cmd2pathname["grep"]:?} "stashed by OVE" | \
					${ove_cmd2pathname["grep"]:?} ${2} | \
					${ove_cmd2pathname["head"]:?} -1 | \
					${ove_cmd2pathname["cut"]:?} -d: -f1)
				[ "${s}" == "" ] && break

				if ! ove_repo_cmd ${repo} stash $1 -q ${s}; then
					ove_echo_error_noprefix "git -C ${repo} stash $1 -q ${s} failed"
					return 1
				fi
			done
		fi
	done
}

function ove_stash_pop {
	ove_stash_forsome pop $1
}

function ove_stash_drop {
	ove_stash_forsome drop $1
}

# $*: [message]
function ove_stash_push {
	local cmd
	local dirty_repos
	local now

	dirty_repos=$(ove_list_dirty_repos | ${ove_cmd2pathname["xargs"]:?})
	[ "${dirty_repos}" == "" ] && return

	now=$(${ove_cmd2pathname["date"]:?} '+%Y%m%d-%H%M%S')
	cmd="ove_repo_cmd \${repo} stash save -q stashed by OVE@${now}"
	if [ $# -eq 0 ]; then
		cmd+=" ${dirty_repos}"
	else
		cmd+=" ${*}"
	fi

	ove_revtab_forsome "${cmd}" "${dirty_repos}"
}

# $1: show or list
# $2: [pattern]
function ove_stash_inspect {
	local cmd
	local repo
	local s
	local t
	local u

	for repo in $(ove_stashed_repos); do
		cmd="ove_repo_cmd ${repo} stash"
		if [ "$1" == "show" ]; then
			s=$(ove_repo_cmd ${repo} stash list | \
				${ove_cmd2pathname["grep"]:?} "stashed by OVE")

			if [ $# -eq 2 ] && [[ ${s} != *"$2"* ]]; then
				continue
			fi

			if [ $# -eq 1 ]; then
				t=$(echo "$s" | \
					${ove_cmd2pathname["head"]:?} -1 | \
					${ove_cmd2pathname["cut"]:?} -d: -f1)
			else
				t=$(echo "$s" | \
					${ove_cmd2pathname["grep"]:?} ${2} | \
					${ove_cmd2pathname["cut"]:?} -d: -f1)
			fi

			cmd+=" show -p"
			for u in ${t}; do
				ove_echo_yellow_noprefix "${repo/${OVE_BASE_DIR}\/}:${u}"
				eval ${cmd} ${u}
			done
		else
			ove_echo_yellow_noprefix "${repo/${OVE_BASE_DIR}\/}"
			cmd+=" list | ${ove_cmd2pathname["grep"]:?} 'stashed by OVE'"
			eval ${cmd}
		fi
	done
}

function ove_stash_show {
	ove_stash_inspect show $1
}

function ove_stash_list {
	ove_stash_inspect list $1
}

# stash:[list|show [pattern]|drop [pattern]|pop [pattern]|push [msg...]]:git stash [drop|pop|show|list|push] for all git repositories:CORE
function ove-stash {
	ove_entry || return

	if [ "$1" == "pop" ] ||
		[ "$1" == "list" ] ||
		[ "$1" == "show" ] ||
		[ "$1" == "drop" ]; then
		ove_stash_$1 $2
	elif [ "$1" == "save" ] || [ "$1" == "push" ] || [ $# -eq 0 ]; then
		ove_stash_push "${@:2}"
	else
		ove_command_usage
		return 1
	fi
}

# diff:[git...]:git diff for all/specified git repositories:CORE
function ove-diff {
	ove_entry || return

	local cmd
	local repos

	if [ $# -eq 0 ]; then
		repos="$(ove_list_dirty_repos_worktree)"
	else
		repos="$(ove_validate_repo_list "$@")"
	fi

	if [ "x${repos}" = "x" ]; then
		return
	fi

	cmd="ove_repo_cmd \${repo} '--no-pager diff-files' --quiet || \
		(ove_echo_yellow_noprefix \${repo_basename} && \
		ALLOW_OVERRIDE=1 ove_repo_cmd \${repo} '--no-pager diff' ${OVE_DIFF_OPTIONS})"

	ove_revtab_forsome "${cmd}" "${repos}" | ${OVE_PAGER}
}

# wdiff:[git...]:git diff (word diff) for all/specified git repositories:CORE
function ove-wdiff {
	ove_entry || return

	local OVE_DIFF_OPTIONS

	OVE_DIFF_OPTIONS="--color-words=."
	ove-diff "$@"
}

# wdiff-cached:[git...]:git diff --cached (word diff) for all/specified git repositories:CORE
function ove-wdiff-cached {
	ove_entry || return

	local OVE_DIFF_OPTIONS

	OVE_DIFF_OPTIONS="--color-words=."
	ove-diff-cached "$@"
}

# diff-cached:[git...]:git diff --cached for all/specified repositories:CORE
function ove-diff-cached {
	ove_entry || return

	local cmd
	local repos

	cmd="ove_repo_cmd \${repo} '--no-pager diff-index' --quiet --cached HEAD -- || \
		(ove_echo_yellow_noprefix \${repo_basename} && \
		ALLOW_OVERRIDE=1 ove_repo_cmd \${repo} '--no-pager diff' --cached ${OVE_DIFF_OPTIONS})"

	if [ $# -eq 0 ]; then
		repos="$(ove_list_dirty_repos_index)"
	else
		repos="$(ove_validate_repo_list "$@")"
	fi

	if [ "x${repos}" = "x" ]; then
		return
	fi

	ove_revtab_forsome "${cmd}" "${repos}" | ${OVE_PAGER}
}

# reset:[git...]:git reset for all/specified repositories:CORE
function ove-reset {
	ove_entry || return

	local cmd

	# shellcheck disable=SC2016
	cmd='ove_repo_cmd ${repo} "--no-pager diff-index" --quiet --cached HEAD -- ||'
	# shellcheck disable=SC2016
	cmd+=' (ove_echo_yellow_noprefix ${repo_basename} && ALLOW_OVERRIDE=1 ove_repo_cmd ${repo} reset)'

	if [ $# -eq 0 ]; then
		ove_revtab_forall "${cmd}"
	else
		ove_revtab_forsome "${cmd}" "$@"
	fi
}

# reset-hard:[git...]:git reset --hard for all/specified repositories, USE WITH CARE:CORE
function ove-reset-hard {
	ove_entry || return

	local cmd

	# shellcheck disable=SC2016
	cmd='ove_repo_cmd ${repo} reset -q --hard'

	if [ $# -eq 0 ]; then
		ove_revtab_forall "${cmd}"
	else
		ove_revtab_forsome "${cmd}" "$@"
	fi
}

# add:[git...]:git add for all/specified repositories:CORE
function ove-add {
	ove_entry || return

	local cmd
	local repos

	# shellcheck disable=SC2016
	cmd='ove_repo_cmd ${repo} "--no-pager diff-files" --quiet ||'
	# shellcheck disable=SC2016
	cmd+=' (ove_echo_yellow_noprefix ${repo_basename} && ALLOW_OVERRIDE=1 ove_repo_cmd ${repo} "--no-pager add")'

	if [ $# -eq 0 ]; then
		repos="$(ove_list_dirty_repos_worktree)"
	else
		repos="$(ove_validate_repo_list "$@")"
	fi

	if [ "x${repos}" = "x" ]; then
		return
	fi

	ove_revtab_forsome "${cmd}" "${repos}"
}

# commit:[git...]:git commit for all/specified git repositories:CORE
function ove-commit {
	ove_entry || return

	local cmd

	cmd="ove_repo_cmd \${repo} '--no-pager diff' --cached --quiet ||
		(ove_echo_yellow_noprefix \${repo_basename};
		true > ${OVE_OWEL_TMP_DIR}/commit-template;
		echo >> ${OVE_OWEL_TMP_DIR}/commit-template;
		echo \# git: \${repo} >> ${OVE_OWEL_TMP_DIR}/commit-template;
		echo \# >> ${OVE_OWEL_TMP_DIR}/commit-template;
		ove_repo_cmd \${repo} diff --cached -U0 | ${ove_cmd2pathname["sed"]:?} 's/^/# /g' >> ${OVE_OWEL_TMP_DIR}/commit-template;
		ove_repo_cmd \${repo} commit -t ${OVE_OWEL_TMP_DIR}/commit-template;
		${ove_cmd2pathname["rm"]:?} ${OVE_OWEL_TMP_DIR}/commit-template)"

	if [ $# -eq 0 ]; then
		ove_revtab_forsome "${cmd}" "$(ove_list_dirty_repos_index)"
	else
		ove_revtab_forsome "${cmd}" "$@"
	fi
}

# list-missing-projects:[project...|tag...]:list any missing project(s):CORE
function ove-list-missing-projects {
	ove_entry || return

	local d
	declare -A m
	local proj_list

	if [ $# -eq 0 ]; then
		proj_list="${OVE_PROJECT_LIST}"
	else
		if ! proj_list=$(ove_validate_project_list "$@"); then
			return 1
		fi
	fi

	for d in $(ove_get_deps_recursive ${proj_list}); do
		[[ -v ove_projects_name2index[${d}] ]] || m[${d}]=
	done

	if [ ${#m[@]} -ne 0 ]; then
		printf "%s\n" "${!m[@]}" | LC_ALL="C" ${ove_cmd2pathname["sort"]:?}
	fi
}

# $* = proj(s)
function ove_get_deps_recursive {
	local dep
	local i
	local proj

	for proj in "$@"; do
		[[ -v ove_projects_name2index[${proj}] ]] || continue
		i=${ove_projects_name2index[${proj}]}
		for dep in ${ove_projects_deps[${i}]}; do
			echo -n "${dep} "
			ove_get_deps_recursive ${dep}
		done
	done
}

# $1 = proj
function ove_get_paths_recursive {
	local dep
	local i

	[ $# -ne 1 ] && return 1

	[[ -v ove_projects_name2index[${1}] ]] || return
	i=${ove_projects_name2index[$1]}

	if [ "${ove_projects_deps[${i}]}" == "" ]; then
		echo -n "${ove_projects_path[${i}]} "
		return
	fi

	for dep in ${ove_projects_deps[${i}]}; do
		echo -n "${ove_projects_path[${i}]} "
		ove_get_paths_recursive ${dep}
	done
}

# proj2path:project:print project path:CORE
function ove-proj2path {
	ove_entry || return

	local i

	if [ $# -ne 1 ] || [[ ! -v ove_projects_name2index[${1}] ]]; then
		ove_command_usage
		return 1
	fi
	i=${ove_projects_name2index[$1]}
	echo "${ove_projects_path[${i}]}"
}

function ove_revtab_validate {
	local a
	local foo
	local d
	local doublets

	[ ! -e "${OVE_OWEL_DIR}/revtab" ] && return

	declare -A r=()
	while read -r a foo; do
		# ignore comments and emtpy lines
		if [[ ${a} == \#* ]] || [[ ${a} == '' ]]; then
			continue
		fi
		if test "${r["${a}"]+isset}"; then
			ove_echo_error_noprefix "found repo doublet(s) in '${OVE_OWEL_DIR}/revtab':"
			# shellcheck disable=SC2016
			doublets="$(${ove_cmd2pathname["grep"]:?} -E -v '^$|^#' ${OVE_OWEL_DIR}/revtab | \
				${ove_cmd2pathname["awk"]:?} 'a[$1]++{print $1}' | \
				LC_ALL="C" ${ove_cmd2pathname["sort"]:?} -u)"
			for d in ${doublets}; do
				${ove_cmd2pathname["grep"]:?} --color=never -n "^${d} " ${OVE_OWEL_DIR}/revtab
			done
			return 1
		fi
		r["${a}"]=1
	done <"${OVE_OWEL_DIR}/revtab"
}

function ove_set_built_ins {
	local funcs

	OVE_BUILT_INS=$(ove_get_built_ins)
	export OVE_BUILT_INS

	funcs=$(${ove_cmd2pathname["grep"]:?} -B1 '^function ove-' ${OVE_SELF})

	OVE_BUILT_INS_WITHOUT_ARGS=$(${ove_cmd2pathname["grep"]:?} ': :' <<< "${funcs}" | \
		${ove_cmd2pathname["cut"]:?} -b3- | \
		${ove_cmd2pathname["cut"]:?} -d: -f1 | \
		LC_ALL="C" ${ove_cmd2pathname["sort"]:?})
	OVE_BUILT_INS_WITHOUT_ARGS=${OVE_BUILT_INS_WITHOUT_ARGS//$'\n'/ }
	export OVE_BUILT_INS_WITHOUT_ARGS
}

function ove_validate_self {
	local funcs

	if ${ove_cmd2pathname["grep"]:?} ^function ${OVE_SELF} | \
		${ove_cmd2pathname["grep"]:?} -q -v 'function ove'; then
		ove_echo_error_noprefix "functions need to start with 'ove-' or 'ove_'"
		${ove_cmd2pathname["grep"]:?} ^function ${OVE_SELF} | \
			${ove_cmd2pathname["grep"]:?} -v 'function ove'
		return 1
	fi

	funcs=$(${ove_cmd2pathname["grep"]:?} -B1 '^function ove-' ${OVE_SELF})

	# shellcheck disable=SC2016
	if [ "$(${ove_cmd2pathname["grep"]:?} '^$' -A1 <<< "${funcs}" | \
		${ove_cmd2pathname["awk"]:?} '{print $2}' | \
		${ove_cmd2pathname["xargs"]:?})" != "" ]; then
		ove_echo_error_noprefix "add help for the following function(s):"
		# shellcheck disable=SC2016
		${ove_cmd2pathname["grep"]:?} '^$' -A1 <<< "${funcs}" | \
			${ove_cmd2pathname["awk"]:?} '{print $2}' | \
			${ove_cmd2pathname["xargs"]:?}
		return 1
	fi
}

function ove_validate_projs {
	local d
	local doublets
	local i
	local name
	declare -a r

	[ ! -e "${OVE_OWEL_DIR}/projs" ] && return

	i=0
	while ((i < ove_number_of_projects)); do
		name="${ove_projects_name[${i}]}"
		if [ "${ove_projects_deps[${i}]}" != "" ]; then
			for d in ${ove_projects_deps[${i}]}; do
				echo "${ove_projects_name[${i}]} ${d}"
			done
		fi

		if [[ -v ove_projects_tags[${name}] ]]; then
			ove_echo_error_noprefix "tag '${name}' is already used as a project name, try another tag!"
			${ove_cmd2pathname["grep"]:?} -C 3 -n -H -w -E "^${name}:|${name}" ${OVE_OWEL_DIR}/projs 1>&2
			return 1
		fi
		(( i+=1 ))
	done | ${ove_cmd2pathname["tsort"]:?} > /dev/null
	read -r -a r <<<"${PIPESTATUS[@]}"

	if [ ${r[0]} -ne 0 ]; then
		return 1
	elif [ ${r[1]} -ne 0 ]; then
		ove_echo_error_noprefix "circular dependency in '${OVE_OWEL_DIR}/projs', see output from 'tsort' above"
		return 1
	fi

	# shellcheck disable=SC2016
	doublets=$(${ove_cmd2pathname["grep"]:?} -o '^[a-zA-Z0-9_]\+' ${OVE_OWEL_DIR}/projs | \
		${ove_cmd2pathname["awk"]:?} 'a[$1]++{print $1}')

	if [ "${doublets}" != "" ]; then
		ove_echo_error_noprefix "found project doublet(s) in '${OVE_OWEL_DIR}/projs':"

		for d in ${doublets}; do
			${ove_cmd2pathname["grep"]:?} -n "^${d}:" ${OVE_OWEL_DIR}/projs
		done
		return 1
	fi
}

# $@: a list of packages
function ove_install_packages {
	local cmd
	local missing_packages
	local missing_packages_sorted

	if [ ${OVE_INSTALL_PKG:?} -eq 0 ]; then
		return
	fi
	missing_packages=$(ove_packages_not_installed "$@")

	# no missing packages?
	if [ "x${missing_packages}" = "x" ]; then
		return
	fi

	# sort the list
	missing_packages_sorted="$(printf "%s\n" ${missing_packages} | \
		LC_ALL="C" ${ove_cmd2pathname["sort"]:?} -u)"
	missing_packages_sorted=${missing_packages_sorted//$'\n'/ }

	if [ "${OVE_DRY_RUN}" -eq 1 ]; then
		ove_echo_yellow "would prompt to install this/these package(s):"
		printf "%s\n" ${missing_packages_sorted}
		return
	fi

	if [ "${OVE_OS_PACKAGE_MANAGER}" == "unknown" ]; then
		ove_echo_fatal_noprefix "package manager is not set"
		return 1
	fi

	if ! command -v ${OVE_OS_PACKAGE_MANAGER} > /dev/null; then
		ove_command_not_found "${OVE_OS_PACKAGE_MANAGER}"
		return 1
	fi

	cmd="${OVE_OS_PACKAGE_MANAGER} ${OVE_OS_PACKAGE_MANAGER_ARGS} ${missing_packages_sorted}"
	if [ ${EUID} != 0 ]; then
		cmd="sudo ${cmd}"
	fi

	if [ ${OVE_INSTALL_PKG:?} -eq 1 ]; then
		if ! ${cmd}; then
			ove_echo_fatal_noprefix "'${cmd}' failed"
			return 1
		fi
		return 0
	elif [ ${OVE_INSTALL_PKG:?} -eq 2 ]; then
		echo "error: missing package(s): '${missing_packages_sorted}'. To fix this, run the following command:"
		echo
		echo -e "\t${cmd}"
		echo
		return 1
	fi
}

# $1: patch file
# $2: key
function ove_modify_patch {
	local f
	local key
	local n

	f="$1"
	key="$2"

	n=$(${ove_cmd2pathname["grep"]:?} -n "^+++ b/${key}" ${f})
	n=${n%%:*}
	((n++))
	${ove_cmd2pathname["sed"]:?} -i \
		-e "${n}s, -0, -99999,g" \
		-e "${n}s/ -[0-9]\+,0 +[0-9]\+,\([0-9]\+\) @@.*/ -99999,0 +1,\1 @@/g" \
		${f}
}

# $1: proj
# $2: work dir
function ove_export_create_proj_patch {
	local f
	local proj
	local wd

	proj="$1"
	wd="$2"

	if ${ove_cmd2pathname["find"]:?} ${OVE_OWEL_DIR}/projects/${proj} -mindepth 1 -print -quit 2> /dev/null | ${ove_cmd2pathname["grep"]:?} -q .; then
		${ove_cmd2pathname["mkdir"]:?} -p "${wd}"/projects/${proj}
		${ove_cmd2pathname["cp"]:?} -ar ${OVE_OWEL_DIR}/projects/${proj}/* "${wd}"/projects/${proj}
		for f in "${wd}"/projects/"${proj}"/*; do
			(cd "${wd}" || exit 1
			${ove_cmd2pathname["git"]:?} diff /dev/null ${f/${OVE_OWEL_TMP_DIR}\/export\/} >> "${wd}"/${proj}.patch)
		done
	fi
}

function ove_export {
	local _end
	local proj
	local projects
	local proj_index
	local proj_path
	local repo_path
	local _start
	local wd="${OVE_OWEL_TMP_DIR}/export"

	${ove_cmd2pathname["mkdir"]:?} -p "${wd}"
	${ove_cmd2pathname["find"]:?} "${wd}" -maxdepth 1 -name '*.patch' -exec rm {} \;

	if [ "$#" -eq 0 ]; then
		projects="${OVE_PROJECT_LIST}"
	else
		projects="${*}"
	fi

	# preparations
	true > "${wd}"/revtab
	true > "${wd}"/projs
	(cd "${wd}" || exit 1
	if [ -d .git ]; then
		${ove_cmd2pathname["rm"]:?} -rf .git
	fi
	${ove_cmd2pathname["git"]:?} init -q .
	${ove_cmd2pathname["git"]:?} add revtab projs
	${ove_cmd2pathname["git"]:?} commit -m "export: revtab projs" -q)

	for proj in ${projects}; do
		echo $proj

		_start=$(${ove_cmd2pathname["grep"]:?} -n '^[a-zA-Z0-9_]\+:' ${OVE_OWEL_DIR}/projs |
			${ove_cmd2pathname["grep"]:?} -A1 "^[0-9]\+:${proj}:" |
			${ove_cmd2pathname["sed"]:?} -e 's,#.*$,,g')
		if [ "x$_start" = "x" ]; then
			ove_echo_warning_noprefix "project '$proj' not found in '$OVE_OWEL_DIR/projs'"
			continue
		fi

		true > "${wd}"/revtab
		true > "${wd}"/projs

		if [ "$(printf "%s\n" $_start | ${ove_cmd2pathname["wc"]:?} -l)" -eq 1 ]; then
			_end=$(${ove_cmd2pathname["wc"]:?} -l < "${OVE_OWEL_DIR}/projs")
		else
			_end=$(printf "%s\n" $_start | ${ove_cmd2pathname["tail"]:?} -1 | ${ove_cmd2pathname["cut"]:?} -d: -f1)
			((_end--))
		fi
		_start="${_start%%:*}"

		# projs
		echo > "${wd}"/projs
		${ove_cmd2pathname["sed"]:?} -n "${_start},${_end}p" ${OVE_OWEL_DIR}/projs >> "${wd}"/projs
		# shellcheck disable=SC2016
		${ove_cmd2pathname["sed"]:?} -i -e '${/^$/d;}' "${wd}"/projs

		ove_export_create_proj_patch "${proj}" "${wd}"
		(cd "${wd}" || exit 1
			${ove_cmd2pathname["git"]:?} diff -U0 projs >> "${wd}"/${proj}.patch)
		ove_modify_patch "${wd}"/${proj}.patch "projs"

		# revtab
		proj_index=${ove_projects_name2index[${proj}]}
		proj_path=${ove_projects_path[${proj_index}]}
		while true; do
			if [ "x${proj_path}" = "x" ]; then
				break
			fi
			repo_path=$(printf "%s\n" ${OVE_REPO_LIST} | ${ove_cmd2pathname["grep"]:?} ^${proj_path}$)
			if [ "x${repo_path}" != "x" ]; then
				i=${ove_revtab_name2index[${repo_path/${OVE_BASE_DIR}\/}]}
				printf "%s %s %s %s\n" \
					${ove_revtab_git_name[${i}]} \
					${ove_revtab_fetch_url[${i}]} \
					${ove_revtab_push_url[${i}]} \
					${ove_revtab_rev[${i}]} >>"${wd}"/revtab
				(cd "${wd}" || exit 1
					${ove_cmd2pathname["git"]:?} diff revtab >> "${wd}"/${proj}.patch)
				ove_modify_patch "${wd}"/${proj}.patch "revtab"
				break
			fi
			proj_path="${proj_path%/*}"
		done
	done

	# common
	ove_export_create_proj_patch "common" "${wd}"

	${ove_cmd2pathname["rm"]:?} -rf "${wd}"/{projs,revtab,projects,.git}
}

# export:[project...|tag...]:export project(s):CORE
function ove-export {
	ove_entry || return

	local args="$*"
	local name
	local proj_list

	if [ $# -eq 0 ]; then
		ove_export
	else
		if ! proj_list=$(ove_validate_project_list "$@"); then
			return 1
		fi

		proj_list="$(ove_get_deps_recursive $proj_list) $proj_list"
		ove_export $(printf "%s\n" "$(ove_uniq $proj_list)" | LC_ALL="C" ${ove_cmd2pathname["sort"]:?})
	fi

	if [ "x$(${ove_cmd2pathname["find"]:?} "${OVE_OWEL_TMP_DIR}/export" -maxdepth 1 -name '*.patch' -print -quit)" == "x" ]; then
		ove_echo_error_noprefix "no project(s) exported"
		return 1
	fi

	# shellcheck disable=SC2016
	name="${OVE_BASE_DIR}/${OVE_OWEL_NAME}-$(ove-describe ${OVE_OWEL_NAME} | ${ove_cmd2pathname["awk"]:?} '{print $2}')"
	if [ $# -eq 1 ]; then
		name+="-${args}"
	fi
	name+=".tar.bz2"
	${ove_cmd2pathname["tar"]:?} -C "${OVE_OWEL_TMP_DIR}/export" -cjf "${name}" --owner=0 --group=0 .
	echo "${name}"

	return 0
}

function ove_patch_one_project {
	local f
	local proj

	f="$1"
	proj=${1##*/}
	proj=${proj/.patch/}

	echo "${proj}"
	if ${ove_cmd2pathname["grep"]:?} -q ^$proj: ${OVE_OWEL_DIR}/projs; then
		return
	fi

	ove_repo_cmd ${OVE_OWEL_DIR} apply --whitespace=nowarn "${f}" 2> /dev/null
}

# import:file:import project(s), see export:CORE
function ove-import {
	ove_entry || return

	local f
	local lines
	local n
	local patch
	local proj
	local repo
	local ret=0
	local out

	if [ $# -ne 1 ]; then
		ove_command_usage
		return 1
	fi

	f="$1"
	if [ ! -e "${f}" ]; then
		echo "error: '${f}' not found"
		return 1
	elif [ ! -s "${f}" ]; then
		echo "error: '${f}' file size is 0"
		return 1
	elif ! ${ove_cmd2pathname["file"]:?} "${f}" | ${ove_cmd2pathname["grep"]:?} -q "bzip2 compressed data"; then
		echo "error: '${f}' is not a bzip2 compressed data file"
		return 1
	fi

	${ove_cmd2pathname["mkdir"]:?} -p "${OVE_OWEL_TMP_DIR}/import"
	${ove_cmd2pathname["find"]:?} "${OVE_OWEL_TMP_DIR}/import" -maxdepth 1 -name '*.patch' -exec rm {} \;
	${ove_cmd2pathname["tar"]:?} -C "${OVE_OWEL_TMP_DIR}/import" -xf "${f}" --no-same-owner

	n=0
	if [ ! -s ${OVE_OWEL_DIR}/projs ]; then
		echo "---" > ${OVE_OWEL_DIR}/projs
		n=1
	fi
	for patch in "${OVE_OWEL_TMP_DIR}/import/"*.patch; do
		if ! ove_patch_one_project "$patch"; then
			((ret++))
			continue
		fi
	done

	if [ $ret -eq 0 ] && [ $n -eq 1 ]; then
		# remove empty 2nd line in 'projs'
		${ove_cmd2pathname["sed"]:?} -i -e '2d' ${OVE_OWEL_DIR}/projs
	fi

	# remove revtab duplicates
	# shellcheck disable=SC2016
	if ! out=$(ove_revtab_validate 2> /dev/null); then
		lines=$(r_prev=; while read -r line; do
			n=${line%%:*}
			repo=${line##*:}
			if [ "x$r_prev" = "x" ]; then
				r_prev="$repo"
				continue
			elif [ "$r_prev" == "$repo" ]; then
				echo $n
				continue
			elif [ "$r_prev" != "$repo" ]; then
				r_prev="$repo"
				continue
			fi
		done <<<"$(printf "${out}" | ${ove_cmd2pathname["awk"]:?} '{print $1}')")
		${ove_cmd2pathname["sed"]:?} -i -e "$(printf "%sd;" $lines)" "${OVE_OWEL_DIR}/revtab"
	fi

	return ${ret}
}

function ove_set_proj_mask {
	local a
	local b

	for a in "$@"; do
		b=${a:1}
		if [[ $a == +* ]] && [[ -v ove_projects_name2index[${b}] ]]; then
			unset proj_mask[${b}]
		elif [[ $a == -* ]] && [[ -v ove_projects_name2index[${b}] ]]; then
			proj_mask[${b}]=1
		fi
	done
}

function ove_parse_project_args {
	local a
	local b
	local delete
	local merge
	local c
	declare -a p

	for a in "$@"; do
		merge=0
		delete=0
		if [[ $a == +* ]]; then
			c=${a:1}
			merge=1
		elif [[ $a == -* ]]; then
			c=${a:1}
			delete=1
		else
			c=$a
			merge=0
		fi

		if [ $delete -eq 1 ]; then
			if [ ${#p[*]} -eq 0 ]; then
				continue
			fi
			# is 'c' a tag?
			if [[ -v ove_projects_tags[$c] ]]; then
				mapfile -t p <<<"$(LC_ALL="C" ${ove_cmd2pathname["comm"]:?} -1 -3 \
					<(printf "%s\n" ${ove_projects_tags[$c]} | LC_ALL="C" ${ove_cmd2pathname["sort"]:?}) \
					<(printf "%s\n" ${p[*]} | LC_ALL="C" ${ove_cmd2pathname["sort"]:?}))"
			else
				mapfile -t p <<<"$(printf "%s\n" ${p[*]} | ${ove_cmd2pathname["grep"]:?} -v ^$c$)"
			fi
			continue
		fi

		# just append if 'c' is NOT a tag
		if [[ ! -v ove_projects_tags[$c] ]]; then
			p+=("$c")
			continue
		fi

		# if 'c' is a tag, we want to merge and we have some previous projects to merge with
		if [ $merge -eq 1 ] && [ ${#p[*]} -ge 1 ]; then
			# keep projects that are common between previous results ('p') and projects pointed by the new tag ('c')
			mapfile -t p <<<"$(LC_ALL="C" ${ove_cmd2pathname["comm"]:?} -1 -2 \
				<(printf "%s\n" ${ove_projects_tags[$c]} | LC_ALL="C" ${ove_cmd2pathname["sort"]:?}) \
				<(printf "%s\n" ${p[*]} | LC_ALL="C" ${ove_cmd2pathname["sort"]:?}))"

			if [ ${#p[*]} -eq 0 ] || [ "x${p[0]}" = "x" ]; then
				ove_echo_error_noprefix "no projects found"
				return 1
			fi
		else
			for b in ${ove_projects_tags[$c]}; do
				p+=("$b")
			done
		fi
	done

	if [ ${#p[*]} -eq 0 ] || [ "x${p[0]}" = "x" ]; then
		ove_echo_error_noprefix "no projects found"
		return 1
	fi
	echo "${p[*]}"

	return 0
}

function ove_validate_project_list {
	local a
	declare -a p

	if ! p=("$(ove_parse_project_args "$@")"); then
		return 1
	fi

	for a in ${p[*]}; do
		if ! [[ -v ove_projects_name2index[${a}] ]]; then
			ove_echo_error_noprefix "unknown project '${a}'"
			return 1
		fi
	done

	echo "${p[*]}"

	return 0
}

function ove_build_pre {
	local a
	local p
	local proj_list
	local q
	local re
	local repos

	if [ $# -eq 0 ]; then
		if [ -n "${OVE_PROJECT_LIST_BUILDABLE+x}" ] && \
			[ "${OVE_PROJECT_LIST_BUILDABLE}" != "${OVE_PROJECT_LIST}" ]; then
			ove_echo_error_noprefix "'$(LC_ALL="C" ${ove_cmd2pathname["comm"]:?} -3 \
				<(printf "%s\n" ${OVE_PROJECT_LIST}) \
				<(printf "%s\n" ${OVE_PROJECT_LIST_BUILDABLE}) |
				${ove_cmd2pathname["xargs"]:?})' is not buildable project(s). Try: 'ove fetch'"
			return 1
		fi
	else
		if ! proj_list=$(ove_validate_project_list "$@"); then
			return 1
		fi

		for a in ${proj_list}; do
			if ! [[ -v ove_projects_name2index[$a] ]]; then
				ove_echo_error_noprefix "unknown project '$a'"
				return 1
			fi

			if [ -n "${OVE_PROJECT_LIST_BUILDABLE+x}" ]; then
				re=\\b$a\\b
				if ! [[ "${OVE_PROJECT_LIST_BUILDABLE}" =~ ${re} ]]; then
					for p in $(ove_get_paths_recursive $a | ${ove_cmd2pathname["xargs"]:?} -n1 | LC_ALL="C" ${ove_cmd2pathname["sort"]:?} -u); do
						[ -d ${p} ] && continue
						for q in ${OVE_REPO_LIST}; do
							if [[ ${p} == *"${q}"* ]] && ! [ -d "${q}" ]; then
								repos+="$(ove_repo2shortpath ${q}) "
							fi
						done
					done
					if [ "x${repos}" != "x" ]; then
						repos=$(printf "%s\n" ${repos} | LC_ALL="C" ${ove_cmd2pathname["sort"]:?} -u | ${ove_cmd2pathname["xargs"]:?})
						if [ "x${OVE_AUTO_CLONE}" = "x1" ]; then
							if ! ove-fetch $repos; then
								return 1
							fi
						else
							ove_echo_error_noprefix "'$a' is not a buildable project. Try: 'ove fetch ${repos}'"
							return 1
						fi
					fi
				fi
			fi
		done
	fi

	# create stage/archive directories if needed
	if [ ! -d "${OVE_STAGE_DIR}" ]; then
		${ove_cmd2pathname["mkdir"]:?} -p "${OVE_STAGE_DIR}"
	fi
	if [ ! -d "${OVE_ARCHIVE_DIR}" ]; then
		${ove_cmd2pathname["mkdir"]:?} -p "${OVE_ARCHIVE_DIR}"
	fi

	return 0
}

function ove_build_post {
	local f

	if [ -d ${OVE_STAGE_DIR} ] && \
		[ "$(${ove_cmd2pathname["find"]:?} ${OVE_STAGE_DIR} -maxdepth 1)" == "${OVE_STAGE_DIR}" ]; then
		f+="${OVE_STAGE_DIR} "
	fi

	if [ -d ${OVE_ARCHIVE_DIR} ] && \
		[ "$(${ove_cmd2pathname["find"]:?} ${OVE_ARCHIVE_DIR} -maxdepth 1)" == "${OVE_ARCHIVE_DIR}" ]; then
		f+="${OVE_ARCHIVE_DIR} "
	fi

	if [ "x${f}" != "x" ]; then
		if ! ${ove_cmd2pathname["rmdir"]:?} ${f}; then
			ove_echo_fatal_noprefix "'rmdir ${f}' failed"
		fi
	fi

	return 0
}

function ove_get_build_list {
	local b

	b="$(ove_get_deps_recursive "$@") $*"
	b="$(printf "%s\n" ${b} | LC_ALL="C" ${ove_cmd2pathname["sort"]:?} -u | ${ove_cmd2pathname["xargs"]:?})"

	echo ${b}
}

# list-tags: :list project tags:CORE
function ove-list-tags {
	ove_entry || return
	local t

	if [ ${#ove_projects_tags[*]} -eq 0 ]; then
		return 0
	fi

	for t in ${!ove_projects_tags[*]}; do
		printf "%s|%s\n" $t "${ove_projects_tags[$t]}"
	done | LC_ALL="C" ${ove_cmd2pathname["sort"]:?} | ${ove_cmd2pathname["column"]:?} -t -s'|'
}

# list-needs:[project...|tag...]:list OS packages needs for all/specified project(s):CORE
function ove-list-needs {
	ove_entry || return

	local b
	local build_list
	local i
	local n
	local p
	local pack_list
	local proj_list
	local re
	declare -A proj_mask

	if [ $# -ge 1 ]; then
		if ! proj_list=$(ove_validate_project_list "$@"); then
			return 1
		fi

		build_list="$(ove_get_build_list ${proj_list})"
		ove_set_proj_mask "$@"
	fi

	for b in ${OVE_BUILD_ORDER}; do
		if [ $# -ge 1 ]; then
			re=\\b${b}\\b
			if [[ -v proj_mask[${b}] ]]; then
				continue
			elif ! [[ "${build_list}" =~ ${re} ]]; then
				continue
			fi
		fi

		i=${ove_projects_name2index[${b}]}
		for n in ${ove_projects_needs[${i}]}; do
			pack_list+="${n} "
		done
	done

	if [ "${pack_list}" != "" ]; then
		printf "%s\n" ${pack_list} | \
			LC_ALL="C" ${ove_cmd2pathname["sort"]:?} -u
	fi

	return 0
}

# install-pkg:[project...|tag...]:install needed OS packages:CORE
function ove-install-pkg {
	ove_entry || return

	local pack_list

	if ! pack_list=$(ove-list-needs "${@}"); then
		return 1
	elif [ "${pack_list}" == "" ]; then
		return 0
	fi

	if ! ove_install_packages ${pack_list}; then
		return 1
	fi
}

# buildme:[project...|tag...]:build project(s) from scratch (=bootstrap, configure, build, install):BUILD
function ove-buildme {
	ove_entry || return

	local b
	local build_list
	local p
	local proj_list
	local re
	declare -A proj_mask

	if ! ove_build_pre "$@"; then
		return 1
	fi
	trap ove_build_post EXIT

	# install packages
	if ! ove-install-pkg "$@"; then
		return 1
	fi

	if [ $# -ge 1 ]; then
		if ! proj_list=$(ove_validate_project_list "$@"); then
			return 1
		fi

		build_list="$(ove_get_build_list ${proj_list})"
		ove_set_proj_mask "$@"
	fi

	for p in ${OVE_BUILDME_PRE_STEPS}; do
		for b in ${OVE_BUILD_ORDER}; do
			if [ $# -ge 1 ]; then
				re=\\b${b}\\b
				if [[ -v proj_mask[${b}] ]]; then
					continue
				elif ! [[ "${build_list}" =~ ${re} ]]; then
					continue
				fi
			fi

			! [ -e "${OVE_OWEL_DIR}/projects/${b}/${p}" ] && continue

			if [ "$(type -t ove-${p})" == "function" ] && \
				! eval ove-${p} ${b} ${OVE_REDIRECT_OUTPUT}; then
				ove_echo_error_noprefix "${FUNCNAME[0]}: ${p} ${b} failed"
				return 1
			fi
		done
	done

	for b in ${OVE_BUILD_ORDER}; do
		if [ $# -ge 1 ]; then
			re=\\b${b}\\b
			if [[ -v proj_mask[${b}] ]]; then
				continue
			elif ! [[ "${build_list}" =~ ${re} ]]; then
				continue
			fi
		fi

		for p in ${OVE_BUILDME_STEPS}; do
			if [ "$(type -t ove-${p})" == "function" ] && \
				! eval ove-${p} ${b} ${OVE_REDIRECT_OUTPUT}; then
				ove_echo_error_noprefix "${FUNCNAME[0]}: ove-${p} ${b} failed"
				return 1
			fi
		done
	done

	return 0
}

function ove_buildme_parallel_shell {
	local b
	local build_list
	local dep
	local inotify_max_user_instances
	local p
	local proj_list
	local pid
	local pids
	local re
	local wait_for_deps
	declare -A proj_mask

	if [ ! -e /proc ]; then
		ove_echo_error_noprefix "procfs mount point '/proc' is missing"
		return 1
	fi

	if [ $# -ge 1 ]; then
		if ! proj_list=$(ove_validate_project_list "$@"); then
			return 1
		fi

		build_list="$(ove_get_build_list ${proj_list})"
		ove_set_proj_mask "$@"
	fi

	for p in ${OVE_BUILDME_PRE_STEPS}; do
		for b in ${OVE_BUILD_ORDER}; do
			if [ $# -ge 1 ]; then
				re=\\b${b}\\b
				if [[ -v proj_mask[${b}] ]]; then
					continue
				elif ! [[ "${build_list}" =~ ${re} ]]; then
					continue
				fi
			fi

			! [ -e "${OVE_OWEL_DIR}/projects/${b}/${p}" ] && continue

			{
				if [ "$(type -t ove-${p})" == "function" ] && \
					! eval ove-${p} ${b} ${OVE_REDIRECT_OUTPUT}; then
					ove_echo_error_noprefix "${FUNCNAME[0]}: ${p} ${b} failed"
					kill -USR1 $$
				fi
			} &
			pids+="$! "
		done
	done

	wait ${pids}
	pids=""

	# pids db
	declare -A pids_db=()

	if [ -e /proc/sys/fs/inotify/max_user_instances ]; then
		inotify_max_user_instances=$(($(${ove_cmd2pathname["cat"]:?} /proc/sys/fs/inotify/max_user_instances) - 20))
	else
		inotify_max_user_instances=1024
	fi
	for b in ${OVE_BUILD_ORDER}; do
		if [ $# -ge 1 ]; then
			re=\\b${b}\\b
			if [[ -v proj_mask[${b}] ]]; then
				continue
			elif ! [[ "${build_list}" =~ ${re} ]]; then
				continue
			fi
		fi

		wait_for_deps=""
		for dep in $(ove_get_deps_recursive ${b}); do
			if [[ -v proj_mask[${dep}] ]]; then
				continue
			elif ! [ -e /proc/${pids_db[${dep}]} ]; then
				pids_db[${dep}]=""
				continue
			fi

			wait_for_deps+="${pids_db[${dep}]} "
		done

		{
			for p in ${wait_for_deps}; do
				${ove_cmd2pathname["tail"]:?} -s 0.01 --pid=${p} -f /dev/null &
			done
			[ "${wait_for_deps}" != "" ] && wait

			for p in ${OVE_BUILDME_STEPS}; do
				if [ "$(type -t ove-${p})" == "function" ] && \
					! eval ove-${p} ${b} ${OVE_REDIRECT_OUTPUT}; then
					ove_echo_error_noprefix "${FUNCNAME[0]}: ${p} ${b} failed"
					kill -USR1 $$
				fi
			done
		} &
		pid=$!
		pids_db[${b}]=${pid}
		pids+=" ${pid}"

		while true; do
			if [ $(${ove_cmd2pathname["pgrep"]:?} -f 'tail -s 0.01' | ${ove_cmd2pathname["wc"]:?} -l) -gt ${inotify_max_user_instances} ]; then
				${ove_cmd2pathname["sleep"]:?} 0.1
				continue
			fi
			break
		done
	done

	wait ${pids}

	return 0
}

function ove_buildme_parallel_make {
	local b
	local build_list
	local dep
	local deps
	local makefile
	local p
	local proj_list
	local phony
	local pre_steps
	local re
	declare -A pre_steps_projects
	# shellcheck disable=SC2034
	declare -A proj_mask

	makefile="${OVE_OWEL_TMP_DIR:?}/Makefile"
	${ove_cmd2pathname["cat"]:?} > "${makefile}" << EOF
SHELL := ${ove_cmd2pathname["bash"]:?}
PID := \$(shell echo \$\$PPID)
PREFIX := @MAKEFLAGS="\${OVE_MAKEFLAGS}"
SUFFIX := kill -TERM \$(PID)
define BUILD =
EOF
	for p in ${OVE_BUILDME_STEPS}; do
		if [ "$(type -t ove-${p})" == "function" ]; then
			echo -e "\t\$(PREFIX) ove-${p} \$@ || \$(SUFFIX)" >> ${makefile}
		fi
	done
	echo "endef" >> ${makefile}

	if [ $# -ge 1 ]; then
		if ! proj_list=$(ove_validate_project_list "$@"); then
			return 1
		fi

		build_list="$(ove_get_build_list ${proj_list})"
		ove_set_proj_mask "$@"
	fi

	for p in ${OVE_BUILDME_PRE_STEPS}; do
		for b in ${OVE_BUILD_ORDER}; do
			if [ $# -ge 1 ]; then
				re=\\b${b}\\b
				if [[ -v proj_mask[${b}] ]]; then
					continue
				elif ! [[ "${build_list}" =~ ${re} ]]; then
					continue
				fi
			fi

			if [ ! -e "${OVE_OWEL_DIR}/projects/${b}/${p}" ]; then
				continue
			fi
			echo "${b}_${p}:" >> "${makefile}"
			phony+=" ${b}_$p"
			echo -e "\t\$(PREFIX) ove-${p} ${b} || \$(SUFFIX)" >> "${makefile}"
			pre_steps_projects["${b}"]+="${b}_${p} "
		done
	done

	for b in ${OVE_BUILD_ORDER}; do
		if [ $# -ge 1 ]; then
			re=\\b${b}\\b
			if [[ -v proj_mask[${b}] ]]; then
				continue
			elif ! [[ "${build_list}" =~ ${re} ]]; then
				continue
			fi
		fi

		deps=
		for dep in $(ove_get_deps_recursive ${b}); do
			if [[ -v proj_mask[${dep}] ]]; then
				continue
			fi
			deps+=" $dep"
		done
		if [ "x${deps}" != "x" ]; then
			deps="$(ove_uniq ${deps})"
			deps="$(printf "%s " ${deps})"
			deps=${deps::-1}
		fi
		pre_steps="${pre_steps_projects[${b}]}"
		if [ "x${pre_steps}" != "x" ]; then
			pre_steps=${pre_steps::-1}
		fi
		if [ "x${deps}" = "x" ] && [ "x${pre_steps}" = "x" ]; then
			echo "$b:" >> "${makefile}"
		elif [ "x${deps}" = "x" ] && [ "x${pre_steps}" != "x" ]; then
			echo "$b: ${pre_steps}" >> "${makefile}"
		elif [ "x${deps}" != "x" ] && [ "x${pre_steps}" = "x" ]; then
			echo "$b: ${deps}" >> "${makefile}"
		else
			echo "$b: ${deps} ${pre_steps}" >> "${makefile}"
		fi
		echo -e "\t\$(BUILD)" >> "${makefile}"
		phony+=" $b"
	done

	{ echo ".PHONY:$phony"; \
		echo ".DEFAULT_GOAL := all"; \
		echo "all:$phony"; } >> "${makefile}"

	eval make -f "${makefile}" "${OVE_MAKEFLAGS}"
	return $?
}

# buildme-parallel:[project...|tag...]:build project(s) from scratch (=bootstrap, configure, build, install):BUILD
function ove-buildme-parallel {
	ove_entry || return

	if ! ove_build_pre "$@"; then
		return 1
	fi
	trap ove_build_post EXIT

	if ! ove-install-pkg "$@"; then
		return 1
	fi

	if command -v make > /dev/null; then
		ove_buildme_parallel_make "$@"
	else
		ove_buildme_parallel_shell "$@"
	fi
	return $?
}

# diff-check:[options]:git diff --check [options]:CORE
function ove-diff-check {
	ove_entry || return

	local cmd

	cmd="echo \${PWD}; ove_repo_cmd \${repo} '--no-pager diff' --check $* -- \$(ove_repo_cmd \${repo} diff --name-only)"
	ove_revtab_forall "${cmd}"
}

# list-repositories:[ahead|behind]:list all git repositories or list repositories that are ahead/behind:CORE
function ove-list-repositories {
	ove_entry || return

	local i
	local str
	local url

	if [ $# -eq 0 ]; then
		:
	elif [ $# -eq 1 ] && [ "x$1" == "xbehind" ]; then
		ove_list_repositories "behind"
		return 0
	elif [ $# -eq 1 ] && [ "x$1" == "xahead" ]; then
		ove_list_repositories "ahead"
		return 0
	else
		ove_command_usage
		return 1
	fi

	i=0

	while ((i < ove_revtab_num_repositories)); do
		str+="${ove_revtab_git_name[${i}]} ${ove_revtab_fetch_url[${i}]} ${ove_revtab_push_url[${i}]} ${ove_revtab_rev[${i}]}\n"
		(( i+=1 ))
	done

	url=$(ove_repo_cmd "${OVE_OWEL_DIR}" "config" --get remote.origin.url)
	if [ "${url}" != "" ]; then
		str+="${OVE_OWEL_NAME} ${url} ${url} $(ove_repo_cmd "${OVE_OWEL_DIR}" "rev-parse" --abbrev-ref HEAD 2> /dev/null)\n"
	else
		str+="${OVE_OWEL_NAME} noremote noremote $(ove_repo_cmd "${OVE_OWEL_DIR}" "rev-parse" --abbrev-ref HEAD 2> /dev/null)\n"
	fi

	printf "${str}" | \
		LC_ALL="C" ${ove_cmd2pathname["sort"]:?} | \
		${ove_cmd2pathname["column"]:?} -t
}

# env:[pattern]:show OVE environment variables:CORE
function ove-env {
	ove_entry || return

	local e
	local str
	local v

	if [ $# -eq 0 ]; then
		v=$(compgen -A variable | \
			${ove_cmd2pathname["grep"]:?} OVE_)
	else
		v=$(compgen -A variable | \
			${ove_cmd2pathname["grep"]:?} OVE_ | \
			${ove_cmd2pathname["grep"]:?} -i $1)
	fi

	for e in ${v}; do
		str+="${e}#${!e/\\/\\\\}\n"
	done

	printf "${str}" | \
		LC_ALL="C" ${ove_cmd2pathname["sort"]:?} | \
		${ove_cmd2pathname["column"]:?} -t -s'#'
}

function ove_entry {
	local f

	if [[ ${FUNCNAME[*]} == *"ove_main"* ]]; then
		return
	fi

	if ! ove_get_base_dir &> /dev/null; then
		return 1
	fi

	for f in ${FUNCNAME[*]}; do
		if [ "x${f}" = "xsource" ] || [ "x${f}" = "xmain" ]; then
			continue
		elif [ "x$(type -t ${f})" != "xfunction" ]; then
			ove_echo_stderr_noprefix "$f: command not found"
			return 127
		fi
	done

	# keep this early
	if ! declare -p ove_cmd2pathname &> /dev/null; then
		ove_externals_init
	fi

	if ! [ -v ove_revtab_fetch_url ]; then
		ove_revtab_init
	fi

	if ! [ -v ove_projects_name ]; then
		ove_projects_init
	fi

	if ! declare -p ove_scripts_paths &> /dev/null; then
		ove_scripts_init
	fi

	if ! declare -p ove_hooks_post &> /dev/null; then
		ove_hooks_init
	fi

	if ! declare -p ove_revtab_git_cmd_opts &> /dev/null; then
		ove_git_command_options_init
	fi

	ove_update_terminal_stats
}

# status:[git...]:git status -zbs -uno for all/specified repositories:CORE
function ove-status {
	ove_entry || return

	# turn off monitor mode to get rid of "Done" messages
	set +m

	ove_revtab_status "$@" | \
		${ove_cmd2pathname["grep"]:?} -v '^\['

	# turn on monitor mode
	set -m
}

# news:[git...]:list upstream changes for all/specified repositories:CORE
function ove-news {
	ove_entry || return

	ove-behind "$@"
}

# behind:[git...]:list upstream changes for all/specified repositories:CORE
function ove-behind {
	ove_entry || return

	if [ -w "${OVE_OWEL_STATE_DIR}" ]; then
		ove_revtab_status_parse behind "$@" | ${ove_cmd2pathname["tee"]:?} ${OVE_OWEL_STATE_DIR}/revtab-news
	else
		ove_revtab_status_parse behind "$@"
	fi
}

# show-behind:[git...]:run 'ove show' on upstream changes for all/specified repositories:CORE
function ove-show-behind {
	ove_entry || return

	ove-show-news "$@"
}

# show-news:[git...]:run 'ove show' on upstream changes for all/specified repositories:CORE
function ove-show-news {
	ove_entry || return

	local less_opt
	local line
	local re_a
	local re_b
	local repo
	local sha

	# refresh news
	ove-news "$@" > /dev/null
	[ -s ${OVE_OWEL_STATE_DIR}/revtab-news ] || return

	# remove color codes
	${ove_cmd2pathname["sed"]:?} -i \
		-r \
		-e "s/\x1b\[0;3[0-9];7m//g" \
		-e "s/\x1b\[[0-9]+m//g" \
		-e "s/\x1b\[m//g" ${OVE_OWEL_STATE_DIR}/revtab-news

	re_a=": [0-9]+ new commit"
	re_b="^[a-f0-9]+"
	while read -r line; do
		if [[ "${line}" =~ ${re_a} ]]; then
			repo="${line%%:*}"
		elif [[ "${line}" =~ ${re_b} ]]; then
			clear
			sha=${line%% *}
			if [ ${OVE_LESS_MORE_OPTIONS} -eq 1 ]; then
				less_opt="-X -R -Ps${repo} ${sha}"
			else
				less_opt="-R"
			fi
			LESS="${less_opt}" ove_repo_cmd ${OVE_BASE_DIR}/${repo} '-p show' --first-parent $sha --
		fi
	done<${OVE_OWEL_STATE_DIR}/revtab-news
}

# ahead:[git...]:list local commits not yet published for all/specified repositories:CORE
function ove-ahead {
	ove_entry || return

	if [ -w "${OVE_OWEL_STATE_DIR}" ]; then
		ove_revtab_status_parse ahead "$@" | ${ove_cmd2pathname["tee"]:?} ${OVE_OWEL_STATE_DIR}/revtab-ahead
	else
		ove_revtab_status_parse ahead "$@"
	fi
}

# show-ahead:[git...]:run 'ove show' on local commits not yet published for all/specified repositories:CORE
function ove-show-ahead {
	ove_entry || return

	local sha_list

	# refresh ahead
	ove-ahead "$@" > /dev/null

	sha_list="$(${ove_cmd2pathname["grep"]:?} -o '^[a-f0-9]\+' ${OVE_OWEL_STATE_DIR}/revtab-ahead | ${ove_cmd2pathname["tac"]:?})"
	[ "${sha_list}" == "" ] && return

	ove-show ${sha_list}
}

# reset-ahead:[git...]:git reset --hard HEAD~N where N is number of commits ahead for all or specified repositories, USE WITH CARE:CORE
function ove-reset-ahead {
	ove_entry || return

	ove-ahead "$@" | \
		${ove_cmd2pathname["sed"]:?} -r \
		-e "s/\x1b\[0;3[0-9];7m//g" \
		-e "s/\x1b\[[0-9]+m//g" \
		-e "s/\x1b\[m//g" | \
		${ove_cmd2pathname["grep"]:?} --color=never ': [0-9]\+ new commit' | \
		while IFS=' ' read -r repo n foo bar; do
			repo=${repo/:/}
			ove_repo_cmd ${OVE_BASE_DIR}/${repo} reset --hard HEAD~${n} |& ${ove_cmd2pathname["sed"]:?} -e "s,^,${repo}: ,g"
		done
}

# rebase-autosquash:[git...]:run 'git rebase -i HEAD~N --autosquash' where N is the number of local commits not yet published:CORE
function ove-rebase-autosquash {
	ove_entry || return

	if ${ove_cmd2pathname["git"]:?} help config &> /dev/null; then
		if ! ${ove_cmd2pathname["git"]:?} help config | ${ove_cmd2pathname["grep"]:?} -q GIT_SEQUENCE_EDITOR; then
			ove_echo_error_noprefix "'GIT_SEQUENCE_EDITOR' not available, too old git version?"
			return 1
		fi
	fi

	ove-ahead "$@"
	ove-ahead "$@" | \
		${ove_cmd2pathname["sed"]:?} -r \
		-e "s/\x1b\[0;3[0-9];7m//g" \
		-e "s/\x1b\[[0-9]+m//g" \
		-e "s/\x1b\[m//g" | \
		${ove_cmd2pathname["grep"]:?} --color=never ': [0-9]\+ new commit' | \
		while IFS=' ' read -r repo n foo bar; do
			repo=${repo/:/}
			ove_echo_yellow_noprefix ${repo}
			GIT_SEQUENCE_EDITOR=: ove_repo_cmd ${OVE_BASE_DIR}/${repo} rebase -i HEAD~${n} --autosquash |& ${ove_cmd2pathname["sed"]:?} -e "s/^/${repo}: /g"
			if [ ${PIPESTATUS[0]} -ne 0 ]; then
				ove_echo_error_noprefix "rebase failed for '${repo}'"
				return 1
			fi
		done
	ove-ahead "$@"
}

# format-patch:[name]:create a bz2 archive for all local commits not yet published:CORE
function ove-format-patch {
	ove_entry || return

	local d
	local f

	d="${OVE_OWEL_TMP_DIR}/format-patch"
	${ove_cmd2pathname["mkdir"]:?} -p ${d}
	${ove_cmd2pathname["find"]:?} ${d} -mindepth 1 -maxdepth 1 -type d -exec rm -rf {} \;

	ove-ahead | \
		${ove_cmd2pathname["sed"]:?} -r \
		-e "s/\x1b\[0;3[0-9];7m//g" \
		-e "s/\x1b\[[0-9]+m//g" \
		-e "s/\x1b\[m//g" | \
		${ove_cmd2pathname["grep"]:?} --color=never ': [0-9]\+ new commit' | \
		while IFS=' ' read -r repo n foo bar; do
			repo=${repo/:/}
			if [ "x$repo" = "x$OVE_OWEL_NAME" ]; then
				repo=".owel"
			fi
			${ove_cmd2pathname["mkdir"]:?} -p ${d}/${repo}
			ove_repo_cmd ${OVE_BASE_DIR}/${repo} format-patch -q -${n} -o ${d}/${repo}
		done

	if [ $(${ove_cmd2pathname["find"]:?} ${d} -type f | ${ove_cmd2pathname["wc"]:?} -l) -eq 0 ]; then
		return 1
	fi

	if [ $# -eq 1 ]; then
		f="$1"
		if [[ "${f}" != *.tar.bz2 ]]; then
			f+=".tar.bz2"
		fi
	else
		f="${PWD}/${OVE_OWEL_NAME}-patches-$(${ove_cmd2pathname["date"]:?} '+%Y%m%d-%H%M%S').tar.bz2"
	fi

	if ! ${ove_cmd2pathname["tar"]:?} -C "${d}" -cjf "${f}" --owner=0 --group=0 .; then
		ove_echo_error_noprefix "format-patch: tar failed"
		return 1
	fi
	${ove_cmd2pathname["readlink"]:?} -f -- "${f}"
}

# am:file:apply a bz2 archive file created with 'format-patch':CORE
function ove-am {
	ove_entry || return

	local d
	local r
	local repos
	local ret=0

	if [ $# -ne 1 ]; then
		ove_command_usage
		return 1
	fi

	if ! [ -e $1 ]; then
		ove_command_usage
		return 1
	fi

	d="${OVE_OWEL_TMP_DIR}/am"
	${ove_cmd2pathname["mkdir"]:?} -p ${d}
	${ove_cmd2pathname["find"]:?} ${d} -mindepth 1 -maxdepth 1 -type d -exec rm -rf {} \;

	# unpack
	${ove_cmd2pathname["tar"]:?} -C "${d}" -xf "$1" --no-same-owner || return 1

	repos=$(${ove_cmd2pathname["find"]:?} ${d} -type f -print0 | ${ove_cmd2pathname["xargs"]:?} -0 dirname | LC_ALL="C" ${ove_cmd2pathname["sort"]:?} -u)
	[ "${repos}" == "" ] && return 1
	for r in ${repos}; do
		r=${r/${d}\/}
		if [ "x$r" = "x.owel" ]; then
			ove_echo_yellow_noprefix "${OVE_OWEL_NAME}"
		else
			ove_echo_yellow_noprefix "${r}"
		fi

		if [ ! -d "${OVE_BASE_DIR}/${r}" ]; then
			ove_echo_error_noprefix "repo '${OVE_BASE_DIR}/${r}' does not exist, try 'ove fetch ${r}'"
			((ret++))
			continue
		fi

		# apply patch(es)
		if ! ove_repo_cmd ${OVE_BASE_DIR}/${r} am ${d}/${r}/*; then
			ove_echo_error_noprefix "git am failed for repo '${r}'. Automatically running 'git am --abort'. Failed patch(es): ${d}/${r}/"
			ove_repo_cmd ${OVE_BASE_DIR}/${r} am --abort
			((ret++))
		fi
	done

	return ${ret}
}

# $1: behind|ahead
function ove_any_repo {
	# shellcheck disable=SC2016
	if ove_revtab_forall_parallel 'ove_repo_cmd ${repo} "branch" -v | ${ove_cmd2pathname["grep"]:?} ^\*' | \
		${ove_cmd2pathname["grep"]:?} -q "${1}.*]"; then
		return 0
	else
		return 1
	fi
}

# $1: behind|ahead
function ove_list_repositories {
	local repos

	# shellcheck disable=SC2016
	repos=$(ove_revtab_forall_parallel 'ove_repo_cmd ${repo} "branch" -v | ${ove_cmd2pathname["sed"]:?} -e "s|^\*|${repo_basename}|g"' |
		${ove_cmd2pathname["grep"]:?} "${1}.*]" |
		${ove_cmd2pathname["cut"]:?} -d' ' -f1)

	if [ "x${repos}" != "x" ]; then
		printf "%s\n" ${repos}
	fi
}

# pull:[git...]:git pull for all/specified repositories:CORE
function ove-pull {
	ove_entry || return

	local repo
	local repos

	# turn off monitor mode to get rid of "Done" messages
	set +m

	if [ $# -ge 1 ]; then
		for repo in $(ove_validate_repo_list ${*//${OVE_BASE_DIR}\/}); do
			if ove_repo_is_dirty ${OVE_BASE_DIR}/${repo}; then
				ove_echo_error_noprefix "cannot pull '${repo}' as it is dirty"
				continue
			fi
			repos+="${repo} "
		done
	else
		if ove_any_repo behind; then
			for repo in $(ove_list_repositories "behind"); do
				if ove_repo_is_dirty ${OVE_BASE_DIR}/${repo}; then
					ove_echo_error_noprefix "cannot pull '${repo}' as it is dirty"
					continue
				fi

				repos+="${repo} "
			done
		else
			repos=${OVE_REPO_LIST//${OVE_BASE_DIR}\/}
		fi
	fi

	for repo in ${repos}; do
		ove_revtab_pull_one ${repo} | ${ove_cmd2pathname["grep"]:?} -v '^\['
		if [ ${PIPESTATUS[0]} -ne 0 ]; then
			return 1
		fi

		if [ "${repo##*/}" == "${OVE_OWEL_NAME}" ]; then
			# validate revtab revision
			ove_revtab_check

			# patch repos
			ove_patch_repos
		fi
	done

	if [ "${repos}" != "" ]; then
		ove_revtab_status ${repos} | ${ove_cmd2pathname["grep"]:?} -v '^\['
	fi

	# turn on monitor mode
	set -m
}

# apply:patch:apply one OVE patch:CORE
function ove-apply {
	ove_entry || return

	local lineno
	local p
	local patches
	local q
	local repo_basename
	local repo_fullpath
	local ret=0

	if [ $# -ne 1 ]; then
		ove_command_usage
		return 1
	fi

	if ! command -v csplit > /dev/null; then
		ove_command_not_found "csplit"
		return 1
	fi

	if ! [ -e "$1" ]; then
		ove_echo_error_noprefix "'$1' patch file not found"
		return 1
	fi

	if ! [ -s "$1" ]; then
		ove_echo_error_noprefix "'$1' is empty"
		return 1
	fi

	${ove_cmd2pathname["cp"]:?} -a "$1" "${OVE_OWEL_TMP_DIR}"
	p="${OVE_OWEL_TMP_DIR}/${1##*/}"

	# get a list of line numbers where to split the file
	lineno=$(${ove_cmd2pathname["grep"]:?} -n "${OVE_COLOR_YELLOW_X}" "${p}"| ${ove_cmd2pathname["tail"]:?} -n +2 | ${ove_cmd2pathname["cut"]:?} -d: -f1 | ${ove_cmd2pathname["xargs"]:?})

	# remove color codes
	${ove_cmd2pathname["sed"]:?} -i \
		-r \
		-e "s/\x1b\[[0-1];3[0-9];7m//g" \
		-e "s/\x1b\[[0-9]+m//g" \
		-e "s/\x1b\[m//g" ${p}

	if ! ${ove_cmd2pathname["file"]:?} "${p}" | ${ove_cmd2pathname["grep"]:?} -q "unified diff"; then
		ove_echo_error_noprefix "'${p}' is not a unified diff"
		return 1
	fi

	# remove any old patch file(s)
	${ove_cmd2pathname["find"]:?} ${OVE_OWEL_TMP_DIR} -maxdepth 1 -name 'ove-apply-patch*' -exec rm {} \;

	if [ "${lineno}" == "" ]; then
		patches=${p}
	else
		# one patch per git
		if ! ${ove_cmd2pathname["csplit"]:?} -s -z --prefix ${OVE_OWEL_TMP_DIR}/ove-apply-patch ${p} ${lineno}; then
			ove_echo_error_noprefix "ops, csplit failed"
			return 1
		fi

		patches=$(${ove_cmd2pathname["find"]:?} ${OVE_OWEL_TMP_DIR} -maxdepth 1 -name 'ove-apply-patch*' | LC_ALL="C" ${ove_cmd2pathname["sort"]:?})
	fi

	for p in ${patches}; do
		repo_basename=$(${ove_cmd2pathname["head"]:?} -1 -q ${p})
		repo_basename=${repo_basename/${OVE_BASE_DIR}\/}
		repo_fullpath=$(ove_repo2fullpath ${repo_basename})
		if [ "${repo_fullpath}" == "" ] || ! [ -d "${repo_fullpath}" ]; then
			ove_echo_yellow_noprefix "'${repo_basename}': unknown repo, next..."
			continue
		fi

		# rename the patch
		q="${OVE_OWEL_TMP_DIR}/ove-apply-${repo_basename////-}.patch"
		${ove_cmd2pathname["mv"]:?} ${p} ${q}
		if [ -d "${repo_fullpath}" ] && \
			[ -e ${repo_fullpath}/.git ]; then
			# Run 'git apply --check' and if ok, apply the patch
			if ! ove_repo_cmd "${repo_fullpath}" apply --check ${q} 2> /dev/null; then
				ove_echo_yellow_noprefix "${repo_basename}: patch '${q}' does not apply"
				((ret++))
				continue
			fi

			# apply the patch
			ove_repo_cmd "${repo_fullpath}" apply ${q}
		fi
	done

	return ${ret}
}

# $1: repo
# $2: patch file
function ove_patch_one_repo {
	local p
	local repo
	local ret=0
	local repo_shortpath

	repo="$1"
	p="$2"
	repo_s="$(ove_repo2shortpath ${repo})"

	if [ ! -d "${repo}" ]; then
		return 0
	elif ove_repo_cmd ${repo} apply -R --check "${p}" 2> /dev/null; then
		return 0
	elif ove_repo_cmd ${repo} apply --check "${p}" 2> /dev/null; then
		printf "%-${OVE_REPO_LIST_WIDTH}sApplying patch '%s'\n" ${repo_s} ${p}
		if [ "${OVE_PATCH_REPOS_METHOD:?}" = "apply" ]; then
			if ! ove_repo_cmd ${repo} apply "${p}" 2> /dev/null; then
				ove_echo_error_noprefix "${repo_s}: patch does not apply: ${p}"
				ret=1
			fi
		elif [ "${OVE_PATCH_REPOS_METHOD:?}" = "am" ] || [ "${OVE_PATCH_REPOS_METHOD:?}" = "auto" ]; then
			if ! ove_repo_cmd ${repo} am "${p}" 2> /dev/null; then
				if [ "${OVE_PATCH_REPOS_METHOD:?}" = "am" ]; then
					ove_echo_error_noprefix "${repo_s}: patch does not apply: ${p}"
					ret=1
				elif ! ove_repo_cmd ${repo} apply "${p}" 2> /dev/null; then
					ove_echo_error_noprefix "${repo_s}: patch does not apply: ${p}"
					ret=1
				fi
			fi
		else
			ove_echo_error_noprefix "unknown patch method: ${OVE_PATCH_REPOS_METHOD}"
			ret=1
		fi
	else
		ove_echo_error_noprefix "${repo_s}: patch does not apply: ${p}"
		ret=1
	fi

	return ${ret}
}

# $1: repos [optional]
function ove_patch_repos {
	local find_opts
	local find_search_dirs
	local n=${FUNCNAME^^}
	local p
	local repo
	local repos
	local ret=0

	if  [ ! -d ${OVE_OWEL_DIR}/patches ]; then
		return
	elif [ -n "${!n}" ] && [ "${!n}" -eq 0 ]; then
		return
	fi

	if [ $# -eq 0 ]; then
		find_search_dirs="${OVE_OWEL_DIR}/patches/"
	else
		repos=$(ove_validate_repo_list "$@")
		if [ "x${repos}" = "x" ]; then
			return 1
		fi

		for repo in ${repos}; do
			if [ ! -d "${OVE_OWEL_DIR}/patches/${repo}" ]; then
				continue
			fi
			find_opts="-maxdepth 1"
			find_search_dirs+="${OVE_OWEL_DIR}/patches/${repo} "
		done
		if [ "x${find_search_dirs}" = "x" ]; then
			return 1
		fi
	fi

	if [ "${OVE_PATCH_REPOS_METHOD:?}" = "am" ] && ! ove_git_config_check; then
		ove_echo_warning_noprefix "not possible to patch repo(s) using 'git am' as git config user.email/user.name is not set"
		return 1
	fi

	while read -r p; do
		repo="${p/${OVE_OWEL_DIR}\/patches\/}"
		repo="${repo%/*}"
		repo="${OVE_BASE_DIR}/${repo}"

		if ! ove_patch_one_repo "${repo}" "${p}"; then
			((ret++))
		fi
	done < <(${ove_cmd2pathname["find"]:?} ${find_search_dirs} ${find_opts} -name "*.patch" -or -name "*.diff" | LC_ALL="C" ${ove_cmd2pathname["sort"]:?})

	return ${ret}
}

# patch-repo:[git...]:patch all/specified repositories (ignore OVE_PATCH_REPO) with $OVE_OWEL_DIR/patches/[<git>/]{*.diff,*.patch}:CORE
function ove-patch-repo {
	ove_entry || return

	OVE_PATCH_REPOS=1 ove_patch_repos "$@"
}

# append revtab with submodules
function ove_submodule2revtab {
	local repo
	local repos_with_submodules
	local sha
	local submodule

	if [ $# -eq 0 ]; then
		return
	fi

	for repo in "$@"; do
		[ -s ${repo}/.gitmodules ] && repos_with_submodules+="${repo} "
	done

	if [ "x${repos_with_submodules}" = "x" ]; then
		return
	fi

	for repo in ${repos_with_submodules}; do
		# shellcheck disable=SC2016
		for submodule in $(ove_repo_cmd ${repo} submodule--helper list | ${ove_cmd2pathname["awk"]:?} '{print $4}'); do
			# already imported?
			if [ -v ove_revtab_name2index[${repo//${OVE_BASE_DIR}\/}/${submodule}] ]; then
				continue
			fi

			url=$(ove_repo_cmd ${repo} config --file .gitmodules --list | \
				${ove_cmd2pathname["grep"]:?} "^submodule.${submodule}.url=" | \
				${ove_cmd2pathname["cut"]:?} -d= -f2)
			if [ "x${url}" = "x" ]; then
				continue
			fi

			# shellcheck disable=SC2016
			sha=$(ove_repo_cmd ${repo} submodule--helper list | \
				${ove_cmd2pathname["awk"]:?} '{print $4,$2}' | \
				${ove_cmd2pathname["grep"]:?} "^${submodule} " | ${ove_cmd2pathname["awk"]:?} '{print $2}')
			if [ "x${sha}" = "x" ]; then
				continue
			fi

			echo "${repo//${OVE_BASE_DIR}\/}/${submodule} ${url} ${url} ${sha}"
		done
	done | ${ove_cmd2pathname["tee"]:?} -a ${OVE_OWEL_DIR}/revtab

	return
}

# import-submodules:[git]:append submodule(s) to 'revtab' and run fetch for all/specified git repositories:CORE
function ove-import-submodules {
	ove_entry || return
	ove_revtab_sanity || return

	local imports
	local out
	local repos

	if [ $# -ge 1 ]; then
		repos=$(ove_validate_repo_list "$@")
	else
		repos=${OVE_REPO_LIST}
	fi
	[ "${repos}" == "" ] && return

	while true; do
		out=$(ove_submodule2revtab ${repos})
		# shellcheck disable=SC2016
		imports=$(printf "%s\n" "${out}" | ${ove_cmd2pathname["awk"]:?} '{print $1}')
		if [ "x$imports" = "x" ]; then
			break
		elif ! ove_reinit; then
			return 1
		elif ! ove-fetch $imports; then
			ove_echo_warning_noprefix "'ove fetch $(printf "%s " $imports)' failed"
		fi
	done

	return 0
}

# do:dir command:run a command within 'dir' relative to ${OVE_BASE_DIR}:CORE
function ove-do {
	ove_entry || return

	local cmd
	local dir

	dir=${1/${OVE_BASE_DIR}}
	cmd="${*:2}"

	if ! [ -d "${OVE_BASE_DIR}/${dir}" ]; then
		ove_echo_error_noprefix "'${OVE_BASE_DIR}/${dir}' is not a directory"
		return 1
	fi

	cd ${OVE_BASE_DIR}/${dir} && eval "${cmd}"
}

# fetch-fetched: :git fetch for already fetched repositories, ends with ove status:CORE
function ove-fetch-fetched {
	ove_entry || return

	# shellcheck disable=SC2016
	ove-fetch $(ove-status | ${ove_cmd2pathname["awk"]:?} '{print $1}')
}

# fetch:[git...]:git fetch for all/specified repositories, ends with ove status:CORE
function ove-fetch {
	ove_entry || return

	local repos

	if [ $# -ne 0 ]; then
		repos=$(ove_validate_repo_list "$@")
		[ "${repos}" == "" ] && return 1
	fi

	if ! ove_revtab_fetch ${repos}; then
		return $?
	fi

	ove-status ${repos}
}

# tag: :list git tags within ${OVE_OWEL_DIR}:CORE
function ove-tag {
	ove_entry || return

	ove_repo_cmd "${OVE_OWEL_DIR}" log --tags --simplify-by-decoration --pretty="format:%ai %D"
}

# log: :project commit log for branch '${OVE_OWEL_CI_BRANCH}':CORE
function ove-log {
	ove_entry || return

	local b

	if ove_repo_cmd "${OVE_OWEL_DIR}" branch -r | ${ove_cmd2pathname["grep"]:?} -q ${OVE_OWEL_CI_BRANCH}; then
		b="${OVE_OWEL_CI_BRANCH}"
	fi

	ove_repo_cmd "${OVE_OWEL_DIR}" log --decorate ${b}
}

# checkout:[rev[ [purge|autostash]]]:git checkout for all git repositories or checkout a new project revision, USE 'purge' WITH CARE:CORE
function ove-checkout {
	ove_entry || return

	local cmd
	local dirty_repos
	local m
	local proj
	local repo
	local revision

	revision="$1"

	if [ $# -eq 0 ]; then
		dirty_repos=$(ove_list_dirty_repos)

		# shellcheck disable=SC2016
		cmd='ove_repo_cmd ${repo} diff --quiet || (ove_echo_yellow_noprefix ${repo_basename}; ALLOW_OVERRIDE=1 ove_repo_cmd ${repo} checkout)'
		(ove_revtab_forsome "${cmd}" "${dirty_repos}")

		[[ "${dirty_repos}" =~ ${OVE_OWEL_NAME} ]] && ove_reinit
	elif [ $# -eq 1 ] || [ $# -eq 2 ]; then
		if [ "$2" == "purge" ]; then
			# shellcheck disable=SC2016
			cmd='ove_repo_cmd ${repo} reset; ove_repo_cmd ${repo} checkout .'

			read -p "Proceed to run 'git reset && git checkout .' for all git repositories? (y/N) " -r
			echo
			if [[ ${REPLY} =~ ^[Yy]$ ]]; then
				read -p "Are you really sure? (y/N) " -r
				echo
				if [[ ${REPLY} =~ ^[Yy]$ ]]; then
					ove_revtab_forall "${cmd}"
				fi
			fi
		elif [ "$2" == "autostash" ]; then
			dirty_repos=$(ove_list_dirty_repos)

			for repo in ${dirty_repos}; do
				ove_repo_cmd "${repo}" stash save -q "stashed by ove-checkout"
			done
		else
			dirty_repos=$(ove_list_dirty_repos)

			if [ "${dirty_repos}" != "" ]; then
				ove_echo_error_noprefix "you have staged/unstaged changes in the following repositories:"
				ove-status ${dirty_repos}
				return 1
			fi
		fi

		if [ ${OVE_REVTAB_CHECK} -eq 0 ]; then
			ove_echo_yellow_noprefix "WARNING: revtab check (=OVE_REVTAB_CHECK) is DISABLED for this workspace"
			ove_echo_yellow_noprefix "WARNING: all repos (except '${OVE_OWEL_NAME}') will stay on their current revisions"
			echo
		fi

		ove_repo_cmd "${OVE_OWEL_DIR}" fetch

		m=${OVE_REPO_LIST_WIDTH}
		ove_repo_cmd "${OVE_OWEL_DIR}" "-c advice.detachedHead=false checkout" "${revision}" |& \
			${ove_cmd2pathname["sed"]:?} -e "1s|^|$(ove_echo_yellow_noprefix ${OVE_OWEL_NAME})$(printf "%0.s " $(eval echo {1..$((${m} - ${#OVE_OWEL_NAME}))}))|g" \
			-e "2s|^|$(printf "%0.s " $(eval echo {1..$((${m}))}))|g"
		if [ ${PIPESTATUS[0]} -ne 0 ]; then
			# cleanup
			if [ "$2" == "autostash" ]; then
				for repo in ${dirty_repos}; do
					ove_repo_cmd "${OVE_BASE_DIR}/${repo}" stash pop -q
				done
			fi

			return 1
		fi

		echo ---

		# init everything
		ove_init

		# clone and checkout
		ove_revtab_clone_and_checkout

		# validate revtab revision
		ove_revtab_check

		if [ "$2" == "autostash" ]; then
			for repo in ${dirty_repos}; do
				ove_repo_cmd "${OVE_BASE_DIR}/${repo}" stash pop -q
			done
		fi

		# patch all repos
		ove_patch_repos
	fi

	return 0
}

# list-commands:[pattern]:list commands:CORE
function ove-list-commands {
	ove_entry || return

	local _help
	local a
	local b
	local c
	local r
	local s

	if [ $# -eq 1 ] && [ "x$1" = "xPLUGIN" ]; then
		{
			echo "cmd:args:help:repo"
			echo "---"
			for a in $(ove-list-scripts); do
				s=${a##*/}
				_help=$(set | \
					${ove_cmd2pathname["grep"]:?} ove_plugin_helptext=\"$s: | \
					${ove_cmd2pathname["grep"]:?} -v '\$'| \
					${ove_cmd2pathname["cut"]:?} -d'"' -f2 | \
					${ove_cmd2pathname["sed"]:?} -e 's,PLUGIN$,,g')

				if [[ "$a" == $OVE_OWEL_DIR* ]]; then
					echo "$_help:$OVE_OWEL_NAME"
					continue
				elif [[ "$a" == $OVE_DIR* ]]; then
					echo "$_help:OVE"
					continue
				fi
				r=${a//${OVE_BASE_DIR}\/}
				r=${r/\/.ove*}
				echo "$_help:$r"
			done
		} | ${ove_cmd2pathname["column"]:?} -t -s':'
		return 0
	fi

	a=$(${ove_cmd2pathname["grep"]:?} -B1 "^function ove-" "${OVE_BASE_DIR}"/ove | \
		${ove_cmd2pathname["grep"]:?} '#' | \
		${ove_cmd2pathname["cut"]:?} -b3-| \
		LC_ALL="C" ${ove_cmd2pathname["sort"]:?})
	b=$(set | \
		${ove_cmd2pathname["grep"]:?} helptext | \
		${ove_cmd2pathname["grep"]:?} -v '\$'| \
		${ove_cmd2pathname["cut"]:?} -d'"' -f2)

	c=$(printf "${a}\n${b}")

	{
		echo "cmd:args:help:category"
		{
			echo "---"
			if [ $# -eq 1 ]; then
				printf "${c}\n" | ${ove_cmd2pathname["grep"]:?} "$1"
			else
				printf "${c}\n"
			fi
		} | LC_ALL="C" ${ove_cmd2pathname["sort"]:?};
	} | ${ove_cmd2pathname["column"]:?} -t -s:
}

# help:[pattern]:OVE help:CORE
function ove-help {
	ove_entry || return

	if [ $# -eq 0 ]; then
		ove_help
	else
		ove_help | ${ove_cmd2pathname["grep"]:?} -E --color=always "${1}"
	fi
}

function ove_list_command_categories {
	# shellcheck disable=SC2059,SC2016
	ove-list-commands | \
		${ove_cmd2pathname["awk"]:?} '{print $NF}' | \
		${ove_cmd2pathname["sort"]:?} -u | \
		${ove_cmd2pathname["grep"]:?} '[A-Z]'
}

# list-commands-by-category: :list commands grouped by category:CORE
function ove-list-commands-by-category {
	local c

	for c in $(ove_list_command_categories); do
		if [ "x$c" = "xPLUGIN" ]; then
			continue
		fi
		ove-list-commands | ${ove_cmd2pathname["grep"]:?} -E "$c|^cmd|^---"
		echo
		echo
		echo
	done

	ove_echo_cyan_noprefix "PLUGIN"
	ove-list-commands PLUGIN
}

function ove_help {
	local f
	local g
	local h

	ove_echo_cyan_noprefix "commands"
	echo "--------"
	ove-list-commands
	echo
	${ove_cmd2pathname["cat"]:?} <<EOF

$(ove_echo_cyan_noprefix "EXAMPLES")
--------

$(ove_echo_cyan_noprefix "high level git commands")
-----------------------
# status of all git repositories
$ ove status

# synchronize with the outside world
$ ove fetch

# view local changes in all repos
$ ove diff

# interactively ask what hunk to checkout
$ ove checkout

# checkout a specific revision
$ ove checkout 1.0.2

# search for the string 'deadbeef'
$ ove grep deadbeef

# create a archive of all 'ahead'-commits
$ ove format-patch featY.tar.bz2

# apply an archive that someone sent me
$ ove am featY.tar.bz2

$(ove_echo_cyan_noprefix "build related commands")
----------------------
# list build order
$ ove build-order

# initial build for all projects, runs 'bootstrap, configure, build, install'
$ ove buildme
$ ove buildme-parallel

# first build for a specific project 'projX', runs 'bootstrap, configure, build, install' for projX and all deps
$ ove buildme projX
$ ove buildme-parallel projX

# build projects in order, runs '[clean], build, install' for all projects
$ ove make

# build a specific project and all project dependencies, runs '[clean], build, install' for projX and deps
$ ove make projX

# build a specific project without dependencies, runs 'build, install' for projX
$ ove make projX-nodeps

# clean projects
$ ove clean

# remove all untracked files for all git repositories USE WITH CARE
$ ove mrproper

$(ove_echo_cyan_noprefix "utility commands")
----------------
# list patches your friends have upstreamed since your last pull
$ ove news

# show new patches
$ ove show-news (or show-behind)

# run 'ls -l' for all repos
$ ove forall ls -l

# run 'git maintenance run --quiet' for all repos (in parallel)
$ ove forall-parallel git maintenance run --quiet

# open your modified files in vi/emacs
$ ove vi
$ ove emacs

# open modified files in vi, but only files with 'test' in the name
$ ove vi test

# search all repositories for 'au' using The Silver Searcher
$ ove ag au

# search all repositories using fzf and vi
$ ove gfv "int i = 0"

# trigger a build of projX when a file is modified
$ ove clean projX && ove loop 0 1 0 build projX
# now modify a file within projX in another tmux pane/terminal

# open a few tmux panes that runs the following OVE commands: news, ahead, fetch
$ ove ide

$(ove_echo_cyan_noprefix "configuration")
-------------
# OVE tries to keep all repos in-sync with whatever is stated in the '\${OVE_OWEL_DIR}/revtab' file.
# If you don't want this behaviour set the 'OVE_REVTAB_CHECK' config to '0'. Choose one of:
$ ove add-config \${OVE_OWEL_DIR}/.oveconfig OVE_REVTAB_CHECK 0
$ ove add-config \${OVE_OWEL_STATE_DIR}/.oveconfig OVE_REVTAB_CHECK 0
$ ove add-config \${OVE_GLOBAL_STATE_DIR}/.oveconfig OVE_REVTAB_CHECK 0
$ ove add-config \${HOME}/.oveconfig OVE_REVTAB_CHECK 0

# NOTE: OVE config files are read in this order:
\${OVE_OWEL_DIR}/.oveconfig -> \${OVE_OWEL_STATE_DIR}/.oveconfig -> \${OVE_GLOBAL_STATE_DIR}/.oveconfig -> \${HOME}/.oveconfig
# I.e. '\${HOME}/.oveconfig' has the highest precedence.
EOF

	f=$(ove_revtab_list_fullpath)
	f="${f// /\/.ove/help }/.ove/help"

	# project and repo specific help
	for h in "${OVE_OWEL_DIR}/help" ${f}; do
		[ -s "${h}" ] || continue
		echo
		g=${h//${OVE_BASE_DIR}\/}
		ove_echo_cyan_noprefix "${g}"
		printf "%0.s-" $(eval echo {1..$((${#g}))})
		echo
		if [ -x "${h}" ]; then
			source "${h}"
		else
			${ove_cmd2pathname["cat"]:?} "${h}"
		fi
	done
}

# rg:pattern:search OVE workspace using rg [duckduckgo.com/?q=ripgrep]:SEARCH
function ove-rg {
	ove_entry || return

	local cmd

	if ! command -v rg > /dev/null; then
		ove_command_not_found "rg"
		return 1
	fi

	if [ $# -ne 1 ]; then
		if [ $# -eq 0 ]; then
			echo "error: no pattern"
		fi
		ove_command_usage
		return 1
	fi

	cmd="\rg --no-ignore --hidden -S -n --color=always $* -- | "
	# shellcheck disable=SC2016
	cmd+='${ove_cmd2pathname["sed"]:?} -e "s,^,${PWD}/,g"'
	if ! (cd $OVE_BASE_DIR || exit; eval $cmd; ); then
		return 1
	fi
}

# ag:pattern:search OVE workspace using ag [duckduckgo.com/?q=The+Silver+Searcher]:SEARCH
function ove-ag {
	ove_entry || return

	local cmd

	if ! command -v ag > /dev/null; then
		ove_command_not_found "ag"
		return 1
	fi

	if [ $# -ne 1 ]; then
		if [ $# -eq 0 ]; then
			echo "error: no pattern"
		fi
		ove_command_usage
		return 1
	fi

	cmd="${ove_cmd2pathname["ag"]:?} --hidden -U --color '$*' -- | "
	# shellcheck disable=SC2016
	cmd+='${ove_cmd2pathname["sed"]:?} -e "s,^,${PWD}/,g"'
	if ! (cd $OVE_BASE_DIR || exit; eval $cmd; ); then
		return 1
	fi
}

# grep:[options] pattern:git grep [options] for all git repositories:SEARCH
function ove-grep {
	ove_entry || return

	if [ $# -eq 0 ]; then
		echo "error: no pattern"
		ove_command_usage
		return 1
	fi

	ALLOW_OVERRIDE=1 ove_git_cmd_forall_parallel 0 "grep" "$@"
}

function ove_gf_helper {
	if ! command -v fzf > /dev/null; then
		ove_command_not_found "fzf"
		echo "duckduckgo.com/?q=fzf"
		return 1
	fi

	if [ $# -ne 1 ]; then
		echo "error: no pattern"
		return 1
	fi

	ove_git_cmd_forall_parallel 0 "grep -i -I -n --color=never" "$@"  | \
		${ove_cmd2pathname["sed"]:?} -e "s,^\([^:]*\):\([0-9]\+\):,\1 +\2 ,"
}

# gfv:pattern:git grep+fzf+vi combo:UTIL
function ove-gfv {
	ove_entry || return

	local out

	if ! command -v vi > /dev/null; then
		ove_command_not_found "vi"
		ove_command_usage
		return 1
	fi

	if ! out=$(ove_gf_helper "$@"); then
		ove_command_usage
		return 1
	elif [ "${out}" == "" ]; then
		return 1
	fi

	printf "%s\n" "${out}" | \
		SHELL=${ove_cmd2pathname["bash"]:?} \
		${ove_cmd2pathname["fzf"]:?} --bind "enter:execute(< /dev/tty eval \$(echo vi {} | ${ove_cmd2pathname["cut"]:?} -d' ' -f1-3))" \
		     --bind "left-click:execute(< /dev/tty eval \$(echo vi {} | ${ove_cmd2pathname["cut"]:?} -d' ' -f1-3))"
}

# gfe:pattern:git grep+fzf+emacs combo:UTIL
function ove-gfe {
	ove_entry || return

	local out

	if ! command -v emacs > /dev/null; then
		ove_command_not_found "emacs"
		ove_command_usage
		return 1
	fi

	if ! out=$(ove_gf_helper "$@"); then
		ove_command_usage
		return 1
	elif [ "${out}" == "" ]; then
		return 1
	fi

	# shellcheck disable=SC2016
	printf "%s\n" "${out}" | \
		SHELL=${ove_cmd2pathname["bash"]:?} \
		${ove_cmd2pathname["fzf"]:?} --bind "enter:execute(eval \$(echo emacs {} | ${ove_cmd2pathname["awk"]:?} '{print \$1,\$3,\$2}'))" \
		     --bind "left-click:execute(eval \$(echo emacs {} | ${ove_cmd2pathname["awk"]:?} '{print \$1,\$3,\$2}'))"
}

# blame-history:pattern:git log -G -p pattern for all git repositories:SEARCH
function ove-blame-history {
	ove_entry || return

	if [ $# -eq 0 ]; then
		echo "error: no pattern"
		ove_command_usage
		return 1
	fi
	# shellcheck disable=SC2016
	ove_revtab_forall 'ove_echo_yellow_noprefix ${repo_basename}; ove_repo_cmd ${repo} "--no-pager log" --color=always -p -G "'"$*"'"'
}

# blame:pattern:git grep+blame+log combo:SEARCH
function ove-blame {
	ove_entry || return

	local f
	local i
	local line
	local repo
	local res
	local s
	local sha
	local str

	[ $# -eq 0 ] && ove_echo_error_noprefix "no pattern, try again" && return 1

	s="$*"

	for repo in ${OVE_REPO_LIST}; do
		! [ -d "${repo}" ] && continue
		mapfile -t res < <(ove_repo_cmd "${repo}" "--no-pager grep" --no-color -I -n "${s}" | ${ove_cmd2pathname["cut"]:?} -d: -f1,2)

		for i in "${res[@]}"; do
			f=$(${ove_cmd2pathname["cut"]:?} -d: -f1 <<<"${i}")
			line=$(${ove_cmd2pathname["cut"]:?} -d: -f2 <<<"${i}")
			sha=$(ove_repo_cmd "${repo}" "--no-pager blame" -L"${line}","${line}" "${f}" | ${ove_cmd2pathname["cut"]:?} -d' ' -f1)
			str="${repo}/${f}:${line}"
			if [ "${sha}" == "00000000" ]; then
				str+=" [ Not Committed Yet ]"
			fi
			if [ "${sha}" != "00000000" ]; then
				ove_repo_cmd "${repo}" "--no-pager log" --color=always -1 "${sha}"
			fi
			echo
			${ove_cmd2pathname["head"]:?} -"${line}" "${repo}"/"${f}" | \
				${ove_cmd2pathname["tail"]:?} -1 | \
				${ove_cmd2pathname["grep"]:?} --color=always "${s}" | \
				${ove_cmd2pathname["sed"]:?} -e 's/^/    /g'
			echo
			echo "    File: ${str}"
			echo
		done
	done
}

# $1: file
# $2: config
# $3: value
function ove_config_one {
	local cfg=$1
	local var

	shift
	if [ $# -eq 0 ]; then
		${ove_cmd2pathname["grep"]:?} ${grep_prefix} -E -v '^#|^$' ${cfg} | \
			LC_ALL="C" ${ove_cmd2pathname["sort"]:?} | \
			${ove_cmd2pathname["grep"]:?} -E --color=always "${grep_postfix}"
	elif [ $# -eq 1 ]; then
		if ${ove_cmd2pathname["grep"]:?} -q -i $1 ${cfg}; then
			${ove_cmd2pathname["grep"]:?} ${grep_prefix} -E -v '^#|^$' ${cfg} | \
			${ove_cmd2pathname["grep"]:?} -i $1 | \
			${ove_cmd2pathname["grep"]:?} -E --color=always "${grep_postfix}"
		fi
	elif [ $# -gt 1 ]; then
		var=$1
		if ${ove_cmd2pathname["grep"]:?} -q -w ${var} ${cfg}; then
			${ove_cmd2pathname["sed"]:?} -i -e "s|\(^${var}\s\+\).*|\1${*:2}|g" \
				-e "s|\(^${var}$\)|\1 ${*:2}|g" \
				-e "s|\s\+$||g" ${cfg}
			ove_config_one ${cfg} ${var}
		fi
	fi
}

# helper function that updates/creates one OVE config file
function ove_update_config {
	local config
	local file
	local value

	file="$1"
	config="$2"
	value="$3"

	if ${ove_cmd2pathname["grep"]:?} -q "^${config} " ${file} &> /dev/null; then
		${ove_cmd2pathname["sed"]:?} -i "s|^${config}.*|${config} ${value}|g" ${file}
	else
		echo "${config} ${value}" >> ${file}
	fi
}

# add-config:file config value:add config/value pair to one OVE config file:CORE
function ove-add-config {
	ove_entry || return

	local config
	local file
	local value

	if [ $# -lt 3 ]; then
		ove_command_usage
		return 1
	fi

	file=$(${ove_cmd2pathname["readlink"]:?} -f -- $1)
	if ! ove_config_validate_filename ${file}; then
		ove_echo_error_noprefix "file '${file}' is not a valid OVE config file, select one of:"
		printf "%s\n" ${OVE_CONFIG_FILES_USER} 1>&2
		return 1
	fi
	config=$2
	if ! ove_read_config_validate_name ${config}; then
		ove_echo_error_noprefix "config name '${config}' is not allowed"
		return 1
	fi
	value="${*:3}"

	if [ -w "${file%/*}" ]; then
		ove_update_config "${file}" "${config}" "${value}"
		ove_reinit
	fi

	return 0
}

function ove_config_validate_filename {
	local f

	for f in ${OVE_CONFIG_FILES_ALL}; do
		if [ "$1" == "${f}" ]; then
			return 0
		fi
	done

	return 1
}

function ove_config_validate_file {
	local f

	f=$(${ove_cmd2pathname["readlink"]:?} -f -- $1)
	[ -s "$f" ] || return 1
	ove_config_validate_filename "${f}" || return 1

	return 0
}

function ove_config2file {
	${ove_cmd2pathname["grep"]:?} -H "^${1} " \
		${OVE_CONFIG_FILES_ALL} 2> /dev/null | \
		${ove_cmd2pathname["tail"]:?} -1 | \
		${ove_cmd2pathname["cut"]:?} -d: -f1
}

function ove_list_oveconfig_files_user {
	local f
	local files

	for f in ${OVE_CONFIG_FILES_USER}; do
		if [ -e "${f}" ]; then
			files+=("${f}")
		fi
	done

	if [ ${#files[@]} -eq 0 ]; then
		return
	fi
	echo "${files[@]}"
}

function ove_list_oveconfig_files_all {
	local f
	local files

	for f in ${OVE_CONFIG_FILES_ALL}; do
		if [ -e "${f}" ]; then
			files+=("${f}")
		fi
	done

	if [ ${#files[@]} -eq 0 ]; then
		return
	fi
	echo "${files[@]}"
}

# config:[file[config[[value]]]]|[config[[value]]]:show/modify OVE config files, configs are read in order so last config takes precedence:CORE
function ove-config {
	ove_entry || return

	local cfg
	local cfg_diff
	local cfgs
	local d
	local grep_prefix
	local grep_postfix

	if [ $# -gt 0 ] && ove_config_validate_file $1; then
		cfgs=("${1}")
		shift
	else
		read -r -a cfgs < <(ove_list_oveconfig_files_user)
	fi

	if [ ${#cfgs[@]} -eq 0 ]; then
		ove_echo_cyan_noprefix "no '.oveconfig' file(s) found"
		return 1
	elif [ ${#cfgs[@]} -gt 1 ]; then
		grep_prefix="-H"
	fi

	# try to mark any local changes in ${OVE_OWEL_DIR}/.oveconfig
	grep_postfix='$'
	if ove_repo_cmd ${OVE_OWEL_DIR} ls-files --error-unmatch ${OVE_OWEL_DIR}/.oveconfig &> /dev/null; then
		# shellcheck disable=SC2016
		cfg_diff="$(ove_repo_cmd ${OVE_OWEL_DIR} diff --no-color -U1 --raw ${OVE_OWEL_DIR}/.oveconfig | \
			${ove_cmd2pathname["grep"]:?} '^+[A-Z]\+'| \
			${ove_cmd2pathname["cut"]:?} -b2- | \
			${ove_cmd2pathname["awk"]:?} '{print $1}')"
		for d in ${cfg_diff}; do
			grep_postfix+="|\b${d}\b"
		done
	fi

	# shellcheck disable=SC2126
	if [ $# -gt 1 ] && [ $(${ove_cmd2pathname["grep"]:?} "^${1} " ${cfgs[*]} | ${ove_cmd2pathname["wc"]:?} -l) -gt 1 ]; then
		ove_echo_yellow_noprefix "'${1}' is present in more than one .oveconfig:"
		while true; do
			${ove_cmd2pathname["grep"]:?} "^${1} " "${cfgs[@]}" | ${ove_cmd2pathname["cut"]:?} -d: -f1
			read -r -p "config: "
			for cfg in ${cfgs[*]}; do
				if [ "${REPLY}" == "${cfg}" ]; then
					cfgs=("${REPLY}")
					break 2
				fi
			done
			echo "error: try again, specify one of these files:"
		done
	fi

	for cfg in "${cfgs[@]}"; do
		ove_config_one ${cfg} "$@"
	done | ${ove_cmd2pathname["sed"]:?} -e 's|^\(/.[^:]*\):|\1#|' -e 's| \+|#|' | ${ove_cmd2pathname["column"]:?} -t -s'#'

	if [ $# -gt 1 ]; then
		ove_reinit
	fi
}

# ls-files:[options]:git ls-files [options] for all git repositories:CORE
function ove-ls-files {
	ove_entry || return

	local opts

	if [ $# -eq 0 ]; then
		opts="--"
	else
		opts="$*"
	fi

	# shellcheck disable=SC2016
	ove_revtab_forall 'ove_repo_cmd ${repo} ls-files '"${opts}"' | ${ove_cmd2pathname["sed"]:?} -e "s|^|${repo}/|g"'
}

# list-modified-files: :list modified files:CORE
function ove-list-modified-files {
	ove_entry || return

	local cmd

	# shellcheck disable=SC2016
	cmd='ove_repo_cmd ${repo} "--no-pager diff-index" --quiet HEAD || ove_repo_cmd ${repo} diff --name-only HEAD | ${ove_cmd2pathname["sed"]:?} -e "s|^|${repo}/|g"'

	ove_revtab_forsome_parallel "${cmd}" 0 "$(ove_list_dirty_repos)" 2> /dev/null | LC_ALL="C" ${ove_cmd2pathname["sort"]:?} -u
}

# list-modified-files-basename: :list modified files (basename):CORE
function ove-list-modified-files-basename {
	ove_entry || return

	ove-list-modified-files | ${ove_cmd2pathname["sed"]:?} "s|.*/||g" | LC_ALL="C" ${ove_cmd2pathname["sort"]:?} -u
}

# list-committed-files:[days]:list committed files within 7 or days day(s):CORE
function ove-list-committed-files {
	ove_entry || return

	local cmd
	local days

	[ $# -eq 1 ] && days="$1" || days=7

	# shellcheck disable=SC2016
	cmd='ove_repo_cmd ${repo} "--no-pager log" --all --no-merges --author=\"$(${ove_cmd2pathname["git"]:?} config --get user.name)\" --name-only --pretty=format:\"\" --since=\"'${days}' days\" | while read line; do [ -f ${PWD}/${line} ] && echo -e ${PWD}/${line}; done'

	ove_revtab_forall_parallel "${cmd}" | LC_ALL="C" ${ove_cmd2pathname["sort"]:?} -u
}

function ove_uniq {
	if [ $# -eq 1 ]; then
		echo "${1}"
		return
	fi

	declare -A a_hash
	while [ $# -ne 0 ]; do
		if test "${a_hash["${1}"]+isset}"; then
			shift
			continue
		fi
		a_hash["${1}"]=1
		echo "${1}"
	done
}

function ove_edit {
	local a
	local b
	local editor
	local editor_cmd
	local editor_opt
	local f
	local files
	local files_by_epoch
	local line
	local ls_files=0
	local mod_files
	local refresh=0
	local res
	local skip=0

	editor="$1"
	shift

	# sanity check
	if ! command -v ${editor} > /dev/null; then
		ove_command_not_found "${editor}"
		return 1
	fi

	# check for files first
	for f in "$@"; do
		if [ -f "$f" ] || [ -h "$f" ]; then
			files+=("$(${ove_cmd2pathname["readlink"]:?} -f -- $f)")
		fi
	done

	# did we find all files already?
	if [ $# -ne 0 ] && [ $# -eq ${#files[@]} ]; then
		skip=1
	fi

	if [ $skip -eq 0 ]; then
		if [ -e ${OVE_OWEL_TMP_DIR}/ls-mod-files ]; then
			a=$(${ove_cmd2pathname["stat"]:?} --format '%Y' "${OVE_OWEL_TMP_DIR}/ls-mod-files")
			b=$(${ove_cmd2pathname["date"]:?} +%s)
			if [ $((b-a)) -gt $OVE_EDIT_LIFESPAN_TIME_IN_SEC ]; then
				refresh=1
			fi
		else
			refresh=1
		fi

		if [ $refresh -eq 1 ]; then
			ove-list-modified-files > ${OVE_OWEL_TMP_DIR}/ls-mod-files
		fi
		if [ -s ${OVE_OWEL_TMP_DIR}/ls-mod-files ]; then
			mapfile -t mod_files <<<"$(${ove_cmd2pathname["cat"]:?} ${OVE_OWEL_TMP_DIR}/ls-mod-files)"
		fi
	fi

	# any modified files?
	if [ $skip -eq 0 ] && [ "${#mod_files[@]}" -ne 0 ]; then
		if [ $# -eq 0 ]; then
			if [ "${#mod_files[@]}" -gt 20 ]; then
				while read -r line; do
					[ "x$line" == "x" ] && continue
					files+=("${line}")
				done <<<"${mod_files[@]}"
			else
				# stat all modified files
				files_by_epoch=$(
				for f in "${mod_files[@]}"; do
					[ -e ${f} ] || continue
					echo $(${ove_cmd2pathname["stat"]:?} --format '%Y' ${f}):${f}
				done | \
					LC_ALL="C" ${ove_cmd2pathname["sort"]:?} -r | \
					${ove_cmd2pathname["cut"]:?} -d: -f2)
				while read -r line; do
					[ "x$line" == "x" ] && continue
					files+=("${line}")
				done<<<"${files_by_epoch}"
			fi
		else
			# stat based on args
			files_by_epoch=$(
			for g in $(ove_uniq "$@"); do
				for f in "${mod_files[@]}"; do
					f_low=${f,,}
					if [[ ${f_low/${OVE_BASE_DIR}\/} == *${g,,}* ]] && [ -e ${f} ]; then
						echo $(${ove_cmd2pathname["stat"]:?} --format '%Y' ${f}):${f}
					fi
				done
			done | \
				LC_ALL="C" ${ove_cmd2pathname["sort"]:?} -r | \
				${ove_cmd2pathname["cut"]:?} -d: -f2)
			while read -r line; do
				[ "x$line" == "x" ] && continue
				files+=("${line}")
			done <<<"${files_by_epoch}"
		fi
	fi

	# still no hits? try all files
	if [ $skip -eq 0 ] && [ "${#files[@]}" -eq 0 ]; then
		refresh=0
		if [ -e ${OVE_OWEL_TMP_DIR}/ls-files ]; then
			a=$(${ove_cmd2pathname["stat"]:?} --format '%Y' "${OVE_OWEL_TMP_DIR}/ls-files")
			b=$(${ove_cmd2pathname["date"]:?} +%s)
			if [ $((b-a)) -gt $OVE_EDIT_LIFESPAN_TIME_IN_SEC ]; then
				refresh=1
			fi
		else
			refresh=1
		fi
		if [ $refresh -eq 1 ]; then
			ove-ls-files > ${OVE_OWEL_TMP_DIR}/ls-files
		fi

		if [ $# -eq 0 ]; then
			mapfile -t files <<<"$(${ove_cmd2pathname["cat"]:?} ${OVE_OWEL_TMP_DIR}/ls-files)"
		else
			for f in "$@"; do
				# a direct hit take precedence
				res=$(${ove_cmd2pathname["grep"]:?} "\/$f$" ${OVE_OWEL_TMP_DIR}/ls-files)
				if [ "x$res" != "x" ]; then
					while read -r line; do
						[ "x$line" == "x" ] && continue
						files+=("$line")
					done <<<"$res"
				else
					res=$(${ove_cmd2pathname["grep"]:?} "$f" ${OVE_OWEL_TMP_DIR}/ls-files)
					if [ "x$res" != "x" ]; then
						while read -r line; do
							[ "x$line" == "x" ] && continue
							files+=("$line")
						done <<<"$res"
					fi
				fi
			done
		fi
		ls_files=1
	fi

	if [ "${#files[@]}" -eq 0 ]; then
		return
	fi

	editor_opt=
	if [ "x$editor" = "xvi" ]; then
		# vim or vi?
		if ! command -v vim > /dev/null; then
			editor_cmd="vi"
		else
			editor_cmd="vim"

			# get rid of "N files to edit" msg
			if [ "${#files[@]}" -gt 1 ]; then
				editor_opt+=" --not-a-term"
			fi

			if [ $ls_files -eq 0 ]; then
				if [ "${#files[@]}" -gt 2 ]; then
					editor_opt+=" -c 'wincmd H'"
					editor_opt+=" -o"
				elif [ "${#files[@]}" -eq 2 ]; then
					editor_opt+=" -O"
				fi
			elif [ "${#files[@]}" -gt 1 ] && [ "${#files[@]}" -lt 20 ]; then
				editor_opt+=" -O"
			fi
		fi
	else
		editor_cmd="$editor"
	fi

	if [ "${#files[@]}" -gt 1 ] && [ $ls_files -eq 1 ]; then
		if ! command -v fzf > /dev/null; then
			printf "%s\n" "${files[@]}" | ${ove_cmd2pathname["cat"]:?} -n
			read -r -t 1
		else
			# launch fzf and vi
			# shellcheck disable=SC2016
			printf "%s\n" "${files[@]}" | \
				${ove_cmd2pathname["fzf"]:?} -m --bind "enter:execute(< /dev/tty eval \$(echo $editor_cmd $editor_opt {+}))" \
				--bind "left-click:execute(< /dev/tty eval \$(echo $editor_cmd $editor_opt {+}))" \
				--bind "ctrl-a:toggle-all" \
				--bind "ctrl-w:deselect-all" \
				--preview 'if [ ! -h {} ]; then head -$LINES {}; else find -L {} -xdev -type f -print0 | xargs -0 head -$LINES | head -$LINES; fi'
			return
		fi
	fi

	eval $editor_cmd $editor_opt $(ove_uniq "${files[@]}")
}

# emacs:[pattern|file...]:open files in emacs:UTIL
function ove-emacs {
	ove_entry || return

	ove_edit emacs "$@"
}

# vi:[pattern|file...]:open files in vi:UTIL
function ove-vi {
	ove_entry || return

	ove_edit vi "$@"
}

# edit:[pattern|file...]:open files in $EDITOR:UTIL
function ove-edit {
	ove_entry || return

	if [ "x$EDITOR" = "x" ]; then
		return 1
	fi

	ove_edit "${EDITOR}" "$@"
}

# helper function for mrproper
function ove_rmdir {
	local _dir
	local _files
	local _files_total

	if [ $# -ne 1 ]; then
		return 1
	fi

	if [ ! -d "$1" ]; then
		return 1
	fi

	_dir="$1"
	_files=$(${ove_cmd2pathname["find"]:?} ${_dir} -mindepth 1)
	if [ "x${_files}" = "x" ]; then
		return 1
	fi
	_files_total=$(printf "%s\n" ${_files} | ${ove_cmd2pathname["wc"]:?} -l)
	if [ ${_files_total} -eq 0 ]; then
		return 1
	fi

	printf "%s\n" ${_files}
	read -p "Proceed to remove ${_files_total} files/directories (list above) from '${_dir}' using 'rm -rf'? (y/N) " -r
	if ! [[ ${REPLY} =~ ^[Yy]$ ]]; then
		return 1
	fi

	read -p "Are you really sure? (y/N) " -r
	if ! [[ ${REPLY} =~ ^[Yy]$ ]]; then
		return 1
	fi

	${ove_cmd2pathname["find"]:?} "${_dir}" -mindepth 1 -print0 | ${ove_cmd2pathname["xargs"]:?} -0 rm -rfv
}

# mrproper:[y]:remove untracked repository files, '${OVE_STAGE_DIR}/*' and '${OVE_ARCHIVE_DIR}/*', USE WITH CARE:BUILD
function ove-mrproper {
	ove_entry || return

	local nbr_untracked_files

	if [ "$1" == "y" ]; then
		# shellcheck disable=SC2016
		ove_revtab_forall 'ove_repo_cmd ${repo} "--no-pager clean" -dffx > /dev/null'
		! [ "${OVE_STAGE_DIR}" == "" ] && ${ove_cmd2pathname["rm"]:?} -rf ${OVE_STAGE_DIR:?}/*
		! [ "${OVE_ARCHIVE_DIR}" == "" ] && ${ove_cmd2pathname["rm"]:?} -rf ${OVE_ARCHIVE_DIR:?}/*

		return 0
	fi

	# shellcheck disable=SC2016
	nbr_untracked_files=$(ove_revtab_forall_parallel 'ove_repo_cmd ${repo} clean -dffxn'| ${ove_cmd2pathname["wc"]:?} -l)
	if [ "${nbr_untracked_files}" -ne 0 ]; then
		# dry-run first
		# shellcheck disable=SC2016
		ove_revtab_forall 'a=$(ove_repo_cmd ${repo} "--no-pager clean" -dffxn); [ "${a}" != "" ] && printf "${a}\n" | ${ove_cmd2pathname["sed"]:?} -e "s|Would remove \(.*\)$|${PWD}/\1|g"'
		read -p "Proceed to remove ${nbr_untracked_files} untracked files/directories (list above) using 'git clean -dffx'? (y/N) " -r
		if [[ ${REPLY} =~ ^[Yy]$ ]]; then
			read -p "Are you really sure? (y/N) " -r
			if [[ ${REPLY} =~ ^[Yy]$ ]]; then
				# shellcheck disable=SC2016
				ove_revtab_forall 'ove_repo_cmd ${repo} "--no-pager clean" -dffx'
			fi
		fi
	fi

	ove_rmdir "${OVE_STAGE_DIR}"
	ove_rmdir "${OVE_ARCHIVE_DIR}"

	return 0
}

# wipe-base-dir:[y]:remove untracked files from ${OVE_BASE_DIR}, USE WITH CARE:CORE
function ove-wipe-base-dir {
	ove_entry || return

	local candidates
	local remove
	local reserved
	local rm_options="-i"

	if [ "${OVE_BASE_DIR}" = "${HOME}" ]; then
		ove_echo_error_noprefix "sorry, but you have to clean your home yourself (reason: \$OVE_BASE_DIR=\$HOME)"
		return 1
	fi

	# search for files/dirs
	mapfile -t candidates <<<"$(${ove_cmd2pathname["find"]:?} $OVE_BASE_DIR -mindepth 1 -maxdepth 1)"

	# sanity check
	if [ "${#candidates[@]}" -eq 1 ]; then
		ove_echo_fatal_noprefix "no candidates found, bash mapfile bug? bash version: ${BASH_VERSINFO[0]}.${BASH_VERSINFO[1]}"
		return 1
	fi

	# repos and some reserved files and directories
	read -a reserved -r <<<"$(echo $(ove_revtab_list_fullpath) ${OVE_OWEL_DIR} ${OVE_STAGE_DIR} ${OVE_ARCHIVE_DIR} ${OVE_BASE_DIR}/{.owel,ove,.ove*,README*})"

	# compare candidates vs. reserved
	mapfile -t remove <<<"$(LC_ALL="C" ${ove_cmd2pathname["comm"]:?} -2 -3 \
		<(printf "%s\n" "${candidates[@]}" | LC_ALL="C" ${ove_cmd2pathname["sort"]:?}) \
		<(printf "%s\n" "${reserved[@]}" | LC_ALL="C" ${ove_cmd2pathname["sort"]:?}))"

	# return early?
	if [ "x${remove[0]}" = "x" ]; then
		return
	fi

	if [ "$1" == "y" ]; then
		rm_options=""
	else
		echo "${remove[@]}" | ${ove_cmd2pathname["xargs"]:?} file | ${ove_cmd2pathname["cat"]:?} -n
		echo
	fi

	${ove_cmd2pathname["xargs"]:?} -a <(echo "${remove[@]}") rm -rf ${rm_options}

	return 0
}

# l:[pattern]:view last command output in pager (=${OVE_PAGER}) or print lines matching pattern:LOG
function ove-l {
	ove_entry || return

	[ -f "${OVE_LAST_COMMAND}" ] || return

	if [ $# -eq 0 ]; then
		${OVE_PAGER} ${OVE_LAST_COMMAND}
		return $?
	fi

	if command -v ag > /dev/null; then
		${ove_cmd2pathname["ag"]:?} -H -i "$@" ${OVE_LAST_COMMAND}
	else
		echo ${OVE_LAST_COMMAND}
		${ove_cmd2pathname["grep"]:?} -i "$@" ${OVE_LAST_COMMAND}
	fi
}

# describe:[git...]:git describe+log+status combo for all/specified git repositories:CORE
function ove-describe {
	ove_entry || return

	local func

	func=ove_revtab_forall_parallel

	if [ $# -gt 0 ]; then
		func=ove_revtab_forsome
	fi

	# yes, this is ugly
	# shellcheck disable=SC1004,SC2016
	${func} 'echo $(\
		echo ${repo} | ${ove_cmd2pathname["sed"]:?} -e "s|${OVE_BASE_DIR}/||g")@$(ALLOW_OVERRIDE=1 ove_repo_cmd ${repo} describe)@"$(\
		${ove_cmd2pathname["git"]:?} log --format="%<(20,trunc)%s" -1\
		)"@"$(\
		${ove_cmd2pathname["git"]:?} -c color.status=never status -s -uno | \
		${ove_cmd2pathname["tr"]:?} "\n" " ")"' "$@" |\
		${ove_cmd2pathname["column"]:?} -t -s'@' | \
		LC_ALL="C" ${ove_cmd2pathname["sort"]:?}
}

# list-heads:[git...]:git log for all/specified git repositories:CORE
function ove-list-heads {
	ove_entry || return

	local cmd

	# shellcheck disable=SC2016
	cmd='echo $(echo -n "$(echo ${repo} | ${ove_cmd2pathname["sed"]:?} -e "s|${OVE_BASE_DIR}/||g")?" && '
	# shellcheck disable=SC2016
	cmd+='ove_repo_cmd ${repo} "--no-pager log" -1 --no-merges --format=%h?%ar?%ae?%s 2> /dev/null)'

	while true; do
		if [ $# -eq 0 ]; then
			ove_revtab_forall_parallel "${cmd}"
		else
			ove_revtab_forsome "${cmd}" "$*"
		fi

		break
	done | LC_ALL="C" ${ove_cmd2pathname["sort"]:?} | ${ove_cmd2pathname["column"]:?} -t -s? 2> /dev/null
}

# ls-remote: :git ls-remote <remote.origin.url> HEAD for all git repositories:CORE
function ove-ls-remote {
	ove_entry || return

	local i
	local p
	local repo
	local ret
	local sha
	local str
	local url

	i=0
	ret=0
	while ((i < ove_revtab_num_repositories)); do
		url="${ove_revtab_fetch_url[${i}]}"
		if [ "${url}" == "noremote" ]; then
			(( i+=1 ))
			continue
		fi
		repo="${ove_revtab_git_name[${i}]}"
		p="${OVE_BASE_DIR}/${repo}"

		# shellcheck disable=SC2016
		sha=$(ove_repo_cmd "${p}" ls-remote ${url} HEAD | ${ove_cmd2pathname["awk"]:?} '{print $1}')
		if [ "${sha}" == "" ]; then
			ove_echo_error_noprefix "ls-remote failed for '${url}'"
			(( ret+=1 ))
		else
			str+="${repo}:${sha}\n"
		fi
		(( i+=1 ))
	done

	url=$(ove_repo_cmd "${OVE_OWEL_DIR}" config --get remote.origin.url)
	if [ "${url}" == "" ] || [ "${url}" == "noremote" ]; then
		:
	else
		# shellcheck disable=SC2016
		sha=$(ove_repo_cmd "${OVE_OWEL_DIR}" ls-remote ${url} HEAD | ${ove_cmd2pathname["awk"]:?} '{print $1}')
		if [ "${sha}" == "" ]; then
			ove_echo_error_noprefix "ls-remote failed for '${url}'"
			(( ret+=1 ))
		else
			str+="${OVE_OWEL_NAME}:${sha}\n"
		fi
	fi

	printf "${str}" | \
		LC_ALL="C" ${ove_cmd2pathname["sort"]:?} | \
		${ove_cmd2pathname["column"]:?} -t -s:

	return ${ret}
}

# heads2revtab:[git...]:update 'revtab' with current SHA-1:CORE
function ove-heads2revtab {
	ove_entry || return
	ove_revtab_sanity || return

	local repo
	local repos
	local sha_1

	if [ $# -eq 0 ]; then
		repos=$(ove_revtab_list_basename)
	else
		repos=$*
	fi

	for repo in ${repos}; do
		[ -d "${OVE_BASE_DIR}"/${repo} ] || continue
		sha_1=$(ove_repo_cmd "${OVE_BASE_DIR}"/${repo} rev-parse HEAD)
		${ove_cmd2pathname["sed"]:?} -i -e 's|^'${repo}'\(\s\+.*\s\+.*\s\+\)\(.*\)$|'${repo}'\1'${sha_1}'|g' "${OVE_OWEL_DIR}"/revtab
	done

	ove_repo_cmd "${OVE_OWEL_DIR}" "--no-pager diff" revtab
}

# head-tail:file [num]:display first/last 3(=num) lines of a text file:UTIL
function ove-head-tail {
	ove_entry || return

	local c
	local f
	local n

	if [[ $# -eq 0 || $# -gt 2 || ( $# -eq 2 && ! "$2" =~ ^[0-9]+$ ) ]]; then
		ove_command_usage
		return 1
	fi

	f=$1
	if ! [ -e ${f} ]; then
		ove_echo_error_noprefix "file '${f}' not found"
		return 1
	fi

	if ! ${ove_cmd2pathname["file"]:?} -bL --mime ${f} | ${ove_cmd2pathname["grep"]:?} -q '^text'; then
		ove_echo_error_noprefix "'${f}' is not a text file, use xxd/hexdump"
		return 1
	fi

	[ $# -eq 1 ] && c=3 || c=$2
	n=$(${ove_cmd2pathname["wc"]:?} -l <${f})
	if [ ${n} -gt $((c + c)) ]; then
		${ove_cmd2pathname["cat"]:?} -n ${f} | ${ove_cmd2pathname["head"]:?} -${c}
		echo -e "\t..."
		${ove_cmd2pathname["cat"]:?} -n ${f} | ${ove_cmd2pathname["tail"]:?} -${c}
	else
		${ove_cmd2pathname["cat"]:?} -n ${f}
	fi
}

# what-is:dir...:classify files inside 'dir' using 'file':UTIL
function ove-what-is {
	ove_entry || return

	local dir

	for dir in "$@"; do
		[ ! -d "${dir}" ] && continue
		echo "${dir}":
		# shellcheck disable=SC2016
		${ove_cmd2pathname["find"]:?} "${dir}" -not -path '*.git*' -print0 | \
			${ove_cmd2pathname["xargs"]:?} -0 -P"$(${ove_cmd2pathname["getconf"]:?} _NPROCESSORS_ONLN)" file | \
			${ove_cmd2pathname["awk"]:?} '{$1=""; print $0}' | \
			LC_ALL="C" ${ove_cmd2pathname["sort"]:?} | \
			${ove_cmd2pathname["uniq"]:?} -c | \
			LC_ALL="C" ${ove_cmd2pathname["sort"]:?} -nr
	done
}

# show:[rev...]:ove list-heads or search for 'rev' within all git repositories. If found run 'git show rev':CORE
function ove-show {
	ove_entry || return

	local revision

	if [ $# -eq 0 ]; then
		# shellcheck disable=SC2119
		ove-list-heads
		return
	fi

	for revision in "$@"; do
		# remove dirty tags
		revision=${revision%-dirty}
		ove_revtab_forall "
		if ove_repo_cmd \${repo} '--no-pager show' ${revision} -- &> /dev/null; then \
			clear; \
			if [ ${OVE_LESS_MORE_OPTIONS} -eq 1 ]; then
				less_opt=\"-X -R -Ps\${repo_basename} ${revision//./\\.}\";
			else
				less_opt=\"-R\";
			fi;
			LESS=\${less_opt} ALLOW_OVERRIDE=1 ove_repo_cmd \${repo} '-p show' ${revision} --;
			unset less_opt
		fi"
	done
}

# cd:[pattern|@] :'cd ${OVE_BASE_DIR}' OR switch to a OVE workspace specified by pattern:CORE
function ove-cd {
	if [ $# -eq 0 ]; then
		cd "${OVE_BASE_DIR}" || return 1
	elif [ $# -eq 1 ] && [ "$1" == "@" ]; then
		ove_set_workspace
	else
		ove_set_workspace "$@"
	fi
}

# version: :print OVE version:CORE
function ove-version {
	ove_entry || return

	local os_real

	os_real=$(${ove_cmd2pathname["uname"]:?} -o 2> /dev/null)
	if [ "x${os_real}" = "x" ]; then
		echo "OVE ${OVE_SHA} | ${OVE_OS} ${OVE_OS_VER}"
	else
		echo "OVE ${OVE_SHA} | ${OVE_OS} ${OVE_OS_VER} | ${os_real}"
	fi
}

# revtab-check:[0|1]:disable/enable if OVE should keep repos in-sync with 'revtab':CORE
function ove-revtab-check {
	ove_entry || return

	local cfg
	local reinit=0

	if [ $# -eq 1 ] && ! [[ "${1}" =~ ^[0-1]$ ]]; then
		ove_command_usage
		return 1
	elif [ $# -eq 1 ]; then
		if [ ${OVE_REVTAB_CHECK} -eq 0 ] && [ ${1} -eq 1 ]; then
			reinit=1
		fi

		OVE_REVTAB_CHECK=$1

		cfg=$(ove_config2file OVE_REVTAB_CHECK)
		[ "${cfg}" == "" ] && cfg="${OVE_OWEL_STATE_DIR}/.oveconfig"
		ove-add-config ${cfg} OVE_REVTAB_CHECK ${OVE_REVTAB_CHECK}
	fi

	if [ ${OVE_REVTAB_CHECK} -eq 1 ]; then
		echo "revtab check (=OVE_REVTAB_CHECK) is ENABLED for this workspace"
		[ ${reinit} -eq 1 ] && ove_reinit
	else
		echo "revtab check (=OVE_REVTAB_CHECK) is DISABLED for this workspace"
	fi
}

# loglevel:[level] :show or change loglevel [0-9]:DEBUG
function ove-loglevel {
	ove_entry || return

	local bcc_tool
	local cfg
	local prefix
	local sysctl_f

	set +x
	if [ $# -eq 1 ] && ! [[ "${1}" =~ ^[0-9]$ ]]; then
		ove_command_usage
		return 1
	elif [ $# -eq 1 ]; then
		if [ $1 -gt 2 ] && [ $1 -lt 7 ]; then
			if ! command -v strace > /dev/null; then
				ove_command_not_found "strace"
				return 1
			fi

			if [ -e /proc/sys/kernel/yama/ptrace_scope ] && [ $(${ove_cmd2pathname["cat"]:?} /proc/sys/kernel/yama/ptrace_scope) -ne 0 ]; then
				ove_echo_error_noprefix "the kernel does not allow you to trace all processes"
				echo
				echo "To fix this for now:"
				[ ${EUID} != 0 ] && prefix="sudo"
				echo " ${prefix} ${ove_cmd2pathname["bash"]:?} -c 'echo 0 > /proc/sys/kernel/yama/ptrace_scope'"
				echo
				echo "To fix this permanently:"
				sysctl_f=$(${ove_cmd2pathname["grep"]:?} -l kernel.yama.ptrace_scope /etc/sysctl.d/*)
				if [ "${sysctl_f}" != "" ]; then
					echo " ${prefix} ${ove_cmd2pathname["bash"]:?} -c 'echo 0 > /proc/sys/kernel/yama/ptrace_scope; sed -i -e \"s/kernel.yama.ptrace_scope.*/kernel.yama.ptrace_scope = 0/g\" ${sysctl_f}'"
				else
					echo " ${prefix} ${ove_cmd2pathname["bash"]:?} -c 'echo 0 > /proc/sys/kernel/yama/ptrace_scope; echo \"kernel.yama.ptrace_scope = 0\" > /etc/sysctl.d/10-ptrace.conf'"
				fi
				return 1
			fi
		fi

		if [ $1 -ge 7 ] && [ $1 -le 10 ]; then
			if [ ${1} -eq 7 ]; then
				bcc_tool="execsnoop"
			elif [ ${1} -eq 8 ]; then
				bcc_tool="tcpconnect"
			elif [ ${1} -eq 9 ]; then
				bcc_tool="opensnoop"
			fi

			if ! command -v python3 > /dev/null; then
				ove_command_not_found "python3" "Needed by '${bcc_tool}'."
				return 1
			fi

			if ! [ -e /usr/share/bcc/tools/${bcc_tool} ]; then
				ove_echo_error_noprefix "'/usr/share/bcc/tools/${bcc_tool}' not found."
				return 1
			fi

			if [ ${EUID} != 0 ]; then
				if ! sudo -n true; then
					if ! sudo true; then
						ove_echo_error_noprefix "'${bcc_tool}' need non-interactive 'sudo'"
						return 1
					fi
				fi
			fi
		fi

		OVE_LOGLEVEL=$1
		cfg=$(ove_config2file OVE_LOGLEVEL)
		[ "${cfg}" == "" ] && cfg="${OVE_OWEL_STATE_DIR}/.oveconfig"
		ove-add-config ${cfg} OVE_LOGLEVEL $1
	fi

	{
		echo "0: silence is golden"
		echo "1: normal"
		echo "2: debug                [set -x]"
		echo "3: execve timeline      [strace]"
		echo "4: execve time analysis [strace]"
		echo "5: connect analysis     [strace]"
		echo "6: graph analysis       [strace]"
		echo "7: execsnoop            [bcc]"
		echo "8: tcpconnect           [bcc]"
		echo "9: opensnoop            [bcc]"
	} | ${ove_cmd2pathname["sed"]:?} -e "s/^${OVE_LOGLEVEL}:\(.*\)$/${OVE_LOGLEVEL}:\1 */g" | \
		${ove_cmd2pathname["grep"]:?} -E --color "$|${OVE_LOGLEVEL}:.*"

	if [ $# -eq 1 ]; then
		OVE_REDIRECT_OUTPUT=""
		if [ $1 -eq 0 ]; then
			OVE_REDIRECT_OUTPUT="> /dev/null"
		elif [ $1 -eq 1 ]; then
			set +x
		elif [ $1 -eq 2 ]; then
			set -x
		fi
	fi
}

# dry-run:[0|1]:toggle or set OVE_DRY_RUN:DEBUG
function ove-dry-run {
	ove_entry || return

	if [ $# -eq 1 ] && ! [[ "$1" =~ ^[0-1]$ ]]; then
		ove_command_usage
		return 1
	fi

	if [ $# -eq 0 ]; then
		OVE_DRY_RUN=$((OVE_DRY_RUN ^= 1))
	else
		OVE_DRY_RUN=$1
	fi

	ove-env ^OVE_DRY_RUN
}

# lastlog-summary:[pattern]:peek inside OVE logs and make a summary:LOG
function ove-lastlog-summary {
	ove_entry || return

	local cmd
	local d
	local exit_code
	local f
	local f_base
	local first
	local ff
	local last
	local log_type
	local second
	local self=${FUNCNAME[0]/ove-/}
	local t
	local u

	# ignore logs before October 1, 2021
	${ove_cmd2pathname["touch"]:?} -t 202110010000 $OVE_TMP/ove-${self}-ref
	${ove_cmd2pathname["find"]:?} /var/tmp/*/ove/logs -type f -name '2*.log' -newer $OVE_TMP/ove-${self}-ref -print  > $OVE_TMP/ove-${self}
	${ove_cmd2pathname["rm"]:?} $OVE_TMP/ove-${self}-ref
	if [ ! -s $OVE_TMP/ove-${self} ]; then
		echo "error: no logs found"
		if [ -e $OVE_TMP/ove-${self} ]; then
			${ove_cmd2pathname["rm"]:?} $OVE_TMP/ove-${self}
		fi
		return 1
	elif [ $# -ne 0 ]; then
		${ove_cmd2pathname["grep"]:?} -E -i ".*$1.*" $OVE_TMP/ove-${self} > $OVE_TMP/ove-${self}.filter
		if [ ! -s $OVE_TMP/ove-${self}.filter ]; then
			echo "error: no logs found after filter"
			if [ -e $OVE_TMP/ove-${self}.filter ]; then
				${ove_cmd2pathname["rm"]:?} $OVE_TMP/ove-${self}.filter
			fi
			return 1
		fi
		${ove_cmd2pathname["mv"]:?} $OVE_TMP/ove-${self}.filter $OVE_TMP/ove-${self}
	fi

	printf "%-24s %-4s %s\n" "date" "exit" "command"
	for f in $(${ove_cmd2pathname["xargs"]:?} stat --format '%Y:%n' < $OVE_TMP/ove-${self} | LC_ALL="C" ${ove_cmd2pathname["sort"]:?} -nr); do
		t=${f%%:*}
		ff=${f#*:}

		first=
		second=
		last=
		exit_code=
		while read -r line; do
			if [ "x$first" = "x" ]; then
				first=${line}
			elif [ "x$second" = "x" ]; then
				second=${line}
				break
			fi
		done <$ff;

		if [[ $first == "Script started"* ]]; then
			log_type="script"
			last=$(${ove_cmd2pathname["tail"]:?} -1 $ff)
		else
			log_type="tee"
		fi

		if [ "x$log_type" = "xscript" ]; then
			cmd=$second
			if [[ $last == "Script done"* ]]; then
				exit_code=${last/*COMMAND_EXIT_CODE=\"}
				exit_code=${exit_code%\"*}
			fi
		elif [ "x$log_type" = "xtee" ]; then
			cmd=$first
			exit_code=${cmd//*# exit code: /}
			cmd=${cmd/\# exit code:*/}
		fi

		if [ ${EUID} -eq 0 ] && [[ $cmd != \#* ]]; then
			continue
		elif [ ${EUID} -ne 0 ] && [[ $cmd != \$* ]]; then
			continue
		fi

		if [ "x$exit_code" = "x" ]; then
			exit_code="NA"
		elif ! [[ "${exit_code}" =~ ^[0-9]+$ ]]; then
			exit_code="NA"
		fi

		if [ "x$cmd" = "x" ]; then
			cmd="unknown"
		else
			cmd=${cmd:2}

			if [[ $cmd != ove* ]]; then
				cmd="unknown"
			fi
		fi

		f_base=${ff##*/}
		d=${f_base:0:24}
		u=${ff#*/}
		u=${u#*/}
		u=${u#*/}
		u=${u%%/*}
		if [ "$u" == "$OVE_USER" ]; then
			printf "%-24s %-4s %s\n" $d $exit_code "$cmd"
		else
			printf "%-24s %-10s %-3s %s\n" $d $u $exit_code "$cmd"
		fi
	done

	if [ -e "$OVE_TMP/ove-${self}" ]; then
		${ove_cmd2pathname["rm"]:?} "$OVE_TMP/ove-${self}"
	fi

	return 0
}

# demo:[git...|pattern]:run 'lastlog-replay' on logs found at '<git>/.ove/demo', '<OVE_OWEL_DIR>/demo' or '<OVE_DIR>/demo':UTIL
function ove-demo {
	ove_entry || return

	local d
	declare demos
	local demo_list
	local p
	local re
	local repo
	local repo_fullpath
	local repos

	if [ $# -ge 1 ]; then
		repos=$(ove_validate_repo_list "$@")
	else
		repos="${OVE_REPO_LIST}"
	fi

	if [ $# -eq 1 ] && [ "x${repos}" = "x" ]; then
		re="$1"
		repos="${OVE_REPO_LIST}"
	fi

	demos=()
	for repo in ${repos}; do
		repo_fullpath=$(ove_repo2fullpath $repo)

		if [ "x${repo_fullpath}" = "x${OVE_BASE_DIR}/${OVE_OWEL_NAME}" ]; then
			p="${OVE_BASE_DIR}/${OVE_OWEL_NAME}/demo"
		elif [ "x${repo_fullpath}" = "x${OVE_DIR}" ]; then
			p="${OVE_DIR}/demo"
		else
			p="${repo_fullpath}/.ove/demo"
		fi

		if [ ! -d "${p}" ]; then
			continue
		fi

		demo_list=$(${ove_cmd2pathname["find"]:?} -L ${p} -name '*.log' -type f | LC_ALL="C" ${ove_cmd2pathname["sort"]:?})
		for d in ${demo_list}; do
			if [ "${re}" != "x" ]; then
			       if [[ $d =~ $re ]]; then
				       demos+=("${d/.log/}")
			       fi
			       continue
		       fi
		       demos+=("${d/.log/}")
		done
	done

	if [ "x${demo_list}" = "x" ]; then
		echo "no demos found" 1>&2
		return 0
	elif [ ${#demos[@]} -eq 0 ]; then
		echo "no demos found, available demos:" 1>&2
		printf "%s\n" "${demo_list}" | ${ove_cmd2pathname["cat"]:?} -n 1>&2
		return 0
	fi

	for d in "${!demos[@]}"; do
		if [ -s "${demos[$d]}".pre ]; then
			if ! source "${demos[$d]}".pre; then
				continue
			fi
		fi

		ove-lastlog-replay "${demos[$d]}".log ${OVE_DEMO_DIVISOR}

		if [ -s "${demos[$d]}".post ]; then
			source "${demos[$d]}".post
		fi
	done
}

# lastlog-replay:[file [divisor]]|[pattern [divisor]]:replay OVE commands:LOG
function ove-lastlog-replay {
	ove_entry || return

	local d
	local divisor=1
	local f
	local ff
	local self=${FUNCNAME[0]/ove-/}

	if [ $# -ne 0 ] && [ -s "$1" ]; then
		echo "$1" > $OVE_TMP/ove-${self}
		if [ $# -eq 2 ]; then
			divisor=$2
		fi
	else
		# ignore logs before October 18, 2021
		${ove_cmd2pathname["touch"]:?} -t 202110180000 $OVE_TMP/ove-${self}-ref
		${ove_cmd2pathname["find"]:?} /var/tmp/*/ove/logs -type f -name '2*' -newer $OVE_TMP/ove-${self}-ref -not -name '*.timing' -print  > $OVE_TMP/ove-${self}
		${ove_cmd2pathname["rm"]:?} $OVE_TMP/ove-${self}-ref
		if [ ! -s $OVE_TMP/ove-${self} ]; then
			echo "error: no logs found"
			if [ -e $OVE_TMP/ove-${self} ]; then
				${ove_cmd2pathname["rm"]:?} $OVE_TMP/ove-${self}
			fi
			return 1
		elif [ $# -ne 0 ]; then
			${ove_cmd2pathname["grep"]:?} -E -i ".*$1.*" $OVE_TMP/ove-${self} > $OVE_TMP/ove-${self}.filter
			if [ ! -s $OVE_TMP/ove-${self}.filter ]; then
				echo "error: no logs found after filter"
				if [ -e $OVE_TMP/ove-${self}.filter ]; then
					${ove_cmd2pathname["rm"]:?} $OVE_TMP/ove-${self}.filter
				fi
				return 1
			fi
			${ove_cmd2pathname["mv"]:?} $OVE_TMP/ove-${self}.filter $OVE_TMP/ove-${self}
		fi

		if [ $# -eq 2 ]; then
			divisor=$2
		fi
	fi

	for f in $(${ove_cmd2pathname["xargs"]:?} stat --format '%Y:%n' < $OVE_TMP/ove-${self} | LC_ALL="C" ${ove_cmd2pathname["sort"]:?} -n); do
		ff=${f#*:}
		[ -e ${ff/.log}.timing ] || continue
		d=${ff##*/}
		# truncate ove logs and just show the date
		if [[ $d = 2*-ove-* ]]; then
			d=${d:0:22}
		fi
		ove_echo_cyan_noprefix "$d"
		${ove_cmd2pathname["scriptreplay"]:?} -m 3 --divisor $divisor --timing ${ff/.log}.timing $ff 2> /dev/null
	done

	if [ -e "$OVE_TMP/ove-${self}" ]; then
		${ove_cmd2pathname["rm"]:?} "$OVE_TMP/ove-${self}"
	fi

	return 0
}

# lastlog:[pattern]:list OVE logs:LOG
function ove-lastlog {
	ove_entry || return

	local find_opt
	local pattern
	local self=${FUNCNAME[0]/ove-/}

	${ove_cmd2pathname["find"]:?} ${OVE_LOG_DIR} -name '2*.log' -type f ${find_opt} -print > $OVE_TMP/ove-${self}
	if [ ! -s $OVE_TMP/ove-${self} ]; then
		echo "error: no logs found"
		return 1
	elif [ $# -eq 0 ]; then
		pattern=$(${ove_cmd2pathname["date"]:?} '+%Y%m%d')
	else
		pattern=$1
	fi

	${ove_cmd2pathname["grep"]:?} -E -i ".*$pattern.*" $OVE_TMP/ove-${self} > $OVE_TMP/ove-${self}.filter
	if [ ! -s $OVE_TMP/ove-${self}.filter ]; then
		echo "error: no logs found after filter"
		return 1
	fi
	${ove_cmd2pathname["mv"]:?} $OVE_TMP/ove-${self}.filter $OVE_TMP/ove-${self}

	${ove_cmd2pathname["xargs"]:?} stat --format '%Y:%n:%s' < $OVE_TMP/ove-${self}| \
		LC_ALL="C" ${ove_cmd2pathname["sort"]:?} -nr | \
		${ove_cmd2pathname["cut"]:?} -d: -f2- | \
		${ove_cmd2pathname["grep"]:?} -v ${FUNCNAME[0]} | \
		${ove_cmd2pathname["sed"]:?} "s/\(^.*-ove-\(.*\)-${HOSTNAME}-\(.*\).log\):\(.*\)/\3@\2@\1@\4/g" | \
		${ove_cmd2pathname["column"]:?} -t -s@
}

# rm-logs:[days [y]]:remove OVE logs older than 30|days days. days=0 => all logs:LOG
function ove-rm-logs {
	ove_entry || return

	local days=30
	local find_opt="-mtime +${days}"
	local interactive=1

	if  [ $# -gt 2 ]; then
		ove_command_usage
		return 1
	elif [ $# -eq 2 ] && [ "$2" != "y" ]; then
		ove_command_usage
		return 1
	fi

	if [ $# -eq 2 ]; then
		interactive=0
	fi

	if [ $# -gt 0 ]; then
		if ! [[ "${1}" =~ ^[0-9]+$ ]]; then
			echo "error: just numbers"
			ove_command_usage
			return 1
		fi

		if [ $1 -eq 0 ]; then
			find_opt=""
		else
			days=$1
			find_opt="-mtime +${days}"
		fi
	fi

	find_opt="-maxdepth 2 -type f ${find_opt} -print"

	if [ "$(${ove_cmd2pathname["find"]:?} ${OVE_LOG_DIR} ${find_opt} -quit)" == "" ]; then
		if [ ${interactive} -eq 1 ]; then
			ove_echo_error_noprefix "no OVE log files older than ${days} days found here: ${OVE_LOG_DIR}"
		fi
		return 1
	fi

	if [ ${interactive} -eq 1 ]; then
		${ove_cmd2pathname["find"]:?} ${OVE_LOG_DIR} ${find_opt} | ${ove_cmd2pathname["cat"]:?} -n

		echo
		echo -n "Proceed to remove "
		if [ $# -eq 1 ] && [ $1 -eq 0 ]; then
			read -p "ALL files (list above) from '${OVE_LOG_DIR}' (y/N) " -r
		else
			read -p "files older than ${days} days (list above) from '${OVE_LOG_DIR}' (y/N) " -r
		fi
		[[ ${REPLY} =~ ^[Yy]$ ]] || return 1
		read -p "Are you really sure? (y/N) " -r
		[[ ${REPLY} =~ ^[Yy]$ ]] || return 1
	fi

	if [ "x${OVE_LAST_COMMAND}" != "x" ]; then
		${ove_cmd2pathname["find"]:?} ${OVE_LOG_DIR} ${find_opt} | \
			${ove_cmd2pathname["grep"]:?} -v ${OVE_LAST_COMMAND} | \
			${ove_cmd2pathname["xargs"]:?} rm -v
	else
		find_opt+="0"
		${ove_cmd2pathname["find"]:?} ${OVE_LOG_DIR} ${find_opt} | \
			${ove_cmd2pathname["xargs"]:?} -0 rm -v
	fi
	${ove_cmd2pathname["find"]:?} ${OVE_LOG_DIR} -maxdepth 1 -empty -type d -delete

	return 0
}

# authors: :list author summary for all git repositories:UTIL
function ove-authors {
	ove_entry || return

	local repo

	declare -A urls

	for repo in ${OVE_REPO_LIST}; do
		if [ ! -d "${repo}" ] || [ "${repo}" == "${OVE_DIR}" ]; then
			continue
		fi

		# Try to avoid that a git is counted more than one time
		url=$(ove_repo_cmd "${repo}" "--no-pager remote" -v | \
			${ove_cmd2pathname["grep"]:?} fetch | \
			${ove_cmd2pathname["cut"]:?} -f2 | \
			${ove_cmd2pathname["cut"]:?} -d' ' -f1 | \
			${ove_cmd2pathname["uniq"]:?} | \
			${ove_cmd2pathname["sed"]:?} -e 's/[^a-zA-Z0-9\-]/_/g' | \
			${ove_cmd2pathname["sed"]:?} -e 's/_git$//g')

		if [ "${url}" != "" ]; then
			test "${urls["${url}"]+isset}" && continue
			urls["${url}"]=1
		fi

		ove_repo_cmd "${repo}" "--no-pager log" --pretty="%ae"
	done | \
		LC_ALL="C" ${ove_cmd2pathname["sort"]:?} | \
		${ove_cmd2pathname["uniq"]:?} -c | \
		LC_ALL="C" ${ove_cmd2pathname["sort"]:?} -nr
}

# domains: :list email domain summary for all git repositories:UTIL
function ove-domains {
	ove_entry || return

	ove-authors | \
		${ove_cmd2pathname["grep"]:?} '@' | \
		${ove_cmd2pathname["cut"]:?} -d@ -f2 | \
		LC_ALL="C" ${ove_cmd2pathname["sort"]:?} | \
		${ove_cmd2pathname["uniq"]:?} -c | \
		LC_ALL="C" ${ove_cmd2pathname["sort"]:?} -nr
}

function ove_bash_complete {
	local a
	local b
	local cmd
	local cur
	local refresh
	local opts
	local size
	local subcommand
	local wordlist

	# sanity check
	if ! ove_get_base_dir &> /dev/null; then
		return 1
	fi

	if ! ove_verify_checksums && ! ove_reinit; then
		return 1
	fi

	COMPREPLY=()

	cur="${COMP_WORDS[COMP_CWORD]}"
	subcommand="${COMP_WORDS[1]}"
	size=$((${#COMP_WORDS[@]} - 1))

	# project commands
	for cmd in ${OVE_PROJECT_COMMANDS}; do
		if [ "${cmd}" == "${subcommand}" ] ||
			[ "${cmd}-parallel" == "${subcommand}" ]; then
			if [ ${size} -ge 2 ]; then
				COMPREPLY=( $(compgen -W "${OVE_PROJECT_LIST} ${!ove_projects_tags[*]}" -- "${cur}") )
				return
			fi
		fi
	done

	# scripts
	for cmd in ${OVE_SCRIPTS_LIST}; do
		if [ "${cmd}" == "${subcommand}" ] && [ -e "${ove_scripts_name2path[${cmd}]}/${cmd}.complete" ]; then
			source "${ove_scripts_name2path[${cmd}]}/${cmd}.complete"
			return
		fi
	done

	# commands without arguments: do nothing
	if [ ${size} -eq 2 ]; then
		if echo ${OVE_BUILT_INS_WITHOUT_ARGS} | ${ove_cmd2pathname["tr"]:?} ' ' '\n' | ${ove_cmd2pathname["grep"]:?} -q ^${subcommand}$; then
			return
		fi
	fi

	wordlist=""
	if [ "${subcommand}" == "make" ]; then
		if [ ${size} -eq 2 ]; then
			wordlist="${OVE_PROJECT_LIST}"
			wordlist+=" ${OVE_PROJECT_LIST// /-nodeps }-nodeps"
		elif [ ${size} -gt 2 ]; then
			return
		fi
	elif [ "${subcommand}" == "buildme" ] ||
		[ "${subcommand}" == "buildme-parallel" ] ||
		[ "${subcommand}" == "export" ] ||
		[ "${subcommand}" == "install-pkg" ] ||
		[ "${subcommand}" == "list-needs" ] ||
		[ "${subcommand}" == "list-missing-projects" ] ||
		[ "${subcommand}" == "list-projects" ]; then
		if [[ $cur == +* ]] || [[ $cur == -* ]]; then
			wordlist=$(printf "\${cur:0:1}%s " $OVE_PROJECT_LIST)
			if [ ${#ove_projects_tags[*]} -ne 0 ]; then
				a="${!ove_projects_tags[*]}"
				wordlist+=" $(printf "\${cur:0:1}%s " ${a})"
			fi
		else
			wordlist=${OVE_PROJECT_LIST}
			if [ ${#ove_projects_tags[*]} -ne 0 ]; then
				wordlist+=" ${!ove_projects_tags[*]}"
			fi
		fi
	elif [ "${subcommand}" == "proj2path" ]; then
		wordlist=${OVE_PROJECT_LIST}
	elif [ "${subcommand}" == "distrocheck" ]; then
		if [ ${size} -eq 2 ]; then
			wordlist=$(${ove_cmd2pathname["find"]:?} ${OVE_OWEL_DIR}/projects/*/ -name 'distcheck' -exec dirname {} \;)
			if [ "x${wordlist}" != "x" ]; then
				wordlist=${wordlist//${OVE_OWEL_DIR}\/projects\/}
			else
				wordlist=${OVE_PROJECT_LIST}
			fi
		elif [ ${size} -eq 3 ] && [ -s "${OVE_GLOBAL_STATE_DIR}/distro-check.images" ]; then
			wordlist=$(${ove_cmd2pathname["cat"]:?} "${OVE_GLOBAL_STATE_DIR}/distro-check.images")
		else
			return
		fi
	elif [ "${subcommand}" == "run" ]; then
		if [ ${size} -eq 2 ]; then
			wordlist="TIMEOUT"
		elif [ ${size} -eq 3 ]; then
			wordlist="${OVE_ALL_COMMANDS}"
		else
			return
		fi
	elif [ "${subcommand}" == "run-parallel" ]; then
		if [ $((size%2)) -eq 0 ]; then
			wordlist="TIMEOUT"
		elif [ $((size%2)) -eq 1 ]; then
			wordlist="${OVE_ALL_COMMANDS}"
		fi
	elif [ "${subcommand}" == "loop" ]; then
		if [ ${size} -eq 2 ]; then
			wordlist="TIMEOUT"
		elif [ ${size} -eq 3 ]; then
			wordlist="INOTIFY"
		elif [ ${size} -eq 4 ]; then
			wordlist="MAX-COUNT"
		elif [ ${size} -eq 5 ]; then
			wordlist="${OVE_ALL_COMMANDS}"
		else
			return
		fi
	elif [ "${subcommand}" == "ide" ]; then
		if [ ${size} -eq 2 ]; then
			wordlist="close reopen"
		fi
	elif [ "${subcommand}" == "update-revtab" ]; then
		if [ ${size} -eq 2 ]; then
			wordlist=$(ove_revtab_list_basename)
		elif  [ ${size} -eq 3 ]; then
			wordlist=$(ove_list_tags_and_branches ${OVE_BASE_DIR}/${COMP_WORDS[2]})
		fi
	elif [ "${subcommand}" == "checkout" ]; then
		if [ ${size} -eq 2 ]; then
			wordlist=$(ove_list_tags_and_branches)
		elif [ ${size} -eq 3 ]; then
			wordlist="purge autostash"
		else
			return
		fi
	elif [ "${subcommand}" == "fzf" ]; then
		[ ${size} -ne 2 ] && return
		wordlist="loop"
	elif [ "${subcommand}" == "stash" ]; then
		if [ ${size} -eq 2 ]; then
			wordlist="drop list pop show push"
		elif [ ${size} -eq 3 ]; then
			if [ "${COMP_WORDS[2]}" == "drop" ] ||
				[ "${COMP_WORDS[2]}" == "pop" ] ||
				[ "${COMP_WORDS[2]}" == "show" ]; then
			wordlist=$(ove-forall-parallel "git stash list" | \
				${ove_cmd2pathname["grep"]:?} -o 'OVE@[0-9].*' | \
				${ove_cmd2pathname["tr"]:?} '@' ' ' | \
				${ove_cmd2pathname["xargs"]:?} -n1 | \
				${ove_cmd2pathname["sort"]:?} -u)
			else
				return
			fi
		else
			return
		fi
	elif [ "${subcommand}" == "show" ]; then
		if [ ${size} -ge 2 ]; then
			# shellcheck disable=SC2016
			wordlist="$(ove_revtab_forall_parallel '${ove_cmd2pathname["git"]:?} tag') HEAD FETCH_HEAD ORIG_HEAD MERGE_HEAD CHERRY_PICK_HEAD"
			# shellcheck disable=SC2016
			wordlist+=" $(ove-list-heads | ${ove_cmd2pathname["awk"]:?} '{print $2}')"
			if [ -e ${OVE_OWEL_STATE_DIR}/revtab-news ]; then
				wordlist+=" $(${ove_cmd2pathname["grep"]:?} -o '^[a-f0-9]\+' ${OVE_OWEL_STATE_DIR}/revtab-news)"
			fi
			if [ -e ${OVE_OWEL_STATE_DIR}/revtab-ahead ]; then
				wordlist+=" $(${ove_cmd2pathname["grep"]:?} -o '^[a-f0-9]\+' ${OVE_OWEL_STATE_DIR}/revtab-ahead)"
			fi
		fi
	elif [ "${subcommand}" == "diff-owel" ] ||
		[ "${subcommand}" == "log-owel" ] ||
		[ "${subcommand}" == "revtab-diff" ] ||
		[ "${subcommand}" == "shortlog-owel" ]; then
		if [ ${size} -lt 4 ]; then
			wordlist=$(ove_list_tags_and_branches)
		else
			return
		fi
	elif [ "${subcommand}" == "do" ]; then
		if [ ${size} -eq 2 ]; then
			wordlist=$(ove_revtab_list_basename)
		elif [ ${size} -eq 3 ]; then
			[ -d ${OVE_BASE_DIR}/${COMP_WORDS[2]} ] &&
				wordlist=$(${ove_cmd2pathname["find"]:?} $(${ove_cmd2pathname["readlink"]:?} -f -- ${OVE_BASE_DIR}/${COMP_WORDS[2]}) -perm -u=x -not -path '*.git*' -type f)
		elif [ ${size} -gt 3 ]; then
			return
		fi
	elif [ "${subcommand}" == "cd" ]; then
		if [ ${size} -eq 2 ]; then
			wordlist=$(ove_list_workspaces_base)
		elif [ ${size} -gt 2 ]; then
			return
		fi
	elif [ "${subcommand}" == "refresh" ]; then
		if [ ${size} -ge 2 ]; then
			wordlist=$(ove_list_workspaces_base)
		fi
	elif [ "${subcommand}" == "vi" ] ||
		[ "${subcommand}" == "edit" ] ||
		[ "${subcommand}" == "emacs" ]; then
		if [ ${size} -lt 2 ]; then
			return
		fi
		refresh=0
		if [ -e ${OVE_OWEL_TMP_DIR}/ls-mod-files-base ]; then
			a=$(${ove_cmd2pathname["stat"]:?} --format '%Y' "${OVE_OWEL_TMP_DIR}/ls-mod-files-base")
			b=$(${ove_cmd2pathname["date"]:?} +%s)
			if [ $((b-a)) -gt $OVE_EDIT_LIFESPAN_TIME_IN_SEC ]; then
				refresh=1
			fi
		else
				refresh=1
		fi
		if [ $refresh -eq 1 ]; then
			ove-list-modified-files | \
				${ove_cmd2pathname["sed"]:?} -e "s,${OVE_BASE_DIR}/,,g" > ${OVE_OWEL_TMP_DIR}/ls-mod-files-base
		fi
		refresh=0
		if [ -e ${OVE_OWEL_TMP_DIR}/ls-files ]; then
			a=$(${ove_cmd2pathname["stat"]:?} --format '%Y' "${OVE_OWEL_TMP_DIR}/ls-files")
			b=$(${ove_cmd2pathname["date"]:?} +%s)
			if [ $((b-a)) -gt $OVE_EDIT_LIFESPAN_TIME_IN_SEC ]; then
				refresh=1
			fi
		else
				refresh=1
		fi
		if [ $refresh -eq 1 ]; then
			ove-ls-files > ${OVE_OWEL_TMP_DIR}/ls-files
		fi
		wordlist="$(${ove_cmd2pathname["cat"]:?} ${OVE_OWEL_TMP_DIR}/ls-mod-files-base ${OVE_OWEL_TMP_DIR}/ls-files)"
	elif [ "${subcommand}" == "add-config" ]; then
		if [ ${size} -eq 2 ]; then
			wordlist=${OVE_CONFIG_FILES_USER}
		elif [ ${size} -eq 3 ]; then
			wordlist="$(type ove_config_builtins_init | \
				${ove_cmd2pathname["grep"]:?} -o 'OVE_[A-Z_]\+')"
		fi
	elif [ "${subcommand}" == "config" ]; then
		# do we have a config file in the first place?
		if [ "x$(ove_list_oveconfig_files_user)" != "x" ]; then
			cmd="ove-config"
			if [ ${size} -eq 3 ]; then
				# is 2 a config file?
				if eval ove_config_validate_file ${COMP_WORDS[2]}; then
					# add the config file as argument to ove-config
					cmd+=" ${COMP_WORDS[2]}"
				else
					wordlist=$(ove_config_get_allowed ${COMP_WORDS[2]})
				fi
			elif [ ${size} -eq 4 ]; then
				wordlist=$(ove_config_get_allowed ${COMP_WORDS[3]})
			fi

			if [ "x$wordlist" = "x" ]; then
				# shellcheck disable=SC2016
				wordlist=$(eval ${cmd} | \
					${ove_cmd2pathname["sed"]:?} -e "s/\x1B\[[0-9;]*[mK]//g" -e "s|^/.*/\.oveconfig||g" -e "s|^:||" | \
					${ove_cmd2pathname["awk"]:?} '{print $1}')
			fi
		fi
	elif [ "${subcommand}" == "reset-hard" ]; then
		if [ ${size} -ge 2 ]; then
			wordlist=$(ove_list_dirty_repos)
		fi
	elif [ "${subcommand}" == "add" ] ||
		[ "${subcommand}" == "diff" ] ||
		[ "${subcommand}" == "wdiff" ]; then
		if [ ${size} -ge 2 ]; then
			wordlist=$(ove_list_dirty_repos_worktree)
		fi
	elif [ "${subcommand}" == "add" ] ||
		[ "${subcommand}" == "commit" ] ||
		[ "${subcommand}" == "diff" ] ||
		[ "${subcommand}" == "diff-cached" ] ||
		[ "${subcommand}" == "reset" ] ||
		[ "${subcommand}" == "wdiff" ] ||
		[ "${subcommand}" == "wdiff-cached" ]; then
		if [ ${size} -ge 2 ]; then
			wordlist=$(ove_list_dirty_repos_index)
		fi
	elif [ "${subcommand}" == "branch" ] ||
		[ "${subcommand}" == "describe" ] ||
		[ "${subcommand}" == "fsck" ] ||
		[ "${subcommand}" == "heads2revtab" ] ||
		[ "${subcommand}" == "list-stash" ] ||
		[ "${subcommand}" == "readme" ] ||
		[ "${subcommand}" == "remote" ] ||
		[ "${subcommand}" == "show-dangling" ]; then
		if [ ${size} -ge 2 ]; then
			wordlist=$(ove_revtab_list_basename)
		fi
	elif [ "${subcommand}" == "remove-repo" ] ||
		[ "${subcommand}" == "revtab-sync" ]; then
		if [ ${size} -ge 2 ]; then
			wordlist=$(ove_revtab_list_basename)
		fi
	elif [ "${subcommand}" == "list-repositories" ]; then
		if [ ${size} -eq 2 ]; then
			wordlist="behind ahead"
		fi
	elif [ "${subcommand}" == "news" ] ||
		[ "${subcommand}" == "behind" ] ||
		[ "${subcommand}" == "show-behind" ] ||
		[ "${subcommand}" == "show-news" ] ||
		[ "${subcommand}" == "pull" ]; then
		wordlist=$(ove_list_repositories "behind")
	elif [ "${subcommand}" == "ahead" ] ||
		[ "${subcommand}" == "rebase-autosquash" ] ||
		[ "${subcommand}" == "reset-ahead" ] ||
		[ "${subcommand}" == "show-ahead" ]; then
		wordlist=$(ove_list_repositories "ahead")
	elif [ "${subcommand}" == "demo" ] ||
		[ "${subcommand}" == "fetch" ] ||
		[ "${subcommand}" == "list-heads" ] ||
		[ "${subcommand}" == "patch-repo" ] ||
		[ "${subcommand}" == "status" ]; then
		wordlist=$(ove_revtab_list_basename)
	elif [ "${subcommand}" == "list-commands" ]; then
		wordlist=$(ove_list_command_categories)
	elif [ "${subcommand}" == "worktree" ]; then
		if [ ${size} -eq 2 ]; then
			wordlist="add"
			wordlist+=" list"
			wordlist+=" prune"
			wordlist+=" remove"
			wordlist+=" status"
		elif [ ${size} -ge 3 ]; then
			if [ "${COMP_WORDS[2]}" == "list" ] ||
				[ "${COMP_WORDS[2]}" == "remove" ] ||
				[ "${COMP_WORDS[2]}" == "status" ]; then
				wordlist=$(${ove_cmd2pathname["find"]:?} $OVE_OWEL_STATE_DIR/worktree/ -mindepth 1 -maxdepth 1 -type l 2> /dev/null)
				wordlist=${wordlist//$OVE_OWEL_STATE_DIR\/worktree\/}
			fi
		fi
	elif [ "${subcommand}" == "systest" ] ||
		[ "${subcommand}" == "systest-parallel" ]; then
		if [ ${size} -ge 2 ]; then
			wordlist=$(ove-list-systests)
		fi
	elif [ "${subcommand}" == "add-project" ]; then
		if [ ${size} -ge 4 ]; then
			wordlist="deps needs bootstrap configure build install clean test"
		fi
	elif [ "${subcommand}" == "apply" ]; then
		if [ ${size} -ge 2 ]; then
			return
		fi
	elif [ "${subcommand}" == "env" ]; then
		if [ ${size} -eq 2 ]; then
			wordlist=$(compgen -A variable | ${ove_cmd2pathname["grep"]:?} OVE_)
		else
			return
		fi
	elif [ "${subcommand}" == "task" ]; then
		if command -v task > /dev/null && [ ${size} -eq 2 ]; then
			wordlist=$(${ove_cmd2pathname["task"]:?} _commands)
		fi
	elif [ "${subcommand}" == "unittest" ]; then
		if [ ${size} -ge 2 ]; then
			wordlist=$(${ove_cmd2pathname["find"]:?} ${OVE_DIR}/tests -maxdepth 1 -mindepth 1 -name "t*.test" -type f -exec basename {} .test \;)
		fi
	elif [ "${subcommand}" == "what-is" ]; then
		if [ ${size} -ge 2 ]; then
			wordlist=$(${ove_cmd2pathname["find"]:?} $(${ove_cmd2pathname["readlink"]:?} -f -- ${PWD}) -maxdepth 1 -mindepth 1 -not -path '*.git' -type d -exec basename {} \;)
		fi
	elif [ "${subcommand}" == "head-tail" ]; then
		if [ ${size} -ge 2 ]; then
			wordlist=$(${ove_cmd2pathname["find"]:?} $(${ove_cmd2pathname["readlink"]:?} -f -- ${PWD}) -maxdepth 1 -mindepth 1 -not -path '*.git' -type f -exec basename {} \;)
		fi
	elif [ "${subcommand}" == "select-configuration" ]; then
		if [ ${size} -eq 2 ]; then
			wordlist="default $(${ove_cmd2pathname["find"]:?} "${OVE_OWEL_DIR}/projects" -name "configure-*" -type l -exec basename {} \; | ${ove_cmd2pathname["sed"]:?} 's/configure-//g')"
		else
			return
		fi
	elif [ "${subcommand}" == "replicate" ]; then
		if [ ${size} -eq 2 ]; then
			if [ "$(type -t _known_hosts_real)" == "function" ]; then
				_known_hosts_real -a -- "$cur"
				return
			fi
		elif [ ${size} -eq 3 ]; then
			wordlist=$(${ove_cmd2pathname["ssh"]:?} ${COMP_WORDS[2]} "command -v locate > /dev/null && ${ove_cmd2pathname["locate"]:?} .owel || \
				${ove_cmd2pathname["find"]:?} \${PWD} -maxdepth 2 -name .owel" | \
				${ove_cmd2pathname["sed"]:?} -e 's|/.owel$||g' | \
				${ove_cmd2pathname["xargs"]:?})
		fi
	elif [ "${subcommand}" == "tail-lastlog" ] ||
		[ "${subcommand}" == "less-lastlog" ]; then
		if [ ${size} -ge 2 ]; then
			if [ -d /var/tmp ]; then
				a="/var/tmp"
			else
				a="/tmp"
			fi

			# shellcheck disable=SC2015
			wordlist=$(${ove_cmd2pathname["find"]:?} ${a}/*/ove/logs -maxdepth 0 -type d | \
				${ove_cmd2pathname["rev"]:?} | \
				${ove_cmd2pathname["cut"]:?} -d'/' -f3 | \
				${ove_cmd2pathname["rev"]:?})
		else
			return
		fi
	fi

	if [ "${wordlist}" != "" ]; then
		COMPREPLY=( $(compgen -W "${wordlist}" -- ${cur}) )
	else
		opts="${OVE_ALL_COMMANDS}"
		if compgen -W "${opts}" -- "${cur}" &> /dev/null; then
			COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
		fi
	fi
}

function ove_get_built_ins {
	local a

	a=$(${ove_cmd2pathname["grep"]:?} -o '^function ove-.* ' ${OVE_SELF} | \
		${ove_cmd2pathname["sed"]:?} -e ':a;N;$!ba;s/function ove-//g' | \
		LC_ALL="C"  ${ove_cmd2pathname["sort"]:?})
	a=${a//$'\n'/ }
	echo ${a}
}

function ove_update_tab_complete {
	local array
	local cmd
	local oldIFS

	# project commands
	OVE_ALL_COMMANDS=${OVE_PROJECT_COMMANDS}

	# built-in functions
	OVE_ALL_COMMANDS+=" ${OVE_BUILT_INS:?}"

	# scripts
	if [ "${OVE_SCRIPTS_LIST}" != "" ]; then
		OVE_ALL_COMMANDS+=" ${OVE_SCRIPTS_LIST}"
	fi

	# parallel project commands
	for cmd in ${OVE_PROJECT_COMMANDS}; do
		OVE_ALL_COMMANDS+=" ${cmd}-parallel"
	done

	array=(${OVE_ALL_COMMANDS})
	oldIFS=${IFS}
	IFS=$'\n' OVE_ALL_COMMANDS=$(printf '%s ' $(LC_ALL="C" ${ove_cmd2pathname["sort"]:?} <<<"${array[*]}"))
	# OVE_ALL_COMMANDS:space separated list of all OVE commands
	OVE_ALL_COMMANDS=${OVE_ALL_COMMANDS::-1}
	export OVE_ALL_COMMANDS
	IFS=${oldIFS}

	complete -o bashdefault -o default -F ove_bash_complete ove
	for cmd in ${OVE_PROJECT_COMMANDS}; do
		complete -W "${OVE_PROJECT_LIST}" "ove-${cmd}"
	done
}

function ove_add_script_func {
	local htext
	local r_dir
	local s
	local s_dir

	s_dir=$1
	s=$2
	r_dir=${s_dir%\/*}
	r_dir=${r_dir%\/*}

	if [ -v ove_scripts_name2path[${s}] ]; then
		ove_echo_yellow_noprefix "warning: found script duplicate:"
		echo "$s_dir/$s (ignored)"
		echo "${ove_scripts_name2path[${s}]}/$s"
		return 1
	fi
	ove_scripts_name2path[${s}]=${s_dir}
	ove_scripts_paths[${s_dir}]=
	if [ -f ${s_dir}/${s}.help ]; then
		htext=$(<${s_dir}/${s}.help)
		if [[ "$htext" != *:PLUGIN ]]; then
			htext="$s:$(${ove_cmd2pathname["cut"]:?} -d: -f2- ${s_dir}/${s}.help):PLUGIN"
		fi
	else
		htext="${s}: :run '${s_dir}/${s}':PLUGIN"
	fi

	eval "ove-${s}() {
		ove_entry || return
		local ove_plugin_helptext=\"${htext}\"
		local __scriptname=ove-${s}
		OVE_ACTIVE_REPO_DIR=${r_dir} \"${s_dir}\"/${s} \"\$@\"
	}"
	export -f ove-${s}
}

function ove_hooks_init {
	local _find
	local cmd
	local h
	local h_list
	local repo

	unset ove_hooks_post
	unset ove_hooks_pre
	declare -A -g ove_hooks_post
	declare -A -g ove_hooks_pre

	# project hooks
	if [ -d "${OVE_OWEL_DIR}/hooks" ]; then
		_find+="${OVE_OWEL_DIR}/hooks "
	fi

	# repo hooks
	for repo in $(ove_revtab_list_fullpath); do
		if ! [ -d "${repo}/.ove/hooks" ]; then
			continue
		fi

		_find+="${repo}/.ove/hooks "
	done

	# global hooks
	if [ -d "${OVE_GLOBAL_STATE_DIR}/hooks" ]; then
		_find+="${OVE_GLOBAL_STATE_DIR}/hooks "
	fi

	if [ "x${_find}" != "x" ]; then
		# post hooks
		h_list=$(${ove_cmd2pathname["find"]:?} -L ${_find} -name 'post-*' -perm -u=x -type f)
		for h in ${h_list}; do
			if ! [ -s "$h" ]; then
				continue
			fi
			cmd="${h##*/}"
			cmd=${cmd/post-/}
			ove_hooks_post[$cmd]+="$h "
		done

		# pre hooks
		h_list=$(${ove_cmd2pathname["find"]:?} -L ${_find} -name 'pre-*' -perm -u=x -type f)
		for h in ${h_list}; do
			if ! [ -s "$h" ]; then
				continue
			fi
			cmd="${h##*/}"
			cmd=${cmd/pre-/}
			ove_hooks_pre[$cmd]+="$h "
		done
	fi
}

function ove_scripts_init {
	local array
	local oldIFS
	local prev_scripts
	local repo
	local s
	local s_list

	unset ove_scripts_name2path
	unset ove_scripts_paths

	declare -A -g ove_scripts_name2path
	declare -A -g ove_scripts_paths

	OVE_SCRIPTS_LIST=

	# unset any ove- functions marked with "__scriptname"
	if prev_scripts=$(set | ${ove_cmd2pathname["grep"]:?} '^    local __scriptname=.*'); then
		prev_scripts=${prev_scripts//    local __scriptname=}
		prev_scripts=${prev_scripts//;}
		[ "${prev_scripts}" != "" ] && unset -f ${prev_scripts}
	fi

	# project scripts
	if [ -d "${OVE_OWEL_DIR}/scripts" ]; then
		s_list=$(${ove_cmd2pathname["find"]:?} ${OVE_OWEL_DIR}/scripts -perm -u=x -not -name '*.help' -type f)
		for s in ${s_list}; do
			ove_add_script_func ${s%/*} ${s##*/}
			OVE_SCRIPTS_LIST+="${s##*/} "
		done
	fi

	# OVE scripts
	if [ -d "${OVE_DIR}/scripts" ]; then
		s_list=$(${ove_cmd2pathname["find"]:?} ${OVE_DIR}/scripts -perm -u=x -not -name '*.help' -type f)
		for s in ${s_list}; do
			ove_add_script_func ${s%/*} ${s##*/}
			OVE_SCRIPTS_LIST+="${s##*/} "
		done
	fi

	# repo scripts
	for repo in $(ove_revtab_list_fullpath); do
		! [ -d "${repo}/.ove/scripts" ] && continue
		s_list=$(${ove_cmd2pathname["find"]:?} -L ${repo}/.ove/scripts -perm -u=x -not -name '*.help' -type f)
		for s in ${s_list}; do
			ove_add_script_func ${s%/*} ${s##*/}
			OVE_SCRIPTS_LIST+="${s##*/} "
		done
	done

	array=(${OVE_SCRIPTS_LIST})
	oldIFS=${IFS}
	IFS=$'\n' OVE_SCRIPTS_LIST=$(printf '%s ' $(LC_ALL="C" ${ove_cmd2pathname["sort"]:?} <<<"${array[*]}"))
	OVE_SCRIPTS_LIST=${OVE_SCRIPTS_LIST::-1}
	IFS=${oldIFS}
}

# show-configuration: :show current build configuration for each project:BUILD
function ove-show-configuration {
	ove_entry || return

	if [ -d "${OVE_OWEL_DIR}/projects" ]; then
		${ove_cmd2pathname["find"]:?} ${OVE_OWEL_DIR}/projects -type f -name 'configure' -print -or -type l -name 'configure' -exec file {} \; | \
			LC_ALL="C" ${ove_cmd2pathname["sort"]:?} | \
			${ove_cmd2pathname["sed"]:?} -e "s,^${OVE_OWEL_DIR}/projects/,,g" | \
			${ove_cmd2pathname["column"]:?} -t -s/ | \
			${ove_cmd2pathname["sed"]:?} -e "s,: symbolic link to, ->,g"
	fi
}

# select-configuration:[pattern|default]:select build configuration for each project:BUILD
function ove-select-configuration {
	ove_entry || return

	local c
	local configs
	local iter
	local nbr_of_configs
	local p
	local projects

	# list of projects
	projects=${OVE_PROJECT_LIST}
	iter=1
	for p in ${projects}; do
		# ignore projects without a project directory
		[ ! -d "${OVE_OWEL_DIR}/projects/${p}" ] && continue

		# multiple configurations, ask which one to select
		configs=$(${ove_cmd2pathname["find"]:?} "${OVE_OWEL_DIR}/projects/${p}" -name "configure-*" -type l)
		nbr_of_configs=$(${ove_cmd2pathname["find"]:?} "${OVE_OWEL_DIR}/projects/${p}" -name "configure-*" -type l | ${ove_cmd2pathname["wc"]:?} -l)
		if [ "${nbr_of_configs}" -gt 1 ]; then
			# pattern, select config
			if [ $# -eq 1 ]; then
				# use the default configuration
				if [ $1 == "default" ]; then
					ove_repo_cmd ${OVE_OWEL_DIR} checkout ${OVE_OWEL_DIR}/projects/${p}/configure
					continue
				fi

				for c in ${configs}; do
					if ${ove_cmd2pathname["grep"]:?} -w -q configure-$1 <<< "${c##*/}"; then
						ove_echo_green_noprefix ${p}:
						if ! pushd ${OVE_OWEL_DIR}/projects/${p} &>/dev/null; then
							ove_echo_fatal_noprefix "'pushd ${OVE_OWEL_DIR}/projects/${p}' failed"
							return 1
						elif ! ${ove_cmd2pathname["ln"]:?} -sfv configure-$1 configure; then
							ove_echo_fatal_noprefix "'ln' failed"
							return 1
						elif ! popd &>/dev/null; then
							ove_echo_fatal_noprefix "'popd' failed"
							return 1
						fi
						break
					fi
				done
				continue
			fi

			# no pattern, ask user
			ove_echo_green_noprefix ${p}:
			echo "0: default"
			(( iter=1 ))
			for c in ${configs}; do
				echo -n "${iter}: "
				${ove_cmd2pathname["basename"]:?} $(echo ${c} | ${ove_cmd2pathname["sed"]:?} 's/configure-//g')
				(( iter+=1 ))
			done
			echo
			read -p "Select configuration? " -r
			echo
			if [[ ${REPLY} =~ ^[0-9]+$ ]] && [[ ${REPLY} -le ${nbr_of_configs} ]]; then
				if [[ ${REPLY} == 0 ]]; then
					ove_repo_cmd ${OVE_OWEL_DIR} checkout ${OVE_OWEL_DIR}/projects/${p}/configure
				else
					cfg=$(echo ${configs} | ${ove_cmd2pathname["cut"]:?} -d' ' -f${REPLY})
					cfg_basename=${cfg##*/}
					if ! pushd ${OVE_OWEL_DIR}/projects/${p} &>/dev/null; then
						ove_echo_fatal_noprefix "'pushd ${OVE_OWEL_DIR}/projects/${p}' failed"
						return 1
					elif ! ${ove_cmd2pathname["ln"]:?} -sfv ${cfg_basename} configure; then
						ove_echo_fatal_noprefix "'ln' failed"
						return 1
					elif ! popd &>/dev/null; then
						ove_echo_fatal_noprefix "'popd' failed"
						return 1
					fi
				fi
			fi
		fi
	done

	ove-show-configuration
}

function ove_dirs_init {
	local OVE_STATE_LINK_NAME
	local OVE_TMP_LINK_NAME

	OVE_STATE_LINK_NAME="${OVE_BASE_DIR}/.ove.state"
	OVE_TMP_LINK_NAME="${OVE_BASE_DIR}/.ove.tmp"

	# OVE_GLOBAL_STATE_DIR:shared directory for all OVE workspaces (per user)
	OVE_GLOBAL_STATE_DIR=
	if [ -d /var/tmp ]; then
		OVE_GLOBAL_STATE_DIR=/var${OVE_TMP}
	else
		OVE_GLOBAL_STATE_DIR=${OVE_TMP}
	fi
	export OVE_GLOBAL_STATE_DIR

	# OVE_OWEL_STATE_DIR:state directory for one OVE workspace
	OVE_OWEL_STATE_DIR=
	if ! [ -h ${OVE_STATE_LINK_NAME} ] || [ "$(${ove_cmd2pathname["readlink"]:?} -f -- ${OVE_STATE_LINK_NAME})" == "" ]; then
		[ -h ${OVE_STATE_LINK_NAME} ] && ${ove_cmd2pathname["rm"]:?} ${OVE_STATE_LINK_NAME}
		OVE_OWEL_STATE_DIR=$(${ove_cmd2pathname["mktemp"]:?} -u -d -p ${OVE_GLOBAL_STATE_DIR}/${OVE_OWEL_NAME} state-XXXXXXXXXX)

		${ove_cmd2pathname["mkdir"]:?} -p ${OVE_OWEL_STATE_DIR}
		${ove_cmd2pathname["ln"]:?} -s ${OVE_OWEL_STATE_DIR} ${OVE_STATE_LINK_NAME}

		# always re-create tmp link
		[ -h ${OVE_TMP_LINK_NAME} ] && ${ove_cmd2pathname["rm"]:?} ${OVE_TMP_LINK_NAME}
	else
		OVE_OWEL_STATE_DIR=$(${ove_cmd2pathname["readlink"]:?} -f -- ${OVE_STATE_LINK_NAME})
		! [ -e "${OVE_STATE_LINK_NAME}" ] && ${ove_cmd2pathname["mkdir"]:?} -p ${OVE_OWEL_STATE_DIR}
	fi
	export OVE_OWEL_STATE_DIR

	# OVE_OWEL_TMP_DIR:temporary directory for one OVE workspace
	OVE_OWEL_TMP_DIR=
	if ! [ -h ${OVE_TMP_LINK_NAME} ] || [ "$(${ove_cmd2pathname["readlink"]:?} -f -- ${OVE_TMP_LINK_NAME})" == "" ]; then
		[ -h ${OVE_TMP_LINK_NAME} ] && ${ove_cmd2pathname["rm"]:?} ${OVE_TMP_LINK_NAME}
		# re-use last 10 characters from OVE_OWEL_STATE_DIR
		OVE_OWEL_TMP_DIR="${OVE_TMP}/${OVE_OWEL_NAME}/tmp-${OVE_OWEL_STATE_DIR: -10}"
		${ove_cmd2pathname["mkdir"]:?} -p ${OVE_OWEL_TMP_DIR}
		${ove_cmd2pathname["ln"]:?} -s ${OVE_OWEL_TMP_DIR} ${OVE_TMP_LINK_NAME}
	else
		OVE_OWEL_TMP_DIR=$(${ove_cmd2pathname["readlink"]:?} -f -- ${OVE_TMP_LINK_NAME})
		! [ -e "${OVE_TMP_LINK_NAME}" ] && ${ove_cmd2pathname["mkdir"]:?} -p ${OVE_OWEL_TMP_DIR}
	fi
	export OVE_OWEL_TMP_DIR

	OVE_LOG_DIR="${OVE_GLOBAL_STATE_DIR}/logs"
	export OVE_LOG_DIR

	if ! [ -d "${OVE_LOG_DIR}" ]; then
		${ove_cmd2pathname["mkdir"]:?} -p "${OVE_LOG_DIR}"
	fi

	if ! [ -d "${OVE_GLOBAL_STATE_DIR}/.ove" ]; then
		${ove_cmd2pathname["mkdir"]:?} -p "${OVE_GLOBAL_STATE_DIR}/.ove"
	fi
}

function ove_config_init {
	local f

	# cleanup previous configs
	if [ "x${OVE_CONFIG_ALL}" != "x" ]; then
		unset ${OVE_CONFIG_ALL} OVE_CONFIG_ALL
	fi

	# keep the order
	OVE_CONFIG_FILES_USER="${OVE_OWEL_DIR}/.oveconfig"
	OVE_CONFIG_FILES_USER+=" ${OVE_OWEL_STATE_DIR}/.oveconfig"
	OVE_CONFIG_FILES_USER+=" ${OVE_GLOBAL_STATE_DIR}/.oveconfig"
	OVE_CONFIG_FILES_USER+=" ${HOME}/.oveconfig"
	export OVE_CONFIG_FILES_USER

	OVE_CONFIG_FILE_INTERNAL="${OVE_GLOBAL_STATE_DIR}/.ove/.oveconfig"
	export OVE_CONFIG_FILE_INTERNAL

	OVE_CONFIG_FILES_ALL="${OVE_CONFIG_FILES_USER}"
	OVE_CONFIG_FILES_ALL+=" ${OVE_CONFIG_FILE_INTERNAL}"
	export OVE_CONFIG_FILES_ALL

	# first set any duplicates
	ove_read_config_pre $OVE_CONFIG_FILES_ALL

	# ...then read configs in order
	for f in ${OVE_CONFIG_FILES_ALL}; do
		if [ -e "${f}" ]; then
			ove_read_config ${f}
		fi
	done
}

function ove_config_builtins_init {
	# OVE_DRY_RUN:int:0|1:all-build-commands systest:dry-run
	if [ -z "${OVE_DRY_RUN+x}" ]; then
		export OVE_DRY_RUN=0
	fi

	# OVE_FETCH_MAX_PARALLEL:int:[0-9]+:fetch:max number of 'git fetch' to run in parallel
	if [ -z "${OVE_FETCH_MAX_PARALLEL+x}" ]; then
		export OVE_FETCH_MAX_PARALLEL=0
	fi

	# OVE_FETCH_SUBMODULES:int:0-1:add-repo,fetch:automatically run 'ove import-submodules' on inital clone
	if [ -z "${OVE_FETCH_SUBMODULES+x}" ]; then
		export OVE_FETCH_SUBMODULES=1
	fi

	# OVE_AUTO_CLONE:int:0|1:all-build-commands:automatically clone repos
	if [ -z "${OVE_AUTO_CLONE+x}" ]; then
		export OVE_AUTO_CLONE=0
	fi

	# OVE_CLONE_MAX_PARALLEL:int:[0-9]+:fetch:max number of 'git clone' to run in parallel
	if [ -z "${OVE_CLONE_MAX_PARALLEL+x}" ]; then
		export OVE_CLONE_MAX_PARALLEL=0
	fi

	# OVE_LOCATE_SEARCH_DIR:string::locate:where to search for OVE workspaces (only if 'locate' is unavailable)
	if [ -z "${OVE_LOCATE_SEARCH_DIR+x}" ]; then
		OVE_LOCATE_SEARCH_DIR=$(${ove_cmd2pathname["readlink"]:?} -f -- $(${ove_cmd2pathname["dirname"]:?} ${HOME}))
		export OVE_LOCATE_SEARCH_DIR
	fi

	# OVE_DEFAULT_BRANCH_NAME:string::add-repo unittest:default branch name
	if [ -z "${OVE_DEFAULT_BRANCH_NAME+x}" ]; then
		export OVE_DEFAULT_BRANCH_NAME="main"
	fi

	# OVE_OWEL_CI_BRANCH:string::log:branch to use for 'ove log'
	if [ -z "${OVE_OWEL_CI_BRANCH+x}" ]; then
		export OVE_OWEL_CI_BRANCH="origin/${OVE_DEFAULT_BRANCH_NAME}"
	fi

	# OVE_LOGLEVEL:int:0-9:all:set a specific log level
	if [ -z "${OVE_LOGLEVEL+x}" ]; then
		export OVE_LOGLEVEL=1
		export OVE_REDIRECT_OUTPUT=""
	fi

	# OVE_AUTO_CORRECT:int:0|1:all:automatically correct commands
	if [ -z "${OVE_AUTO_CORRECT+x}" ]; then
		export OVE_AUTO_CORRECT=0
	fi

	# OVE_LOCAL_ECHO:int:0|1:all:print command-to-be-executed on stderr
	if [ -z "${OVE_LOCAL_ECHO+x}" ]; then
		export OVE_LOCAL_ECHO=0
	fi

	# OVE_AUTO_RM_LOGS:int:0|days:all:automatically remove OVE logs
	if [ -z "${OVE_AUTO_RM_LOGS+x}" ]; then
		export OVE_AUTO_RM_LOGS=0
	fi

	# OVE_ANONYMIZE_LOGS:int:0|1:all:try to anonymize logs by removing user specific info
	if [ -z "${OVE_ANONYMIZE_LOGS+x}" ]; then
		export OVE_ANONYMIZE_LOGS=0
	fi

	# OVE_REVTAB_CHECK:int:0|1:all:keep repos in-sync with 'revtab'
	if [ -z "${OVE_REVTAB_CHECK+x}" ]; then
		export OVE_REVTAB_CHECK=1
	fi

	# OVE_PATCH_REPOS:int:0|1:patch-repo pull source:if set, use OVE_PATCH_REPOS_METHOD to apply patches
	if [ -z "${OVE_PATCH_REPOS+x}" ]; then
		export OVE_PATCH_REPOS=1
	fi

	# OVE_PATCH_REPOS_METHOD:string:am|apply|auto:patch-repo pull source:patch method
	if [ -z "${OVE_PATCH_REPOS_METHOD+x}" ]; then
		export OVE_PATCH_REPOS_METHOD="apply"
	fi

	# OVE_MAKEFLAGS:int::all-build-commands:passed on to 'make' based build systems through MAKEFLAGS
	if [ -z "${OVE_MAKEFLAGS+x}" ]; then
		OVE_MAKEFLAGS="-j$(${ove_cmd2pathname["getconf"]:?} _NPROCESSORS_ONLN)"
		export OVE_MAKEFLAGS
	fi

	# OVE_LOG_DIR_DISK_USAGE_WARNING_MB:int:[0-9]+:all:threshold when logs take too much space
	if [ -z "${OVE_LOG_DIR_DISK_USAGE_WARNING_MB+x}" ]; then
		export OVE_LOG_DIR_DISK_USAGE_WARNING_MB=100
	fi

	# OVE_TAINT_USER_ENV:int:0|1:user's env:taint user's PATH/LD_LIBRARY_PATH/PKG_CONFIG/MAKEFLAGS
	if [ -z "${OVE_TAINT_USER_ENV+x}" ]; then
		export OVE_TAINT_USER_ENV=1
	fi

	# OVE_BUILDME_PRE_STEPS:string::buildme buildme-parallel:project step(s) to run without build order considerations
	if [ -z "${OVE_BUILDME_PRE_STEPS+x}" ]; then
		export OVE_BUILDME_PRE_STEPS="bootstrap"
	fi

	# OVE_BUILDME_STEPS:string::buildme buildme-parallel:project step(s) to run
	if [ -z "${OVE_BUILDME_STEPS+x}" ]; then
		export OVE_BUILDME_STEPS="configure build install"
	fi

	# OVE_SYSTEST_REPEAT:int:>0:systest:repeat tests
	if [ -z "${OVE_SYSTEST_REPEAT+x}" ]; then
		export OVE_SYSTEST_REPEAT=1
	fi

	# OVE_SYSTEST_SKIP:int|string::systest:skip every nth test or specific tests
	if [ -z "${OVE_SYSTEST_SKIP+x}" ]; then
		export OVE_SYSTEST_SKIP=1
	fi

	# OVE_SYSTEST_CLEANUP:int:0|1:systest:cleanup child procs after each systest
	if [ -z "${OVE_SYSTEST_CLEANUP+x}" ]; then
		export OVE_SYSTEST_CLEANUP=0
	fi

	# OVE_SYSTEST_HEADER:string:detailed|short|off:systest:systest text detail level
	if [ -z "${OVE_SYSTEST_HEADER+x}" ]; then
		export OVE_SYSTEST_HEADER="short"
	fi

	# OVE_FORCE_SERIALIZE_COMMANDS:string::all-parallel-build-commands:force OVE to serialize one or more project steps
	if [ -z "${OVE_FORCE_SERIALIZE_COMMANDS+x}" ]; then
		export OVE_FORCE_SERIALIZE_COMMANDS=""
	fi

	# OVE_LOOP_INOTIFY_EXTRA:string::loop:semi-colon separated list of additional files/directories to watch using inotify
	if [ -z "${OVE_LOOP_INOTIFY_EXTRA+x}" ]; then
		export OVE_LOOP_INOTIFY_EXTRA=""
	fi

	# OVE_TMUX_LAYOUT:string::less-lastlog loop run tail-lastlog:tmux layout to use when launching new panes
	if [ -z "${OVE_TMUX_LAYOUT+x}" ]; then
		export OVE_TMUX_LAYOUT="tiled"
	fi

	# OVE_TMUX_PANE_HEADER:string:wide|short|off:fzf loop run :header style for tmux panes
	if [ -z "${OVE_TMUX_PANE_HEADER+x}" ]; then
		export OVE_TMUX_PANE_HEADER="short"
	fi

	# OVE_LOCATE_LIFESPAN_TIME_IN_SEC:int::cd forowel locate locate-all refresh:local OVE workspace cache lifespan
	if [ -z "${OVE_LOCATE_LIFESPAN_TIME_IN_SEC+x}" ]; then
		export OVE_LOCATE_LIFESPAN_TIME_IN_SEC=86400
	fi

	# OVE_EDIT_LIFESPAN_TIME_IN_SEC:int::emacs vi:cache ls-files and ls-modified-files
	if [ -z "${OVE_EDIT_LIFESPAN_TIME_IN_SEC+x}" ]; then
		export OVE_EDIT_LIFESPAN_TIME_IN_SEC=30
	fi

	# OVE_IDE_LOOP_ARGS:string::ide:semi-colon separated list of arguments to 'ove-loop' to launch
	if [ -z "${OVE_IDE_LOOP_ARGS+x}" ]; then
		export OVE_IDE_LOOP_ARGS="3600 0 0 fetch;60 1 0 ahead;3600 0 0 news"
	fi

	# OVE_IDE_SLEEP_BETWEEN_COMMANDS:float::ide:sleep between each command
	if [ -z "${OVE_IDE_SLEEP_BETWEEN_COMMANDS+x}" ]; then
		export OVE_IDE_SLEEP_BETWEEN_COMMANDS=0.5
	fi

	# OVE_ACCELERATE_BUILDS:int:0|1:all-build-commands:prefix build acceleration tools (ccache/icecream) to PATH
	if [ -z "${OVE_ACCELERATE_BUILDS+x}" ]; then
		export OVE_ACCELERATE_BUILDS=0
	fi

	# OVE_STATUS_TRUNC:int:0|1:status:truncate output to fit terminal
	if [ -z "${OVE_STATUS_TRUNC+x}" ]; then
		export OVE_STATUS_TRUNC=1
	fi

	# OVE_INSTALL_PKG:int:0-2:buildme buildme-parallel install-pkg:skip (=0), install (=1) or prompt (=2) packages
	if [ -z "${OVE_INSTALL_PKG+x}" ]; then
		export OVE_INSTALL_PKG=2
	fi

	# OVE_GIT_COMMAND_OPTIONS_DEFAULT:string::all commands:semi-colon separated list of git command options (defaults)
	if [ -z "${OVE_GIT_COMMAND_OPTIONS_DEFAULT+x}" ]; then
		OVE_GIT_COMMAND_OPTIONS_DEFAULT=
		OVE_GIT_COMMAND_OPTIONS_DEFAULT+=".*@add:-p;"
		OVE_GIT_COMMAND_OPTIONS_DEFAULT+=".*@branch:-vv --color=always;"
		OVE_GIT_COMMAND_OPTIONS_DEFAULT+=".*@checkout:-p;"
		OVE_GIT_COMMAND_OPTIONS_DEFAULT+=".*@clone: ;"
		OVE_GIT_COMMAND_OPTIONS_DEFAULT+=".*@describe:--tags --always --dirty --long;"
		OVE_GIT_COMMAND_OPTIONS_DEFAULT+=".*@diff:--color=always;"
		OVE_GIT_COMMAND_OPTIONS_DEFAULT+=".*@fetch:--all --tags;"
		OVE_GIT_COMMAND_OPTIONS_DEFAULT+=".*@fsck:--full;"
		OVE_GIT_COMMAND_OPTIONS_DEFAULT+=".*@grep:--color=always;"
		OVE_GIT_COMMAND_OPTIONS_DEFAULT+=".*@reset:-p;"
		OVE_GIT_COMMAND_OPTIONS_DEFAULT+=".*@pull:--rebase;"
		OVE_GIT_COMMAND_OPTIONS_DEFAULT+=".*@show:--first-parent --color=always;"
		OVE_GIT_COMMAND_OPTIONS_DEFAULT+=".*@status:-bs -uno;"
		export OVE_GIT_COMMAND_OPTIONS_DEFAULT
	fi

	# OVE_GIT_COMMAND_OPTIONS_OVERRIDE:string::all commands:semi-colon separated list of git command options (overrides)
	if [ -z "${OVE_GIT_COMMAND_OPTIONS_OVERRIDE+x}" ]; then
		export OVE_GIT_COMMAND_OPTIONS_OVERRIDE=
	fi

	# OVE_ALIAS:int:0|1::enable/disable aliases defined in OVE_ALIAS_LIST
	if [ -z "${OVE_ALIAS+x}" ]; then
		export OVE_ALIAS=0
	fi

	# OVE_ALIAS_LIST:string:::semi-colon separated list of shell aliases
	if [ -z "${OVE_ALIAS_LIST+x}" ]; then
		export OVE_ALIAS_LIST="a=ove-ahead;b=ove-behind;d=ove-diff;f=ove-fetch;ff=ove-fetch-fetched;h=ove-list-aliases;n=ove-news;s=ove-status;sa=ove-show-ahead;sb=ove-show-behind;sn=ove-show-news"
	fi

	# OVE_DEMO_DIVISOR:int::demo:divisor sent to 'lastlog-replay' and later to 'scriptreplay'
	if [ -z "${OVE_DEMO_DIVISOR+x}" ]; then
		export OVE_DEMO_DIVISOR=20
	fi

	# OVE_BATCH_IT:int:0-1:all:run commands using ts/tsp batch system
	if [ -z "${OVE_BATCH_IT+x}" ]; then
		export OVE_BATCH_IT=0
	fi

	# OVE_COMMAND_SETSID:int:0-1:all:run non-terminal commands in a separate session (SID)
	if [ -z "${OVE_COMMAND_SETSID+x}" ]; then
		export OVE_COMMAND_SETSID=0
	fi

	# OVE_HASH_SIZE_THRESHOLD_IN_BYTES:int::all:do not run md5sum on large files
	if [ -z "${OVE_HASH_SIZE_THRESHOLD_IN_BYTES+x}" ]; then
		export OVE_HASH_SIZE_THRESHOLD_IN_BYTES="104857600"
	fi
}

# $1: a built in OVE config
function ove_config_get_allowed {
	if [ $# -ne 1 ]; then
		return
	elif [ ! -s ${OVE_DIR}/ove-config-list.md ]; then
		return
	elif ! ${ove_cmd2pathname["grep"]:?} -q "^| $1 " ${OVE_DIR}/ove-config-list.md; then
		return
	fi

	# shellcheck disable=SC2016
	${ove_cmd2pathname["grep"]:?} "^| $1 " ${OVE_DIR}/ove-config-list.md | \
		${ove_cmd2pathname["awk"]:?} '{print $6}' | \
		${ove_cmd2pathname["sed"]:?} -e 's,\\|, ,g' -e 's,|,,g'
}

# re-initialize
function ove_reinit {
	if ! ove_init; then
		return 1
	fi

	ove_post_checks

	return 0
}

# probe a few external programs and their capabilities
function ove_externals_probe {
	if [ -z "${OVE_COLUMN_WRAP_BUG}" ]; then
		if ! ( for i in {1..205} ; do echo -n 123456789, ; done ; echo ) | ${ove_cmd2pathname["column"]:?} -t -s "," &> /dev/null; then
			OVE_COLUMN_WRAP_BUG=1
		else
			OVE_COLUMN_WRAP_BUG=0
		fi
		ove_update_config "${OVE_CONFIG_FILE_INTERNAL:?}" "OVE_COLUMN_WRAP_BUG" "$OVE_COLUMN_WRAP_BUG"
	fi
	export OVE_COLUMN_WRAP_BUG

	if [ -z "${OVE_LESS_MORE_OPTIONS}" ]; then
		if ${ove_cmd2pathname["less"]:?} --version |& ${ove_cmd2pathname["head"]:?} -1 | ${ove_cmd2pathname["grep"]:?} -q '^less [0-9]\+'; then
			OVE_LESS_MORE_OPTIONS=1
		else
			OVE_LESS_MORE_OPTIONS=0
		fi
		ove_update_config "${OVE_CONFIG_FILE_INTERNAL:?}" "OVE_LESS_MORE_OPTIONS" "$OVE_LESS_MORE_OPTIONS"
	fi
	export OVE_LESS_MORE_OPTIONS

	if [ -z "${OVE_SCRIPT_OPTIONS}" ]; then
		OVE_SCRIPT_OPTIONS="-q "
		script_help=$(2>&1 ${ove_cmd2pathname["script"]:?} --help)
		if [[ "${script_help}" != *"invalid option"* ]]; then
			[[ "${script_help}" == *"-a"* ]] && OVE_SCRIPT_OPTIONS+="-a "
			[[ "${script_help}" == *"-e"* ]] && OVE_SCRIPT_OPTIONS+="-e "
			[[ "${script_help}" == *"-f"* ]] && OVE_SCRIPT_OPTIONS+="-f "
		fi
		OVE_SCRIPT_OPTIONS="${OVE_SCRIPT_OPTIONS% *}"
		ove_update_config "${OVE_CONFIG_FILE_INTERNAL:?}" "OVE_SCRIPT_OPTIONS" "$OVE_SCRIPT_OPTIONS"
	fi
	export OVE_SCRIPT_OPTIONS

	if [ -z "${OVE_FLOCK_OPTIONS}" ]; then
		if ${ove_cmd2pathname["flock"]:?} --help |& ${ove_cmd2pathname["grep"]:?} -q '\--no-fork'; then
			OVE_FLOCK_OPTIONS="--no-fork"
		fi
		ove_update_config "${OVE_CONFIG_FILE_INTERNAL:?}" "OVE_FLOCK_OPTIONS" "$OVE_FLOCK_OPTIONS"
	fi
	export OVE_FLOCK_OPTIONS
}

# init:initialize OVE workspace
function ove_init {
	local broken_link
	local dir
	local func
	local resolved
	local script_help

	if ! dir=$(ove_get_base_dir); then
		return 1
	fi

	# OVE_BASE_DIR:OVE workspace base directory
	OVE_BASE_DIR="${dir}"
	export OVE_BASE_DIR

	# OVE_OWEL_DIR:OWEL base dir. This directory contains 'projs', 'revtab', projects/... files.
	OVE_OWEL_DIR=$(${ove_cmd2pathname["readlink"]:?} -f -- ${OVE_BASE_DIR}/.owel)
	export OVE_OWEL_DIR

	# OVE_OWEL_NAME:OWEL name
	OVE_OWEL_NAME=${OVE_OWEL_DIR##*/}
	export OVE_OWEL_NAME

	# OVE_PROJECT_LIST:space separated list of OVE projects defined in 'projs'
	OVE_PROJECT_LIST=$(ove_list_projects)
	export OVE_PROJECT_LIST

	# OVE_PROJECT_COMMANDS:space separated list of project commands
	OVE_PROJECT_COMMANDS=$(ove_project_commands_list)
	export OVE_PROJECT_COMMANDS

	# OVE_STAGE_DIR:directory where intermediate build files can be shared
	OVE_STAGE_DIR=${OVE_BASE_DIR}/stage
	export OVE_STAGE_DIR

	# OVE_ARCHIVE_DIR:directory to share build archive files
	OVE_ARCHIVE_DIR=${OVE_BASE_DIR}/archives
	export OVE_ARCHIVE_DIR

	resolved="$(${ove_cmd2pathname["readlink"]:?} -f -- ${OVE_BASE_DIR}/ove)"
	if ! OVE_DIR="$(cd "$(${ove_cmd2pathname["dirname"]:?} "${resolved}")" || exit 1; pwd -P)"; then
		return 1
	fi
	export OVE_DIR

	OVE_BASENAME="${resolved##*/}"
	export OVE_BASENAME

	OVE_SELF="${OVE_DIR}/${OVE_BASENAME}"
	export OVE_SELF

	: "${OVE_PREFIX:=/usr}"
	export OVE_PREFIX

	ove_dirs_init
	ove_config_init
	if ! ove_revtab_init; then
		return 1
	fi
	if ! ove_projects_init; then
		return 1
	fi
	ove_scripts_init

	ove_hooks_init

	ove_sanitise_vars

	if [ "${OVE_LOGLEVEL}" == "2" ]; then
		set -x
	fi

	if [ -n "${OVE_TRACE_CMD+x}" ]; then
		echo ${BASHPID} > ${OVE_OWEL_TMP_DIR}/bash.pid
		while true; do
			[ -e ${OVE_OWEL_TMP_DIR}/trace.cont ] && break
		done
	fi

	if ! ove_set_built_ins; then
		return 1
	fi

	# remove broken README symlink
	broken_link=$(${ove_cmd2pathname["find"]:?} ${OVE_BASE_DIR} -maxdepth 1 -name 'README' -type l ! -exec test -e {} \; -print)
	if [ "x${broken_link}" != "x" ]; then
		${ove_cmd2pathname["rm"]:?} "${broken_link}"
	fi

	if ! [ -L ${OVE_BASE_DIR}/README ]; then
		if [ -s ${OVE_OWEL_DIR}/README ]; then
			( cd ${OVE_BASE_DIR} && ${ove_cmd2pathname["ln"]:?} -s -r ${OVE_OWEL_DIR}/README .)
		elif [ -s ${OVE_OWEL_DIR}/README.md ]; then
			( cd ${OVE_BASE_DIR} && ${ove_cmd2pathname["ln"]:?} -s -r ${OVE_OWEL_DIR}/README.md README )
		fi
	fi

	ove_update_tab_complete

	ove_config_builtins_init

	read -r -a OVE_LD_SEARCH_PATH < <(${ove_cmd2pathname["ld"]:?} --verbose | \
		${ove_cmd2pathname["sed"]:?} -n -e '/^SEARCH_DIR/s,SEARCH_DIR("=\?,,g' -e 's,");,,gp')
	OVE_LDFLAGS=""
	for dir in "${OVE_LD_SEARCH_PATH[@]}"; do
		OVE_LDFLAGS+=" -L${OVE_STAGE_DIR}${dir}"
	done
	for dir in "${OVE_LD_SEARCH_PATH[@]}"; do
		OVE_LDFLAGS+=" -Wl,-rpath-link=${OVE_STAGE_DIR}${dir}"
	done
	export OVE_LDFLAGS

	OVE_CPPFLAGS=" -I${OVE_STAGE_DIR}${OVE_PREFIX}/include"
	export OVE_CPPFLAGS

	# OVE_SHA:OVE version in use
	OVE_SHA=$(${ove_cmd2pathname["git"]:?} -C ${OVE_DIR} rev-parse --short HEAD)
	export OVE_SHA

	# OVE_LAST_COMMAND:file of the last OVE command executed
	OVE_LAST_COMMAND=
	export OVE_LAST_COMMAND

	OVE_PAGER="${ove_cmd2pathname["less"]:?} -R"
	export OVE_PAGER

	OVE_PKG_CONFIG_PATH="${OVE_STAGE_DIR}${OVE_PREFIX}/lib/pkgconfig:"
	OVE_LD_LIBRARY_PATH=""
	for dir in "${OVE_LD_SEARCH_PATH[@]}"; do
		OVE_LD_LIBRARY_PATH+="${OVE_STAGE_DIR}${dir}:"
	done
	unset OVE_LD_SEARCH_PATH

	if ove_debian_based; then
		OVE_LD_LIBRARY_PATH+="${OVE_STAGE_DIR}${OVE_PREFIX}/lib/x86_64-linux-gnu:"
		OVE_LD_LIBRARY_PATH+="${OVE_STAGE_DIR}${OVE_PREFIX}/lib"
		OVE_PKG_CONFIG_PATH+="${OVE_STAGE_DIR}${OVE_PREFIX}/lib/x86_64-linux-gnu/pkgconfig"
	else
		OVE_LD_LIBRARY_PATH+="${OVE_STAGE_DIR}${OVE_PREFIX}/lib:"
		OVE_LD_LIBRARY_PATH+="${OVE_STAGE_DIR}${OVE_PREFIX}/lib64"
		OVE_PKG_CONFIG_PATH+="${OVE_STAGE_DIR}${OVE_PREFIX}/lib64/pkgconfig"
	fi
	export OVE_LD_LIBRARY_PATH
	export OVE_PKG_CONFIG_PATH

	if [ ${OVE_TAINT_USER_ENV} -eq 1 ]; then
		if [[ ${PATH} != *"${OVE_STAGE_DIR}"* ]]; then
			PATH=${OVE_STAGE_DIR}${OVE_PREFIX}/sbin:${OVE_STAGE_DIR}${OVE_PREFIX}/bin:${PATH}
		fi

		if [ ${OVE_ACCELERATE_BUILDS} -eq 1 ]; then
			# icecream
			dir="/usr/lib/icecc/bin"
			if command -v icecc > /dev/null && \
				[ -d "${dir}" ] && \
				[[ ${PATH} != *${dir}* ]]; then
				PATH=${dir}:${PATH}
			fi

			# ccache
			if command -v ccache > /dev/null && \
				[[ ${PATH} != *ccache* ]]; then
				if ove_debian_based; then
					dir="/usr/lib/ccache"
				else
					dir="/usr/lib64/ccache"
				fi

				if [ -d ${dir} ]; then
					PATH=${dir}:${PATH}
				fi
			fi
		fi
		export PATH

		if [ -n "${LD_LIBRARY_PATH}" ] && [[ ${LD_LIBRARY_PATH} != *"${OVE_LD_LIBRARY_PATH}"* ]]; then
			LD_LIBRARY_PATH=${OVE_LD_LIBRARY_PATH}:${LD_LIBRARY_PATH}
		else
			LD_LIBRARY_PATH=${OVE_LD_LIBRARY_PATH}
		fi
		export LD_LIBRARY_PATH

		if [ -n "${PKG_CONFIG_PATH}" ] && [[ ${PKG_CONFIG_PATH} != *"${OVE_PKG_CONFIG_PATH}"* ]]; then
			PKG_CONFIG_PATH=${OVE_PKG_CONFIG_PATH}:${PKG_CONFIG_PATH}
		else
			PKG_CONFIG_PATH=${OVE_PKG_CONFIG_PATH}
		fi
		export PKG_CONFIG_PATH

		MAKEFLAGS="${OVE_MAKEFLAGS}"
		export MAKEFLAGS
	else
		ove_unsource_user_env
	fi

	ove_externals_probe

	if [ $(ove_repos_fetched) -eq $(${ove_cmd2pathname["wc"]:?} -w <<<"${OVE_REPO_LIST}") ]; then
		unset OVE_PROJECT_LIST_BUILDABLE
	else
		ove_buildable_projects
	fi

	ove_update_checksum

	# export functions
	for func in $(compgen -A function | ${ove_cmd2pathname["grep"]:?} "^ove[-_]") ove; do
		# shellcheck disable=SC2163
		export -f ${func}
	done

	# setup git command options
	ove_git_command_options_init

	return 0
}

function ove_disk_usage_check {
	local log_dir_disk_usage

	# log dir disk usage
	if [ ${OVE_LOG_DIR_DISK_USAGE_WARNING_MB} -ne 0 ]; then
		log_dir_disk_usage=$(${ove_cmd2pathname["du"]:?} -B 1M -s ${OVE_LOG_DIR})
		log_dir_disk_usage=${log_dir_disk_usage%%$'\t'*}
		if [ $log_dir_disk_usage -ge ${OVE_LOG_DIR_DISK_USAGE_WARNING_MB} ]; then
			echo
			ove_echo_note_noprefix "the directory '${OVE_LOG_DIR}' is ${log_dir_disk_usage}MB, you might want to:"
			echo
			echo "- remove OVE logs older than X days:"
			echo -e "\tove rm-logs X"
			echo "- automatically remove OVE logs older than X days:"
			echo -e "\tove add-config ${OVE_GLOBAL_STATE_DIR}/.oveconfig OVE_AUTO_RM_LOGS X"
			echo "- increase the threshold (=${OVE_LOG_DIR_DISK_USAGE_WARNING_MB}MB) for this NOTE 10x times:"
			echo -e "\tove add-config ${OVE_GLOBAL_STATE_DIR}/.oveconfig OVE_LOG_DIR_DISK_USAGE_WARNING_MB $((OVE_LOG_DIR_DISK_USAGE_WARNING_MB * 10))"
			echo "- suppress this NOTE:"
			echo -e "\tove add-config ${OVE_GLOBAL_STATE_DIR}/.oveconfig OVE_LOG_DIR_DISK_USAGE_WARNING_MB 0"
		fi
	fi
}

function ove_aliases {
	local a
	local aliases

	if [[ $- != *i* ]]; then
		return
	elif [ "x${OVE_ALIAS}" = "x0" ]; then
		return
	elif [ "x${OVE_ALIAS_LIST}" = "x" ]; then
		return
	fi

	IFS=';' read -r -a aliases <<< "${OVE_ALIAS_LIST}"
	for a in "${!aliases[@]}"; do
		alias "${aliases[$a]}"
	done
}

# list-aliases: :list OVE aliases:CORE
function ove-list-aliases {
	ove_entry || return

	local a
	local aliases

	if [ "x${OVE_ALIAS}" = "x0" ]; then
		ove_echo_note_noprefix "OVE aliases are DISABLED, enable with 'ove add-config \$HOME/.oveconfig OVE_ALIAS 1'"
	fi

	IFS=';' read -r -a aliases <<< "${OVE_ALIAS_LIST}"
	for a in "${!aliases[@]}"; do
		echo "alias ${aliases[$a]}"
	done

	return 0
}

function ove_update_terminal_stats {
	if ! shopt -q checkwinsize; then
		shopt -s checkwinsize
		# force an update
		if [ -x /bin/true ]; then
			/bin/true
		fi

	fi

	if [ "x${COLUMNS}" != "x" ]; then
		OVE_COLUMNS=$COLUMNS
		OVE_LINES=$LINES
	else
		OVE_COLUMNS=
		OVE_LINES=
	fi
	export OVE_COLUMNS
	export OVE_LINES
}

function ove_post_checks {
	local c
	local doublets

	# check for systest doublets
	if [ -e ${OVE_OWEL_DIR}/systests ]; then
		# yes, this is ugly
		# shellcheck disable=SC2016
		mapfile -t doublets < <(${ove_cmd2pathname["grep"]:?} -E -v '#|^$' ${OVE_OWEL_DIR}/systests | \
			${ove_cmd2pathname["awk"]:?} '{print $1}' | \
			${ove_cmd2pathname["cut"]:?} -d: -f1 | \
			LC_ALL="C" ${ove_cmd2pathname["sort"]:?} | \
			${ove_cmd2pathname["uniq"]:?} -d)
		if [ "${doublets[*]}" != "" ]; then
			echo
			ove_echo_yellow_noprefix "warning: found ${#doublets[*]} systest duplicate(s):"
			for c in ${doublets[*]}; do
				${ove_cmd2pathname["grep"]:?} -H -n -w ^${c} ${OVE_OWEL_DIR}/systests
			done
		fi
	fi

	# keep ${HOME}/.ove.bash up-to-date
	if [ -e "${HOME}/.ove.bash" ] && ! ${ove_cmd2pathname["diff"]:?} -q "${OVE_DIR}/ove.bash" "${HOME}/.ove.bash" > /dev/null; then
		${ove_cmd2pathname["cp"]:?} "${OVE_DIR}/ove.bash" "${HOME}/.ove.bash"
	fi

	# inform user if logs etc. take too much space
	ove_disk_usage_check

	# validate revtab revision
	ove_revtab_check

	# patch repos
	ove_patch_repos

	# aliases
	ove_aliases

	ove_update_terminal_stats

	return 0
}

function ove_buildable_projects {
	local deps
	local i
	local proj
	local proj_path
	local projs_and_deps_not_buildable
	local projs_not_buildable
	local repos_not_fetched
	local q
	local re
	declare -A projs_hash

	for q in ${OVE_REPO_LIST}; do
		[ -d "${q}" ] && continue
		repos_not_fetched+="${q} "
	done

	# remove projects with paths within git repos not yet fetched
	for q in ${repos_not_fetched}; do
		for proj in ${OVE_PROJECT_LIST}; do
			i=${ove_projects_name2index[${proj}]}
			proj_path="${ove_projects_path[${i}]}"
			if [ "${proj_path}" = "${q}" ] || [[ ${proj_path} == ${q}/* ]]; then
				test "${projs_hash["${proj}"]+isset}" && continue
				projs_hash["${proj}"]=1
				projs_not_buildable+="${proj} "
			fi
		done
	done

	if [ "x${projs_not_buildable}" = "x" ]; then
		unset OVE_PROJECT_LIST_BUILDABLE
		return
	fi

	# remove none buildable projects and its dependencies
	projs_and_deps_not_buildable="${projs_not_buildable}"
	for proj in ${OVE_PROJECT_LIST}; do
		deps=$(ove_get_deps_recursive ${proj})
		for q in ${projs_not_buildable}; do
			re=\\b${q}\\b
			if [[ "${deps}" =~ ${re} ]]; then
				re=\\b${proj}\\b
				# already marked as removed?
				if [[ "${projs_and_deps_not_buildable}" =~ ${re} ]]; then
					continue
				fi
				projs_and_deps_not_buildable+="${proj} "
			fi
		done
	done

	OVE_PROJECT_LIST_BUILDABLE=$(LC_ALL="C" ${ove_cmd2pathname["comm"]:?} -3 \
		<(printf "%s\n" ${OVE_PROJECT_LIST}) \
		<(printf "%s\n" ${projs_and_deps_not_buildable} | LC_ALL="C" ${ove_cmd2pathname["sort"]:?}) |
		${ove_cmd2pathname["xargs"]:?})
	export OVE_PROJECT_LIST_BUILDABLE
}

# $1: dir
function ove_get_revision {
	local revision

	if [ ! -d "${1}" ]; then
		return 1
	fi

	# detached?
	if ! ${ove_cmd2pathname["git"]:?} -C "${1}" symbolic-ref -q HEAD > /dev/null; then
		revision=$(${ove_cmd2pathname["git"]:?} -C "${1}" rev-parse --short HEAD)
	else
		revision=$(${ove_cmd2pathname["git"]:?} -C "${1}" branch | \
			${ove_cmd2pathname["cut"]:?} -d' ' -f2 | \
			${ove_cmd2pathname["tr"]:?} -d '\n')
	fi

	echo "${revision}"
}

function ove_get_nbr_of_remotes {
	local array

	if [ ! -d "${1}" ]; then
		return 1
	elif ! mapfile -t array < <(${ove_cmd2pathname["git"]:?} -C "${1}" remote 2> /dev/null); then
		return 1
	fi

	echo "${#array[*]}"
}

# $1: dir
# $2: remote
function ove_get_fetch_url {
	local fetch_url

	if [ ! -d "${1}" ]; then
		return 1
	fi

	fetch_url=$(${ove_cmd2pathname["git"]:?} -C "${1}" remote get-url $2 2> /dev/null)
	if [ "x${fetch_url}" = "x" ]; then
		fetch_url="noremote"
	fi

	echo "${fetch_url}"
}

# $1: dir
# $2: remote
function ove_get_push_url {
	local push_url

	if [ ! -d "${1}" ]; then
		return 1
	fi

	push_url=$(${ove_cmd2pathname["git"]:?} -C "${1}" remote get-url --push $2 2> /dev/null)
	if [ "x${push_url}" = "x" ]; then
		push_url="noremote"
	fi

	echo "${push_url}"
}

# init:|[dir]|[dir name]:scan directories and look for git repositories, if found create/update a OVE workspace:CORE
function ove-init {
	ove_entry || return

	local d
	local dir
	local do_init_git
	local doublets
	local fetch_url
	local i
	local init_opt
	local name
	local ove_link
	local ove_default_branch
	local ove_url="https://github.com/Ericsson/ove.git"
	local owel_default
	local owel_name
	local push_url
	local repo
	local revision
	local revtabs
	local revtab_file
	local skeleton
	local str

	if [ $# -eq 0 ]; then
		while true; do
			read -r -p "Directory to scan for git repositories? Leave blank to search in '$PWD': "
			if [ "${REPLY}" == "" ]; then
				if ove_is_base_dir "${PWD}"; then
					ove_echo_error_noprefix "'${PWD}' is already a OVE workspace. Remove the symblic link '${PWD}/.owel' to be able to re-init this directory."
					continue
				fi

				dir=${PWD}
				break
			fi

			if ! [ -d "${REPLY}" ]; then
				ove_echo_error_noprefix "'${REPLY}' is not a directory, try again"
				continue
			fi

			if ove_is_base_dir "${REPLY}"; then
				ove_echo_error_noprefix "'${REPLY}' is already a OVE workspace. Remove the symbolic link '${REPLY%/}/.owel' to be able to re-init this directory."
				continue
			fi
			dir=${REPLY}
			break
		done

	elif [ $# -lt 3 ]; then
		if ! [ -d ${1} ]; then
			ove_echo_error_noprefix "'${1}' is not a directory"
			return 1
		fi
		if ove_is_base_dir "${1}"; then
			ove_echo_error_noprefix "'${1}' is already a OVE workspace. Remove the symbolic link '${1%/}/.owel' to be able to re-init this directory."
			return 1
		fi
		dir=${1}
	fi

	# remove any trailing slash
	[ ${#dir} -ne 1 ] && dir="${dir%/}"

	if ! [ -w "${dir}" ]; then
		ove_echo_error_noprefix "sorry you are not allowed to create files/directories here: '${dir}'"
		return 1
	fi

	if [ -e ${dir}/ove ] && ! [ -L ${dir}/ove ]; then
		ove_echo_error_noprefix "you already have a file/directory named '${dir}/ove', rename/remove to proceed"
		return 1
	fi

	mapfile -t revtabs < <(${ove_cmd2pathname["find"]:?} ${dir} -mindepth 2 -maxdepth 2 -name revtab 2> /dev/null)
	if [ $# -lt 2 ] && [ ${#revtabs[*]} -eq 1 ]; then
		owel_default="$(${ove_cmd2pathname["basename"]:?} $(${ove_cmd2pathname["dirname"]:?} ${revtabs[0]}))"
	else
		owel_default="top"
	fi

	if [ $# -eq 0 ] || [ $# -eq 1 ]; then
		while true; do
			read -r -p "OWEL name? Leave blank to name it '${owel_default}': "
			if [ "${REPLY}" == "" ]; then
				owel_name="${owel_default}"
			else
				owel_name="${REPLY}"
			fi
			break
		done
	elif [ $# -eq 2 ]; then
		owel_name=${2}
	fi

	dir=$(${ove_cmd2pathname["readlink"]:?} -f -- ${dir})
	i=0
	do_init_git=0

	# updating an existing git repo?
	# shellcheck disable=SC2016
	if [ -d ${dir}/${owel_name}/.git ]; then
		owel_remote=$(ove_get_fetch_url "${dir}/${owel_name}" origin)
	else
		do_init_git=1
	fi

	for repo in $(${ove_cmd2pathname["find"]:?} "${dir}" -type d -name .git 2>/dev/null); do
		if ! ${ove_cmd2pathname["git"]:?} -C ${repo} log -1 --oneline &> /dev/null; then
			continue
		fi

		name=$(${ove_cmd2pathname["dirname"]:?} "${repo}")
		name=${name/${dir}\//}

		if [ $(ove_get_nbr_of_remotes "${repo}") -gt 1 ]; then
			ove_echo_cyan_noprefix "select one remote for '${name}'"
			${ove_cmd2pathname["git"]:?} -C "${repo}" remote -v
			while true; do
				read -r -p "remote: "
				remote="${REPLY}"
				if ${ove_cmd2pathname["git"]:?} -C "${repo}" remote | ${ove_cmd2pathname["grep"]:?} -q ^${remote}$; then
					break;
				fi
			done
		else
			remote=$(${ove_cmd2pathname["git"]:?} -C "${repo}" remote)
		fi

		fetch_url=$(ove_get_fetch_url "${repo}" "${remote}")
		# ignore OWEL remote
		if [ "${fetch_url}" == "${owel_remote}" ]; then
			continue
		fi
		push_url=$(ove_get_push_url "${repo}" "${remote}")
		revision=$(ove_get_revision "${repo}")

		((i++))
		echo -en "Scanning '${dir}'. #repos: ${i}\r"
		str+="${name} ${fetch_url} ${push_url} ${revision}\n"
	done

	if [ ${i} -eq 0 ]; then
		ove_echo_error_noprefix "no git repositories found here: '${dir}'"
		return 1
	fi

	echo
	${ove_cmd2pathname["mkdir"]:?} -p ${dir}/${owel_name}

	if [ ${do_init_git} -eq 1 ]; then
		# Git v2.28
		if ${ove_cmd2pathname["git"]:?} init -h | ${ove_cmd2pathname["grep"]:?} -q '\-\-initial-branch'; then
			# $OVE_DEFAULT_BRANCH_NAME is not available at this moment
			init_opt="--initial-branch main"
		else
			init_opt=""
		fi

		if ! ${ove_cmd2pathname["git"]:?} -C ${dir}/${owel_name} init ${init_opt}; then
			ove_echo_error_noprefix "'git -C ${dir}/${owel_name} init ${init_opt}' failed"
			return 1
		fi
	fi

	# owel symlink
	(cd ${dir} && ${ove_cmd2pathname["ln"]:?} -s ${owel_name} .owel)

	if ! [ -L ${dir}/ove ]; then
		# clone myself
		if [ ! -d "$dir/.ove" ] && ! ${ove_cmd2pathname["git"]:?} -C "${dir}" clone -q "${ove_url}" .ove; then
			ove_echo_error_noprefix "'git -C ${dir} clone -q ${ove_url}' failed"
			return 1
		# get default branch name
		elif ! ove_default_branch=$(${ove_cmd2pathname["git"]:?} -C "${dir}/.ove" symbolic-ref refs/remotes/origin/HEAD); then
			ove_echo_error_noprefix "'git -C ${dir}/.ove symbolic-ref refs/remotes/origin/HEAD' failed"
			return 1
		fi
		ove_default_branch=${ove_default_branch##*/}
		str+=".ove ${ove_url} ${ove_url} ${ove_default_branch}\n"
		ove_link=".ove/ove"
		(cd ${dir} && ${ove_cmd2pathname["ln"]:?} -s ${ove_link} ove)
	fi

	# create a revtab file
	revtab_file="${dir}/${owel_name}/revtab"
	printf "${str}" | \
		${ove_cmd2pathname["column"]:?} -t | \
		LC_ALL="C" ${ove_cmd2pathname["sort"]:?} -u > ${revtab_file}

	# inform user on repos with same fetch url
	# shellcheck disable=SC2016
	mapfile -t doublets < <(${ove_cmd2pathname["awk"]:?} '{print $2}' ${revtab_file} | ${ove_cmd2pathname["grep"]:?} -v noremote | LC_ALL="C" ${ove_cmd2pathname["sort"]:?} | ${ove_cmd2pathname["uniq"]:?} -d)
	if [ "${doublets[*]}" != "" ]; then
		ove_echo_note_noprefix "found a few repos with the same fetch url:"
		for d in ${doublets[*]}; do
			${ove_cmd2pathname["grep"]:?} -H -n "${d}" ${revtab_file}
		done | ${ove_cmd2pathname["column"]:?} -t
	fi

	skeleton=0
	if [ -t 1 ]; then
		read -r -p "Create example/skeleton files? (y/N) "
		if [[ ${REPLY} =~ ^[Yy]$ ]]; then
			skeleton=1
			# projs
			${ove_cmd2pathname["cat"]:?} > "${dir}/${owel_name}/projs" << EOF
---
base:
  needs:
    coreutils
  path:
    .

foobar:
  deps:
    base
  path:
    foobar
  version:
    0.1.0
EOF

			# projects
			${ove_cmd2pathname["mkdir"]:?} -p ${dir}/${owel_name}/projects/foobar

			for d in bootstrap configure build install test; do
				${ove_cmd2pathname["cat"]:?} > "${dir}/${owel_name}/projects/foobar/$d" << EOF
#!/usr/bin/env bash

echo "'$d' step for the OVE project named 'foobar'"
echo "OVE_ACTIVE_PROJECT_NAME=\$OVE_ACTIVE_PROJECT_NAME"
echo "OVE_ACTIVE_PROJECT_COMMAND=\$OVE_ACTIVE_PROJECT_COMMAND"
echo "OVE_ACTIVE_PROJECT_VERSION=\$OVE_ACTIVE_PROJECT_VERSION"
echo
echo "This script is located here: \$OVE_OWEL_DIR/projects/foobar/$d"
EOF
				chmod +x ${dir}/${owel_name}/projects/foobar/$d
			done

			# scripts
			${ove_cmd2pathname["mkdir"]:?} -p ${dir}/${owel_name}/scripts
			${ove_cmd2pathname["cat"]:?} > "${dir}/${owel_name}/scripts/qwerty" << EOF
#!/usr/bin/env bash

echo "This is one OVE plugin named 'qwerty' and it is located here: \$OVE_OWEL_DIR/scripts/qwerty"
EOF
			chmod +x ${dir}/${owel_name}/scripts/qwerty

			# SETUP
			echo "# add your oneliner in this file and the 'ove setup' will display it" > ${dir}/${owel_name}/SETUP

			# systests and systests-groups
			${ove_cmd2pathname["cat"]:?} > "${dir}/${owel_name}/systests" << EOF
# name       timeout (s)   type   path   command
t1           2             0      .      sleep 1
t2           1             0      .      sleep 2
EOF
			${ove_cmd2pathname["cat"]:?} > "${dir}/${owel_name}/systests-groups" << EOF
---
all:
  - t1
  - t2

sanity:
  - t1
EOF
		fi
	fi

	echo
	echo "Summary:"
	echo "* created/updated '${revtab_file}' with ${i} repositories"
	if [ "${ove_link}" != "" ]; then
		echo "* created a symbolic link '${dir}/ove' -> '${ove_link}'"
	fi
	echo "* created a symbolic link '${dir}/.owel' -> '${dir}/${owel_name}'"

	if [ ${do_init_git} -eq 1 ]; then
		echo "* created an empty git repository here: '${dir}/${owel_name}'"
	fi
	if [ ${#doublets[*]} -ne 0 ]; then
		echo "* found that a few repos are mentioned more than one time in '${revtab_file}', details above"
	fi
	if [ ${dir} != "${PWD}" ]; then
		cd ${dir} || return 1
		echo "* changed current working directory to ${dir}"
	fi
	if [ ${skeleton} -eq 1 ]; then
		echo "* created these example/skeleton files:"
		${ove_cmd2pathname["find"]:?} ${dir}/${owel_name}/{projects,scripts,projs,SETUP} -type f
	fi
	echo
	echo "# now what?"
	echo
	echo "# check status"
	echo "$ ove status"
	echo
	if [ ${skeleton} -eq 1 ]; then
		echo "# try some OVE commands"
		echo "$ ove buildme foobar"
		echo "$ ove bootstrap foobar"
		echo "$ ove list-needs foobar"
		echo "$ ove qwerty"
		echo "$ ove systest t1"
		echo "$ ove systest all"
		echo
	fi
	echo "# add new repos/projects"
	echo "$ ove add-repo"
	echo "$ ove add-project"
	echo
	echo "# need help? ask OVE"
	echo "$ ove help"
}

function ove_debian_based {
	if [ "${OVE_OS_ID_LIKE,,}" == "debian" ]; then
		return 0
	elif [ "${OVE_OS_ID_LIKE,,}" == "ubuntu" ]; then
		return 0
	elif [[ ${OVE_OS} == *"Debian"* ]]; then
		return 0
	elif [[ ${OVE_OS} == *"Ubuntu"* ]]; then
		return 0
	else
		return 1
	fi
}

# $1: command
function ove_command_to_package {
	local package

	# column
	if [ "$1" == "column" ]; then
		if ove_debian_based; then
			package="bsdmainutils"
		elif [[ ${OVE_OS} == *"Gentoo"* ]]; then
			package="sys-apps/util-linux"
		else
			package="util-linux"
		fi
	# flock
	elif [ "$1" == "flock" ]; then
		if [[ ${OVE_OS} == *"Gentoo"* ]]; then
			package="sys-apps/util-linux"
		else
			package="util-linux"
		fi
	# git
	elif [ "$1" == "git" ]; then
		if [[ ${OVE_OS} == *"Alpine"* ]]; then
			package="git git-perl"
		elif [[ ${OVE_OS} == *"Gentoo"* ]]; then
			package="dev-vcs/git"
		fi
	# ld
	elif [ "$1" == "ld" ]; then
		package="binutils"
	# less
	elif [ "$1" == "less" ]; then
		if [[ ${OVE_OS} == *"Gentoo"* ]]; then
			package="sys-apps/less"
		fi
	# locate
	elif [ "$1" == "locate" ]; then
		package="mlocate"
	# pgrep
	elif [ "$1" == "pgrep" ]; then
		if ove_debian_based; then
			package="procps"
		fi
	# script
	elif [ "$1" == "script" ]; then
		if ove_debian_based; then
			package="bsdutils"
		elif [[ ${OVE_OS} == *"Gentoo"* ]]; then
			package="sys-apps/util-linux"
		else
			package="util-linux"
		fi
	# tsort
	elif [ "$1" == "tsort" ]; then
		package="coreutils"
	# xz
	elif [ "$1" == "xz" ]; then
		if ove_debian_based; then
			package="xz-utils"
		elif [[ ${OVE_OS} == *"Gentoo"* ]]; then
			package="app-arch/xz"
		fi
	fi

	[ "${package}" != "" ] && echo ${package} || echo $1
}

function ove_deps {
	local dep
	local deps
	local pack
	local str_cmds
	local str_packs

	str_packs=""
	str_cmds=""

	deps=()
	deps+=('bzip2')
	deps+=('column')
	deps+=('file')
	deps+=('flock')
	deps+=('git')
	deps+=('gzip')
	deps+=('ld')
	deps+=('less')
	deps+=('pgrep')
	deps+=('script')
	deps+=('tsort')

	for dep in "${deps[@]}"; do
		if ! command -v ${dep} > /dev/null; then
			str_cmds+="${dep} "
			pack=$(ove_command_to_package ${dep})
			if [ "${pack}" != "" ]; then
				str_packs+="${pack} "
			fi
		fi
	done

	if [ "${str_cmds}" != "" ]; then
		ove_echo_error_noprefix "missing command(s):"
		echo
		for dep in ${str_cmds}; do
			echo -e "\t${dep}"
		done | LC_ALL="C" ${ove_cmd2pathname["sort"]:?}
		echo
		echo "To fix this, run the following command:"
		echo
		echo -e "\t${OVE_OS_PACKAGE_MANAGER} ${OVE_OS_PACKAGE_MANAGER_ARGS} $(printf "%s " $(ove_uniq ${str_packs}))"
		echo
		return 1
	fi

	ove_version_check || return 1

	return 0
}

# $*: list of packages
# returns a list of packages NOT installed
function ove_packages_not_installed {
	local p_sort

	[ $# -eq 0 ] && return

	p_sort=$(printf "%s\n" "$@" | LC_ALL="C" ${ove_cmd2pathname["sort"]:?} -u)

	if [[ ${OVE_OS} == *"Arch Linux"* ]]; then
		# shellcheck disable=SC2016
		LC_ALL="C" ${ove_cmd2pathname["comm"]:?} -2 -3 <(printf "%s\n" ${p_sort}) <(\pacman -Q | ${ove_cmd2pathname["awk"]:?} '{print $1}')
	elif [[ ${OVE_OS} == *"Alpine"* ]]; then
		LC_ALL="C" ${ove_cmd2pathname["comm"]:?} -2 -3 <(printf "%s\n" ${p_sort}) <(\apk info | LC_ALL="C" ${ove_cmd2pathname["sort"]:?})
	elif [[ ${OVE_OS} == *"CentOS"* ]] || \
		[[ ${OVE_OS} == *"Fedora"* ]] || \
		[[ ${OVE_OS} == *"SLES"* ]] || \
		[[ ${OVE_OS} == *"openSUSE"* ]] || \
		[[ ${OVE_OS} == *"RedHatEnterpriseServer"* ]] ||
		[[ ${OVE_OS_ID_LIKE,,} == *rhel* ]] ||
		[[ ${OVE_OS_ID_LIKE,,} == *centos* ]] ||
		[[ ${OVE_OS_ID_LIKE,,} == *fedora* ]]; then
		LC_ALL="C" ${ove_cmd2pathname["comm"]:?} -2 -3 <(printf "%s\n" ${p_sort}) <(\rpm -qa --qf "%{NAME}\n"| LC_ALL="C" ${ove_cmd2pathname["sort"]:?})
	elif ove_debian_based; then
		\dpkg-query -W -f='${Package}:${Status}\n' ${p_sort} 2>&1 | \
			${ove_cmd2pathname["grep"]:?} -v ":install ok installed" | \
			${ove_cmd2pathname["sed"]:?} -e 's/dpkg-query: no packages found matching //g' -e 's/:.*//g' | \
			${ove_cmd2pathname["xargs"]:?}
	elif [[ ${OVE_OS} == *"void"* ]]; then
		# shellcheck disable=SC2016
		LC_ALL="C" ${ove_cmd2pathname["comm"]:?} -2 -3 \
			<(printf "%s\n" ${p_sort}) \
			<(\xbps-query --list-pkgs | \
			${ove_cmd2pathname["awk"]:?} '{print $2}' | \
			${ove_cmd2pathname["rev"]:?} | \
			${ove_cmd2pathname["cut"]:?} -d- -f2- | \
			${ove_cmd2pathname["rev"]:?} | \
			LC_ALL="C" ${ove_cmd2pathname["sort"]:?} | \
			${ove_cmd2pathname["xargs"]:?} -n1)
	else
		ove_echo_error_noprefix "function '${FUNCNAME[0]}' is not implemented for ${OVE_OS}"
	fi
}

function ove_determine_dist_version_and_pack_manager {
	# OVE_OS:Linux distribution NAME
	OVE_OS=
	# OVE_OS_ID:Linux distribution ID
	OVE_OS_ID=
	# OVE_OS_VER:Linux distribution VERSION_ID
	OVE_OS_VER=
	# OVE_OS_ID_LIKE:Linux distribution ID_LIKE
	OVE_OS_ID_LIKE=
	if [ -e /etc/os-release ]; then
		OVE_OS=$(source /etc/os-release; echo ${NAME})
		OVE_OS_ID=$(source /etc/os-release; echo ${ID})
		OVE_OS_ID_LIKE=$(source /etc/os-release; echo ${ID_LIKE:-$ID})
		OVE_OS_VER=$(source /etc/os-release; echo ${VERSION_ID})
	elif command -v lsb_release > /dev/null; then
		OVE_OS=$(${ove_cmd2pathname["lsb_release"]:?} --id --short)
		OVE_OS_ID=${OVE_OS}
		OVE_OS_VER=$(${ove_cmd2pathname["lsb_release"]:?} --release --short)
	else
		OVE_OS=$(${ove_cmd2pathname["uname"]:?} -s)
		OVE_OS_ID=${OVE_OS}
		OVE_OS_VER=$(${ove_cmd2pathname["uname"]:?} -r)
	fi

	# OVE_OS_PACKAGE_MANAGER:package manager
	OVE_OS_PACKAGE_MANAGER=
	# OVE_OS_PACKAGE_MANAGER_ARGS:package manager arguments
	OVE_OS_PACKAGE_MANAGER_ARGS=
	if [[ ${OVE_OS} == *"Alpine"* ]]; then
		OVE_OS_PACKAGE_MANAGER="apk"
		OVE_OS_PACKAGE_MANAGER_ARGS="add"
	elif [[ ${OVE_OS} == *"Arch Linux"* ]]; then
		OVE_OS_PACKAGE_MANAGER="pacman"
		OVE_OS_PACKAGE_MANAGER_ARGS="-S"
	elif [[ ${OVE_OS} == *"CentOS"* ]]; then
		OVE_OS_PACKAGE_MANAGER="yum"
		OVE_OS_PACKAGE_MANAGER_ARGS="install"
	elif ove_debian_based; then
		OVE_OS_PACKAGE_MANAGER="apt"
		OVE_OS_PACKAGE_MANAGER_ARGS="install"
	elif [[ ${OVE_OS} == *"Fedora"* ]] || \
		[[ ${OVE_OS} == *"RedHatEnterpriseServer"* ]] || \
		command -v dnf > /dev/null; then
		OVE_OS_PACKAGE_MANAGER="dnf"
		OVE_OS_PACKAGE_MANAGER_ARGS="install"
	elif [[ ${OVE_OS} == *"Gentoo"* ]]; then
		OVE_OS_PACKAGE_MANAGER="emerge"
		OVE_OS_PACKAGE_MANAGER_ARGS=""
	elif [[ ${OVE_OS} == *"openSUSE"* ]] || \
		[[ ${OVE_OS} == *"SLES"* ]]; then
		OVE_OS_PACKAGE_MANAGER="zypper"
		OVE_OS_PACKAGE_MANAGER_ARGS="install"
	elif [[ ${OVE_OS} == *"void"* ]]; then
		OVE_OS_PACKAGE_MANAGER="xbps-install"
		OVE_OS_PACKAGE_MANAGER_ARGS=""
	else
		OVE_OS_PACKAGE_MANAGER="unknown"
		OVE_OS_PACKAGE_MANAGER_ARGS=""
	fi

	export OVE_OS
	export OVE_OS_ID
	export OVE_OS_ID_LIKE
	export OVE_OS_VER
	export OVE_OS_PACKAGE_MANAGER
	export OVE_OS_PACKAGE_MANAGER_ARGS
}

# fsck:[git...]:git fsck --full for all/specified git repositories:DEBUG
function ove-fsck {
	ove_entry || return

	local cmd

	cmd="ove_echo_yellow_noprefix \$(pwd -P) && \
		ALLOW_OVERRIDE=1 ove_repo_cmd \${repo} fsck || \
		ove_echo_error_noprefix \'${ove_cmd2pathname["git"]:?} -C \$(pwd -P) fsck\' returned != 0, corrupt repo?; echo"

	if [ $# -eq 0 ]; then
		ove_revtab_forall "${cmd}"
	else
		ove_revtab_forsome "${cmd}" "$*"
	fi
}

# show-dangling:[git...]:show dangling git objects (=blob|commit|tag|tree) for all/specified git repositories:DEBUG
function ove-show-dangling {
	ove_entry || return

	local sha_list

	# shellcheck disable=SC2016
	sha_list=$(ove-fsck "$@" | ${ove_cmd2pathname["grep"]:?} '^dangling' | ${ove_cmd2pathname["awk"]:?} '{print $3}')
	[ "${sha_list}" == "" ] || ove-show ${sha_list}
}

# readme:[git...]:display README files for all/specified git repositories:UTIL
function ove-readme {
	ove_entry || return

	local cmd

	# shellcheck disable=SC2016
	cmd='${ove_cmd2pathname["find"]:?} ${PWD} -maxdepth 1 -name "README*" -print0 | '
	# shellcheck disable=SC2016
	cmd+='${ove_cmd2pathname["xargs"]:?} -r -0 ${ove_cmd2pathname["head"]:?} -v |'
	# shellcheck disable=SC2016
	cmd+='${ove_cmd2pathname["sed"]:?} -e "1 i$(ove_echo_yellow_noprefix $(pwd -P))" -e "s/^/\t/g"'

	if [ $# -eq 0 ]; then
		ove_revtab_forall "${cmd}"
	else
		ove_revtab_forsome "${cmd}" "$*"
	fi
}

# $1: worktree name
# $2: rev to checkout [optional]
function ove_worktree_add {
	local i
	local name
	local revision
	local worktree
	local worktree_base
	local worktree_dir

	if [ $# -eq 0 ] || [ $# -ge 3 ]; then
		return 1
	fi

	if ! worktree="$(${ove_cmd2pathname["readlink"]:?} -f -- $1)"; then
		ove_echo_error_noprefix "$1 is not a valid path"
		return 1
	fi
	worktree_base="${worktree##*/}"
	worktree_dir="${worktree%/*}"

	if [[ ${worktree} == ${OVE_BASE_DIR}/* ]]; then
		ove_echo_error_noprefix "use a path that is outside of the OVE workspace"
		return 1
	elif [ -d "${worktree}" ]; then
		ove_echo_error_noprefix "'${worktree}' already exist"
		return 1
	elif [ -h "${OVE_OWEL_STATE_DIR}/worktree/${worktree_base}" ]; then
		ove_echo_error_noprefix "'${worktree_base}' name is already taken"
		return 1
	elif [ ! -w "${worktree_dir}" ]; then
		ove_echo_error_noprefix "'${worktree_dir}' is not writable"
		return 1
	elif [ -f "${worktree}" ]; then
		ove_echo_error_noprefix "'${worktree}' is a regular file"
		return 1
	fi

	if [ $# -eq 2 ]; then
		if ! ove_repo_cmd "${OVE_OWEL_DIR}" cat-file -e "$2" &> /dev/null; then
			ove_echo_error_noprefix "'$2' is not a valid revision"
			return 1
		fi

		# get revtab for revision '$2'
		${ove_cmd2pathname["mkdir"]:?} -p ${OVE_OWEL_TMP_DIR}/worktree
		ove_repo_cmd "${OVE_OWEL_DIR}" show $2:revtab > ${OVE_OWEL_TMP_DIR}/worktree/revtab
		if [ ! -s ${OVE_OWEL_TMP_DIR}/worktree/revtab ]; then
			ove_echo_error_noprefix "revtab was empty/non-existing in '$2'"
			return 1
		fi

		(
			# run this in a subshell
			OVE_OWEL_DIR=${OVE_OWEL_TMP_DIR}/worktree ove_revtab_init
			i=0
			while ((i < ove_revtab_num_repositories)); do
				name=${ove_revtab_git_name[${i}]}
				revision=${ove_revtab_rev[${i}]}
				if [ ! -d $OVE_BASE_DIR/${name} ]; then
					ove_echo_warning_noprefix "$OVE_BASE_DIR/${name} is missing"
					continue
				fi
				ove_repo_cmd "$OVE_BASE_DIR/${name}" worktree add -B ove-worktree-${worktree_base} -f ${worktree}/${name} ${revision}
				(( i+=1 ))
			done
			ove_repo_cmd "$OVE_OWEL_DIR" worktree add -B ove-worktree-${worktree_base} -f ${worktree}/$OVE_OWEL_NAME $2
		)
	else
		ove-forall "ove_repo_cmd \$repo worktree add -B ove-worktree-${worktree_base} -f ${worktree}/\$repo_basename &> /dev/null"
	fi

	(cd ${worktree} || return 1; [ -h ove ]   || ${ove_cmd2pathname["ln"]:?} -s ${OVE_SELF/$OVE_BASE_DIR\/} ove)
	(cd ${worktree} || return 1; [ -h .owel ] || ${ove_cmd2pathname["ln"]:?} -s $OVE_OWEL_NAME .owel)

	${ove_cmd2pathname["mkdir"]:?} -p $OVE_OWEL_STATE_DIR/worktree
	(cd $OVE_OWEL_STATE_DIR/worktree || return 1; ${ove_cmd2pathname["ln"]:?} -s ${worktree} ${worktree_base})

	ove_worktree_list ${worktree_base}

	return 0
}

function ove_worktree_gc {
	local broken_links

	if [ ! -d $OVE_OWEL_STATE_DIR/worktree ]; then
		return
	fi

	broken_links=$(${ove_cmd2pathname["find"]:?} $OVE_OWEL_STATE_DIR/worktree/ -maxdepth 1 -type l ! -exec test -e {} \; -print)
	if [ "x${broken_links}" != "x" ]; then
		${ove_cmd2pathname["rm"]:?} ${broken_links}
	fi
}

function ove_worktree_remove {
	local ret
	local w
	local worktree

	if [ $# -eq 0 ]; then
		return 1
	fi

	ret=0
	for w in $(ove_uniq "$@"); do
		worktree="$OVE_OWEL_STATE_DIR/worktree/${w##*/}"
		if [ ! -e "${worktree}" ]; then
			((ret++))
			continue
		fi

		ove-forall "git worktree remove ${worktree}/\$repo_basename 2> /dev/null"
		${ove_cmd2pathname["rm"]:?} -rf ${worktree:?}/
		${ove_cmd2pathname["rmdir"]:?} $(${ove_cmd2pathname["readlink"]:?} -f -- ${worktree})
	done

	return ${ret}
}

# $1: worktree path
function ove_worktree_status_one {
	if ! ove_is_base_dir "$1"; then
		ove_echo_yellow_noprefix "worktree '$(${ove_cmd2pathname["readlink"]:?} -f -- $1)' is corrupt, fixme!"
		return 1
	fi

	ove_echo_green_noprefix "$(${ove_cmd2pathname["readlink"]:?} -f -- $1)"
	${ove_cmd2pathname["bash"]:?} -i -c "cd $1; . ove hush; ove status"
}

# $1: worktree basename
function ove_worktree_status {
	local d
	local d_base

	if [ ! -d $OVE_OWEL_STATE_DIR/worktree ]; then
		return 1
	fi

	if [ $# -eq 0 ]; then
		for d in $(${ove_cmd2pathname["find"]:?} $OVE_OWEL_STATE_DIR/worktree/ -mindepth 1 -maxdepth 1 -type l 2> /dev/null | LC_ALL="C" ${ove_cmd2pathname["sort"]:?} -V); do
			if [ ! -d "${d}" ]; then
				ove_echo_yellow_noprefix "worktree '$(${ove_cmd2pathname["readlink"]:?} -f -- $d)' is not a directory as expected, fixme!"
				continue
			fi

			ove_worktree_status_one "${d}"
		done

	else
		for d in $(ove_uniq "$@"); do
			d_base=${d##*/}
			if [ -d $OVE_OWEL_STATE_DIR/worktree/${d_base} ]; then
				ove_worktree_status_one "$OVE_OWEL_STATE_DIR/worktree/${d_base}"
			fi
		done
	fi

	return 0
}

# $1: worktree basename
function ove_worktree_list {
	local d
	local d_base

	if [ ! -d $OVE_OWEL_STATE_DIR/worktree ]; then
		return 1
	fi

	if [ $# -eq 0 ]; then
		for d in $(${ove_cmd2pathname["find"]:?} $OVE_OWEL_STATE_DIR/worktree/ -mindepth 1 -maxdepth 1 -type l 2> /dev/null | LC_ALL="C" ${ove_cmd2pathname["sort"]:?} -V); do
			if [ ! -d "${d}" ]; then
				ove_echo_yellow_noprefix "worktree '$(${ove_cmd2pathname["readlink"]:?} -f $d)' is not a directory as expected, fixme!"
				continue
			fi

			ove_echo_green_noprefix "$(${ove_cmd2pathname["readlink"]:?} -f -- ${d})"
		done

	else
		for d in $(ove_uniq "$@"); do
			d_base=${d##*/}
			if [ -d $OVE_OWEL_STATE_DIR/worktree/${d_base} ]; then
				ove_echo_green_noprefix "$(${ove_cmd2pathname["readlink"]:?} -f -- $OVE_OWEL_STATE_DIR/worktree/${d_base})"
			fi
		done
	fi

	return 0
}

# worktree:[add <path> [rev]]|list [worktree...]|prune|remove worktree...|status [worktree...]]:replicate OVE workspace on this host using 'git worktree':CORE
function ove-worktree {
	ove_entry || return
	local name

	ove_worktree_gc

	if [ $# -eq 0 ]; then
		ove_worktree_list
	elif [ $# -ge 1 ] && [ "x$1" = "xlist" ]; then
		shift
		ove_worktree_list "$@"
	elif [ $# -ge 1 ] && [ "x$1" = "xstatus" ]; then
		shift
		ove_worktree_status "$@"
	elif [ $# -eq 1 ] && [ "x$1" = "xprune" ]; then
		ove-forall 'git worktree prune -v'
	elif [ $# -ge 2 ] && [ "x$1" = "xremove" ]; then
		shift
		if ! ove_worktree_remove "$@"; then
			return 1
		fi
	elif [ $# -ge 2 ] && [ "x$1" = "xadd" ]; then
		shift
		if ! ove_worktree_add "$@"; then
			return 1
		fi
	else
		ove_command_usage
		return 1
	fi

	return 0
}

# replicate:host [path]:replicate OVE workspace on 'host':UTIL
function ove-replicate {
	ove_entry || return

	local base_dir
	local d
	local host
	local now
	local p
	local ps_local
	local ps_remote
	local q
	local s

	if [ $# -eq 0 ] || [ $# -gt 2 ]; then
		ove_command_usage
		return 1
	fi

	if [ $# -eq 1 ]; then
		if [ ! -e "${OVE_OWEL_DIR}/SETUP" ]; then
			ove_echo_error_noprefix "'${OVE_OWEL_DIR}/SETUP' not found"
			return 1
		elif [ ! -s "${OVE_OWEL_DIR}/SETUP" ]; then
			ove_echo_error_noprefix "'${OVE_OWEL_DIR}/SETUP' is empty"
			return 1
		elif ! s="$(${ove_cmd2pathname["cat"]:?} ${OVE_OWEL_DIR}/SETUP)"; then
			return 1
		fi
	fi

	host="$1"
	if ! ${ove_cmd2pathname["ssh"]:?} -q ${host} exit 0; then
		ove_echo_error_noprefix "'${host}' is not reachable via ssh"
		return 1
	fi

	# remote directory
	if [ $# -eq 1 ]; then
		d=$(${ove_cmd2pathname["ssh"]:?} ${host} mktemp -d)
	else
		d=$(${ove_cmd2pathname["ssh"]:?} ${host} readlink -f $2)
		# sanity check
		if ! ${ove_cmd2pathname["ssh"]:?} -q ${host} "[ -L ${d}/ove ] && [ -L ${d}/.owel ]"; then
			ove_echo_error_noprefix "'${d}' is not a valid OVE workspace on '${host}'"
			return 1
		fi
	fi

	now=$(${ove_cmd2pathname["date"]:?} '+%Y%m%d-%H%M%S')
	ps_local="[${HOSTNAME}]$"
	ps_remote="[${host}]$"

	q="$(${ove_cmd2pathname["mktemp"]:?} -p ${OVE_OWEL_TMP_DIR}).tar.bz2"
	echo "${ps_local} ove format-patch ${q}"
	ove-format-patch ${q}
	if [ -s "${q}" ]; then
		q_remote="${d}/${now}.tar.bz2"
		echo "${ps_local} scp -q ${q} ${host}:${q_remote}"
		if ! ${ove_cmd2pathname["scp"]:?} -q ${q} ${host}:${q_remote}; then
			ove_echo_error_noprefix "not possible to transfer patch archive to '${host}'"
			${ove_cmd2pathname["rm"]:?} ${q}
			return 1
		fi
	fi

	p=$(${ove_cmd2pathname["mktemp"]:?} -p ${OVE_OWEL_TMP_DIR})
	echo "${ps_local} ove diff > ${p}"
	ove-diff > ${p}
	if [ -s "${p}" ]; then
		p_remote="${d}/${now}.patch"
		echo "${ps_local} scp -q ${p} ${host}:${p_remote}"
		if ! ${ove_cmd2pathname["scp"]:?} -q ${p} ${host}:${p_remote}; then
			ove_echo_error_noprefix "not possible to transfer patch file to '${host}'"
			${ove_cmd2pathname["rm"]:?} ${p} ${q}
			return 1
		fi
	fi

	if ! ${ove_cmd2pathname["ssh"]:?} ${host} "
		echo '${ps_local} ssh ${host}'
		echo '${ps_remote} cd ${d}'
		cd ${d}
		if [ $# -eq 1 ]; then
			echo '${ps_remote} ${s}'
			set -o pipefail
			eval ${s} || exit
			cd \$(${ove_cmd2pathname["find"]:?} \${PWD} -maxdepth 1 -mindepth 1 -type d)
			echo '${ps_remote} pwd'
			echo \${PWD}
		fi
		echo '${ps_remote} source ove'
		source ove || exit
		if [ $# -eq 1 ]; then
			echo '${ps_remote} ove fetch'
			ove-fetch
		fi
		md5=\$(md5sum \$OVE_OWEL_DIR/revtab)
		if [ -e \"${q_remote}\" ]; then
			echo '${ps_remote} ove am ${q_remote}'
			ove-am ${q_remote}
		fi
		if [ -e \"${p_remote}\" ]; then
			echo '${ps_remote} ove apply ${p_remote}'
			ove-apply ${p_remote}
		fi

		# one extra fetch if revtab was changed
		if [ \"x\$md5\" != \"x\$(md5sum \$OVE_OWEL_DIR/revtab)\" ]; then
			echo '${ps_remote} ove fetch'
			ove-fetch
		else
			echo '${ps_remote} ove status'
			ove-status
		fi"; then
		ove_echo_error_noprefix "trying to replicate OVE workspace on '${host}'"
	else
		echo
		echo -n "OVE workspace has been replicated to '${host}:${d}'"
		base_dir=$(${ove_cmd2pathname["ssh"]:?} ${host} find ${d} -maxdepth 2 -name .owel 2> /dev/null)
		if [ "x${base_dir}" != "x" ]; then
			echo ". Start a login shell on '${host}' and enter the replicated workspace:"
			echo
			base_dir=${base_dir%/*}
			echo -e " ssh -t ${host} 'cd ${base_dir}; bash --login'"
		else
			echo
		fi
	fi

	if [ -e ${p} ]; then
		${ove_cmd2pathname["rm"]:?} ${p}
	fi
	if [ -e ${q} ]; then
		${ove_cmd2pathname["rm"]:?} ${q}
	fi

	return 0
}

function ove_unittest_preparations {
	local a
	local b
	local f_all
	local i
	local nbr_of_files_per_repo
	local nbr_of_projs
	local nbr_of_repos
	local nbr_of_systests
	local unittest_dir

	nbr_of_files_per_repo=$1
	nbr_of_projs=$2
	nbr_of_repos=$3
	nbr_of_systests=$4

	unittest_dir="${OVE_OWEL_TMP_DIR}/unittest"

	echo "${unittest_dir}"
	[ -d ${unittest_dir} ] && \
		${ove_cmd2pathname["rm"]:?} -rf ${unittest_dir}
	${ove_cmd2pathname["mkdir"]:?} -p ${unittest_dir}/.ove

	cd ${unittest_dir} || return 1
	${ove_cmd2pathname["ln"]:?} -s ${OVE_SELF} ove
	${ove_cmd2pathname["ln"]:?} -s ${OVE_DIR}/tests .

	# remotes
	${ove_cmd2pathname["mkdir"]:?} -p remotes

	# create some remote bare repos
	for a in $(${ove_cmd2pathname["seq"]:?} 1 ${nbr_of_repos}) top; do
		${ove_cmd2pathname["mkdir"]:?} -p ${unittest_dir}/remotes/git-${a}
		if ! [ -d .git ]; then
			${ove_cmd2pathname["git"]:?} init -q --bare ${unittest_dir}/remotes/git-${a}
			${ove_cmd2pathname["git"]:?} -C ${unittest_dir}/remotes/git-${a} symbolic-ref HEAD refs/heads/${OVE_DEFAULT_BRANCH_NAME}
		fi
	done

	# clone all repositories
	${ove_cmd2pathname["mkdir"]:?} -p testing/src
	for a in $(${ove_cmd2pathname["seq"]:?} 1 ${nbr_of_repos}); do
		if [ $((a%2)) -eq 0 ]; then
			${ove_cmd2pathname["git"]:?} clone -q remotes/git-${a} ${unittest_dir}/testing/src/git-${a} &> /dev/null
		else
			${ove_cmd2pathname["git"]:?} clone -q remotes/git-${a} ${unittest_dir}/git-${a} &> /dev/null
		fi
	done
	${ove_cmd2pathname["git"]:?} clone -q ${unittest_dir}/remotes/git-top &> /dev/null
	${ove_cmd2pathname["ln"]:?} -s git-top .owel

	# add some files
	for a in $(${ove_cmd2pathname["seq"]:?} 1 ${nbr_of_repos}); do
		if [ $((a%2)) -eq 0 ]; then
			cd ${unittest_dir}/testing/src/git-${a} || return 1
		else
			cd ${unittest_dir}/git-${a} || return 1
		fi

		f_all=
		for i in $(${ove_cmd2pathname["seq"]:?} 1 ${nbr_of_files_per_repo}); do
			filename=$(${ove_cmd2pathname["head"]:?} /dev/urandom | \
				${ove_cmd2pathname["tr"]:?} -dc A-Za-z0-9 | \
				${ove_cmd2pathname["head"]:?} -c 13 ; echo '')
			${ove_cmd2pathname["tr"]:?} -dc "\t\n [:alnum:]" < /dev/urandom | ${ove_cmd2pathname["head"]:?} -c10 > ${filename}
			f_all+=" $filename"
		done
		if [ ${nbr_of_files_per_repo} -ne 0 ]; then
			${ove_cmd2pathname["git"]:?} add $f_all
			${ove_cmd2pathname["git"]:?} commit -q -m "asdf"
			${ove_cmd2pathname["git"]:?} checkout -q -b ${OVE_DEFAULT_BRANCH_NAME} 2> /dev/null
			${ove_cmd2pathname["git"]:?} tag 0.0.1
			${ove_cmd2pathname["git"]:?} tag 0.0.2
			${ove_cmd2pathname["git"]:?} tag 0.0.3
			${ove_cmd2pathname["git"]:?} push -q origin ${OVE_DEFAULT_BRANCH_NAME}
			${ove_cmd2pathname["git"]:?} push -q --tags
			${ove_cmd2pathname["git"]:?} branch -q --set-upstream-to=origin/${OVE_DEFAULT_BRANCH_NAME}
		fi
	done

	# create revtab
	for a in $(${ove_cmd2pathname["seq"]:?} 1 ${nbr_of_repos}); do
		if [ $((a%2)) -eq 0 ]; then
			echo "testing/src/git-${a} ${unittest_dir}/remotes/git-${a} ${unittest_dir}/remotes/git-${a} ${OVE_DEFAULT_BRANCH_NAME}" >> ${unittest_dir}/git-top/revtab
		else
			echo "git-${a} ${unittest_dir}/remotes/git-${a} ${unittest_dir}/remotes/git-${a} ${OVE_DEFAULT_BRANCH_NAME}" >> ${unittest_dir}/git-top/revtab
		fi
	done

	# create projs
	if [ $nbr_of_projs -eq 0 ]; then
		echo "---" > ${unittest_dir}/git-top/projs
	else
		for a in $(${ove_cmd2pathname["seq"]:?} 1 ${nbr_of_projs}); do
			echo "p${a}:" >> ${unittest_dir}/git-top/projs
			echo "  path: .owel" >> ${unittest_dir}/git-top/projs
			if [ ${a} -lt ${nbr_of_projs} ]; then
				echo "  deps: p$((a+1))" >> ${unittest_dir}/git-top/projs
			fi
			echo >> ${unittest_dir}/git-top/projs
			${ove_cmd2pathname["mkdir"]:?} -p ${unittest_dir}/git-top/projects/p${a}
			for b in bootstrap configure build install; do
				echo "#!${ove_cmd2pathname["bash"]:?}" > ${unittest_dir}/git-top/projects/p${a}/${b}
				echo "echo ${b} p${a}" >> ${unittest_dir}/git-top/projects/p${a}/${b}
				chmod +x ${unittest_dir}/git-top/projects/p${a}/${b}
			done
		done
	fi

	# create systests
	for a in $(${ove_cmd2pathname["seq"]:?} 1 ${nbr_of_systests}); do
		echo -e "ok${a} 10 0 . true\nnok${a} 10 0 / false\nbg${a} 10 2 / sleep 0.1; true" >> ${unittest_dir}/git-top/systests
	done

	if [ ${nbr_of_systests} -ne 0 ]; then
		# create systests-groups
		echo "all:" >> ${unittest_dir}/git-top/systests-groups
		for a in $(${ove_cmd2pathname["seq"]:?} 1 ${nbr_of_systests}); do
			echo -e "- ok${a}\n- nok${a}\n- bg${a}" >> ${unittest_dir}/git-top/systests-groups
		done
	fi

	# commit and push
	${ove_cmd2pathname["git"]:?} -C ${unittest_dir}/git-top add .
	${ove_cmd2pathname["git"]:?} -C ${unittest_dir}/git-top commit -q -m "test"
	${ove_cmd2pathname["git"]:?} -C ${unittest_dir}/git-top checkout -q -b ${OVE_DEFAULT_BRANCH_NAME} 2> /dev/null
	${ove_cmd2pathname["git"]:?} -C ${unittest_dir}/git-top push -q origin ${OVE_DEFAULT_BRANCH_NAME}
	${ove_cmd2pathname["git"]:?} -C ${unittest_dir}/git-top branch -q --set-upstream-to=origin/${OVE_DEFAULT_BRANCH_NAME}
}

function ove_unittest_exit {
	if [ -e "${OVE_GLOBAL_STATE_DIR}/.oveconfig.bak" ]; then
		mv ${OVE_GLOBAL_STATE_DIR}/.oveconfig.bak ${OVE_GLOBAL_STATE_DIR}/.oveconfig
	fi
	if [ -e "${HOME}/.oveconfig.bak" ]; then
		mv ${HOME}/.oveconfig.bak ${HOME}/.oveconfig
	fi
}

function ove_unittest_cleanup {
	${ove_cmd2pathname["git"]:?} -C ${OVE_OWEL_DIR} checkout projs revtab &> /dev/null || true
}

function ove_unittest {
	local nbr_of_files_per_repo
	local nbr_of_projs
	local nbr_of_repos
	local nbr_of_systests
	local shelltest_opts
	local tot_files
	local unittest_dir

	nbr_of_files_per_repo=$1
	nbr_of_projs=$2
	nbr_of_repos=$3
	nbr_of_systests=$4

	echo "nbr_of_files_per_repo: ${nbr_of_files_per_repo} nbr_of_projs: ${nbr_of_projs} nbr_of_repos: ${nbr_of_repos} nbr_of_systests: ${nbr_of_systests}"

	if ! ove_unittest_preparations ${nbr_of_files_per_repo} ${nbr_of_projs} ${nbr_of_repos} ${nbr_of_systests}; then
		return 1
	fi

	tot_files=$((nbr_of_files_per_repo * nbr_of_repos + (4 * nbr_of_projs)))

	# projs is always there
	((tot_files++))

	# revtab?
	if [ $nbr_of_repos -ne 0 ]; then
		((tot_files++))
	fi

	# systests?
	if [ $nbr_of_systests -ne 0 ]; then
		# systests and systests-groups
		((tot_files+=2))
	fi

	tot_tests=$((nbr_of_systests * 3))
	if [ $nbr_of_systests -ne 0 ]; then
		((tot_tests+=1))
	fi

	# launch shelltestrunner
	cd ${OVE_OWEL_TMP_DIR}/unittest || return 1
	shelltest_opts=" --debug "

	${ove_cmd2pathname["env"]:?} -i - HOME=${HOME} USER=${OVE_USER} \
		${shelltest} ${tests} \
		${shelltest_opts} \
		--color \
		--diff \
		-a \
		-DOVE_TEST_STRING="set -m; source ove > /dev/null; ove_init > /dev/null; export TIMEFORMAT=\"%3lR\"; ove-loglevel 0 > /dev/null; trap ove_unittest_cleanup EXIT" \
		-DOVE_DEFAULT_BRANCH_NAME=${OVE_DEFAULT_BRANCH_NAME} \
		-Dnbr_of_systests=${tot_tests} \
		-Dnbr_of_projs=${nbr_of_projs} \
		-Dnbr_of_repos=$((nbr_of_repos + 1 )) \
		-Dnbr_of_files=${tot_files} \
		-DOVE_DIR=${OVE_DIR} \
		-DOVE_TEST_BASE="$(${ove_cmd2pathname["sed"]:?} -e 's|/|\\/|g' <<<"${OVE_OWEL_TMP_DIR}/unittest")" | \
		${ove_cmd2pathname["sed"]:?} -e 's|\\n|\n|g'
}

# unittest:[test...]:run all/specific unit tests:INTERNAL
function ove-unittest {
	ove_entry || return

	local a
	local tests

	if command -v shelltest > /dev/null; then
		shelltest=$(command -v shelltest)
	elif [ -x "${HOME}/.cabal/bin/shelltest" ]; then
		shelltest="${HOME}/.cabal/bin/shelltest"
	else
		ove_command_not_found "shelltestrunner" "Version 1.9 or greater is needed."
		return 1
	fi

	trap ove_unittest_exit EXIT
	if [ -e "${OVE_GLOBAL_STATE_DIR}/.oveconfig" ]; then
		mv ${OVE_GLOBAL_STATE_DIR}/.oveconfig  ${OVE_GLOBAL_STATE_DIR}/.oveconfig.bak
	fi
	if [ -e "${HOME}/.oveconfig" ]; then
		mv ${HOME}/.oveconfig ${HOME}/.oveconfig.bak
	fi

	if [ $# -eq 0 ]; then
		tests="tests/t*.test"
	else
		for a in "$@"; do
			if ! [ -e "${OVE_DIR}/tests/${a}.test" ]; then
				continue
			fi
			tests+="tests/${a}.test "
		done

		if [ "${tests}" == "" ]; then
			echo "error: select test(s) from:"
			${ove_cmd2pathname["find"]:?} ${OVE_DIR}/tests -name 't*.test' -type f -exec basename {} .test \; | LC_ALL="C" ${ove_cmd2pathname["sort"]:?}
			return 1
		fi
	fi

	#            files_per_repo | projs | repos | systest
	ove_unittest       0            0       0        0
	ove_unittest       0            1       0        0
	ove_unittest       1            0       1        0
	ove_unittest       0            0       0        1
	ove_unittest       1            1       1        1
	ove_unittest       2            2       2        2
	ove_unittest       3            3       3        3
	ove_unittest       3           10      10        3
}

# less-lastlog:[user...]:peek into user(s) last OVE log using less:LOG
function ove-less-lastlog {
	ove_entry || return

	ove_watch_logs "less" "$@"
}

# tail-lastlog:[user...]:peek into user(s) last OVE log using tail -f:LOG
function ove-tail-lastlog {
	ove_entry || return

	ove_watch_logs "tail" "$@"
}

# $1: tail|less
# ${@:2}: users
function ove_watch_logs {
	local cmd
	local cmdline
	local cmdpathname
	local d
	local e
	local i
	local ignore
	local log
	local u
	local users

	cmd=$1
	if [ "${cmd}" == "tail" ]; then
		cmdpathname="${ove_cmd2pathname["tail"]:?}"
	elif [ "${cmd}" == "less" ]; then
		cmdpathname="${ove_cmd2pathname["less"]:?}"
	else
		return 1
	fi
	shift

	if [ -d /var/tmp ]; then
		d="/var/tmp"
	else
		d="/tmp"
	fi

	if [ $# -eq 0 ]; then
		e+="./*/ove/logs"
	else
		for u in "$@"; do
			[ -d ${d}/${u}/ove/logs ] || continue
			e+="./${u}/ove/logs "
		done
	fi

	if [ "${e}" == "" ]; then
		ove_echo_error_noprefix "no logs found for user(s): $*"
		return 1
	fi

	# shellcheck disable=SC2164
	mapfile -t users < <(cd ${d}; ${ove_cmd2pathname["find"]:?} ${e} -maxdepth 0 -type d | ${ove_cmd2pathname["cut"]:?} -d/ -f2)
	if [ "${users[*]}" == "" ]; then
		ove_echo_error_noprefix "no logs found for user(s): $*"
		return 1
	fi

	ignore="tail-lastlog|less-lastlog"
	if ove_sanity_check_tmux 2> /dev/null; then
		for u in ${users[*]}; do
			log=$(${ove_cmd2pathname["find"]:?} ${d}/${u}/ove/logs/current/ -type f -name "*-ove-*.log" 2> /dev/null | \
				${ove_cmd2pathname["grep"]:?} -v -E "${ignore}" | \
				LC_ALL="C" ${ove_cmd2pathname["sort"]:?} | \
				${ove_cmd2pathname["tail"]:?} -1)
			if [ "${log}" == "" ]; then
				ove_echo_error_noprefix "no logs found for user: ${u}"
				continue
			fi

			cmdline=
			if [ "${cmd}" == "less" ] && [ "${OVE_LESS_MORE_OPTIONS}" -eq 1 ]; then
				cmdline="${cmdpathname} -R -Ps\"${log//./\\.}\""
			elif [ "${cmd}" == "less" ]; then
				cmdline="${cmdpathname} -R"
			else
				if [ -h "${d}/${u}/ove/logs/ongo" ]; then
					log="${d}/${u}/ove/logs/ongo"
				fi
				cmdline="${cmdpathname} -f -s 0.1 -q -F"
			fi

			${ove_cmd2pathname["tmux"]:?} split-window -h "${cmdline} ${log} 2> /dev/null"
			[ $# -eq 1 ] && return
			${ove_cmd2pathname["tmux"]:?} select-layout ${OVE_TMUX_LAYOUT}
		done

		return
	fi

	# not TMUX
	if [ ${#users[*]} -eq 1 ]; then
		u=${users[0]}
	else
		i=1
		for u in ${users[*]}; do
			echo "$i:$u"
			((i++))
		done
		read -r -p "user: "
		if ! [[ "${REPLY}" =~ ^[0-9]+$ ]] || [ "${REPLY}" -gt ${#users[*]} ]; then
			return 1
		fi
		echo
		u=${users[$((REPLY - 1))]}
	fi

	if ! [ -d "${d}/${u}" ]; then
		ove_echo_error_noprefix "no logs found for user: ${u}"
		return 1
	fi

	log=$(${ove_cmd2pathname["find"]:?} ${d}/${u}/ove/logs/current/ -type f -name "*-ove-*.log" 2> /dev/null | \
		${ove_cmd2pathname["grep"]:?} -v -E "${ignore}" | \
		LC_ALL="C" ${ove_cmd2pathname["sort"]:?} | \
		${ove_cmd2pathname["tail"]:?} -1)
	if [ "${log}" == "" ]; then
		ove_echo_error_noprefix "no logs found for user: ${u}"
		return 1
	fi

	if [ "${cmd}" == "less" ] && [ "${OVE_LESS_MORE_OPTIONS}" -eq 1 ]; then
		cmdline="${cmdpathname} -R -Ps\"${log//./\\.}\""
	elif [ "${cmd}" == "less" ]; then
		cmdline="${cmdpathname} -R"
	else
		if [ -h "${d}/${u}/ove/logs/ongo" ]; then
			log="${d}/${u}/ove/logs/ongo"
		fi
		cmdline="${cmdpathname} -f -s 0.1 -q -F"
	fi

	eval ${cmdline} ${log} 2> /dev/null
}

# remove-repo:name...:remove repo(s) from 'revtab':CORE
function ove-remove-repo {
	ove_entry || return
	ove_revtab_sanity || return

	local e=0
	local r
	local repos

	if [ $# -eq 0 ]; then
		ove_command_usage
		return 1
	fi

	repos=$(ove_validate_repo_list "$@")
	if [ "x${repos}" = "x" ]; then
		ove_echo_error_noprefix "invalid repo name(s): ${*}"
		return 1
	fi

	for r in ${repos}; do
		if [ "${r}" == "${OVE_OWEL_NAME}" ]; then
			ove_echo_error_noprefix "not possible to remove '${OVE_OWEL_NAME}'"
			((e++))
			continue
		elif ! ${ove_cmd2pathname["sed"]:?} -i -e "\,^${r} ,d" "${OVE_OWEL_DIR}/revtab"; then
			ove_echo_fatal_noprefix "removing '$r' from '${OVE_OWEL_DIR}/revtab' failed"
			((e++))
			return $e
		fi
	done

	return $e
}

# add-repo:dir|url|url name|url name rev:add a new repo to this OVE workspace:CORE
function ove-add-repo {
	ove_entry || return

	local fetch_url
	local name
	local push_url
	local remote
	local revision

	if [ $# -eq 0 ] || [ $# -gt 3 ]; then
		ove_command_usage
		return 1
	elif [ $# -eq 1 ] && [ -d "${1}" ] && [ -e "${1}"/.git ]; then
		name=${1}

		# remove any trailing slash
		if [ ${#name} -ne 1 ]; then
			name="${name%/}"
		fi

		# sanity check
		if [ "x$(ove_validate_repo_list "$name")" != "x" ]; then
			ove_echo_error_noprefix "'$name' is already added"
			return 1
		fi

		# multiple remotes?
		if [ $(ove_get_nbr_of_remotes "${name}") -gt 1 ]; then
			ove_echo_cyan_noprefix "select one remote for '${name}'"
			${ove_cmd2pathname["git"]:?} -C "${name}" remote -v
			while true; do
				read -r -p "remote: "
				remote="${REPLY}"
				if ${ove_cmd2pathname["git"]:?} -C "${name}" remote | ${ove_cmd2pathname["grep"]:?} -q ^${remote}$; then
					break;
				fi
			done
		else
			remote=$(${ove_cmd2pathname["git"]:?} -C "${1}" remote)
		fi

		fetch_url=$(ove_get_fetch_url "${name}" ${remote})
		push_url=$(ove_get_push_url "${name}" ${remote})
		revision=$(ove_get_revision "${name}")
	else
		fetch_url="${1}"
		push_url="${fetch_url}"
		revision="${OVE_DEFAULT_BRANCH_NAME}"

		if [ $# -eq 1 ]; then
			name="${1##*/}"
			name="${name%%.*}"

			read -r -p "name? (leave empty to name it '${name}'): "
			[ "${REPLY}" != "" ] && name="${REPLY}"
		elif [ $# -eq 2 ]; then
			name="${2}"
		elif [ $# -eq 3 ]; then
			name="${2}"
			revision="${3}"
		fi

		# sanity check
		if [ "x$(ove_validate_repo_list "$name")" != "x" ]; then
			ove_echo_error_noprefix "'$name' is already added"
			return 1
		fi

		if [ $# -eq 1 ] || [ $# -eq 2 ]; then
			read -r -p "revision? (leave empty to use '${revision}'): "
			[ "${REPLY}" != "" ] && revision="${REPLY}"
		fi
	fi

	# update revtab
	echo "${name} ${fetch_url} ${push_url} ${revision}" >> "${OVE_OWEL_DIR}/revtab"

	# parse revtab
	if ! ove_revtab_init; then
		# remove last line
		${ove_cmd2pathname["sed"]:?} -i '$ d' "${OVE_OWEL_DIR}/revtab"
		return 1
	elif [ ! -d "${name}" ] && ! ove-fetch "${name}"; then
		return 1
	fi

	return 0
}

# add-project:[name path]|[name path cmd...]|[name path cmd@content...]:add one project to 'projs' and 'projects/...':CORE
function ove-add-project {
	ove_entry || return

	local c
	local cmd
	local content
	local deps
	local i
	local j
	local name
	local name_check_ok
	local needs
	local needs_dist
	local path
	local proj_dir
	local tags

	if [ $# -eq 1 ]; then
		ove_command_usage
		return 1
	elif [ $# -ge 2 ]; then
		name="$1"

		if ! ove_read_config_validate_name ${name}; then
			ove_echo_error_noprefix "project name '${name}' is not allowed"
			return 1
		fi

		path="$2"
		proj_dir="$OVE_OWEL_DIR/projects/${name}"
		if ! ${ove_cmd2pathname["mkdir"]:?} -p ${proj_dir}; then
			ove_echo_fatal_noprefix "'mkdir -p ${proj_dir}' failed"
			return 1
		fi

		shift 2
		for c in "$@"; do
			if [[ ${c} == *@* ]]; then
				cmd=${c%%@*}
				content="${c#*@}"
				if [ "x${cmd}" = "x" ]; then
					ove_echo_error_noprefix "format error: ${c}"
					continue
				fi
			else
				cmd=${c}
			fi

			if [ "${cmd}" = "name" ] || [ "${cmd}" = "path" ]; then
				ove_echo_error_noprefix "reserved word: ${cmd}"
				continue
			fi

			if [[ ${c} != *@* ]]; then
				while true; do
					read -p "$(printf "%-9s" ${cmd}): " -r
					if [ "x$REPLY" = "x" ]; then
						continue
					fi
					content="$REPLY"
					break
				done
			fi

			if [ "${cmd}" = "deps" ] || [ "${cmd}" = "needs" ] || [ "${cmd}" = "tags" ]; then
				if [ -v ${cmd} ]; then
					eval ${cmd}="\"${!cmd} ${content}\""
				else
					eval local ${cmd}="\"${content}\""
				fi
				continue
			elif [[ "${cmd}" = needs_* ]]; then
				if [ -v ${cmd} ]; then
					eval ${cmd}="\"${!cmd} ${content}\""
				else
					eval local ${cmd}="\"${content}\""
					needs_dist+=" $cmd"
				fi
				continue
			fi
			echo -e "${content}" > ${proj_dir}/${cmd}
			if ! ${ove_cmd2pathname["chmod"]:?} +x ${proj_dir}/${cmd}; then
				ove_echo_fatal_noprefix "'chmod +x ${proj_dir}/${cmd}' failed"
				return 1
			fi
		done

	else
		name_check_ok=0
		for c in name path deps needs tags bootstrap configure build install clean test; do
			while true; do
				read -p "$(printf "%-9s" ${c}): " -r
				if [ "${c}" = "name" ] || [ "${c}" = "path" ]; then
					if [ "x$REPLY" = "x" ]; then
						continue
					fi

					if [ "${c}" = "name" ]; then
						if [ $name_check_ok -eq 0 ] && ! ove_read_config_validate_name "${REPLY}"; then
							ove_echo_error_noprefix "project name '${REPLY}' is not allowed"
							continue
						fi
						name_check_ok=1
					fi
					eval local ${c}="$REPLY"
					continue 2
				elif [ "${c}" = "deps" ] || [ "${c}" = "needs" ] || [ "${c}" = "tags" ]; then
					if [ "x$REPLY" = "x" ]; then
						echo -en "\033[1A\033[2K"
					else
						eval local ${c}="$REPLY"
					fi
					continue 2
				elif [ "x$REPLY" = "x" ]; then
					echo -en "\033[1A\033[2K"
					continue 2
				fi
				break
			done

			if [ "${c}" = "path" ] || [ "${c}" = "deps" ] || [ "${c}" = "needs" ] || [ "${c}" = "tags" ]; then
				continue
			fi

			proj_dir="$OVE_OWEL_DIR/projects/${name}"

			if ! ${ove_cmd2pathname["mkdir"]:?} -p ${proj_dir}; then
				ove_echo_fatal_noprefix "'mkdir -p ${proj_dir}' failed"
				return 1
			fi

			echo "$REPLY" > ${proj_dir}/${c}
			if ! ${ove_cmd2pathname["chmod"]:?} +x ${proj_dir}/${c}; then
				ove_echo_fatal_noprefix "'chmod +x ${proj_dir}/${c}' failed"
				return 1
			fi
		done
	fi

	if [ -s $OVE_OWEL_DIR/projs ] && ${ove_cmd2pathname["grep"]:?} -q ${name}: $OVE_OWEL_DIR/projs; then
		ove_echo_note_noprefix "project '${name}' is already present in '$OVE_OWEL_DIR/projs':"
		${ove_cmd2pathname["grep"]:?} -H -n -A3 --color=always "${name}:" $OVE_OWEL_DIR/projs | ${ove_cmd2pathname["sed"]:?} -e "s,$OVE_BASE_DIR/,,g"
	else
		if [ -s $OVE_OWEL_DIR/projs ]; then
			echo >> $OVE_OWEL_DIR/projs
		else
			echo "---" >> $OVE_OWEL_DIR/projs
		fi
		echo -e "${name}:\n  path:\n    ${path}" >> $OVE_OWEL_DIR/projs

		if [ "x${deps}" != "x" ]; then
			echo -e "  deps:" >> $OVE_OWEL_DIR/projs
			while read -r i; do
				echo "    $i" >> $OVE_OWEL_DIR/projs
			done < <(LC_ALL="C" ${ove_cmd2pathname["sort"]:?} <<<"$(printf "%s\n" ${deps})")
		fi

		if [ "x${needs}" != "x" ]; then
			echo -e "  needs:" >> $OVE_OWEL_DIR/projs
			while read -r i; do
				echo "    $i" >> $OVE_OWEL_DIR/projs
			done < <(LC_ALL="C" ${ove_cmd2pathname["sort"]:?} <<<"$(printf "%s\n" ${needs})")
		fi

		if [ "x${tags}" != "x" ]; then
			echo -e "  tags:" >> $OVE_OWEL_DIR/projs
			while read -r i; do
				echo "    $i" >> $OVE_OWEL_DIR/projs
			done < <(LC_ALL="C" ${ove_cmd2pathname["sort"]:?} <<<"$(printf "%s\n" ${tags})")
		fi

		if [ "x${needs_dist}" != "x" ]; then
			for i in ${needs_dist}; do
				echo -e "  $i:" >> $OVE_OWEL_DIR/projs
				while read -r j; do
					echo "    $j" >> $OVE_OWEL_DIR/projs
				done < <(LC_ALL="C" ${ove_cmd2pathname["sort"]:?} <<<"$(printf "%s\n" ${!i})")
			done
		fi
	fi

	if [ "x${proj_dir}" != "x" ]; then
		ove_reinit
		ove-list-projects ${name}
	fi
}

# generate-doc: :generate OVE documentation (ove-cmd-list.md/ove.bash):INTERNAL
function ove-generate-doc {
	ove_entry || return

	local a
	local b
	local c
	local d
	local header
	local sorted
	local str

	# ove-cmd-list.md (command list)
	a=$(${ove_cmd2pathname["grep"]:?} -B1 "^function ove-" "${OVE_BASE_DIR}"/ove | \
		${ove_cmd2pathname["grep"]:?} '#' | \
		${ove_cmd2pathname["cut"]:?} -b3-)
	b=$(set | \
		${ove_cmd2pathname["grep"]:?} ove_plugin_helptext | \
		${ove_cmd2pathname["grep"]:?} -v '\$'| \
		${ove_cmd2pathname["cut"]:?} -d'"' -f2 | \
		${ove_cmd2pathname["grep"]:?} -v -f<(printf "%s\n" ${OVE_SCRIPTS_LIST} | ${ove_cmd2pathname["sed"]:?} -e 's|^|^|g' -e 's|$|:|g'))

	header="| Command:| Arguments:| Description:| Category: |"
	sorted=$(printf "${a}\n${b}" | \
		${ove_cmd2pathname["sed"]:?} \
		-e 's/|/#/g' \
		-e 's/:/ :| /g' \
		-e 's/^/| /g' \
		-e 's/$/: |/g' | \
		LC_ALL="C" ${ove_cmd2pathname["sort"]:?})


	printf "${header}\n|-|-|-|-|\n${sorted}\n" | \
		${ove_cmd2pathname["sed"]:?} -e 's/\#/\\|/g' | \
		${ove_cmd2pathname["column"]:?} -s: -t \
		> ${OVE_DIR}/ove-cmd-list.md

	# ove-config-list.md (configuration list)
	for c in $(type ove_config_builtins_init | ${ove_cmd2pathname["grep"]:?} -o 'OVE_[A-Z_]\+'| LC_ALL="C" ${ove_cmd2pathname["sort"]:?} -u); do
		str+="$(${ove_cmd2pathname["grep"]:?} -o "# ${c}:.*:.*" ${OVE_SELF} | ${ove_cmd2pathname["cut"]:?} -b3-):$(type ove_config_builtins_init | \
			${ove_cmd2pathname["grep"]:?} "export ${c}=" | \
			${ove_cmd2pathname["cut"]:?} -d= -f2- | \
			${ove_cmd2pathname["sed"]:?} -e 's,;$,,g' | \
			${ove_cmd2pathname["tr"]:?} -d '"')\n"
	done
	sorted=$(printf "${str}" | \
		${ove_cmd2pathname["sed"]:?} \
		-e 's/|/#/g' \
		-e 's/:/ :| /g' \
		-e 's/^/| /g' \
		-e 's/$/: |/g' | \
		LC_ALL="C" ${ove_cmd2pathname["sort"]:?})

	header="| Config:| Type: | Allowed:| Affect: | Description: | Default value:"
	printf "${header}\n|-|-|-|-|-|-|\n${sorted}\n" | \
		${ove_cmd2pathname["sed"]:?} -e 's/\#/\\|/g' | \
		${ove_cmd2pathname["column"]:?} -s: -t \
		> ${OVE_DIR}/ove-config-list.md

	# ove.bash
	${ove_cmd2pathname["sed"]:?} -i "s/^ove_built_ins=.*/ove_built_ins=\"$(ove_get_built_ins)\"/g" ${OVE_DIR}/ove.bash

	# ove-variables-list.md (variables with descriptions)
	# shellcheck disable=SC2016
	a=$(ove-env | ${ove_cmd2pathname["awk"]:?} '{print $1}')
	# shellcheck disable=SC2016
	b=$(${ove_cmd2pathname["grep"]:?} OVE_ ${OVE_DIR}/ove-config-list.md | ${ove_cmd2pathname["awk"]:?} '{print $2}')
	str=
	header="| Variable:| Description:"
	for c in $(LC_ALL="C" ${ove_cmd2pathname["comm"]:?} -3 \
		<(LC_ALL="C" ${ove_cmd2pathname["sort"]:?} \
		<(printf "%s" "$a")) <(LC_ALL="C" ${ove_cmd2pathname["sort"]:?} <(printf "%s" "$b"))); do
		d=$(${ove_cmd2pathname["grep"]:?} "# $c:" $OVE_SELF | ${ove_cmd2pathname["cut"]:?} -d':' -f2-)
		if [ "$d" != "" ]; then
			str+="| $c:| $d:|\n"
		fi
	done

	# shellcheck disable=SC2059
	printf "$header\n|-|-|\n$str" | \
		${ove_cmd2pathname["column"]:?} -s: -t > ${OVE_DIR}/ove-variables-list.md

	# ove-externals-list.md (external commands and usage)
	header="| Command:| Usage:"
	str=
	# shellcheck disable=SC2016
	while read -r a b; do
		str+="| $a:| $b:|\n"
	done <<<"$(ove-list-externals | \
		${ove_cmd2pathname["awk"]:?} '{print $1,$5}')"
	printf "$header\n|-|-|\n$str" | \
		${ove_cmd2pathname["column"]:?} -s: -t > ${OVE_DIR}/ove-externals-list.md

	return 0
}

# shell-check: :run shellcheck on OVE:INTERNAL
function ove-shell-check {
	ove_entry || return

	local exclude
	local sc

	if ! command -v shellcheck > /dev/null; then
		ove_command_not_found "shellcheck"
		return 1
	fi

	# first, run shellcheck on some random scripts
	while read -r f; do
		(cd "${OVE_DIR}" && \shellcheck "${f}")
	done < <(${ove_cmd2pathname["git"]:?} -C ${OVE_DIR} ls-files -- ":(exclude)${OVE_BASENAME}" | ${ove_cmd2pathname["xargs"]:?} file | ${ove_cmd2pathname["grep"]:?} 'shell script' | ${ove_cmd2pathname["cut"]:?} -d: -f1)

	# then, run shellcheck on self

	# this {/} is literal...
	exclude+="SC1083,"

	# can't follow non-constant source
	exclude+="SC1090,"

	# quote this to prevent word splitting
	exclude+="SC2046,"

	# double quote to prevent globbing and word splitting
	exclude+="SC2086,"

	# use foo "$@" if function's $1 should mean script's $1
	exclude+="SC2119,"

	# foo references arguments, but none are ever passed
	exclude+="SC2120"

	(cd "${OVE_DIR}" && \shellcheck -x -e ${exclude} "${OVE_SELF}" > "${OVE_TMP}/shell-check")
	${ove_cmd2pathname["grep"]:?} -c -o ' SC[0-9]\+.*' "${OVE_TMP}/shell-check" > "${OVE_TMP}/shellcheck.summary"
	${ove_cmd2pathname["grep"]:?} -o ' SC[0-9]\+.*' "${OVE_TMP}/shell-check" | \
		LC_ALL="C" ${ove_cmd2pathname["sort"]:?} | \
		${ove_cmd2pathname["uniq"]:?} -c | \
		LC_ALL="C" ${ove_cmd2pathname["sort"]:?} -nr >> "${OVE_TMP}/shellcheck.summary"
	${ove_cmd2pathname["cp"]:?} -a "${OVE_TMP}/shellcheck.summary" "${OVE_DIR}/tests/.shellcheck"
	${ove_cmd2pathname["git"]:?} --no-pager -C "${OVE_DIR}" diff -- tests/.shellcheck

	if ${ove_cmd2pathname["git"]:?} -C "${OVE_DIR}" diff-files  --quiet -- tests/.shellcheck; then
		return 0
	else
		echo "\${OVE_TMP}/shell-check"
		for sc in $(${ove_cmd2pathname["git"]:?} -C "${OVE_DIR}" diff -U0 ${OVE_DIR}/tests/.shellcheck | \
			${ove_cmd2pathname["grep"]:?} '^+\s' | \
			${ove_cmd2pathname["grep"]:?} -o 'SC[0-9]\+'); do
			${ove_cmd2pathname["grep"]:?} --color=always -B5 ${sc} ${OVE_TMP}/shell-check
		done
		return 1
	fi
}

function ove_externals_init {
	local cmds=()
	local cmd
	local pathname
	local restore

	if declare -p ove_cmd2pathname &> /dev/null; then
		return
	fi

	cmds+=('ag')
	cmds+=('awk')
	cmds+=('basename')
	cmds+=('bash')
	cmds+=('cat')
	cmds+=('chmod')
	cmds+=('column')
	cmds+=('comm')
	cmds+=('cp')
	cmds+=('csplit')
	cmds+=('cut')
	cmds+=('date')
	cmds+=('diff')
	cmds+=('dirname')
	cmds+=('du')
	cmds+=('env')
	cmds+=('file')
	cmds+=('find')
	cmds+=('flock')
	cmds+=('fold')
	cmds+=('fzf')
	cmds+=('getconf')
	cmds+=('git')
	cmds+=('grep')
	cmds+=('head')
	cmds+=('inotifywait')
	cmds+=('ld')
	cmds+=('less')
	cmds+=('ln')
	cmds+=('locate')
	cmds+=('lsb_release')
	cmds+=('md5deep')
	cmds+=('md5sum')
	cmds+=('mkdir')
	cmds+=('mktemp')
	cmds+=('mv')
	cmds+=('pgrep')
	cmds+=('ps')
	cmds+=('readlink')
	cmds+=('rev')
	cmds+=('rm')
	cmds+=('rmdir')
	cmds+=('scp')
	cmds+=('script')
	cmds+=('scriptreplay')
	cmds+=('sed')
	cmds+=('seq')
	cmds+=('setsid')
	cmds+=('sleep')
	cmds+=('sort')
	cmds+=('ssh')
	cmds+=('stat')
	cmds+=('sync')
	cmds+=('tac')
	cmds+=('tail')
	cmds+=('tar')
	cmds+=('task')
	cmds+=('tee')
	cmds+=('timeout')
	cmds+=('tmux')
	cmds+=('tr')
	cmds+=('tsort')
	cmds+=('tsp')
	cmds+=('touch')
	cmds+=('uname')
	cmds+=('uniq')
	cmds+=('wc')
	cmds+=('whoami')
	cmds+=('xargs')
	cmds+=('yamllint')

	declare -g -A ove_cmd2pathname

	restore=0

	if shopt -q expand_aliases; then
		shopt -u expand_aliases
		restore=1
	fi
	for cmd in "${cmds[@]}"; do
		unset -f $cmd
		if ! pathname=$(command -v ${cmd}); then
			continue
		fi

		ove_cmd2pathname["$cmd"]="${pathname}"
	done
	if [ $restore -eq 1 ]; then
		shopt -s expand_aliases
	fi
}

# list-externals: :list all external commands that OVE is dependent on:CORE
function ove-list-externals {
	ove_entry || return

	local cmd
	local cnt
	local md5
	local ver

	for cmd in "${!ove_cmd2pathname[@]}"; do
		md5="$(${ove_cmd2pathname["md5sum"]:?} $(${ove_cmd2pathname["readlink"]:?} -f -- ${ove_cmd2pathname[$cmd]}))"
		ver="$(${ove_cmd2pathname["timeout"]:?} 1 ${ove_cmd2pathname[$cmd]:?} --version 2> /dev/null | ${ove_cmd2pathname["head"]:?} -1)"
		cnt="$(${ove_cmd2pathname["grep"]:?} -c "\${ove_cmd2pathname\[\"$cmd\"\]" ${OVE_SELF})"
		echo "${cmd}@${ove_cmd2pathname[$cmd]}@${md5}@${cnt}@${ver}"
	done | ${ove_cmd2pathname["column"]:?} -t -s@ | LC_ALL="C" ${ove_cmd2pathname["sort"]:?}
}

# nop: :do nothing:DEBUG
function ove-nop {
	ove_entry || return

	:
}

# rename:[new]:rename OWEL/workspace, USE WITH CARE:CORE
function ove-rename {
	ove_entry || return

	local a
	local b
	local cur
	local link
	local new
	local resolved

	if [ $# -gt 1 ]; then
		ove_command_usage
		return 1
	fi

	cur="${OVE_OWEL_NAME}"
	if [ $# -eq 1 ]; then
		new="$1"
	else
		echo "current: ${cur}"
		read -r -p "new name: "
		if [ "x${REPLY}" = "x" ]; then
			return
		fi
		new="${REPLY}"
	fi

	# sanity checks
	if [ "x${new}" = "x" ] || [ "${new}" = "${cur}" ]; then
		return 1
	elif [ -e "${new}" ]; then
		ove_echo_error_noprefix "'${new}' exists"
		return 1
	elif [[ "${new}" =~ [^a-zA-Z0-9_-] ]]; then
		ove_echo_error_noprefix "the name '${new}' is not allowed. Try: a-zA-Z0-9_-"
		return 1
	elif ${ove_cmd2pathname["grep"]:?} -q -w "${new}" <<<"archives ove stage tmp var ${OVE_USER}"; then
		ove_echo_error_noprefix "'${new}' is a reserved word"
		return 1
	elif ove_uniq $(printf "%s\n" $(ove_revtab_list_basename) | ${ove_cmd2pathname["cut"]:?} -d/ -f1) | ${ove_cmd2pathname["grep"]:?} -q "^${new}$"; then
		ove_echo_error_noprefix "'${new}' clash with a repo name in '${OVE_OWEL_DIR}/revtab'"
		return 1
	fi

	cd ${OVE_BASE_DIR} || return 1
	for link in .owel .ove.state .ove.tmp README; do
		resolved="$(${ove_cmd2pathname["readlink"]:?} ${link})"
		if [[ "${resolved}" == *${cur}* ]]; then
			if [ -d "${resolved}" ]; then
				a="${resolved%%${cur}*}${cur}"
				b="${resolved%%${cur}*}${new}"
				${ove_cmd2pathname["mv"]:?} ${a} ${b}
			fi
			${ove_cmd2pathname["rm"]:?} ${link}
			${ove_cmd2pathname["ln"]:?} -s ${resolved/${cur}/${new}} ${link}
		fi
	done
}

# distrocheck:project [pattern]:verify a project (using LXC/LXD) within multiple Linux distributions:UTIL
function ove-distrocheck {
	ove_entry || return

	local proj

	if [ $# -eq 0 ] || [ $# -gt 2 ]; then
		ove_command_usage
		return 1
	fi

	proj="$1"
	if ! [[ -v ove_projects_name2index[${proj}] ]]; then
		ove_echo_error_noprefix "unknown project '${proj}'"
		return 1
	fi

	if [ ! -s "${OVE_OWEL_DIR}/projects/${proj}/distcheck" ]; then
		ove_echo_error_noprefix "file '${OVE_OWEL_DIR}/projects/${proj}/distcheck' not found"
		return 1
	fi
	${OVE_DIR}/tests/distro-check.sh "${OVE_OWEL_DIR}/projects/${proj}/distcheck" "$2"
}

# pre-push: :shell-check+unittest+generate-doc combo:INTERNAL
function ove-pre-push {
	ove_entry || return

	if ! ove_validate_self; then
		return 1
	fi

	if [ -d ${OVE_OWEL_TMP_DIR}/unittest ]; then
		${ove_cmd2pathname["rm"]:?} -rf ${OVE_OWEL_TMP_DIR}/unittest
	fi

	if ove_sanity_check_tmux 2> /dev/null; then
		ove-run-parallel 0 shell-check 0 generate-doc 0 "blame ${OVE_USER}" 0 "tail-lastlog ${OVE_USER}"
		ove-unittest
	else
		ove-shell-check
		ove-unittest
		ove-generate-doc
		ove-blame "${OVE_USER}"
	fi

	ove-status .ove
}

# post-push: :run OVE unittests (using LXC/LXD) within Linux distributions specified by ${OVE_DIR}/tests/distro-check.list:INTERNAL
function ove-post-push {
	ove_entry || return

	local args

	if [ ! -s "${OVE_DIR}/tests/distro-check.list" ]; then
		return 1
	fi

	args=$(${ove_cmd2pathname["sed"]:?} -e '/^#/d' -e 's,^,^,g' -e 's,$,$|,g' "${OVE_DIR}/tests/distro-check.list")
	args=${args//$'\n'/}
	args=${args::-1}
	if [ $(${ove_cmd2pathname["wc"]:?} -l <"${OVE_DIR}/tests/distro-check.list") -gt 1 ] && ove_sanity_check_tmux 2> /dev/null; then
		ove run 0 "do . ${ove_cmd2pathname["tail"]:?} -f ${OVE_LAST_COMMAND} | ${ove_cmd2pathname["grep"]:?} -A3 '^ Passed'"
	fi
	${OVE_DIR}/tests/distro-check.sh "unittest" "${args}"
}

ove_main "$@"
