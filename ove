#!/usr/bin/env bash
# SPDX-License-Identifier: MIT
#
# MIT License
#
# Copyright (c) 2019 Ericsson
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is furnished
# to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice (including the next
# paragraph) shall be included in all copies or substantial portions of the
# Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
# FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS
# OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
# OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

function ove_read_config {
	local p
	local p_arr
	local val
	local var

	if [ -e "$1" ]; then
		while read -r p; do
			# ignore comments
			[[ ${p} == \#* ]] && continue
			# ignore empty lines
			[[ ${p} == '' ]] && continue
			p_arr=( ${p} )
			var=${p_arr[0]}
			if [ "$2" == "clean" ]; then
				unset ${var}
			else
				val=${p_arr[*]:1}
				eval ${var}=\"${val}\"
				# shellcheck disable=SC2163
				export ${var}
			fi
		done <$1
	fi
}

function ove_unsource {
	# remove stage string from ${PATH}
	if [ "${OVE_STAGE_DIR}" != "" ] && \
		[[ ${PATH} == *"${OVE_STAGE_DIR}"* ]]; then
		PATH=${PATH/:${OVE_STAGE_DIR}${OVE_PREFIX}\/bin/}
		export PATH
	fi

	unset LD_LIBRARY_PATH

	# clean config variables
	if [ -e ${HOME}/.oveconfig ]; then
		ove_read_config ${HOME}/.oveconfig clean
	elif [ "${OVE_PROJECT_DIR}" != "" ] && \
		[ -e "${OVE_PROJECT_DIR}/.oveconfig" ]; then
		ove_read_config ${OVE_PROJECT_DIR}/.oveconfig clean
	fi

	# unset old ove[-_] functions
	unset -f $(compgen -A function | \
		grep -E '^ove($|[-_])' | \
		grep -E -v "ove_read_config|ove-unsource|${FUNCNAME[0]}" | \
		awk '{print $1}')

	# unset old ove_/OVE_ variables
	unset $(set -o posix ; set | \
		grep -i ^ove_ | \
		cut -d= -f1)

	# unset completion for ove
	if complete -p | grep -q ' ove$'; then
		complete -r ove
	fi
}

# unsource: :clean up all OVE vars/funcs from this shell
function ove-unsource {
	ove_unsource
	# unset leftovers and myself
	unset -f $(compgen -A function | \
		grep -E '^ove($|[-_])' | \
		awk '{print $1}') \
		${FUNCNAME[0]}
	echo "ove has been removed from this bash shell [pid:${BASHPID}]" 1>&2
}

# interactive shell? clean up
[[ $- == *i* ]] && ove_unsource

function ove_welcome_msg {
	local script_ver

	ove-version
	echo
	echo "This script will do a few things:"
	echo

	echo "* add $(set | grep -c ^ove-) bash functions:"
	set | \
		grep ^ove- | \
		cut -d' ' -f1 | \
		column
	echo
	( set -o posix ; set ) | \
		cut -d= -f1 > ${OVE_TMP}/bash-vars-after

	mapfile ove_bash_vars_diff <<<$(comm -1 -3 <(sort ${OVE_TMP}/bash-vars-before) <(sort ${OVE_TMP}/bash-vars-after) | sort)
	rm ${OVE_TMP}/bash-vars-after ${OVE_TMP}/bash-vars-before
	echo "* add ${#ove_bash_vars_diff[@]} bash variables:"
	xargs -n1 <<<${ove_bash_vars_diff[*]} | column
	unset ove_bash_vars_diff

	echo
	echo "* enable tab completion for ove"

	if ! [ -e "${HOME}/.ove.bash" ]; then
		echo
		echo "Do you want to skip the initial 'source ove' step? Run this:"
		echo " cp ${OVE_DIR}/ove.bash ${HOME}/.ove.bash && echo '[ -f ~/.ove.bash ] && source ~/.ove.bash' >> ${HOME}/.bashrc"
	fi

	script_ver=$(script --version | awk '{print $NF}')
	if [[ ${script_ver} =~ ^2.3[12] ]]; then
		echo
		echo "NOTE: due to a bug in $(command -v script) 2.31/2.32 (you have ${script_ver}), it's not possible to Ctrl-C any ove command. Upgrade package: '$(ove_command_to_package script)'."
	fi

	echo
	echo "Now what? Run 'ove fetch' to sync with the outside world or 'ove help' for more information."
}

function ove_main {
	/proc/self/exe --version | grep -q 'GNU bash'
	test $? -ne 0 && echo 'error: run this in bash' && return 1

	if [ ${BASH_VERSINFO[0]} -lt 4 ]; then
		echo "error: bash ${BASH_VERSINFO[0]}.${BASH_VERSINFO[1]} is way too old. I need bash 4.3+"
		return 1
	elif [ ${BASH_VERSINFO[0]} -eq 4 ] && [ ${BASH_VERSINFO[0]} -lt 3 ]; then
		echo "error: bash ${BASH_VERSINFO[0]}.${BASH_VERSINFO[1]} is too old. I need bash 4.3+"
		return 1
	fi

	ove_green="\033[1;32;7m"
	ove_cyan="\033[1;36;7m"
	ove_yellow_x="1;33;7m"
	ove_yellow="\033[${ove_yellow_x}"
	ove_red="\033[1;31;7m"
	ove_blank="\033[0m"

	OVE_TMP=/tmp/${USER}/ove
	export OVE_TMP
	! [ -d "${OVE_TMP}" ] && mkdir -p "${OVE_TMP}"

	# set OVE_OS_* variables
	ove_determine_dist_version_and_pack_manager

	# interactive shell?
	if [[ $- == *i* ]]; then
		# turn off monitor mode to get rid of "Done" messages
		set +m

		if [[ "$*" == *"hush"* ]]; then
			:
		else
			( set -o posix ; set ) | \
				cut -d= -f1 | \
				grep -v ^OVE > ${OVE_TMP}/bash-vars-before
		fi

		if ! ove_deps; then
			ove-unsource
			return 1
		fi

		if [ -e ".owel" ] && [ -e ove ]; then
			:
		else
			ove-init
		fi

		if ! ove_init; then
			ove-unsource
			return 1
		fi

		if [ ${OVE_LOGLEVEL} -eq 0 ] || [[ "$*" == *"hush"* ]]; then
			:
		else
			ove_welcome_msg
		fi

		ove_post_checks

		# turn on monitor mode
		set -m
	fi
}

# $1: pid
function ove_strace_execve_one_pid {
	local cmd
	local exit_code
	local line
	local syscall
	local t0

	cmd=
	pid=$1
	while read -r line; do
		[ "${line}" == "" ] && continue
		syscall=${line#* }
		syscall=${syscall%%(*}

		if [ "${syscall}" == "execve" ]; then
			[[ "${line}" == *"ENOENT"* ]] && continue
			cmd=${line##* [\"}
			cmd=${cmd%%\"]*}
			cmd=${cmd//\", \"/ }
			t0=$(ove_strace_get_t0 ${pid})
			[ "${cmd}" == "" ] && continue
			exit_code=$(ove_strace_get_exit_code ${pid})
			if [ ${OVE_LOGLEVEL} -eq 3 ]; then
				echo "${t0}:${pid}:${exit_code}:${cmd}"
			elif [ ${OVE_LOGLEVEL} -eq 4 ]; then
				echo "$(ove_strace_get_duration_s ${pid}):${pid}:${exit_code}:${cmd}"
			fi
			continue
		fi
	done <<< "${all_files[$1]}"
}

# $1: directory with strace pid files
function ove_analyze_strace_execve_timing {
	local all_files
	local f
	local pid

	! [ -d "$1" ] && return 1

	declare -A all_files
	while true; do
		for f in $(find $1 -type f); do
			pid=${f##*.}
			all_files[${pid}]="$(<${f})"
			ove_strace_execve_one_pid ${pid} &
		done
		wait
		break
	done | sort -n$([ ${OVE_LOGLEVEL} -eq 4 ] && echo r)
}

function ove_line2ipv4 {
	grep -E -o '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}' <<<"$@"
}

# $1: IPv4 address
function ove_ip2host {
	local ip
	local ip_lookup

	if ! command -v dig > /dev/null; then
		ove_echo_error_noprefix "'dig' is not found"
		return 1
	fi

	if ! command -v whois > /dev/null; then
		ove_echo_error_noprefix "'whois' is not found"
		return 1
	fi

	ip=${1}

	if [[ ${ip} == 127* ]]; then
		ip_lookup="localhost"
	else
		ip_lookup=$(dig +short -x ${ip} | \
			tr '\n' ' ' | \
			xargs)

		if [ "${ip_lookup}" == "" ]; then
			ip_lookup="NA"
		else
			ip_lookup=${ip_lookup::-1}
		fi
	fi

	echo ${ip_lookup}
}

# $1: IPv4 address
function ove_ip2org {
	local ip
	local org

	if ! command -v whois > /dev/null; then
		ove_echo_error_noprefix "'whois' is not found"
		return 1
	fi

	ip=${1}

	if [[ ${ip} == 127* ]]; then
		org="NA"
	else
		org=$(timeout 3 whois ${ip} 2> /dev/null | \
			grep -E -i 'netrange:|netname|parent')
		[ "${org}" == "" ] && return
	fi

	printf "${org}"
}

# $1: port
function ove_port2service {
	local port
	local port_service

	port=${1}

	if [ -e /etc/services ]; then
		port_service=$(grep -m1 -w ${port} /etc/services | \
			awk '{print $1}')
	fi

	[ "${port_service}" == "" ] && port_service="NA"
	echo "${port_service}"
}

# $1: pid
function ove_strace_connect_one_pid {
	local cmd
	local ip
	local ip_lookup
	local line
	local port
	local port_service
	local ret
	local sa_family
	local str
	local sun_path
	local syscall

	cmd=
	pid=$1
	while read -r line; do
		[ "${line}" == "" ] && continue
		syscall=${line#* }
		syscall=${syscall%%(*}

		if [ "${syscall}" == "bind" ] ||
			[ "${syscall}" == "connect" ]; then
			sa_family=${line##*sa_family=}
			sa_family=${sa_family%%,*}
			t0=${line%% *}

			ret=${line##* =}
			ret=${ret% <*}
			if [[ "${ret}" == " -1"* ]] && ! [[ "${ret}" != "EINPROGRESS"* ]]; then
				continue
			fi

			if [ "${sa_family}" == "AF_LOCAL" ] || \
				[ "${sa_family}" = "AF_UNIX" ]; then
				sun_path=${line#*\"}
				sun_path=${sun_path%\"*}

				# abstract sockets
				[[ "${line}" == *"=@"* ]] && sun_path="@${sun_path}"

				cmd=$(ove_strace_get_execve ${pid})

				str+="${t0}:${syscall}:${sa_family}:${sun_path}:${cmd}\n"
			elif [ "${sa_family}" == "AF_INET" ]; then
				ip=$(ove_line2ipv4 ${line})
				port=$(cut -d'(' -f3- <<<"${line}" | \
					cut -d')' -f1)

				ip_lookup=${ove_ip2host_db["${ip}"]}
				port_service=${ove_port2service_db["${port}"]}
				cmd=$(ove_strace_get_execve ${pid})

				str+="${t0}:${syscall}:${sa_family}:${ip}:${ip_lookup}:${port}:${port_service}:${cmd}\n"
			fi
		fi
	done <<< "${all_files[${pid}]}"

	[ "${str}" != "" ] && printf "${str}"
}

function ove_read_connect_cache {
	local line

	declare -A -g ove_ip2host_db
	declare -A -g ove_ip2org_db
	declare -A -g ove_port2service_db

	if [ -e ${OVE_GLOBAL_STATE_DIR}/ip2host.cache ]; then
		for line in $(cat ${OVE_GLOBAL_STATE_DIR}/ip2host.cache); do
			ove_ip2host_db["${line%%:*}"]="${line##*:}"
		done
	fi

	if [ -e ${OVE_GLOBAL_STATE_DIR}/port2service.cache ]; then
		for line in $(cat ${OVE_GLOBAL_STATE_DIR}/port2service.cache); do
			ove_port2service_db["${line%%:*}"]="${line##*:}"
		done
	fi

	if [ -e ${OVE_GLOBAL_STATE_DIR}/ip2org.cache ]; then
		while read -r line; do
			ove_ip2org_db["${line%%:*}"]="$(tr '@' '\n' <<<${line#*:})"
		done < <(cat ${OVE_GLOBAL_STATE_DIR}/ip2org.cache)
	fi
}

# $1: directory with strace pid files
function ove_update_connect_db {
	local host
	local ip
	local line
	local org
	local port
	local service

	ove_read_connect_cache

	if command -v ag > /dev/null; then
		ag --nobreak --nofilename -o --nonumbers 'AF_INET,.* =' $1 | \
			sort -u > ${OVE_PROJECT_TMP_DIR}/af_inet
	else
		grep -E -R -o -h 'AF_INET,.* =' $1 | \
			sort -u > ${OVE_PROJECT_TMP_DIR}/af_inet
	fi

	if ! [ -s "${OVE_PROJECT_TMP_DIR}/af_inet" ]; then
		rm ${OVE_PROJECT_TMP_DIR}/af_inet
		return
	fi

	while read -r line; do
		ip=$(ove_line2ipv4 ${line})
		[ "${ip}" == "" ] && continue
		port=$(cut -d'(' -f2- <<<${line} | \
			cut -d')' -f1)
		[ "${port}" == "" ] && continue

		if ! test "${ove_ip2host_db["${ip}"]+isset}"; then
			host="$(ove_ip2host ${ip})"
			ove_ip2host_db["${ip}"]="${host}"
			echo "${ip}:${host}" >> ${OVE_GLOBAL_STATE_DIR}/ip2host.cache
		fi

		if ! test "${ove_ip2org_db["${ip}"]+isset}"; then
			org="$(ove_ip2org ${ip} | tr '\n' '@')"
			ove_ip2org_db["${ip}"]="$(echo ${org} | tr '@' '\n')"
			echo "${ip}:${org}" >> ${OVE_GLOBAL_STATE_DIR}/ip2org.cache
		fi

		if ! test "${ove_port2service_db["${port}"]+isset}"; then
			service="$(ove_port2service ${port})"
			ove_port2service_db["${port}"]=${service}
			echo "${port}:${service}" >> ${OVE_GLOBAL_STATE_DIR}/port2service.cache
		fi
	done <${OVE_PROJECT_TMP_DIR}/af_inet

	rm ${OVE_PROJECT_TMP_DIR}/af_inet

	for line in ${OVE_GLOBAL_STATE_DIR}/{ip2host,ip2org,port2service}.cache; do
		sort -V -o ${line} ${line} &
	done
	wait
}

# $1: directory with strace pid files
function ove_analyze_strace_connect {
	local all_files
	local f
	local pid

	! [ -d "$1" ] && return 1

	declare -A all_files
	ove_update_connect_db $1
	while true; do
		for f in $(find $1 -type f); do
			pid=${f##*.}
			all_files[${pid}]="$(<${f})"
			ove_strace_connect_one_pid ${pid} &
		done
		wait
		break
	done | sort -n
}

# $1: pid
function ove_strace_get_exit_code {
	local exit_code
	local strace_file

	strace_file=${all_files[$1]}
	exit_code=${strace_file##*$'\n'}
	if [[ "${exit_code}" == *"killed by"* ]]; then
		exit_code=${exit_code##* killed by }
		exit_code=${exit_code%% +++}
	elif [[ "${exit_code}" == *"exited with"* ]]; then
		exit_code=${exit_code##* exited with }
		exit_code=${exit_code%% +++}
	else
		exit_code="alive"
	fi

	echo ${exit_code}
}

# $1: pid
function ove_strace_get_duration_s {
	local diff
	local strace_file
	local t0
	local t1

	strace_file=${all_files[$1]}
	t0=${strace_file%% *}
	t1=${strace_file##*$'\n'}
	t1=${t1%% *}

	[ "${t0}" == "${t1}" ] && echo "0.000000" && return

	diff=$(awk "BEGIN{printf \"%.6f\n\", (${t1} - ${t0})}")
	echo ${diff}
}

# $1: pid
function ove_strace_get_duration_ms {
	local diff
	local strace_file
	local t0
	local t1

	strace_file=${all_files[$1]}
	t0=${strace_file%% *}
	t1=${strace_file##*$'\n'}
	t1=${t1%% *}

	[ "${t0}" == "${t1}" ] && echo "0" && return

	diff=$(awk "BEGIN{printf \"%.0f\n\", (${t1} - ${t0}) * 1000}")
	echo ${diff}
}

# $1: pid
function ove_strace_get_t0 {
	local strace_file
	local t0

	strace_file=${all_files[$1]}
	t0=${strace_file%% *}
	echo ${t0}
}

# $1: pid
function ove_strace_get_execve {
	local cmd
	local line
	local syscall

	while read -r line; do
		[ "${line}" == "" ] && continue
		syscall=${line#* }
		syscall=${syscall%%(*}

		[ "${syscall}" != "execve" ] && continue
		[[ "${line}" == *"ENOENT"* ]] && continue
		cmd=${line##* [\"}
		cmd=${cmd%%\"]*}
		cmd=${cmd//\", \"/ }
	done <<< "${all_files[$1]}"

	[ "${cmd}" == "" ] && cmd="NA"
	echo -e "${cmd}"
}

# $1: pid
function ove_strace_one_pid {
	local cmd
	local duration_ms
	local duration_s
	local ip
	local ip_lookup
	local ip_org
	local key
	local line
	local out_1
	local out_2
	local p
	local pid
	local port
	local port_service
	local ret
	local sa_family
	local suffix
	local sun_path
	local t

	pid=$1

	duration_ms=$(ove_strace_get_duration_ms ${pid})
	duration_s=$(ove_strace_get_duration_s ${pid})
	t=$(ove_strace_get_t0 ${pid})

	# label START
	out_1="    ${pid} [label=\"p: ${pid}\l\nt: ${t}\l\nd: ${duration_ms} ms (${duration_s} s)\l\n"

	# exit code
	exit_code=$(ove_strace_get_exit_code ${pid})
	if [[ "${exit_code}" =~ ^[0-9]+$ ]]; then
		if [ ${exit_code} -ne 0 ]; then
			out_1+="e: ${exit_code}\l\n"
			border_color='"red"'
		else
			border_color='"green"'
		fi
	elif [ "${exit_code}" == "alive" ]; then
		border_color='"blue"'
	else
		out_1+="e: ${exit_code}\l\n"
		border_color='"black"'
	fi

	cmd=
	out_2=
	declare -A ip_port_cnt
	while read -r line; do
		[ "${line}" == "" ] && continue
		syscall=${line#* }
		syscall=${syscall%%(*}
		! [[ "${syscall}" =~ ^[a-z]+$ ]] && continue

		echo "${t}:${syscall}:${pid}:${duration_ms}:${duration_s}" >> ${OVE_PROJECT_TMP_DIR}/timing
		if [ "${syscall}" == "clone" ] ||
			[ "${syscall}" == "fork" ] ||
			[ "${syscall}" == "vfork" ]; then
			p=${line##* = }
			p=${p%% *}
			! [[ "${p}" =~ ^[0-9]+$ ]] && continue
			out_2+="    ${pid} -> ${p} [label=${syscall}];"
			continue
		elif [ "${syscall}" == "execve" ]; then
			[[ "${line}" == *"ENOENT"* ]] && continue
			cmd=${line##* [\"}
			cmd=${cmd%%\"]*}
			cmd=${cmd//\", \"/ }
			continue
		elif [ "${syscall}" == "bind" ] ||
			[ "${syscall}" == "connect" ]; then
			sa_family=${line##*sa_family=}
			sa_family=${sa_family%%,*}

			ret=${line##* =}
			ret=${ret% <*}
			if [[ "${ret}" == " -1"* ]] && ! [[ "${ret}" != "EINPROGRESS"* ]]; then
				continue
			fi

			if [ "${sa_family}" == "AF_LOCAL" ] || \
				[ "${sa_family}" = "AF_UNIX" ]; then
				sun_path=${line#*\"}
				sun_path=${sun_path%\"*}

				# abstract sockets
				[[ "${line}" == *"=@"* ]] && sun_path="@${sun_path}"

				out_2+="    \"${sun_path}\" [label=\"${sun_path}\l\n\" shape=box3d,fontsize=20,style=filled,fillcolor=\"cyan\"];"
				out_2+="    ${pid} -> \"${sun_path}\" [label=\"${syscall}\"];"
			elif [ "${sa_family}" == "AF_INET" ]; then
				ip=$(ove_line2ipv4 ${line})
				[ "${ip}" == "" ] && continue
				port=$(cut -d'(' -f3- <<<${line} | \
					cut -d')' -f1)
				[ "${port}" == "" ] && continue

				if test "${ip_port_cnt["${ip}:${port}"]+isset}"; then
					ip_port_cnt["${ip}:${port}"]=$((${ip_port_cnt["${ip}:${port}"]} + 1))
				else
					ip_port_cnt["${ip}:${port}"]=1
				fi

				ip_lookup=${ove_ip2host_db["${ip}"]}
				ip_org=${ove_ip2org_db["${ip}"]}
				port_service=${ove_port2service_db["${port}"]}

				org=$(sed -e 's/$/ \\l\\n/g' <<<"${ip_org}" | tr '\n' ' ' | tr \" \')

				out_2+="    \"${ip}\" [label=\"t: ${t}\l\nIP: ${ip}\l\n${ip_lookup}\l\n${org}\l\n\" shape=box3d,fontsize=20,style=filled, fillcolor=\"yellow\"];"
				out_2+="    ${pid} -> \"${ip}\" [label=\"${syscall} ${port} ${port_service["${port}"]}\"];"
			else
				continue
			fi
		fi
	done <<< "${all_files[$1]}"

	for key in "${!ip_port_cnt[@]}"; do
		ip=${key%%:*}
		port=${key##*:}
		ip_lookup="${ove_ip2host_db["${ip}"]}"
		port_service=${ove_port2service_db["${port}"]}
		if [ ${ip_port_cnt[${ip}:${port}]} -gt 1 ]; then
			suffix="(repeated ${ip_port_cnt[${ip}:${port}]} time(s))"
		fi
		out_1+="c: ${ip}|${ip_lookup}|${port}|${port_service} ${suffix}\l\n"
	done

	# penwidth based on duration
	penwidth=${duration_ms}
	if [ ${duration_ms} -gt 20 ]; then
		penwidth=20
	elif [ ${duration_ms} -eq 0 ]; then
		penwidth=1
	fi

	[ "${cmd}" != "" ] && \
		out_1+="x: $(echo -e ${cmd} | fold -w 80 -s | sed -e 's/$/ \\l\\n/g' | tr '\n' ' ' | tr \" \')"

	# label END
	out_1+="\",color=${border_color},penwidth=${penwidth},fontsize=14,fontcolor=black];"

	echo "${out_1}"
	[ "${out_2}" != "" ] && echo "${out_2}"
}

# strace-graph:DIR:run strace graph analysis on DIR
function ove-strace-graph {
	if [ $# -ne 1 ]; then
		ove-help "^${FUNCNAME/ove-/} "
		return 1
	fi

	ove_strace_create_graph $1 $(basename $1)
}

# strace-execve-timeline:DIR:run strace execve timeline analysis on DIR
function ove-strace-execve-timeline {
	if [ $# -ne 1 ]; then
		ove-help "^${FUNCNAME/ove-/} "
		return 1
	fi

	OVE_LOGLEVEL=3 ove_analyze_strace_execve_timing $1

}

# strace-execve-time:DIR:run strace execve time analysis on DIR
function ove-strace-execve-time {
	if [ $# -ne 1 ]; then
		ove-help "^${FUNCNAME/ove-/} "
		return 1
	fi

	OVE_LOGLEVEL=4 ove_analyze_strace_execve_timing $1
}

# strace-connect:DIR:run strace connect time analysis on DIR
function ove-strace-connect {
	if [ $# -ne 1 ]; then
		ove-help "^${FUNCNAME/ove-/} "
		return 1
	fi

	ove_analyze_strace_connect $1
}

# $1: directory with strace pid files
# $2: append string to output files
function ove_strace_create_graph {
	local all_files
	local f
	local o_base
	local o_dot
	local o_svg
	local o_timing
	local pid

	! [ -d "$1" ] && return 1
	[ $# -ne 2 ] && return 2

	o_base="${OVE_PROJECT_TMP_DIR}/strace-${2}"
	o_dot=${o_base}.dot
	o_svg=${o_base}.svg
	o_timing=${o_base}.timing

	echo "strict digraph $(tr '-' '_' <<<${OVE_PROJECT_NAME} | tr -d '.') {" > ${o_dot}
	echo "    nodesep=2" >> ${o_dot}
	echo "    ranksep=5" >> ${o_dot}
	echo "    node [margin=1,shape=octagon,nodesep=10];" >> ${o_dot}

	# remove leftovers
	find ${OVE_PROJECT_TMP_DIR} -name "strace-${2}.dot.*" -print0 | xargs -0 rm &> /dev/null

	declare -A all_files
	true > ${OVE_PROJECT_TMP_DIR}/timing
	ove_update_connect_db $1
	for f in $(find $1 -type f); do
		pid=${f##*.}
		all_files[${pid}]="$(<${f})"
		ove_strace_one_pid ${pid} >> ${o_dot}.${pid} &
	done
	wait

	# merge all files into one
	find ${OVE_PROJECT_TMP_DIR} -name "strace-${2}.dot.*" -print0 | xargs -0 cat >> ${o_dot}
	find ${OVE_PROJECT_TMP_DIR} -name "strace-${2}.dot.*" -print0 | xargs -0 rm

	echo "}" >> ${o_dot}

	sort -u ${OVE_PROJECT_TMP_DIR}/timing > ${o_timing}
	rm ${OVE_PROJECT_TMP_DIR}/timing

	du -sh ${o_dot}
	if command -v dot > /dev/null; then
		if ! dot -Tsvg ${o_dot} > ${o_svg}; then
			return 1
		fi
		du -sh ${o_svg}
	fi
}

# $1: timeout in seconds
# $2: files to watch. Passed on to inotifywait --fromfile
function ove_inotifywait {
	local ret

	! [ -e ${2} ] && return 1
	[ $(wc -l < ${2}) -eq 0 ] && return 1

	sleep 0.01
	inotifywait \
		-t ${1} \
		-qq \
		--event modify \
		--event delete_self \
		--event create \
		--event delete \
		--fromfile ${2}
	ret=$?

	sleep 0.01
	[ ${ret} -eq 1 ] && return 1 || return 0
}

function ove_inotify_cleanup {
	find ${OVE_PROJECT_TMP_DIR}/ -name "inotifywait-*-${1}*" -exec rm {} \;
}

# $1  : timeout in sec
# $2  : use inotifywait (0 or 1)
# $3  : max count
# $4..: command
function ove_loop_command {
	local all_files
	local cmd
	local counter
	local f
	local files_modified_by_command
	local max_count
	local prefix
	local read_args
	local inotifywait_pid
	local timeout
	local use_inotify

	[ $# -lt 4 ] && return 1

	timeout=$1
	use_inotify=$2
	max_count=$3
	shift 3
	(( counter=0 ))
	while true; do
		(( counter+=1 ))
		[ ${max_count} -ne 0 ] && [ ${counter} -gt ${max_count} ] && break
		clear
		ove_echo_cyan_error "ove-${*} [c:${counter} t:${timeout} i:${use_inotify} m:${max_count}]"

		# inotify: first iteration?
		if [ ${use_inotify} -eq 1 ] && [ ${counter} -eq 1 ]; then
			all_files=$(mktemp -u -p ${OVE_PROJECT_TMP_DIR} inotifywait-fromfile-XXXXXXXXXX)

			# trap to be able to cleanup files
			# shellcheck disable=SC2064
			trap "ove_inotify_cleanup ${all_files: -10}" EXIT

			# start inotifywait in monitor mode in the background
			# monitor all files (for now)
			# shellcheck disable=SC2016
			cmd='for f in $(git -C ${git} ls-files); do [ -f ${f} ] && echo ${PWD}/${f}; done; echo ${PWD}/.git'
			ove_revtab_forall_parallel "${cmd}" > ${all_files}
			files_modified_by_command=${OVE_PROJECT_TMP_DIR}/inotifywait-${1}-${all_files: -10}

			if [ $(cat /proc/sys/fs/inotify/max_user_watches) -lt $(wc -l < ${all_files}) ]; then
				ove_echo_error_noprefix "you need to increase the number of inotify user watches. Try:"
				echo
				[ $(id -u) != 0 ] && prefix="sudo"
				echo "$ ${prefix} bash -c 'echo $(wc -l < ${all_files}) > /proc/sys/fs/inotify/max_user_watches'"
				read -r -p ""
				return 1
			fi

			inotifywait \
				-q \
				-m \
				--format '%w%f' \
				--fromfile ${all_files} > ${files_modified_by_command} &
			inotifywait_pid=${!}
			# let inotify start up
			sleep 1

			# still running?
			if ! kill -0 ${inotifywait_pid} > /dev/null 2>&1; then
				return 1
			fi
		fi

		# run the command
		OVE_PAGER='tee /dev/null' ove-${1} ${*:2}

		# inotify: first iteration?
		if [ ${use_inotify} -eq 1 ] && [ ${counter} -eq 1 ]; then
			sleep 1
			kill -9 ${inotifywait_pid} &> /dev/null
			wait &> /dev/null
			rm ${all_files}

			# remove doublets and only regular files
			for f in $(sort -u ${files_modified_by_command}); do
				[ -f ${f} ] && echo ${f};
			done > ${files_modified_by_command}.uniq
			rm ${files_modified_by_command}
			if [ $(wc -l < ${files_modified_by_command}.uniq) -eq 0 ]; then
				use_inotify=0
				ove_echo_cyan_error "0 files touched, not using inotifywait"
			else
				echo
				echo "$(wc -l < ${files_modified_by_command}.uniq) uniq file(s) was touched by '${1} ${*:2}'"
				echo "$ ove head-tail ${files_modified_by_command}.uniq"
				ove-head-tail ${files_modified_by_command}.uniq
			fi
		fi

		echo -
		if [ ${use_inotify} -eq 1 ]; then
			if ! ove_inotifywait ${timeout} ${files_modified_by_command}.uniq; then
				break
			fi
		else
			[ "${timeout}" -gt 0 ] && read_args="-t ${timeout}"
			# shellcheck disable=SC2229
			read -n 1 -s -r -p '' ${read_args}
			[[ ${REPLY} =~ ^[Qq]$ ]] && break
		fi
	done
}

# run:|TIMEOUT COMMAND:run one OVE command in terminal|tmux
function ove-run {
	local _cmd
	local cmd
	local read_args

	if [ $# -eq 1 ]; then
		ove-help "^${FUNCNAME/ove-/} "
		return 1
	fi

	if [ $# -eq 0 ]; then
		read -r -p "command timeout in sec (default 0 = no timeout): "
		[ "${REPLY}" == "" ] && timeout=0 || timeout=${REPLY}
		read -r -p "command: "
		[ "${REPLY}" == "" ] && return || cmd=${REPLY}
	else
		timeout=$1
		shift
		cmd=$*
	fi

	if ! [[ "${timeout}" =~ ^[0-9]+$ ]]; then
		echo "error: timeout: just numbers"
		return 1
	fi

	cmd=${cmd#ove }
	cmd=${cmd#ove-}
	_cmd=$(cut -d' ' -f1 <<<${cmd})
	if [ "$(type -t ove-"${_cmd}")" != "function" ]; then
		ove_echo_red_noprefix "error: '${_cmd}' unknown command"
		return 1
	fi

	# turn off monitor mode to get rid of "Done" messages
	set +m
	[ "${timeout}" -gt 0 ] && read_args="-t ${timeout}"

	if [ -n "${TMUX}" ]; then
		tmux split-window -h "\
			source ${OVE_BASE_DIR}/ove; \
			ove_init; \
			ove_echo_cyan_error \"ove-${cmd}\"; \
			OVE_PAGER='tee /dev/null' ove-${cmd}; \
			echo -; \
			read -n 1 -s -r -p '' ${read_args}"

		tmux select-layout main-vertical
		tmux select-pane -t 0
	else
		ove_echo_cyan_error "ove-${cmd}"
		OVE_PAGER='tee /dev/null' ove-${cmd}
		echo -
		# shellcheck disable=SC2229
		read -n 1 -s -r -p '' ${read_args}
	fi

	# turn on monitor mode
	set -m
}

# loop:|[TIMEOUT|x] [INOTIFY|x] [MAX-COUNT|x] COMMAND]:loop one OVE command
function ove-loop {
	local _cmd
	local cmd
	local max_count
	local timeout
	local use_inotify

	if [ $# -gt 0 ] && [ $# -lt 4 ]; then
		ove-help "^${FUNCNAME/ove-/} "
		return 1
	fi

	if [ $# -eq 0 ]; then
		read -r -p "command timeout in sec (default 0 = no timeout): "
		[ "${REPLY}" == "" ] && timeout=0 || timeout=${REPLY}
		read -r -p "inotify 0=no 1=yes (default 0): "
		[ "${REPLY}" == "" ] && use_inotify=0 || use_inotify=${REPLY}
		read -r -p "max count: (default 0 = forever): "
		[ "${REPLY}" == "" ] && max_count=0 || max_count=${REPLY}
		read -r -p "command: "
		[ "${REPLY}" == "" ] && return || cmd=${REPLY}
	else
		if [ "${1,}" == "x" ]; then
			read -r -p "command timeout in sec (0=no timeout): "
			[ "${REPLY}" == "" ] && timeout=0 || timeout=${REPLY}
		else
			timeout=$1
		fi

		if [ "${2,}" == "x" ]; then
			read -r -p "inotify 0=no 1=yes (default 0): "
			[ "${REPLY}" == "" ] && use_inotify=0 || use_inotify=${REPLY}
		else
			use_inotify=$2
		fi

		if [ "${3,}" == "x" ]; then
			read -r -p "max count: (default 0 = forever): "
			[ "${REPLY}" == "" ] && max_count=0 || max_count=${REPLY}
		else
			max_count=$3
		fi

		shift 3
		cmd=$*
	fi

	if ! [[ "${timeout}" =~ ^[0-9]+$ ]]; then
		echo "error: timeout: just numbers"
		return 1
	fi

	if ! [[ "${use_inotify}" =~ ^[0-1]$ ]]; then
		echo "error: inotify: 0 or 1"
		return 1
	fi

	if [ "${use_inotify}" -eq 1 ] && ! command -v inotifywait > /dev/null; then
		echo "duckduckgo.com/?q=inotifywait"
		return 1
	fi

	if ! [[ "${max_count}" =~ ^[0-9]+$ ]]; then
		echo "error: max count: just numbers"
		return 1
	fi

	cmd=${cmd#ove }
	cmd=${cmd#ove-}
	_cmd=$(cut -d' ' -f1 <<<${cmd})
	if [ "$(type -t ove-"${_cmd}")" != "function" ]; then
		ove_echo_red_noprefix "error: '${_cmd}' unknown command"
		return 1
	fi

	if [ -n "${TMUX}" ]; then
		tmux split-window -h "\
			source ${OVE_BASE_DIR}/ove; \
			ove_init; \
			ove_loop_command ${timeout} ${use_inotify} ${max_count} ${cmd}"

		tmux select-layout main-vertical
		tmux select-pane -t 0
	else
		ove_loop_command ${timeout} ${use_inotify} ${max_count} ${cmd}
	fi
}

function ove {
	local args
	local candidates
	local cmd
	local re
	local ret
	local script_help
	local script_opts
	local strace_expression

	cmd="$1"

	# keep this as early as possible
	if [ "${cmd}" == "cd" ] || [ "${cmd}" == "init" ]; then
		ove-${cmd} "${@:2}"
		return $?
	fi

	# sanity check
	if ! ove_get_base_dir > /dev/null; then
		return 1
	fi

	if [ "$(type -t ove_verify_checksums)" == "function" ] && ! ove_verify_checksums; then
		return 1
	fi

	if [ $# -eq 0 ]; then
		ove-fzf || ove-help
	elif [ "$(type -t ove-"${cmd}")" != "function" ]; then
		re=\\b${cmd}
		if ! [[ "${OVE_ALL_COMMANDS}" =~ ${re} ]]; then
			ove_echo_red_noprefix "error: '${cmd}' unknown command"
			return 1
		fi

		candidates=$(ove-help $(xargs -n1 <<<${OVE_ALL_COMMANDS} | \
			grep --color=never ^${cmd} | \
			sed -e 's/^/^/g' -e 's/$/\\s/g'))

		if [ ${OVE_AUTOCORRECT} -eq 1 ] && [ $(printf "${candidates}\n" | wc -l) -eq 1 ]; then
			cmd=$(printf "${candidates}\n" | \
				sed -e "s/\x1B\[[0-9;]*[mK]//g" | \
				awk '{print $1}')
			ove ${cmd} ${*:2}
			return $?
		fi

		ove_echo_red_noprefix "error: '${cmd}' unknown command"
		echo
		echo "Did you mean?"
		printf "${candidates}\n"

		return 1
	elif [ "${cmd}" == "!" ] || \
		[ "${cmd}" == "dry-run" ] || \
		[ "${cmd}" == "config" ] || \
		[ "${cmd}" == "loglevel" ] || \
		[ "${cmd}" == "checkout" ] || \
		[ "${cmd}" == "switch" ] || \
		[ "${cmd}" == "unsource" ]; then
		ove-${cmd} "${@:2}"
	else
		args="${*:2}"
		mkdir -p ${OVE_LOG_DIR}/${OVE_SHA}
		(cd ${OVE_LOG_DIR} && ln -sfn ${OVE_SHA} current)
		OVE_LAST_COMMAND="${OVE_LOG_DIR}/${OVE_SHA}/$(date '+%Y%m%d-%H%M%S%N')-ove-${cmd}-${HOSTNAME}-${OVE_PROJECT_NAME}.log"

		if [ -t 1 ]; then
			script_help=$(2>&1 script --help)
			if [[ "${script_help}" != *"invalid option"* ]]; then
				[[ "${script_help}" == *"-e"* ]] && script_opts+="-e "
				[[ "${script_help}" == *"-f"* ]] && script_opts+="-f "
			fi

			if [ ${OVE_LOGLEVEL} -gt 2 ] && [ ${OVE_LOGLEVEL} -lt 7 ]; then
				[ -e ${OVE_PROJECT_TMP_DIR}/strace-${cmd} ] && \
					rm -rf ${OVE_PROJECT_TMP_DIR}/strace-${cmd}
				mkdir -p ${OVE_PROJECT_TMP_DIR}/strace-${cmd}

				if [ ${OVE_LOGLEVEL} -eq 5 ]; then
					strace_expression="connect,bind,execve"
				elif [ ${OVE_LOGLEVEL} -eq 6 ]; then
					strace_expression="execve,clone,fork,vfork,connect,bind"
				else
					strace_expression="execve"
				fi

				OVE_ANALYZE_EXECVE="strace \
					-s 1024 \
					-q \
					-o ${OVE_PROJECT_TMP_DIR}/strace-${cmd}/strace-${cmd} \
					-ff \
					-T \
					-e ${strace_expression} \
					-ttt"
				export OVE_ANALYZE_EXECVE
			else
				unset OVE_ANALYZE_EXECVE
			fi

			if [ -n "${OVE_ANALYZE_EXECVE+x}" ]; then
				[ -e ${OVE_PROJECT_TMP_DIR}/strace.pid ] && \
					rm ${OVE_PROJECT_TMP_DIR}/strace.pid
				[ -e ${OVE_PROJECT_TMP_DIR}/strace.cont ] && \
					rm ${OVE_PROJECT_TMP_DIR}/strace.cont

				{
					while true; do [ -e ${OVE_PROJECT_TMP_DIR}/strace.pid ] && break; done

					# launch strace in background and let strace start up
					(${OVE_ANALYZE_EXECVE} -p $(cat ${OVE_PROJECT_TMP_DIR}/strace.pid) &)
					sleep 1
					true > ${OVE_PROJECT_TMP_DIR}/strace.cont
				} &
			fi

			# turn off monitor mode to get rid of "Done" messages
			set +m
			SHELL=$(command -v bash) \
				script ${script_opts} -q -c \
				"source ${OVE_BASE_DIR}/ove; ove_init quick && ove-${cmd} ${args}" \
				${OVE_LAST_COMMAND}
			ret=$?

			if [ -n "${OVE_ANALYZE_EXECVE+x}" ]; then
				pkill -SIGTERM -f strace
				[ -e ${OVE_PROJECT_TMP_DIR}/strace.pid ] && \
					rm ${OVE_PROJECT_TMP_DIR}/strace.pid
				[ -e ${OVE_PROJECT_TMP_DIR}/strace.cont ] && \
					rm ${OVE_PROJECT_TMP_DIR}/strace.cont

				while true; do
					if [ ${OVE_LOGLEVEL} -eq 3 ] || [ ${OVE_LOGLEVEL} -eq 4 ]; then
						ove_analyze_strace_execve_timing ${OVE_PROJECT_TMP_DIR}/strace-${cmd}
					elif [ ${OVE_LOGLEVEL} -eq 5 ]; then
						ove_analyze_strace_connect ${OVE_PROJECT_TMP_DIR}/strace-${cmd}
					elif [ ${OVE_LOGLEVEL} -eq 6 ]; then
						ove_strace_create_graph ${OVE_PROJECT_TMP_DIR}/strace-${cmd} ${cmd}
					fi
					break
				done | tee -a ${OVE_LAST_COMMAND}

				unset OVE_ANALYZE_EXECVE
			fi

			sed -i -e 's/\r$//' -e 's/\x0//' ${OVE_LAST_COMMAND}
			ln -s -f ${OVE_LAST_COMMAND} ${OVE_LOG_DIR}/last

			return ${ret}
		else
			{
				ove-"${cmd}" ${args}
			} 2>&1 | tee -i ${OVE_LAST_COMMAND}
			ret=${PIPESTATUS[0]}
			sed -i 's/\x0//g' ${OVE_LAST_COMMAND}
			ln -s -f ${OVE_LAST_COMMAND} ${OVE_LOG_DIR}/last
			return ${ret}
		fi
	fi
}

# fzf:[loop]:OVE fzf [duckduckgo.com/?q=fzf]
function ove-fzf {
	local args
	local cmd

	if ! command -v fzf > /dev/null; then
		return 1
	fi

	# sanity check
	if ! ove_get_base_dir > /dev/null; then
		return 1
	fi

	if [ $# -gt 1 ]; then
		ove-help "^${FUNCNAME/ove-/} "
		return 1
	fi

	while true; do
		# shellcheck disable=SC2016
		cmd=$(xargs -n 1 <<<${OVE_ALL_COMMANDS} | \
			grep -v '!' | \
			fzf \
			--cycle \
			--preview '${OVE_INIT_STRING}; ove-help ^{1}\\s' \
			--preview-window=down:1 \
		)
		[ "${cmd}" == "" ] && break

		if tr ' ' '\n' <<<"${OVE_BUILT_INS_WITHOUT_ARGS}" | grep -q ^${cmd}$; then
			if [ "$1" == "loop" ]; then
				echo "$ ove-loop ? ? ? ${cmd}"
				# shellcheck disable=SC2035
				ove-loop ? ? ? ${cmd}
				echo -
			else
				ove-run 0 ${cmd}
			fi
			continue
		fi

		COMP_WORDS=(ove ${cmd} ' ')
		COMP_LINE="ove ${cmd}"
		COMP_CWORD=3
		COMP_POINT=${#COMP_LINE}
		ove_bash_complete
		if [ ${#COMPREPLY[@]} -eq 0 ]; then
			if [ $1 == "loop" ]; then
				echo "$ ove-loop ? ? ? ${cmd}"
				# shellcheck disable=SC2035
				ove-loop ? ? ? ${cmd}
				echo -
			else
				ove-run 0 ${cmd}
			fi
		else
			args=$(printf '%s\n' "${COMPREPLY[@]}" | \
				sort -u | \
				fzf \
					--cycle \
					--preview "echo ESC\|CTRL+C to skip args $ ove ${cmd} {}" \
					--preview-window=down:1)

			if [ "$1" == "loop" ]; then
				echo "$ ove-loop ? ? ? ${cmd} ${args}"
				# shellcheck disable=SC2035
				ove-loop ? ? ? ${cmd} ${args}
				echo -
			else
				ove-run 0 ${cmd} ${args}
			fi
		fi
	done
}

function ove_projects_init {
	unset ove_projects_name
	unset ove_projects_deps
	unset ove_projects_path
	unset ove_projects_needs
	unset ove_projects_version
	unset ove_projects_name2index

	declare -a -g ove_projects_name
	declare -a -g ove_projects_deps
	declare -a -g ove_projects_path
	declare -a -g ove_projects_needs
	declare -a -g ove_projects_version
	declare -A -g ove_projects_name2index

	ove_number_of_projects=0
}

# not really a complete YAML parser
function ove_parse_yaml {
	local line

	while IFS=: read -r line; do
		[[ ${line} == "---" ]] && continue
		(sed -e 's/: /:/g' -e "s/\([a-z]\+\):/\" ove_${line%%:*}_\1=\"/g" -e "s/$/\"/g" -e "s/^\" //g" -e "s/ \"/\"/g" <<<${line#*: } & )
	done < <(sed -e 's/^\([a-z]\+:$\)/\n\1/g' -e 's/#.*//g' $1 | awk NF=NF RS= OFS=' ')
	wait
}

# uniq list of project commands
function ove_project_commands_list {
	local f
	local proj
	local search_dirs

	# for each project, look for executable files
	# ignore files with hyphens and underscore
	for proj in ${OVE_PROJECT_LIST} common; do
		# ignore projects without a project directory
		[ ! -d ${OVE_PROJECT_DIR}/projects/${proj} ] && continue

		search_dirs+="${proj} "
	done

	[ "${search_dirs}" == "" ] && return

	for f in $(cd ${OVE_PROJECT_DIR}/projects && find -L ${search_dirs} -perm -u=x -type f); do
		echo ${f#*/}
	done | \
		grep -v '[-_]' | \
		sort -u | \
		xargs
}

# uniq list of mandatory attributes
function ove_projects_attributes {
	if [ -f "${OVE_PROJECT_DIR}"/projs ]; then
		grep -E -o '  \w+:' "${OVE_PROJECT_DIR}"/projs | \
			cut -d: -f1 | \
			tr -d ' ' | \
			sort -u
	fi
}

# $1: dir (optional)
function ove_list_tags_and_branches {
	local d

	[ $# -eq 0 ] && d=${OVE_PROJECT_DIR} || d=$1
	! [ -d ${d} ] && return

	(
	git -C "${d}" tag
	git -C "${d}" branch --no-color --all --list | \
		grep -v HEAD | \
		tr -d '*' | \
		xargs | \
		tr ' ' '\n'
	) | sort -V
}

# $1: dir (optional)
function ove_list_branches {
	local d

	[ $# -eq 0 ] && d=${OVE_PROJECT_DIR} || d=$1
	! [ -d ${d} ] && return

	(
	git -C "${d}" branch --no-color --all --list | \
		grep -v HEAD | \
		tr -d '*' | \
		xargs | \
		tr ' ' '\n'
	) | sort -V
}

# iterate through projects
function ove_projects_parse {
	local i
	local m
	local projects
	local tmp_var

	ove_number_of_projects=0

	[ ! -e "${OVE_PROJECT_DIR}/projs" ] && return

	eval $(ove_parse_yaml "${OVE_PROJECT_DIR}/projs")

	# create ove-functions for all project commands
	for m in ${OVE_PROJECT_COMMANDS}; do
		eval "ove-${m}() {
			local count
			local helptext=\"${m}:[PROJECT...]:run the '${m}' step for all or individual projects\"
			local p

			if ! ove_build_pre \$*; then
				return 1
			fi

			# common .pre
			if [ -e \${OVE_PROJECT_DIR}/projects/common/${m}.pre ]; then
				source \${OVE_PROJECT_DIR}/projects/common/${m}.pre
			fi

			if [ \$# -eq 0 ]; then
				count=0
				while ((count < ove_number_of_projects)); do
					if ! ove_projects_cmd "\${ove_projects_name[\${count}]}" ${m}; then
						return 1
					fi
					(( count+=1 ))
				done
			else
				for p in \$@; do
					if ! ove_projects_cmd \${p} ${m}; then
						return 1
					fi
				done
			fi

			# common .post
			if [ -e \${OVE_PROJECT_DIR}/projects/common/${m}.post ]; then
				source \${OVE_PROJECT_DIR}/projects/common/${m}.post
			fi
		}"
	done

	# create parallel ove-functions for all project commands
	for m in ${OVE_PROJECT_COMMANDS}; do
		eval "ove-${m}-parallel() {
			local count
			local helptext=\"${m}-parallel:[PROJECT...]:run the '${m}' step for all or individual projects (in parallel)\"
			local p

			if ! ove_build_pre \$*; then
				return 1
			fi

			# common .pre
			if [ -e \${OVE_PROJECT_DIR}/projects/common/${m}.pre ]; then
				source \${OVE_PROJECT_DIR}/projects/common/${m}.pre
			fi

			if [ \$# -eq 0 ]; then
				count=0
				while ((count < ove_number_of_projects)); do
					{
						if ! ove_projects_cmd "\${ove_projects_name[\${count}]}" ${m}; then
							kill -USR1 \$\$
						fi
					} &
					(( count+=1 ))
				done
			else
				for p in \$@; do
					{
						if ! ove_projects_cmd \${p} ${m}; then
							kill -USR1 \$\$
						fi
					} &
				done
			fi

			wait

			# common .post
			if [ -e \${OVE_PROJECT_DIR}/projects/common/${m}.post ]; then
				source \${OVE_PROJECT_DIR}/projects/common/${m}.post
			fi
		}"
	done

	read -a projects -r <<<"${OVE_PROJECT_LIST}"
	ove_number_of_projects=${#projects[@]}

	# set projects deps|name|path|needs|version
	i=0
	while ((i < ove_number_of_projects)); do
		# name
		ove_projects_name[${i}]=${projects[${i}]}
		unset ove_${projects[${i}]}

		# index
		ove_projects_name2index[${projects[${i}]}]=${i}

		# deps
		tmp_var="ove_${projects[${i}]}_deps"
		ove_projects_deps[${i}]=${!tmp_var}
		unset ${tmp_var}

		# path
		tmp_var="ove_${projects[${i}]}_path"
		ove_projects_path[${i}]=${!tmp_var}
		unset ${tmp_var}

		# needs
		tmp_var="ove_${projects[${i}]}_needs"
		ove_projects_needs[${i}]=${!tmp_var}
		unset ${tmp_var}

		# version
		tmp_var="ove_${projects[${i}]}_version"
		ove_projects_version[${i}]=${!tmp_var}
		unset ${tmp_var}

		(( i+=1 ))
	done

	if ! ove_validate_projs; then
		return 1
	fi

	if [ $(ove_repos_fetched) -eq $(wc -w <<<${OVE_REPO_LIST}) ]; then
		unset OVE_PROJECT_LIST_BUILDABLE
	else
		ove_buildable_projects
	fi

	OVE_BUILD_ORDER="$(ove-build-order)"
}

function ove_list_projects_without_deps {
	local i

	i=0
	while ((i < ove_number_of_projects)); do
		if [ "${ove_projects_deps[${i}]}" == "" ]; then
			echo -n "${ove_projects_name[${i}]} "
		fi
		(( i+=1 ))
	done
}

function ove_list_projects_with_deps {
	local i

	i=0
	while ((i < ove_number_of_projects)); do
		if [ "${ove_projects_deps[${i}]}" != "" ]; then
			echo -n "${ove_projects_name[${i}]} "
		fi
		(( i+=1 ))
	done
}

function ove_list_projects_paths {
	local i
	local s

	i=0
	while ((i < ove_number_of_projects)); do
		s+="${OVE_BASE_DIR}/${ove_projects_path[${i}]} "
		(( i+=1 ))
	done

	echo -n "${s}"
}

# $1: target
# $2: command
function ove_projects_cmd {
	local cmd
	local index
	local path
	local re
	local ret
	local target

	target=$1
	cmd=$2
	ret=0

	# sanity check
	! [ -e "${OVE_PROJECT_DIR}/projects/${target}/${cmd}" ] && return

	index=${ove_projects_name2index[${target}]}

	# create dir if needed
	[ ! -d "${OVE_BASE_DIR}"/"${ove_projects_path[${index}]}" ] \
		&& mkdir -vp "${OVE_BASE_DIR}"/"${ove_projects_path[${index}]}"

	path="${OVE_BASE_DIR}/${ove_projects_path[${index}]}"

	if [ ${OVE_LOGLEVEL} -ne 0 ]; then
		ove_echo_cyan_error "${target}: ${cmd}"
	fi

	if [ "${OVE_DRY_RUN}" -eq 0 ]; then
		pushd "${path}" &>/dev/null
	fi

	if [[ ${FUNCNAME[*]} == *-parallel ]] && [ -n "${OVE_FORCE_SERIALIZE_COMMANDS}" ]; then
		re=\\b${cmd}\\b
		if [[ "${OVE_FORCE_SERIALIZE_COMMANDS}" =~ ${re} ]]; then
			exec {fd}>${OVE_PROJECT_TMP_DIR}/${cmd}.lock
			flock ${fd}
		fi
	fi

	# common for this command?
	if [ -e "${OVE_PROJECT_DIR}/projects/common/${cmd}" ]; then
		# shellcheck disable=SC1090
		source "${OVE_PROJECT_DIR}/projects/common/${cmd}"
		# preserve return code
		ret="$?"
	fi

	if [ ${ret} -eq 0 ]; then
		# "$1"/$2 is no longer needed
		shift 2

		if [ ${OVE_DRY_RUN} -eq 0 ]; then
			# run it
			eval "${target}_version=${ove_projects_version[${index}]} \
				${OVE_PROJECT_DIR}/projects/${target}/${cmd} \
				${OVE_REDIRECT_OUTPUT}"
		else
			# dry: print the command
			ove_echo_stderr_noprefix "cd ${path} && ${OVE_PROJECT_DIR}/projects/${target}/${cmd}"
		fi

		# preserve return code
		ret="$?"
	fi

	# exit directory
	[ "${OVE_DRY_RUN}" -eq 0 ] && popd &>/dev/null

	if [ "${ret}" -ne 0 ]; then
		ove_echo_error "${target}: ${cmd}"
	else
		if [ ${OVE_LOGLEVEL} -ne 0 ]; then
			ove_echo_cyan_error "${target}: ${cmd}: done"
		fi
	fi

	return "${ret}"
}

function ove_revtab_init {
	unset ove_revtab_fetch_url
	unset ove_revtab_push_url
	unset ove_revtab_rev
	unset ove_revtab_git_name

	declare -a -g ove_revtab_fetch_url
	declare -a -g ove_revtab_push_url
	declare -a -g ove_revtab_rev
	declare -a -g ove_revtab_git_name
	declare -A -g ove_revtab_name2index

	ove_revtab_num_repositories=0
}

function ove_revtab_parse {
	local array
	local line
	local lineno=0

	[ ! -e "${OVE_PROJECT_DIR}/revtab" ] && return

	ove_revtab_num_repositories=0

	while read -r line; do
		(( lineno+=1 ))
		# skip comments and blank lines
		[ "${line:0:1}" == "#" ] && continue
		[ "${line}" == "" ] && continue

		read -a array -r <<<"${line}"

		if [ "${array[1]}" == "" ] || [ "${array[2]}" == "" ] || [ "${array[3]}" == "" ]; then
			ove_echo_warning_noprefix "${OVE_PROJECT_DIR}/revtab:${lineno} format error"
			continue
		fi

		ove_revtab_git_name[${ove_revtab_num_repositories}]=${array[0]}
		ove_revtab_fetch_url[${ove_revtab_num_repositories}]=${array[1]}
		ove_revtab_push_url[${ove_revtab_num_repositories}]=${array[2]}
		ove_revtab_rev[${ove_revtab_num_repositories}]=${array[3]}
		ove_revtab_name2index[${array[0]}]=${ove_revtab_num_repositories}

		(( ove_revtab_num_repositories+=1 ))
	done < "${OVE_PROJECT_DIR}/revtab"

	if ! ove_validate_revtab; then
		return 1
	fi

	OVE_REPO_LIST=$(ove_revtab_list_fullpath)
}

# $1: repo name (either 'name' or '${OVE_BASE_DIR}/'name')
function ove_git2fullpath {
	local git_fullpath
	local index
	local name

	name=${1/${OVE_BASE_DIR}\/}
	if [ "${name}" == "${OVE_PROJECT_NAME}" ]; then
		git_fullpath="${OVE_BASE_DIR}/${OVE_PROJECT_NAME}"
	elif [ -v ove_revtab_name2index[${name}] ]; then
		index=${ove_revtab_name2index[${name}]}
		git_fullpath="${OVE_BASE_DIR}/${ove_revtab_git_name[${index}]}"
	fi

	echo ${git_fullpath}
}

# $1: repo name (either 'name' or '${OVE_BASE_DIR}/'name')
function ove_git2shortpath {
	local git_shortpath
	local index
	local name

	[ $# -ne 1 ] && return 1

	name=${1/${OVE_BASE_DIR}\/}
	if [ "${name}" == "${OVE_PROJECT_NAME}" ]; then
		git_shortpath="${OVE_PROJECT_NAME}"
	elif [ -v ove_revtab_name2index[${name}] ]; then
		index=${ove_revtab_name2index[${name}]}
		git_shortpath="${ove_revtab_git_name[${index}]}"
	fi

	echo ${git_shortpath}
}

# $1: git
function ove_status_one_repo {
	local git_fullpath
	local git_shortpath
	local index
	local rev
	local s

	[ $# -ne 1 ] && return 1

	git_fullpath=$(ove_git2fullpath $1)
	if [ "${git_fullpath}" == "" ] || ! [ -d "${git_fullpath}" ]; then
		return
	fi

	git_shortpath="$(ove_git2shortpath $1)"
	index=${ove_revtab_name2index[${git_shortpath}]}

	if [ "${git_shortpath}" == "${OVE_PROJECT_NAME}" ]; then
		rev="$(git -C "${OVE_PROJECT_DIR}" describe --tags --always 2> /dev/null)"
		[ -n "${rev}" ] || rev=" "
	else
		rev="${ove_revtab_rev[${index}]}"
	fi

	s=$(git -c color.status=always -C "${git_fullpath}" status -bs -uno)
	s=${s//$'\n'/ }
	printf "${git_shortpath}:${rev}:$s\n"
}

function ove_validate_repo_list {
	local repos

	while true; do
		[ $# -eq 0 ] && break
		if [ "$1" == "${OVE_PROJECT_NAME}" ] || [ -v ove_revtab_name2index[${1}] ]; then
			repos+="$(ove_git2shortpath $1)\n"
		fi
		shift
	done

	echo -e "${repos}" | sort -u | xargs -n1
}

function ove_revtab_status {
	local f
	local git
	local repos
	local o

	if [ $# -ge 1 ]; then
		repos=$(ove_validate_repo_list "$@")
	else
		repos=${OVE_REPO_LIST}
	fi

	[ "${repos}" == "" ] && return

	if [ -w "${OVE_PROJECT_STATE_DIR}" ]; then
		f="${OVE_PROJECT_STATE_DIR}"
	else
		f="${OVE_TMP}"
	fi
	o=${f}

	f+="/$(date '+%Y%m%d-%H%M%S%N')-revtab-status"

	for git in ${repos}; do
		ove_status_one_repo ${git} >> ${f} &
	done

	wait

	LC_ALL="C" sort -o ${f} ${f}
	if [ "${OVE_COLUMN_WRAP_BUG}" -eq 1 ]; then
		column -t -s: <<<$(fold -w 2048 -s ${f})
	else
		column -t -s: <${f}
	fi

	mv "${f}" "${o}/revtab-status"
}

# $1: ahead|behind
function ove_revtab_status_parse_one {
	local git_args
	local git_fmt
	local git_fullpath
	local git_status
	local i
	local nbr_commits
	local tense

	tense=$1
	shift

	git_fmt='%<(15,trunc)%h?%<(15,trunc)%ar?%<(40,mtrunc)%ae?%s'
	git_fullpath=$(ove_git2fullpath $1)

	if [ "${git_fullpath}" == "" ] || ! [ -d "${git_fullpath}" ]; then
		return
	fi

	git_status=$(git -C "${git_fullpath}" status -zbs -uno | tr '\0' ' ')
	nbr_commits=0

	# keep 'ahead X, behind Y'
	git_status=${git_status##*[}
	git_status=${git_status%%]*}

	if [[ "${git_status}" == *"${tense}"* ]]; then
		if [ "${tense}" == "ahead" ]; then
			git_status=${git_status%%,*}
			nbr_commits=${git_status##${tense} }
		elif [ "${tense}" == "behind" ]; then
			nbr_commits=${git_status##*${tense} }
			git_args="FETCH_HEAD"
		else
			return 1
		fi

		ove_echo_yellow_noprefix "$(ove_git2shortpath $1): ${nbr_commits} new commit(s):"
		git --no-pager -C "${git_fullpath}" log ${git_args} -n ${nbr_commits} --format="${git_fmt}" | \
			column -t -s?
		echo
	fi
}

# $1: ahead|behind
function ove_revtab_status_parse {
	local git
	local repos
	local tense

	[ $# -eq 0 ] && return 1

	tense="$1"
	shift

	# refresh status
	ove-status > /dev/null

	# turn off monitor mode to get rid of "Done" messages
	set +m

	if [ $# -ge 1 ]; then
		repos=$(ove_validate_repo_list "$@")
	elif [ -e ${OVE_PROJECT_STATE_DIR}/revtab-status ] && grep -q "\[.*${tense}.*\]" ${OVE_PROJECT_STATE_DIR}/revtab-status; then
		repos=$(grep "\[.*${tense}.*\]" ${OVE_PROJECT_STATE_DIR}/revtab-status | \
			cut -d: -f1 | \
			xargs)
	else
		repos=${OVE_REPO_LIST}
	fi

	for git in ${repos}; do
		ove_revtab_status_parse_one ${tense} ${git}
	done | head -n -1

	# turn on monitor mode
	set -m
}

function ove_revtab_list {
	local count
	local str
	local url

	count=0

	if [ "${ove_revtab_num_repositories}" == 0 ]; then
		echo "run 'ove fetch' first!"
		return 1
	fi

	while ((count < ove_revtab_num_repositories)); do
		str+="${ove_revtab_git_name[${count}]} ${ove_revtab_fetch_url[${count}]} ${ove_revtab_push_url[${count}]} ${ove_revtab_rev[${count}]}\n"
		(( count+=1 ))
	done

	url=$(git -C "${OVE_PROJECT_DIR}" config --get remote.origin.url)
	if [ "${url}" != "" ]; then
		str+="${OVE_PROJECT_NAME} ${url} ${url} $(git -C "${OVE_PROJECT_DIR}" rev-parse --abbrev-ref HEAD 2> /dev/null)\n"
	else
		str+="${OVE_PROJECT_NAME} noremote noremote $(git -C "${OVE_PROJECT_DIR}" rev-parse --abbrev-ref HEAD 2> /dev/null)\n"
	fi

	printf "${str}" | \
		LC_ALL="C" sort | \
		column -t
}

function ove_repos_fetched {
	local f=0
	local git

	for git in ${OVE_REPO_LIST}; do
		[ -d ${git} ] && (( f+=1 ))
	done

	echo ${f}
}

function ove_verify_checksums {
	local md5
	local reinit=0

	if [ -e "${OVE_PROJECT_DIR}/revtab" ]; then
		md5=$(md5sum ${OVE_PROJECT_DIR}/revtab)
		md5=${md5% *}
		# got updated?
		if [ -n "${OVE_REVTAB_MD5+x}" ] && [ "${md5}" != "${OVE_REVTAB_MD5}" ]; then
			(( reinit+=1 ))
		# just created?
		elif [ -z "${OVE_REVTAB_MD5+x}" ]; then
			(( reinit+=1 ))
		fi
	elif [ -n "${OVE_REVTAB_MD5+x}" ]; then
		# got removed?
		unset OVE_REVTAB_MD5
		(( reinit+=1 ))
	fi

	if [ -e "${OVE_PROJECT_DIR}/projs" ]; then
		md5=$(md5sum ${OVE_PROJECT_DIR}/projs)
		md5=${md5% *}
		# got updated?
		if [ -n "${OVE_PROJS_MD5+x}" ] && [ "${md5}" != "${OVE_PROJS_MD5}" ]; then
			(( reinit+=1 ))
		# just created?
		elif [ -z "${OVE_PROJS_MD5+x}" ]; then
			(( reinit+=1 ))
		fi
	elif [ -n "${OVE_PROJS_MD5+x}" ]; then
		# got removed?
		unset OVE_PROJS_MD5
		(( reinit+=1 ))
	fi

	md5=$(ove_dir_fingerprint $(ove_list_scripts_directories))
	# got updated?
	if [ -n "${OVE_SCRIPTS_MD5+x}" ] && [ "${md5}" != "${OVE_SCRIPTS_MD5}" ]; then
		(( reinit+=1 ))
	fi

	if [ "${OVE_REPOS_FETCHED}" != "" ] && [ $(ove_repos_fetched) -ne ${OVE_REPOS_FETCHED} ]; then
		(( reinit+=1 ))
	fi

	# OVE_BASE_DIR got lost?
	if [ -z "${OVE_BASE_DIR+x}" ]; then
		(( reinit+=1 ))
	fi

	if [ ${reinit} -gt 0 ]; then
		if ! ove_reinit; then
			return 1
		fi
	fi

	return 0
}

function ove_update_checksum {
	local md5

	if [ -e "${OVE_PROJECT_DIR}/revtab" ]; then
		md5=$(md5sum ${OVE_PROJECT_DIR}/revtab)
		md5=${md5% *}
		OVE_REVTAB_MD5=${md5}
		export OVE_REVTAB_MD5
	fi

	if [ -e "${OVE_PROJECT_DIR}/projs" ]; then
		md5=$(md5sum ${OVE_PROJECT_DIR}/projs)
		md5=${md5% *}
		OVE_PROJS_MD5=${md5}
		export OVE_PROJS_MD5
	fi

	OVE_SCRIPTS_MD5=$(ove_dir_fingerprint $(xargs -n1 <<<${ove_scripts_name2path[*]} | sort -u))
	export OVE_SCRIPTS_MD5

	OVE_REPOS_FETCHED=$(ove_repos_fetched)
	export OVE_REPOS_FETCHED
}

# $1: name
# $2: rev
function ove_revtab_check_one {
	local branch_name
	local co=0
	local detached=0
	local m
	local name
	local re
	local rev
	local rev_is_branch=0
	local sha_a
	local sha_b

	name=$1
	rev=$2

	if [ -d "${OVE_BASE_DIR}/${name}/.git" ]; then
		sha_a=$(git -C ${OVE_BASE_DIR}/${name} rev-list -n 1 --abbrev-commit HEAD --)
		sha_b=$(git -C ${OVE_BASE_DIR}/${name} rev-list -n 1 --abbrev-commit ${rev} --)
		[ $? -ne 0 ] &&  b=""

		if [ "${sha_a}" != "${sha_b}" ]; then
			# diff => checkout
			co=1
		else
			re=\\b${rev}\\b
			git -C "${OVE_BASE_DIR}/${name}" symbolic-ref -q HEAD > /dev/null || detached=1
			[[ "$(ove_list_branches ${OVE_BASE_DIR}/${name} | xargs)" =~ ${re} ]] && rev_is_branch=1

			# detached and rev is a branch => checkout
			if [ ${detached} -eq 1 ] && [ ${rev_is_branch} -eq 1 ]; then
				co=1
			# not detached and rev is not a branch => checkout
			elif [ ${detached} -eq 0 ] && [ ${rev_is_branch} -eq 0 ]; then
				co=1
			# switched branch?
			elif [ ${detached} -eq 0 ] && [ ${rev_is_branch} -eq 1 ]; then
				branch_name=$(git -C ${OVE_BASE_DIR}/${name} rev-parse --abbrev-ref HEAD)
				if [ "${branch_name}" != "${rev}" ]; then
					co=1
				fi
			fi
		fi

		if [ ${co} -eq 1 ]; then
			if test -z "$(git -C ${OVE_BASE_DIR}/${name} --no-pager status --porcelain -uno)"; then
				m=$(xargs -n1 <<<${OVE_REPO_LIST//${OVE_BASE_DIR}\/} | wc -L)
				ove_revtab_checkout ${name} |& sed -e "1s|^|$(ove_echo_yellow_noprefix ${name})$(printf "%0.s " $(eval echo {1..$((${m} + 2 - ${#name}))}))|g" \
					-e "2,10s|^|$(printf "%0.s " $(eval echo {1..$((${m} + 2))}))|g"
				ove_patch_repositories
			else
				ove_echo_yellow_noprefix "${name}: cannot checkout '${rev}' as repo is dirty:"
			fi
		fi
	fi
}

function ove_revtab_check {
	local count

	[ "${ove_revtab_num_repositories}" == 0 ] && return 1

	set +m

	count=0
	while ((count < ove_revtab_num_repositories)); do
		ove_revtab_check_one ${ove_revtab_git_name[${count}]} ${ove_revtab_rev[${count}]} &
		(( count+=1 ))
	done | grep -v '^\['
	wait
}

function ove_revtab_list_fullpath {
	local git
	local s

	for git in "${ove_revtab_git_name[@]}"; do
		s+="${OVE_BASE_DIR}/${git} "
	done
	s+="${OVE_PROJECT_DIR}"

	echo ${s}
}

function ove_revtab_list_basename {
	local git
	local s

	for git in "${ove_revtab_git_name[@]}" ${OVE_PROJECT_NAME}; do
		s+="${git} "
	done

	echo ${s}
}

function ove_revtab_forall {
	local git
	local git_basename

	for git in ${OVE_REPO_LIST}; do
		! [ -d "${git}" ] && continue
		git_basename=${git/${OVE_BASE_DIR}\/}
		eval "pushd ${git} &>/dev/null && $1; popd&>/dev/null"
	done
}

function ove_revtab_forall_parallel {
	(
	local git
	local git_basename
	local job_list
	local max_parallel=0

	[ $# -eq 2 ] && max_parallel=$2

	for git in ${OVE_REPO_LIST}; do
		! [ -d "${git}" ] && continue
		git_basename=${git/${OVE_BASE_DIR}\/}
		pushd "${git}" &>/dev/null && eval "$1" &

		[ ${max_parallel} -eq 0 ] && continue
		mapfile -t job_list < <(jobs -p -r)
		[ "${#job_list[@]}" -eq "${max_parallel}" ] && wait -n
	done
	wait
	)
}

function ove_revtab_forsome {
	local git
	local git_basename
	local i

	for i in ${*:2}; do
		for git in ${OVE_REPO_LIST}; do
			! [ -d "${git}" ] && continue
			if [ "${git}" == "${OVE_BASE_DIR}/${i}" ]; then
				git_basename=${git/${OVE_BASE_DIR}\/}
				eval "pushd ${git} &>/dev/null && $1; popd&>/dev/null"
			fi
		done
	done
}

function ove_revtab_forsome_parallel {
	(
	local git
	local i

	for i in ${*:2}; do
		for git in ${OVE_REPO_LIST}; do
			! [ -d "${git}" ] && continue
			if [ "${git}" == "${OVE_BASE_DIR}/${i}" ]; then
				eval "pushd ${git} &>/dev/null; $1; popd&>/dev/null" &
			fi
		done
	done
	wait
	)
}

# $*: optional list of repositories
function ove_revtab_clone_and_checkout {
	(
	local count
	local index
	local repo
	local repos

	if [ $# -gt 0 ]; then
		repos=$(ove_validate_repo_list "$@")
		[ "${repos}" == "" ] && return 1
		for repo in ${repos}; do
			index=${ove_revtab_name2index[${1}]}
			if [ ! -d "${OVE_BASE_DIR}/${repo}" ]; then
				git clone "${ove_revtab_fetch_url[${index}]}" "${OVE_BASE_DIR}/${ove_revtab_git_name[${index}]}" && ove_revtab_checkout ${1} &
			fi
			shift
		done
	else
		count=0
		while ((count < ove_revtab_num_repositories)); do
			if [ ! -d "${OVE_BASE_DIR}/${ove_revtab_git_name[${count}]}" ]; then
				git clone "${ove_revtab_fetch_url[${count}]}" "${OVE_BASE_DIR}/${ove_revtab_git_name[${count}]}" && ove_revtab_checkout ${ove_revtab_git_name[${count}]} &
			fi
			(( count+=1 ))
		done
	fi

	wait
	)
}

# $*: optional list of repositories
function ove_revtab_checkout {
	(
	local count
	local index
	local repo
	local repos

	if [ $# -gt 0 ]; then
		repos=$(ove_validate_repo_list "$@")
		[ "${repos}" == "" ] && return 1
		for repo in ${repos}; do
			index=${ove_revtab_name2index[${1}]}
			git -C "${OVE_BASE_DIR}/${ove_revtab_git_name[${index}]}" -c advice.detachedHead=false checkout "${ove_revtab_rev[${index}]}" &
			shift
		done
	else
		count=0
		while ((count < ove_revtab_num_repositories)); do
			git -C "${OVE_BASE_DIR}/${ove_revtab_git_name[${count}]}" -c advice.detachedHead=false checkout "${ove_revtab_rev[${count}]}" &
			(( count+=1 ))
		done
	fi

	wait
	)
}

function ove_revtab_pull_one {
	local base
	local cmd
	local git
	local git_fullpath
	local loc
	local remote
	local upstream

	git="$1"
	upstream="@{u}"

	git_fullpath=$(ove_git2fullpath $1)
	if [ "${git_fullpath}" == "" ] || ! [ -d "${git_fullpath}" ]; then
		return
	fi

	# check if detached
	if ! git -C "${git_fullpath}" rev-parse -q "${upstream}" &> /dev/null; then
		return
	fi

	loc=$(git -C "${git_fullpath}" rev-parse @)
	remote=$(git -C "${git_fullpath}" rev-parse "${upstream}")
	base=$(git -C "${git_fullpath}" merge-base @ "${upstream}")

	if [ "${loc}" = "${remote}" ]; then
		# up-to-date
		:
	elif [ "${remote}" = "${base}" ]; then
		# need to push
		:
	else
		ove_echo_yellow_noprefix "${git}"
		cmd="git -C ${git_fullpath} pull --rebase"
		if ! ${cmd}; then
			ove_echo_error_noprefix "${cmd}"
		fi
	fi
}

# $*: optional list of repositories
function ove_revtab_fetch {
	local co_list
	local count
	local m

	if ! ove_revtab_parse; then
		return 1
	fi

	if [ $# -ge 1 ]; then
		ove_revtab_clone_and_checkout "$@"
		m=$(xargs -n1 <<<"$@" | wc -L)
		ove_revtab_forsome_parallel "git -C \${git} fetch --all --tag | sed -e \"s|^|\${i}\$(printf \"%0.s \" \$(eval echo {1..\$((${m} + 2 - \${#i}))}))|g\"" "$@"
		return $?
	fi

	count=0
	while ((count < ove_revtab_num_repositories)); do
		if [ ! -d "${OVE_BASE_DIR}/${ove_revtab_git_name[${count}]}" ]; then
			co_list+="${ove_revtab_git_name[${count}]} "
		fi
		(( count+=1 ))
	done

	[ "${co_list}" != "" ] && ove_revtab_clone_and_checkout ${co_list}

	m=$(xargs -n1 <<<${OVE_REPO_LIST//${OVE_BASE_DIR}\/} | wc -L)
	ove_revtab_forall_parallel "git -C \${git} fetch --all --tags | sed -e \"s|^|\${git_basename}\$(printf \"%0.s \" \$(eval echo {1..\$((${m} + 2 - \${#git_basename}))}))|g\"" ${OVE_FETCH_MAX_PARALLEL}
	return $?
}

# $1: dir
function ove_is_base_dir {
	if [[ -L ${1}/ove && -L ${1}/.owel ]]; then
		return 0
	else
		return 1
	fi
}

function ove_get_base_dir {
	local s

	pushd . &> /dev/null
	s=$(pwd -P)
	while [ "${s}" != "" ]; do
		if ove_is_base_dir "${s}"; then
			echo "${s}"
			break
		fi
		s=${s%/*}
	done

	popd > /dev/null

	# base directory found?
	if [ "${s}" == "" ]; then
		ove_echo_error_noprefix "not in an OVE workspace. Try 'ove cd'"
		return 1

	# First time? Do nothing
	elif [ -z "${OVE_BASE_DIR+x}" ]; then
		:

	# Have we moved to another OVE workspace? source that project
	elif [ "${s}" != "${OVE_BASE_DIR}" ] && [[ $- == *i* ]]; then
		cd ${s} && . ove > /dev/null && cd -
	fi
}
export -f ove_get_base_dir

function ove_list_projects {
	if [ -f "${OVE_PROJECT_DIR}"/projs ]; then
		grep -o '^[a-zA-Z0-9_]\+' ${OVE_PROJECT_DIR}/projs | \
			sort | \
			xargs "${OVE_ECHO}"
	fi
}
export -f ove_list_projects

# $*: dir...
function ove_dir_md5sum_parallel {
	local f

	[ $# -eq 0 ] && return 1

	while [ $# -ne 0 ]; do
		! [ -d ${1} ] && shift && continue
		while read -r line; do
			md5sum ${line} &
		done < <(find ${1} -type f)
		shift
	done
	wait
}

# $*: dir...
function ove_dir_fingerprint {
	[ $# -eq 0 ] && return 1

	if [ -n "${OVE_DRY_RUN+x}" ] && [ "${OVE_DRY_RUN}" -eq 1 ]; then
		echo
		return
	fi

	ove_dir_md5sum_parallel "${@}" | \
		sort -k 2 | \
		md5sum | \
		cut -d' ' -f1
}

# make:[PROJECT[-nodeps]]:build project(s)
function ove-make {
	local fingerprint_a
	local fingerprint_b
	local index
	local proj
	local stage_dir_updated_by
	local target
	local withdeps

	target="$*"
	withdeps="true"

	[ $# -eq 0 ] && target="all"

	if [[ ${target} == *-nodeps ]]; then
		withdeps="false"
		target=${target%-nodeps}
	fi

	# build all?
	if [ "${target}" == "all" ]; then
		if ! ove_build_pre; then
			return 1
		fi

		for proj in ${OVE_BUILD_ORDER}; do
			index=${ove_projects_name2index[${proj}]}

			# does proj have any dependencies?
			if [ "${ove_projects_deps[${index}]}" != "" ]; then
				# check if some of the deps has modified the stage dir
				for dep in ${ove_projects_deps[${index}]}; do
					if [[ "${stage_dir_updated_by}" == *"${dep}"* ]]; then
						ove_projects_cmd "${proj}" clean
						break
					fi
				done
			fi

			fingerprint_a=$(ove_dir_fingerprint ${OVE_STAGE_DIR})
			ove_projects_cmd "${proj}" build
			ove_projects_cmd "${proj}" install
			fingerprint_b=$(ove_dir_fingerprint ${OVE_STAGE_DIR})

			# remember if project modified the stage dir
			if [ "${fingerprint_a}" != "${fingerprint_b}" ]; then
				stage_dir_updated_by+="${proj} "
			fi
		done
	else
		if ! ove_build_pre ${target}; then
			return 1
		fi

		if [ "${withdeps}" == "false" ]; then
			ove_projects_cmd "${target}" build
		else
			if [[ "$(caller 0)" != *"ove-make"* ]]; then
				# keep track of projects built
				_ove_projects_built=""
			fi

			index=${ove_projects_name2index[${target}]}
			[ "${index}" == "" ] && echo "${FUNCNAME[0]}: unknown target '${target}'" && return 1

			# has deps?
			if [ "${ove_projects_deps[${index}]}" != "" ]; then
				fingerprint_a=$(ove_dir_fingerprint ${OVE_STAGE_DIR})

				for dep in ${ove_projects_deps[${index}]}; do
					# already built? next!
					if [[ "${_ove_projects_built}" == *"${dep}"* ]]; then
						continue
					fi

					if ! ove-make "${dep}"; then
						return 1
					fi
				done

				fingerprint_b=$(ove_dir_fingerprint ${OVE_STAGE_DIR})

				# clean the project if OVE_STAGE_DIR was updated
				if [ "${fingerprint_a}" != "${fingerprint_b}" ]; then
					ove_projects_cmd "${target}" clean
				fi
			fi

			if ! ove_projects_cmd "${target}" build; then
				return 1
			fi

			if ! ove_projects_cmd "${target}" install; then
				return 1
			fi

			# remember projects built
			_ove_projects_built+="${target} "

			# cleanup
			if [[ "$(caller 0)" != *"ove-make"* ]]; then
				unset _ove_projects_built
			fi
		fi
	fi
}

# list-projects:[verbose]:list projects
function ove-list-projects {
	local f_basename
	local f
	local p
	local projects

	if [ "$1" == 'verbose' ]; then
		projects=${OVE_PROJECT_LIST}
		for p in ${projects}; do
			# ignore projects without a project directory
			[ ! -d "${OVE_PROJECT_DIR}"/projects/${p} ] && continue

			ove_echo_cyan_noprefix "${p}"
			for f in bootstrap configure build install clean; do
				[ -x ${OVE_PROJECT_DIR}/projects/${p}/${f} ] || continue
				echo -e "\t${f}"
				sed -e 's|^|\t\t|g' <${OVE_PROJECT_DIR}/projects/${p}/${f}
			done

			while read -r line; do
				f_basename=${line##*/}
				[[ "bootstrap configure build install clean" =~ ${f_basename} ]] && continue
				echo -e "\t${f_basename}"
				sed -e 's|^|\t\t|g' <${OVE_PROJECT_DIR}/projects/${p}/${f_basename}
			done < <(find "${OVE_PROJECT_DIR}"/projects/${p} -perm -u=x -type f)
			echo
		done | head -n -1
	else
		xargs -n1 <<<${OVE_PROJECT_LIST}
	fi

	return 0
}

# digraph: :create a DOT directed graph for all projects
function ove-digraph {
	local i

	[ ${ove_number_of_projects} -eq 0 ] && return

	echo "digraph $(tr '-' '_' <<<${OVE_PROJECT_NAME}) {"

	i=0
	while ((i < ove_number_of_projects)); do
		if [ "${ove_projects_deps[${i}]}" != "" ]; then
			for d in ${ove_projects_deps[${i}]}; do
				echo "    ${ove_projects_name[${i}]} -> ${d};"
			done
		else
			echo "    ${ove_projects_name[${i}]};"
		fi
		(( i+=1 ))
	done

	echo "}"
}

function ove_build_topology {
	local i

	i=0
	while ((i < ove_number_of_projects)); do
		if [ "${ove_projects_deps[${i}]}" != "" ]; then
			for d in ${ove_projects_deps[${i}]}; do
				echo "${ove_projects_name[${i}]} ${d}"
			done
		fi
		(( i+=1 ))
	done | tsort | tac | xargs
}

# build-order: :show build order
function ove-build-order {
	local autonomous_projs
	local topology

	[ ${ove_number_of_projects} -eq 0 ] && return

	# just a bunch of projects without deps?
	if [ "$(ove_list_projects_with_deps)" == "" ]; then
		ove_list_projects_without_deps
		return
	fi

	topology=$(ove_build_topology)
	autonomous_projs=$(comm -3 \
		<(printf "%s\n" ${OVE_PROJECT_LIST}) \
		<(tr ' ' '\n' <<<${topology} | sort))

	echo ${autonomous_projs} ${topology}
}

# forowel:COMMAND:run 'COMMAND' for all OVE workspaces on this host
function ove-forowel {
	local cmd
	local i
	local projs

	[ $# -eq 0 ] && return

	i=0
	mapfile -t projs < <(ove-locate | grep '^/')
	while ((i < ${#projs[@]})); do
		cmd+=$(printf "
			echo '# %s'
			cd %s
			ove_init
			$*
			" $(ove_echo_green_noprefix $(basename ${projs[i]})) ${projs[i]})
		(( i+=1 ))
	done
	eval "${cmd}"
}

# forowel-parallel:COMMAND:run 'COMMAND' in parallel for all OVE workspaces on this host
function ove-forowel-parallel {
	local cmd
	local i
	local projs

	[ $# -eq 0 ] && return

	i=0
	mapfile -t projs < <(ove-locate | grep '^/')
	while ((i < ${#projs[@]})); do
		cmd=$(printf "
			cd %s
			ove_init
			$*
			" ${projs[i]})
		(( i+=1 ))
		{
			eval "${cmd}"
		} &
	done
	wait
}

# forall:COMMAND:run 'COMMAND' for all git repositories
function ove-forall {
	[ $# -ne 0 ] && ove_revtab_forall "$*"
}

# forall-parallel:COMMAND:run 'COMMAND' in parallel for all git repositories
function ove-forall-parallel {
	[ $# -ne 0 ] && ove_revtab_forall_parallel "$*"
}

# list-systests: :list available system tests
function ove-list-systests {
	! [ -e ${OVE_PROJECT_DIR}/systests ] && return
	(
	grep -E -v '^$|^\s*\#|.*:|^#.*' "${OVE_PROJECT_DIR}"/systests | \
		awk '{print $1}'
	grep : "${OVE_PROJECT_DIR}"/systests | \
		grep -v '#' | \
		cut -d: -f1

	if [ -e ${OVE_PROJECT_DIR}/systests-groups ]; then
		grep : "${OVE_PROJECT_DIR}"/systests-groups | \
			sed 's|[-:[:space:]]||g'
	fi) | sort
}

# list-systests-aliases: :list available system test aliases
function ove-list-systests-aliases {
	! [ -e ${OVE_PROJECT_DIR}/systests ] && return

	grep : "${OVE_PROJECT_DIR}"/systests | \
		grep -v '#' | \
		cut -d: -f1 | \
		sort
}

# list-scripts: :list available scripts
function ove-list-scripts {
	local p
	local repo

	# project scripts
	if [ -d "${OVE_PROJECT_DIR}/scripts" ]; then
		find ${OVE_PROJECT_DIR}/scripts -perm -u=x -not -name '*.help' -type f
	fi

	# OVE scripts
	if [ -d "${OVE_DIR}/scripts" ]; then
		find ${OVE_DIR}/scripts -perm -u=x -not -name '*.help' -type f
	fi

	# repo scripts
	for repo in $(ove_revtab_list_fullpath); do
		! [ -d "${repo}/.ove/scripts" ] && continue
		p+="${repo}/.ove/scripts "
	done
	[ "${p}" != "" ] && \
		find -L ${p} -perm -u=x -not -name '*.help' -type f

	return 0
}

function ove_list_scripts_directories {
	local repo

	while true; do
		# project scripts
		if [ -d "${OVE_PROJECT_DIR}/scripts" ]; then
			find ${OVE_PROJECT_DIR}/scripts -perm -u=x -not -name '*.help' -type f -printf "%h\n" -quit
		fi

		# OVE scripts
		if [ -d "${OVE_DIR}/scripts" ]; then
			find ${OVE_DIR}/scripts -perm -u=x -not -name '*.help' -type f -printf "%h\n" -quit
		fi

		# repo scripts
		for repo in ${OVE_REPO_LIST}; do
			[ -d "${repo}/.ove/scripts" ] || continue
			find -L ${repo}/.ove/scripts -perm -u=x -not -name '*.help' -type f -printf "%h\n" -quit &
		done

		wait
		break
	done | LC_ALL="C" sort -u
}

function ove_echo {
	local diff
	local diff_ns
	local diff_s
	local now
	local now_ns
	local now_s

	diff="00:00:00"
	diff_ns="000000000"

	now=$(date +%s:%N)
	now_s=${now%:*}
	now_ns=${now#*:}
	# remove leading zeros
	now_ns=$((10#${now_ns}))

	if [ "${OVE_PREV_S}" != "" ]; then
		diff_ns="$((now_ns - OVE_PREV_NS))"
		diff_s=$((now_s - OVE_PREV_S))
		if [ "${diff_ns}" -lt 0 ]; then
			(( diff_s-=1 ))
			diff_ns="$((1000000000 + diff_ns))"
		fi

		diff="$(awk '{printf "%02d:%02d:%02d\n", int($1/3600),int(($1%3600)/60),int($1%60)}' <<<${diff_s})"
	fi

	echo -e "$(date -d @${now_s} +'%Y-%m-%d %H:%M:%S').$(printf "%09d" ${now_ns}) (+${diff}:$(printf "%09d" ${diff_ns})):$*"

	OVE_PREV_S=${now_s}
	OVE_PREV_NS=${now_ns}
}

function ove_echo_cyan {
	ove_echo "${ove_cyan}""$*""${ove_blank}"
}

function ove_echo_cyan_error {
	ove_echo "${ove_cyan}""$*""${ove_blank}" 1>&2;
}

function ove_echo_yellow {
	ove_echo "${ove_yellow}""$*""${ove_blank}"
}

function ove_echo_green_noprefix {
	echo -e "${ove_green}""$*""${ove_blank}"
}

function ove_echo_red {
	ove_echo "${ove_red}""$*""${ove_blank}"
}

function ove_echo_red_noprefix {
	echo -e "${ove_red}""$*""${ove_blank}"
}

function ove_echo_yellow_noprefix {
	echo -e "${ove_yellow}""$*""${ove_blank}"
}

function ove_echo_warning {
	ove_echo_yellow "warning: $*" 1>&2;
}

function ove_echo_cyan_noprefix {
	echo -e "${ove_cyan}""$*""${ove_blank}"
}

function ove_echo_error {
	ove_echo_red "error: $*" 1>&2;
}

function ove_echo_error_noprefix {
	ove_echo_red_noprefix "error: $*" 1>&2;
}

function ove_echo_warning_noprefix {
	ove_echo_yellow_noprefix "warning: $*" 1>&2;
}

function ove_echo_stderr {
	ove_echo "$@" 1>&2;
}
function ove_echo_stderr_noprefix {
	echo "$@" 1>&2;
}

# systest:[TEST|GROUP...]:run one or more system tests/groups described in ${OVE_PROJECT_DIR}/systests-groups and ${OVE_PROJECT_DIR}/systests
function ove-systest {
	local exit_status
	local groups
	local i
	local match
	local nbr_tests
	local new_test_list
	local q
	local result
	local summary
	local systest_cmd
	local systest_exit_code
	local systest_path
	local systest_row
	local systest_timeout
	local systest_type
	local test_list
	local test_name
	local timeout_cmd

	[ -e ${OVE_PROJECT_DIR}/systests ] || return 1

	if [ $# -eq 0 ]; then
		echo "Need arguments, plz see ove help systest"
		return 1
	fi

	if ! [ -e ${OVE_PROJECT_DIR}/systests-groups ]; then
		test_list="$*"
	else
		groups=$(grep : ${OVE_PROJECT_DIR}/systests-groups | \
			sed 's|[-:[:space:]]||g'| \
			sort)

		if [ "${groups}" == "" ]; then
			test_list="$*"
		elif ! command -v python3 > /dev/null; then
			ove_echo_yellow_noprefix "python3 not found, not possible to launch 'yex'"
			test_list="$*"
		else
			for test_name in "$@"; do
				if grep -w -q ${test_name} <<<${groups}; then
					test_list+=" $(${OVE_DIR}/yex ${OVE_PROJECT_DIR}/systests-groups -s -r --groups "${test_name}")"
				else
					test_list+=" ${test_name}"
				fi
			done
		fi
	fi

	[ "${test_list}" == "" ] && echo "error: no tests found" && return 1

	# repeat?
	if [ -n "${OVE_SYSTEST_REPEAT+x}" ] && \
		[ "${OVE_SYSTEST_REPEAT}" -gt 1 ]; then

		for test_name in ${test_list}; do
			for q in $(seq 1 ${OVE_SYSTEST_REPEAT}); do
				new_test_list+=" ${test_name}"
			done
		done

		test_list=${new_test_list}
	fi

	# skip tests
	if [ -n "${OVE_SYSTEST_SKIP+x}" ] && \
		[ "${OVE_SYSTEST_SKIP}" -gt 1 ]; then

		i=0
		for test_name in ${test_list}; do
			if (( i % OVE_SYSTEST_SKIP == 0 )); then
				new_test_list+=" ${test_name}"
			fi
			(( i=i+1 ))
		done

		test_list=${new_test_list}
	fi

	nbr_tests=$(wc -w <<<${test_list})
	if [ ${nbr_tests} -gt 1 ]; then
		echo "${FUNCNAME[0]}:Will run ${nbr_tests} test cases:"
		i=0
		for test_name in ${test_list}; do
			(( i=i+1 ))
			printf "${FUNCNAME[0]}:[%03d/%03d    ]:${test_name}\n" ${i} ${nbr_tests}
		done
		echo
	fi

	# trap SIGINT to allow user to press CTRL+C
	trap true SIGINT

	i=0
	for test_name in ${test_list}; do
		(( i=i+1 ))

		# alias?
		match=$(grep -c ^${test_name}: "${OVE_PROJECT_DIR}"/systests)
		if [ ${match} -eq 1 ]; then
			test_name=$(grep ^${test_name}: "${OVE_PROJECT_DIR}"/systests | \
				cut -d: -f2)
		else
			match=$(grep -c -w ^${test_name} "${OVE_PROJECT_DIR}"/systests)
			if [ ${match} -eq 0 ]; then
				ove_echo_error_noprefix "${FUNCNAME[0]}:can not find '${test_name}'"
				continue
			elif [ ${match} -gt 1 ]; then
				ove_echo_error_noprefix "${FUNCNAME[0]}:${match} match(es) for '${test_name}'"
				grep ^${test_name} "${OVE_PROJECT_DIR}"/systests
				continue
			fi
		fi

		read -r -a systest_row <<<"$(grep -w ^${test_name} "${OVE_PROJECT_DIR}"/systests)"
		test_name=${systest_row[0]}
		systest_timeout=${systest_row[1]}
		systest_type=${systest_row[2]}
		systest_path=${OVE_BASE_DIR}/${systest_row[3]//\"}
		systest_cmd=${systest_row[*]:4}
		systest_cmd=${systest_cmd//\"}

		if ! [ -d "${systest_path}" ]; then
			ove_echo_error_noprefix "'${systest_path}' is not a valid path for systest: '${test_name}'"
			continue
		fi

		pushd "${systest_path}" &> /dev/null
		shift
		printf "${FUNCNAME[0]}:[%03d/%03d    ]:${test_name}\n" ${i} ${nbr_tests}

		OVE_SYSTEST_ACTIVE_TEST_CASE=${test_name}
		OVE_SYSTEST_ITERATION=${i}
		OVE_SYSTEST_NBR_TESTS=${nbr_tests}
		export OVE_SYSTEST_ACTIVE_TEST_CASE
		export OVE_SYSTEST_ITERATION
		export OVE_SYSTEST_NBR_TESTS

		if [ "${OVE_DRY_RUN}" -eq 1 ]; then
			# dry run
			result=$(printf "${FUNCNAME[0]}:[%03d/%03d ${ove_green}OK${ove_blank}]:${test_name}" ${i} ${nbr_tests})
		else
			if [ ${systest_timeout} -eq 0 ]; then
				timeout_cmd=""
			else
				timeout_cmd="timeout --foreground --kill-after 30s ${systest_timeout}"
			fi

			if ${timeout_cmd} ${systest_cmd}; then
				# test passed
				result=$(printf "${FUNCNAME[0]}:[%03d/%03d ${ove_green}OK${ove_blank}]:${test_name}" ${i} ${nbr_tests})
			else
				systest_exit_code=$?

				if [ ${systest_exit_code} -eq 124 ]; then
					exit_status="TIMEOUT"
				elif [ ${systest_exit_code} -eq 126 ]; then
					exit_status="PERMISSION_DENIED"
				elif [ ${systest_exit_code} -eq 127 ]; then
					exit_status="CAN_NOT_FIND_CMD"
				elif [ ${systest_exit_code} -gt 128 ] && [ ${systest_exit_code} -lt 166 ]; then
					exit_status="SIG$(kill -l ${systest_exit_code})"
				elif [ -e /usr/include/sysexits.h ] && \
					grep -P -q "#define EX_[A-Z]+\s+${systest_exit_code}" /usr/include/sysexits.h; then
					exit_status=$(grep -P "#define EX_[A-Z]+\s${systest_exit_code}" /usr/include/sysexits.h | \
						grep -o -P 'EX_[A-Z]+')
				elif [ -e ${OVE_PROJECT_DIR}/${OVE_PROJECT_NAME}-sysexits.h ] && \
					grep -P -q "#define [A-Z0-9_]+\s+${systest_exit_code}$" ${OVE_PROJECT_DIR}/${OVE_PROJECT_NAME}-sysexits.h; then
					exit_status=$(grep -P "#define [A-Z0-9_]+\s+${systest_exit_code}$" ${OVE_PROJECT_DIR}/${OVE_PROJECT_NAME}-sysexits.h | \
						cut -f1 | \
						cut -d' ' -f2)
				else
					exit_status="${systest_exit_code}"
				fi

				# test failed
				result=$(printf "${FUNCNAME[0]}:[%03d/%03d ${ove_yellow}NOK${ove_blank} ${exit_status}]:${test_name}"  ${i} ${nbr_tests})

				# type 1 systest or SIGINT => stop loop
				if [ ${systest_type} -eq 1 ] || [ ${exit_status} == "SIGINT" ] ; then
					echo ${result}
					summary+="${result}\n"
					popd &> /dev/null
					break
				fi
			fi
		fi

		summary+="${result}\n"
		echo -e ${summary}
		popd &> /dev/null
	done
	echo
	if [ ${nbr_tests} -gt 1 ]; then
		echo ${FUNCNAME[0]}:Summary:
		echo -e ${summary}
	fi
	echo "OVE log: ${OVE_LAST_COMMAND}"

	return ${systest_exit_code}
}

# helper function for a few revtab functions below
function ove_revtab_sanity_check {
	if [ $# -ne 2 ]; then
		ove_echo_error_noprefix "please provide two revisions for '${OVE_PROJECT_DIR}'"
		return 1
	fi

	if [ "$1" == "$2" ]; then
		ove_echo_error_noprefix "please provide two different revisions for '${OVE_PROJECT_DIR}'"
		return 2
	fi

	if ! git -C "${OVE_PROJECT_DIR}" cat-file -e "$1" &> /dev/null; then
		ove_echo_error_noprefix "'$1' is not a valid revision"
		return 3
	fi

	if ! git -C "${OVE_PROJECT_DIR}" cat-file -e "$2" &> /dev/null; then
		ove_echo_error_noprefix "'$2' is not a valid revision"
		return 4
	fi

	if ! git -C "${OVE_PROJECT_DIR}" --no-pager show $1:revtab &> /dev/null; then
		ove_echo_error_noprefix "revtab for '$1' is not available"
		return 5
	fi

	if ! git -C "${OVE_PROJECT_DIR}" --no-pager show $2:revtab &> /dev/null; then
		ove_echo_error_noprefix "revtab for '$2' is not available"
		return 6
	fi
}

# revtab-diff:<rev> <rev>:print changes between two project revisions
function ove-revtab-diff {
	local a
	local b
	local r
	local sha_1
	local sha_2

	ove_revtab_sanity_check "$@" || return $?

	# save revtab for rev A and rev B
	a=$(git -C "${OVE_PROJECT_DIR}" --no-pager show $1:revtab | \
		grep -v \# | \
		xargs -n4)
	b=$(git -C "${OVE_PROJECT_DIR}" --no-pager show $2:revtab | \
		grep -v \# | \
		xargs -n4)

	# extract repo
	printf "${a}" | \
		awk '{print $1}' | \
		LC_ALL="C" sort > ${OVE_PROJECT_TMP_DIR}/repos_A
	printf "${b}" | \
		awk '{print $1}' | \
		LC_ALL="C" sort > ${OVE_PROJECT_TMP_DIR}/repos_B

	# extract repo/rev
	printf "${a}" | \
		awk '{print $1,$4}' | \
		LC_ALL="C" sort > ${OVE_PROJECT_TMP_DIR}/rev_A
	printf "${b}" | \
		awk '{print $1,$4}' | \
		LC_ALL="C" sort  > ${OVE_PROJECT_TMP_DIR}/rev_B

	while true; do
		# repos only in A
		for r in $(LC_COLLATE="C" comm -2 -3 ${OVE_PROJECT_TMP_DIR}/repos_A ${OVE_PROJECT_TMP_DIR}/repos_B); do
			grep "^${r} " ${OVE_PROJECT_TMP_DIR}/rev_A | sed -e 's/^/a /g'
		done

		# repos only in B
		for r in $(LC_COLLATE="C" comm -1 -3 ${OVE_PROJECT_TMP_DIR}/repos_A ${OVE_PROJECT_TMP_DIR}/repos_B); do
			grep "^${r} " ${OVE_PROJECT_TMP_DIR}/rev_B | sed -e 's/^/b /g'
		done

		# repos common for A and B
		for r in $(LC_COLLATE="C" comm -1 -2 ${OVE_PROJECT_TMP_DIR}/repos_A ${OVE_PROJECT_TMP_DIR}/repos_B); do
			sha_1=$(grep "^${r} " ${OVE_PROJECT_TMP_DIR}/rev_A | \
				awk '{print $2}')
			sha_2=$(grep "^${r} " ${OVE_PROJECT_TMP_DIR}/rev_B | \
				awk '{print $2}')
			[ "${sha_1}" == "${sha_2}" ] && continue
			echo c ${r} ${sha_1} ${sha_2}
		done

		break
	done | column -t

	# cleanup
	rm ${OVE_PROJECT_TMP_DIR}/repos_A \
		${OVE_PROJECT_TMP_DIR}/repos_B \
		${OVE_PROJECT_TMP_DIR}/rev_A \
		${OVE_PROJECT_TMP_DIR}/rev_B
}

# helper function for diff/log/shortlog-project functions
function ove_extract_only_a {
	local line=${*}
	local repo
	local sha_1

	repo=$(awk '{print $2}' <<<${line})
	sha_1=$(awk '{print $3}' <<<${line})
	if [ -d ${OVE_BASE_DIR}/${repo} ] && [ -d ${OVE_BASE_DIR}/${repo}/.git ]; then
		only_a+="  ${repo}|$(git -C ${OVE_BASE_DIR}/${repo} log -1 --oneline --pretty="  %C(auto)%h|%s" ${sha_1})\n"
	else
		only_a+="${line:1}\n"
	fi
}

# helper function for diff/log/shortlog-project functions
function ove_extract_only_b {
	local line=${*}
	local repo
	local sha_1

	repo=$(awk '{print $2}' <<<${line})
	sha_1=$(awk '{print $3}' <<<${line})
	if [ -d ${OVE_BASE_DIR}/${repo} ] && [ -d ${OVE_BASE_DIR}/${repo}/.git ]; then
		only_b+="  ${repo}|$(git -C ${OVE_BASE_DIR}/${repo} log -1 --oneline --pretty="  %C(auto)%h|%s" ${sha_1})\n"
	else
		only_b+="${line:1}\n"
	fi
}

# helper function for diff/log/shortlog-project functions
function ove_print_only_a_and_b {
	if [ "${only_a}" != "" ]; then
		echo
		ove_echo_yellow_noprefix "only in '$1':"
		printf "${only_a}" | column -t -s'|'
	fi

	if [ "${only_b}" != "" ]; then
		echo
		ove_echo_yellow_noprefix "only in '$2':"
		printf "${only_b}" | column -t -s'|'
	fi
}

# $1: repo
# $2: rev
function ove_validate_rev {
	local repo="$1"
	local rev="$2"

	if ! git -C "${OVE_BASE_DIR}/${repo}" cat-file -e "${rev}" &> /dev/null; then
		ove_echo_error_noprefix "${repo}: '${rev}' is not a valid revision, try 'ove fetch ${repo}'"
		return 1
	fi
}

# helper function for diff/log/shortlog-project functions
function ove_extract_repo_and_sha {
	local line=${*}

	repo=$(awk '{print $2}' <<<${line})
	sha_1=$(awk '{print $3}' <<<${line})
	if ! ove_validate_rev ${repo} ${sha_1}; then
		return 1
	fi
	sha_2=$(awk '{print $4}' <<<${line})
	if ! ove_validate_rev ${repo} ${sha_2}; then
		return 1
	fi
}

# diff-project:<rev> <rev>:diff the entire project
function ove-diff-project {
	local cmd
	local diff
	local line
	local only_a
	local only_b
	local repo
	local sha_1
	local sha_2

	ove_revtab_sanity_check "$@" || return $?

	cmd="git -C ${OVE_PROJECT_DIR} diff --color=always $1 $2"
	diff=$(${cmd})
	if [ "${diff}" != "" ]; then
		echo -e "${diff}" | ${OVE_PAGER} -Ps"${OVE_PROJECT_NAME}\:${cmd/./\\.}"
	fi

	while IFS= read -r line; do
		[ "${line}" == "" ] && break
		if [ ${line:0:1} == "a" ]; then
			ove_extract_only_a ${line}
		elif [ ${line:0:1} == "b" ]; then
			ove_extract_only_b ${line}
		elif [ ${line:0:1} == "c" ]; then
			ove_extract_repo_and_sha ${line} || continue
			cmd="git -C ${OVE_BASE_DIR}/${repo} diff --color=always ${sha_1} ${sha_2}"
			diff=$(${cmd})
			if [ "${diff}" != "" ]; then
				echo -e "${diff}" | ${OVE_PAGER} -Ps"${repo}\:${cmd/./\\.}"
			fi
		fi
	done <<<"$(ove-revtab-diff "$1" "$2")"

	ove_print_only_a_and_b $1 $2
}

# log-project:<rev> <rev>:git log the project '${OVE_PROJECT_NAME}'
function ove-log-project {
	local diff
	local line
	local only_a
	local only_b
	local repo
	local sha_1
	local sha_2

	ove_revtab_sanity_check "$@" || return $?

	diff=$(git --no-pager -C "${OVE_PROJECT_DIR}" log --oneline --pretty="  %C(auto)%h %s" "$1".."$2")
	if [ "${diff}" != "" ]; then
		ove_echo_yellow_noprefix "${OVE_PROJECT_NAME}:"
		echo -e "${diff}"
	fi

	while IFS= read -r line; do
		[ "${line}" == "" ] && break
		if [ ${line:0:1} == "a" ]; then
			ove_extract_only_a ${line}
		elif [ ${line:0:1} == "b" ]; then
			ove_extract_only_b ${line}
		elif [ ${line:0:1} == "c" ]; then
			ove_extract_repo_and_sha ${line} || continue
			diff=$(git --no-pager -C ${OVE_BASE_DIR}/${repo} log --oneline --pretty="  %C(auto)%h %s" ${sha_1}..${sha_2})
			if [ "${diff}" != "" ]; then
				echo
				ove_echo_yellow_noprefix "${repo}:"
				echo -e "${diff}"
			fi
		fi
	done <<<"$(ove-revtab-diff "$1" "$2")"

	ove_print_only_a_and_b $1 $2
}

# shortlog-project:<rev> <rev>:git shortlog the project
function ove-shortlog-project {
	local diff
	local line
	local only_a
	local only_b
	local repo
	local sha_1
	local sha_2

	ove_revtab_sanity_check "$@" || return $?

	diff=$(git --no-pager -C "${OVE_PROJECT_DIR}" shortlog --email --oneline "$1".."$2")
	if [ "${diff}" != "" ]; then
		ove_echo_yellow_noprefix ${OVE_PROJECT_NAME}:
		echo -e "${diff}"
		echo
	fi

	while IFS= read -r line; do
		[ "${line}" == "" ] && break
		if [ ${line:0:1} == "a" ]; then
			ove_extract_only_a ${line}
		elif [ ${line:0:1} == "b" ]; then
			ove_extract_only_b ${line}
		elif [ ${line:0:1} == "c" ]; then
			ove_extract_repo_and_sha ${line} || continue
			diff=$(git --no-pager -C ${OVE_BASE_DIR}/${repo} shortlog --email --oneline ${sha_1}..${sha_2} | sed -e 's/^/  /g')
			if [ "${diff}" != "" ]; then
				ove_echo_yellow_noprefix "${repo}:"
				echo -e "${diff}"
				echo
			fi
		fi
	done <<<"$(ove-revtab-diff "$1" "$2")"

	ove_print_only_a_and_b $1 $2
}

# help function that will print OVE project info
#
# $1 = path to OVE project directory
function ove_locate_print {
	local num_projs
	local num_repos
	local ove_dir

	ove_dir=$1

	! [ -d ${ove_dir} ] && return

	num_repos=$(awk '{print $1}' ${ove_dir}/revtab | \
		sed -e 's/#.*$//' -e '/^$/d' | \
		wc -l)
	OVE_PROJECT_DIR=${ove_dir} num_projs=$(ove_list_projects | \
		wc -w)
	dirname ${ove_dir}
	[ -e "${ove_dir}/SETUP" ] && echo "  $(cat ${ove_dir}/SETUP)"
	echo "  repos [${num_repos}]: $(awk '{print $1}' ${ove_dir}/revtab | \
		sed -e 's/#.*$//' -e '/^$/d' | \
		tr '\n' ' ')"
	OVE_PROJECT_DIR=${ove_dir} echo "  projs [${num_projs}]: $(ove_list_projects)"
	echo
}

# setup: :print how to set this project up
function ove-setup {
	[ -e "${OVE_PROJECT_DIR}/SETUP" ] && cat "${OVE_PROJECT_DIR}/SETUP"

	return 0
}

# refresh: :refresh projects found by ove-locate
function ove-refresh {
	local i
	local projs
	local str

	i=0
	mapfile -t projs < <(ove-locate | grep '^/')
	while ((i < ${#projs[@]})); do
		str+=$(printf "
			echo '$ # %s'
			echo '$ cd %s'
			cd %s
			ove_init
			echo '$ ove fetch'
			ove fetch
			if ove news > /dev/null; then
				ove news
				while true; do
					read -p '%s [?,a,A,c,d,n,p,q,s,x]? ' -r -n1
					echo
					if [[ \${REPLY} =~ ^[Pp]$ ]]; then
						echo '$ ove pull'
						ove pull
						echo
					elif [[ \${REPLY} =~ ^[a]$ ]]; then
						echo '$ ove ahead'
						ove ahead
						echo
					elif [[ \${REPLY} =~ ^[A]$ ]]; then
						echo '$ ove show-ahead'
						ove show-ahead
						echo
					elif [[ \${REPLY} =~ ^[Cc]$ ]]; then
						echo '$ ove checkout'
						ove checkout
						echo '$ ove status'
						ove status
						echo
					elif [[ \${REPLY} =~ ^[Dd]$ ]]; then
						echo '$ ove diff'
						ove diff
						echo
						echo '$ ove status'
						ove status
						echo
					elif [[ \${REPLY} =~ ^[Xx]$ ]]; then
						echo '$ ove pull'
						if ove pull; then
							break
						fi
						echo
					elif [[ \${REPLY} =~ ^[Ss]$ ]]; then
						echo '$ ove show-news'
						ove show-news
						echo
					elif [[ \${REPLY} =~ ^[Qq]$ ]]; then
						return
					elif [[ \${REPLY} =~ ^[Nn]$ ]]; then
						break
					elif [[ \${REPLY} =~ ^[?]$ ]]; then
						echo 'a - ahead'
						echo 'A - show ahead'
						echo 'c - checkout'
						echo 'd - diff'
						echo 'n - next'
						echo 'p - pull'
						echo 'q - quit'
						echo 's - show news'
						echo 'x - pull and next'
						echo '? - this help'
						continue
					fi
				done
			fi
			echo" $(ove_echo_green_noprefix $(basename ${projs[i]})) ${projs[i]} ${projs[i]} $(ove_echo_green_noprefix $(basename ${projs[i]})))
		(( i+=1 ))
	done
	eval "${str}"
}

function ove_locate_owels {
	local a
	local b
	local diff
	local invalidate_cache
	local o
	local owels

	if [ -e "${OVE_GLOBAL_STATE_DIR}/owel.cache" ]; then
		a=$(stat --format '%Y' "${OVE_GLOBAL_STATE_DIR}/owel.cache")
		b=$(date +%s)
		if [ $((b-a)) -lt 600 ]; then
			for o in $(cat "${OVE_GLOBAL_STATE_DIR}/owel.cache"); do
				if ! [ -d ${o} ]; then
					invalidate_cache=true
				fi

			done

			if ! [ "${invalidate_cache}" = true ]; then
				cat "${OVE_GLOBAL_STATE_DIR}/owel.cache"
				return
			fi
		fi
	fi

	if command -v locate > /dev/null; then
		owels=$(locate -e -r '\.owel$')
	else
		owels=$(find ${OVE_LOCATE_SEARCH_DIR} -type l -name .owel 2> /dev/null)
	fi

	if [ "${owels}" == "" ]; then
		return 1
	fi

	for o in ${owels}; do
		if ! [ -e ${o}/revtab ]; then
			owels=${owels/${o}/}
		fi
	done

	xargs -n1 <<<${owels} | \
		tee "${OVE_GLOBAL_STATE_DIR}/owel.cache"
}

# locate: :print OVE workspaces owned by you on this host
function ove-locate {
	local owel
	local owels

	owels=$(ove_locate_owels)

	if [ "${owels}" == "" ]; then
		ove_echo_error_noprefix "no OVE projects found"
		return 1
	fi

	for owel in ${owels}; do
		if [ "$(stat -c %u ${owel})" == "$(id -u)" ]; then
			ove_locate_print ${owel}
		fi
	done | head -n -1
}

# locate-all: :print all OVE workspaces on this host
function ove-locate-all {
	local owel
	local owels

	owels=$(ove_locate_owels)

	if [ "${owels}" == "" ]; then
		ove_echo_error_noprefix "no OVE project(s) found"
		return 1
	fi

	for owel in ${owels}; do
		ove_locate_print ${owel}
	done | head -n -1
}

# switch:[PATTERN]:switch to another OVE project
function ove-switch {
	local i
	local projs

	i=0
	mapfile -t projs < <(ove-locate | grep '^/')
	if [ $# -eq 0 ]; then
		while ((i < ${#projs[@]})); do
			printf "%d: %s # %s\n" $((i + 1)) ${projs[i]} $(ove_echo_green_noprefix $(basename ${projs[i]}))
			# shellcheck disable=SC2030
			(( i+=1 ))
		done | column -t -s#

		echo
		read -r -p "Proj: "
		if ! [[ "${REPLY}" =~ ^[0-9]+$ ]]; then
			[ "${REPLY}" != "" ] && \
				echo "error: just numbers"
			return 1
		fi

		if [ ${REPLY} -gt ${#projs[@]} ] || [ ${REPLY} -eq 0 ]; then
			echo "error: out of bounds"
			return 2
		fi

		eval $(printf "cd %s; . ove > /dev/null\n" ${projs[$((REPLY - 1))]})
	elif [ $# -eq 1 ]; then
		while ((i < ${#projs[@]})); do
			if basename ${projs[i]} | grep -i -q $1; then
				eval $(printf "cd %s; . ove > /dev/null\n" ${projs[i]})
				return
			fi
			(( i+=1 ))
		done

		echo "error: project '$1' not found"
		return 1
	fi
}

# branch:[GIT...]|[GIT... NAME]:list branch(es) OR create-and-checkout 'NAME' branch for 'GIT...' and update 'revtab' accordingly
function ove-branch {
	local a
	local args
	local branch_name
	local branch_start_point
	local cmd
	local index
	local r
	local repos

	if [ $# -lt 2 ]; then
		# shellcheck disable=SC2016
		cmd='ove_echo_yellow_noprefix ${git_basename} && git --no-pager -C ${git} branch -vv; echo'
		if [ $# -eq 0 ]; then
		        ove_revtab_forall "${cmd}"
		else
		        ove_revtab_forsome "${cmd}" "$@"
		fi

		return 0
	fi

	read -r -a a <<<"$*"
	# all but last arg
	args=${a[*]:0:${#a[*]}-1}
	branch_name=${a[*]: -1}
	repos=$(ove_validate_repo_list ${args})
	if [ "${repos}" == "" ]; then
		echo "error: repo(s) '${args}' is not valid repo(s)"
		return 1
	fi

	for r in ${repos}; do
		if ! [ -d "${OVE_BASE_DIR}/${r}" ]; then
			echo "error: repo '${r}' is not yet fetched"
			continue
		fi

		while true; do
			read -r -p "${r}: starting point for branch '${branch_name}'? (leave empty to create branch from current HEAD): "
			[ "${REPLY}" == "" ] && break
			if ! git -C "${OVE_BASE_DIR}/${r}" cat-file -e "${REPLY}" &> /dev/null; then
				ove_echo_error_noprefix "'${REPLY}' is not a valid revision for ${r}, try again"
				continue
			fi
			branch_start_point=${REPLY}
			break
		done

		# checkout branch
		if ! git -C "${OVE_BASE_DIR}/${r}" checkout -b ${branch_name} ${branch_start_point} |& sed "s|^|${r}: |g"; then
			continue
		fi

		[ -e "${OVE_PROJECT_DIR}/revtab" ] || continue
		[ "${OVE_PROJECT_NAME}" == "${r}" ] && continue

		# update revtab
		index=${ove_revtab_name2index[${r}]}
		sed -i "s|^\(${r} .*\)${ove_revtab_rev[${index}]}|\1${branch_name}|g" "${OVE_PROJECT_DIR}/revtab"
	done
}

# remote:[GIT...]:git remote -v for all/specified git repositories
function ove-remote {
	local cmd

	# shellcheck disable=SC2016
	cmd='ove_echo_yellow_noprefix ${git_basename} && git --no-pager -C ${git} remote -v'

	if [ $# -eq 0 ]; then
		ove_revtab_forall "${cmd}"
	else
		ove_revtab_forsome "${cmd}" "$@"
	fi
}

# remote-check: :sanity check that all remotes are online
function ove-remote-check {
	local count

	count=0
	while ((count < ove_revtab_num_repositories)); do
		if ! git -C "${PWD}" ls-remote ${ove_revtab_fetch_url[${count}]} HEAD > /dev/null; then
			return 1
		fi

		(( count+=1 ))
	done
}

function ove_dirty_repos {
	local repo

	# shellcheck disable=SC2016
	for repo in $(ove_revtab_forall_parallel 'test -z "$(git --no-pager -C ${git} status --porcelain -uno)" || echo ${PWD}'); do
		ove_git2shortpath ${repo}
	done
}

function ove_stashed_repos {
	local repo

	# shellcheck disable=SC2016
	for repo in $(ove_revtab_forall_parallel 'test -z "$(git --no-pager -C ${git} stash show 2> /dev/null)" || echo ${PWD}'); do
		ove_git2shortpath ${repo}
	done
}

# $1: drop or pop
function ove_stash_forsome {
	local cmd

	if ! [ -w "${OVE_PROJECT_STATE_DIR}" ]; then
		ove_echo_error_noprefix "you are not allowed to 'stash $1'"
		return 1
	fi

	! [ -f ${OVE_PROJECT_STATE_DIR}/ove-stashed-repos ] && return
	cmd="git stash $1 -q"
	ove_revtab_forsome "${cmd}" "$(sed "s|${OVE_BASE_DIR}/||g" ${OVE_PROJECT_STATE_DIR}/ove-stashed-repos | xargs)"
	rm ${OVE_PROJECT_STATE_DIR}/ove-stashed-repos
}

function ove_stash_pop {
	ove_stash_forsome pop
}

function ove_stash_drop {
	ove_stash_forsome drop
}

function ove_stash_save {
	local cmd
	local dirty_repos
	local now

	if ! [ -w "${OVE_PROJECT_STATE_DIR}" ]; then
		ove_echo_error_noprefix "you are not allowed to 'stash'"
		return 1
	fi

	[ -f ${OVE_PROJECT_STATE_DIR}/ove-stashed-repos ] && return

	dirty_repos=$(ove_dirty_repos)
	[ "${dirty_repos}" == "" ] && return

	true > ${OVE_PROJECT_STATE_DIR}/ove-stashed-repos
	now=$(date '+%Y%m%d-%H%M%S')
	cmd="git -C \${git} stash save -q stashed by OVE@${now} && echo \${git} >> ${OVE_PROJECT_STATE_DIR}/ove-stashed-repos"

	ove_revtab_forsome "${cmd}" "${dirty_repos}"
}

function ove_stash_inspect {
	local cmd
	local stashed_repos

	stashed_repos=$(ove_stashed_repos)
	[ "${stashed_repos}" == "" ] && return

	cmd="git --no-pager -C \${git} stash"
	if [ "$1" == "show" ]; then
		cmd+=" show -p"
	elif [ "$1" == "list" ]; then
		cmd+=" list"
	else
		return
	fi

	ove_revtab_forsome "ove_echo_yellow_noprefix \${git_basename}: && ${cmd}" "${stashed_repos}"
}

function ove_stash_show {
	ove_stash_inspect show
}

function ove_stash_list {
	ove_stash_inspect list
}

# stash:[drop|list|pop|show]:git stash [drop|list|pop|show] for all git repositories
function ove-stash {
	if [ "$1" == "pop" ] ||
		[ "$1" == "list" ] ||
		[ "$1" == "show" ] ||
		[ "$1" == "drop" ]; then
		ove_stash_$1
	elif [ $# -eq 0 ]; then
		ove_stash_save
	else
		ove-help "^${FUNCNAME/ove-/} "
		return 1
	fi
}

# diff:[GIT...]:git diff for all/specified git repositories
function ove-diff {
	local cmd
	local repos

	cmd="git --no-pager -C \${git} diff-files --quiet || \
		(ove_echo_yellow_noprefix \${git_basename} && \
		git --no-pager -C \${git} diff --color=always ${OVE_DIFF_OPTIONS})"

	[ $# -eq 0 ] && repos="$(ove_dirty_repos)" || repos="$*"

	ove_revtab_forsome "${cmd}" "${repos}" | ${OVE_PAGER}
}

# wdiff:[GIT...]:git diff (word diff) for all/specified git repositories
function ove-wdiff {
	local OVE_DIFF_OPTIONS

	OVE_DIFF_OPTIONS="--color-words=."
	ove-diff "$@"
}

# wdiff-cached:[GIT...]:git diff --cached (word diff) for all/specified git repositories
function ove-wdiff-cached {
	local OVE_DIFF_OPTIONS

	OVE_DIFF_OPTIONS="--color-words=."
	ove-diff-cached "$@"
}

# diff-cached:[GIT...]:git diff --cached for all/specified repositories
function ove-diff-cached {
	local cmd
	local repos

	cmd="git --no-pager -C \${git} diff-index --quiet --cached HEAD -- || \
		(ove_echo_yellow_noprefix \${git_basename} && \
		git --no-pager -C \${git} diff --color=always --cached ${OVE_DIFF_OPTIONS})"

	[ $# -eq 0 ] && repos="$(ove_dirty_repos)" || repos="$*"

	ove_revtab_forsome "${cmd}" "${repos}" | ${OVE_PAGER}
}

# reset:[GIT...]:git reset -p for all/specified repositories
function ove-reset {
	local cmd

	# shellcheck disable=SC2016
	cmd='git --no-pager -C ${git} diff-index --quiet --cached HEAD -- ||'
	# shellcheck disable=SC2016
	cmd+=' (ove_echo_yellow_noprefix ${git_basename} && git -C ${git} reset -p)'

	if [ $# -eq 0 ]; then
		ove_revtab_forall "${cmd}"
	else
		ove_revtab_forsome "${cmd}" "$@"
	fi
}

# reset-hard:[GIT...]:git reset --hard for all/specified repositories, use with care
function ove-reset-hard {
	local cmd

	# shellcheck disable=SC2016
	cmd='git -C ${git} reset -q --hard'

	if [ $# -eq 0 ]; then
		ove_revtab_forall "${cmd}"
	else
		ove_revtab_forsome "${cmd}" "$@"
	fi
}

# add:[GIT...]:git add -p for all/specified repositories
function ove-add {
	local cmd
	local repos

	# shellcheck disable=SC2016
	cmd='git --no-pager -C ${git} diff-files --quiet ||'
	# shellcheck disable=SC2016
	cmd+=' (ove_echo_yellow_noprefix ${git_basename} && git --no-pager -C ${git} add -p)'

	[ $# -eq 0 ] && repos="$(ove_dirty_repos)" || repos="$*"

	ove_revtab_forsome "${cmd}" "${repos}"
}

# commit:[GIT...]:git commit for all/specified git repositories
function ove-commit {
	local cmd

	cmd="git --no-pager -C \${git} diff --cached --quiet || \
		(ove_echo_yellow_noprefix \${git_basename} && \
		git -C \${git} commit -t <(echo; echo \# git: \${git}; echo \#; git -C \${git} diff --cached -U0 | sed 's/^/# /g'))"

	if [ $# -eq 0 ]; then
		ove_revtab_forsome "${cmd}" "$(ove_dirty_repos)"
	else
		ove_revtab_forsome "${cmd}" "$@"
	fi
}

# $* = proj(s)
function ove_get_deps_recursive {
	local dep
	local index
	local proj

	for proj in "$@"; do
		index=${ove_projects_name2index[${proj}]}
		for dep in ${ove_projects_deps[${index}]}; do
			echo -n "${dep} "
			ove_get_deps_recursive ${dep}
		done
	done
}

# $1 = proj
function ove_get_paths_recursive {
	local dep
	local index

	if [ $# -ne 1 ]; then
		ove_echo_error_noprefix "${FUNCNAME[0]}: need one arg"
		return 1
	fi

	index=${ove_projects_name2index[$1]}
	if [ "${ove_projects_deps[${index}]}" == "" ]; then
		echo -n "${OVE_BASE_DIR}/${ove_projects_path[${index}]} "
		return
	fi

	for dep in ${ove_projects_deps[${index}]}; do
		echo -n "${OVE_BASE_DIR}/${ove_projects_path[${index}]} "
		ove_get_paths_recursive ${dep}
	done
}

function ove_validate_revtab {
	local d
	local doublets

	[ ! -e "${OVE_PROJECT_DIR}/revtab" ] && return

	doublets="$(grep -E -v '^$|^#' ${OVE_PROJECT_DIR}/revtab | \
		awk 'a[$1]++{print $1}')"

	# check for doublets
	if [ "${doublets}" != "" ]; then
		ove_echo_error_noprefix "found repo doublet(s) in '${OVE_PROJECT_DIR}/revtab':"

		for d in ${doublets}; do
			grep -n "^${d} " ${OVE_PROJECT_DIR}/revtab
		done
		return 1
	fi
}

function ove_validate_self {
	if grep ^function ${OVE_SELF} | grep -q -v 'function ove'; then
		ove_echo_error_noprefix "functions need to start with 'ove-' or 'ove_'"
		grep ^function ${OVE_SELF} | grep -v 'function ove'
		return 1
	fi

	if [ "$(grep -B1 '^function ove-' ${OVE_SELF} | \
		grep '^$' -A1 | \
		awk '{print $2}' | \
		xargs)" != "" ]; then
		ove_echo_error_noprefix "add help for the following function(s):"
		grep -B1 '^function ove-.*' ${OVE_SELF} |
			grep '^$' -A1 | \
			awk '{print $2}' | \
			xargs
		return 1
	fi
}

function ove_validate_projs {
	local d
	local doublets
	local i

	[ ! -e "${OVE_PROJECT_DIR}/projs" ] && return

	i=0
	while ((i < ove_number_of_projects)); do
		if [ "${ove_projects_deps[${i}]}" != "" ]; then
			for d in ${ove_projects_deps[${i}]}; do
				echo "${ove_projects_name[${i}]} ${d}"
			done
		fi
		(( i+=1 ))
	done | tsort > /dev/null

	# shellcheck disable=SC2181
	if [ $? -ne 0 ]; then
		ove_echo_error_noprefix "circular dependency in '${OVE_PROJECT_DIR}/projs', see output from 'tsort' above"
		return 1
	fi

	doublets=$(grep -o '^[a-zA-Z0-9_]\+' ${OVE_PROJECT_DIR}/projs | \
		awk 'a[$1]++{print $1}')

	if [ "${doublets}" != "" ]; then
		ove_echo_error_noprefix "found project doublet(s) in '${OVE_PROJECT_DIR}/projs':"

		for d in ${doublets}; do
			grep -n "^${d}:" ${OVE_PROJECT_DIR}/projs
		done
		return 1
	fi
}

# $@: a list of packages
function ove_install_packages {
	local cmd
	local missing_packages
	local missing_packages_sorted

	missing_packages=$(ove_packages_not_installed "$@")

	# no missing packages?
	[ "${missing_packages}" == "" ] && return

	# sort the list
	missing_packages_sorted="$(xargs -n1 "${OVE_ECHO}" <<<${missing_packages} | \
		LC_ALL="C" sort -u | \
		xargs "${OVE_ECHO}")"

	if [ "${OVE_DRY_RUN}" -eq 1 ]; then
		ove_echo_yellow "would prompt to install this/these package(s):"
		xargs -n1 <<<${missing_packages_sorted}
		return
	fi

	if [ "${OVE_OS_PACKAGE_MANAGER}" == "unknown" ]; then
		ove_echo_error_noprefix "${FUNCNAME[0]}: fatal: package manager is not set"
		return 1
	fi

	if ! command -v ${OVE_OS_PACKAGE_MANAGER} > /dev/null; then
		ove_echo_error_noprefix "${FUNCNAME[0]}: fatal: '${OVE_OS_PACKAGE_MANAGER}' not found"
		return 2
	fi

	cmd="${OVE_OS_PACKAGE_MANAGER} ${OVE_OS_PACKAGE_MANAGER_ARGS} ${missing_packages_sorted}"

	echo "missing package(s):"
	echo
	echo "To fix this, run the following command:"
	echo
	[ $(id -u) != 0 ] && cmd="sudo ${cmd}"
	echo -e "\t${cmd}"
	echo
	return 1
}

# export:[PROJECT...]:export project(s)
function ove-export {
	local attr
	local b
	local deps
	local index
	local paths
	local projs
	local re
	local tmp_var

	mkdir -p ${OVE_PROJECT_TMP_DIR}/export ${OVE_PROJECT_TMP_DIR}/export/projects
	true > ${OVE_PROJECT_TMP_DIR}/export/revtab
	true > ${OVE_PROJECT_TMP_DIR}/export/projs
	[ -d ${OVE_PROJECT_TMP_DIR}/export/projects ] && rm -rf ${OVE_PROJECT_TMP_DIR}/export/projects

	while true; do
		if [ $# -ge 1 ]; then
			if ! [[ -v ove_projects_name2index[$1] ]]; then
				ove_echo_error_noprefix "unknown project '$1'"
				shift
				[ $# -eq 0 ] && break
				continue
			fi

			deps=$(ove_get_deps_recursive $1)
		fi

		for b in $(xargs -n1 <<<${OVE_BUILD_ORDER} | sort); do
			if [ $# -ge 1 ]; then
				re=\\b${b}\\b
				if ! [[ "${deps}" =~ ${re} ]] && [ "${b}" != "$1" ]; then
					continue
				fi
			fi

			# already exported?
			if grep -q ^${b}: ${OVE_PROJECT_TMP_DIR}/export/projs; then
				continue
			fi

			projs+="${b} "
			str+="${b}:\n"
			index=${ove_projects_name2index[${b}]}
			for attr in $(ove_projects_attributes); do
				tmp_var="ove_projects_${attr}[${index}]"
				[ "${!tmp_var}" != "" ] && \
					str+="  ${attr}:\n$(tr ' ' '\n' <<<${!tmp_var} | \
					sort -u | \
					sed -e 's|^|    |g')\n"

				paths+="${OVE_BASE_DIR}/${ove_projects_path[${index}]} "
			done
			str+="\n"
		done

		printf "${str}" | sed '$ d' > ${OVE_PROJECT_TMP_DIR}/export/projs

		for b in ${projs}; do
			mkdir -p ${OVE_PROJECT_TMP_DIR}/export/projects/${b}
			if find ${OVE_PROJECT_DIR}/projects/${b} -mindepth 1 -print -quit 2> /dev/null | grep -q .; then
				cp -ar ${OVE_PROJECT_DIR}/projects/${b}/* ${OVE_PROJECT_TMP_DIR}/export/projects/${b}
			fi
		done

		shift
		[ $# -eq 0 ] && break
	done

	! [ -s ${OVE_PROJECT_TMP_DIR}/export/projs ] && return 1

	# YAML header
	sed -i '1i ---' ${OVE_PROJECT_TMP_DIR}/export/projs

	for b in $(tr ' ' '\n' <<<${paths} | sort -u); do
		while true; do
			[ "${b}" == "" ] && break
			if xargs -n 1 <<<${OVE_REPO_LIST} 2> /dev/null | grep -q ^${b}$; then
				ove-list-repositories | grep "^$(ove_git2shortpath ${b}) " >> ${OVE_PROJECT_TMP_DIR}/export/revtab
				break
			fi
			b="${b%/*}"
		done
	done
	LC_ALL="C" sort -u -o ${OVE_PROJECT_TMP_DIR}/export/revtab ${OVE_PROJECT_TMP_DIR}/export/revtab

	tree ${OVE_PROJECT_TMP_DIR}/export
	tar -C "${OVE_PROJECT_TMP_DIR}/export" -cjf "${OVE_PROJECT_TMP_DIR}/export.tar.bz2" .
	echo
	echo "${OVE_PROJECT_TMP_DIR}/export.tar.bz2"

	return 0
}

# import:[FILE]:import project(s), see export
function ove-import {
	local f

	if [ $# -eq 0 ]; then
		f="${OVE_PROJECT_TMP_DIR}/export.tar.bz2"
	elif [ $# -eq 1 ]; then
		f="$1"
	else
		echo "error: too many args"
		return 1
	fi

	if ! [ -s "${f}" ]; then
		echo "error: file '${f}' is not found or file size is 0"
		return 2
	fi

	tar -C "${OVE_PROJECT_DIR}" -xf "${f}"
}

function ove_build_pre {
	local p
	local q
	local re
	local repos

	if [ $# -eq 0 ]; then
		if [ -n "${OVE_PROJECT_LIST_BUILDABLE+x}" ] && \
			[ "${OVE_PROJECT_LIST_BUILDABLE}" != "${OVE_PROJECT_LIST}" ]; then
			ove_echo_error_noprefix "'$(comm -3 \
				<(xargs -n1 <<<${OVE_PROJECT_LIST} | sort) \
				<(xargs -n1 <<<${OVE_PROJECT_LIST_BUILDABLE} | sort) |
				xargs)' is not buildable project(s). Try: 'ove fetch'"
			return 1
		fi
	else
		while true; do
			if ! [[ -v ove_projects_name2index[$1] ]]; then
				ove_echo_error_noprefix "unknown project '$1'"
				return 1
			fi

			if [ -n "${OVE_PROJECT_LIST_BUILDABLE+x}" ]; then
				re=\\b$1\\b
				if ! [[ "${OVE_PROJECT_LIST_BUILDABLE}" =~ ${re} ]]; then
					for p in $(ove_get_paths_recursive $1 | xargs -n1 | sort -u); do
						[ -d ${p} ] && continue
						for q in ${OVE_REPO_LIST}; do
							if [[ ${p} == *"${q}"* ]] && ! [ -d "${q}" ]; then
								repos+="$(ove_git2shortpath ${q}) "
							fi
						done
					done
					if [ "${repos}" != "" ]; then
						repos=$(xargs -n1 <<<${repos} | sort -u | xargs)
						ove_echo_error_noprefix "'$1' is not a buildable project. Try: 'ove fetch ${repos}'"
					fi
					return 1
				fi
			fi
			shift
			[ $# -eq 0 ] && break
		done
	fi

	# create stage/archive directories if needed
	[ ! -d "${OVE_STAGE_DIR}" ] && mkdir -p "${OVE_STAGE_DIR}"
	[ ! -d "${OVE_ARCHIVE_DIR}" ] && mkdir -p "${OVE_ARCHIVE_DIR}"

	return 0
}

function ove_build_post {
	local rm

	if [ -d ${OVE_STAGE_DIR} ] && \
		[ "$(find ${OVE_STAGE_DIR} -maxdepth 1)" == "${OVE_STAGE_DIR}" ]; then
		rm+="${OVE_STAGE_DIR} "
	fi

	if [ -d ${OVE_ARCHIVE_DIR} ] && \
		[ "$(find ${OVE_ARCHIVE_DIR} -maxdepth 1)" == "${OVE_ARCHIVE_DIR}" ]; then
		rm+="${OVE_ARCHIVE_DIR} "
	fi

	[ "${rm}" != "" ] && rmdir ${rm}
}

# buildme:[PROJECT...]:build project(s) from scratch (=bootstrap, configure, build, install)
function ove-buildme {
	local b
	local build_list
	local index
	local n
	local p
	local pack_list
	local re

	if ! ove_build_pre "$@"; then
		return 1
	fi

	trap ove_build_post EXIT

	if [ $# -ge 1 ]; then
		for p in "$@"; do
			if ! [[ -v ove_projects_name2index[${p}] ]]; then
				ove_echo_error_noprefix "unknown project '${p}'"
				return 1
			fi
		done

		build_list="$(ove_get_deps_recursive "$@") $*"
		build_list="$(xargs -n1 <<<${build_list} | sort -u | xargs)"
	fi

	for b in ${OVE_BUILD_ORDER}; do
		if [ $# -ge 1 ]; then
			re=\\b${b}\\b
			if ! [[ "${build_list}" =~ ${re} ]]; then
				continue
			fi
		fi

		index=${ove_projects_name2index[${b}]}
		for n in ${ove_projects_needs[${index}]}; do
			pack_list+="${n} "
		done
	done

	# install packages
	if [ "${pack_list}" != "" ]; then
		if ! ove_install_packages ${pack_list}; then
			ove_echo_error_noprefix "${FUNCNAME[0]}: missing package(s)"
			return 1
		fi
	fi

	# bootstrap
	for b in ${OVE_BUILD_ORDER}; do
		if [ $# -ge 1 ]; then
			re=\\b${b}\\b
			if ! [[ "${build_list}" =~ ${re} ]]; then
				continue
			fi
		fi

		! [ -e "${OVE_PROJECT_DIR}/projects/${b}/bootstrap" ] && continue

		if [ "$(type -t ove-bootstrap)" == "function" ] && \
			! eval ove-bootstrap ${b} ${OVE_REDIRECT_OUTPUT}; then
			ove_echo_error_noprefix "${FUNCNAME[0]}: ove-bootstrap ${b} failed"
			return 1
		fi
	done

	for b in ${OVE_BUILD_ORDER}; do
		if [ $# -ge 1 ]; then
			re=\\b${b}\\b
			if ! [[ "${build_list}" =~ ${re} ]]; then
				continue
			fi
		fi

		for p in configure build install; do
			if [ "$(type -t ove-${p})" == "function" ] && \
				! eval ove-${p} ${b} ${OVE_REDIRECT_OUTPUT}; then
				ove_echo_error_noprefix "${FUNCNAME[0]}: ove-${p} ${b} failed"
				return 1
			fi
		done
	done

	return 0
}

# buildme-parallel:[PROJECT...]:build project(s) from scratch (=bootstrap, configure, build, install)
function ove-buildme-parallel {
	local b
	local build_list
	local dep
	local inotify_max_user_instances
	local n
	local p
	local pack_list
	local pid
	local pids
	local re
	local wait_for_deps

	if ! ove_build_pre "$@"; then
		return 1
	fi

	trap ove_build_post EXIT

	if [ $# -ge 1 ]; then
		for p in "$@"; do
			if ! [[ -v ove_projects_name2index[${p}] ]]; then
				ove_echo_error_noprefix "unknown project '${p}'"
				return 1
			fi
		done

		build_list="$(ove_get_deps_recursive "$@") $*"
		build_list="$(xargs -n1 <<<${build_list} | sort -u | xargs)"
	fi

	for b in ${OVE_BUILD_ORDER}; do
		if [ $# -ge 1 ]; then
			re=\\b${b}\\b
			if ! [[ "${build_list}" =~ ${re} ]]; then
				continue
			fi
		fi

		index=${ove_projects_name2index[${b}]}
		for n in ${ove_projects_needs[${index}]}; do
			pack_list+="${n} "
		done
	done

	# install packages
	if [ "${pack_list}" != "" ]; then
		if ! ove_install_packages ${pack_list}; then
			ove_echo_error_noprefix "${FUNCNAME[0]}: missing package(s)"
			return 1
		fi
	fi

	# bootstrap
	for b in ${OVE_BUILD_ORDER}; do
		if [ $# -ge 1 ]; then
			re=\\b${b}\\b
			if ! [[ "${build_list}" =~ ${re} ]]; then
				continue
			fi
		fi

		! [ -e "${OVE_PROJECT_DIR}/projects/${b}/bootstrap" ] && continue

		{
			if [ "$(type -t ove-bootstrap)" == "function" ] && \
				! eval ove-bootstrap ${b} ${OVE_REDIRECT_OUTPUT}; then
				ove_echo_error_noprefix "${FUNCNAME[0]}: bootstrap ${b} failed"
				kill -USR1 $$
			fi
		} &
		pids+="$! "
	done

	wait ${pids}
	pids=""

	# pids db
	declare -A pids_db=()

	inotify_max_user_instances=$(($(cat /proc/sys/fs/inotify/max_user_instances) - 20))
	for b in ${OVE_BUILD_ORDER}; do
		if [ $# -ge 1 ]; then
			re=\\b${b}\\b
			if ! [[ "${build_list}" =~ ${re} ]]; then
				continue
			fi
		fi

		wait_for_deps=""
		for dep in $(ove_get_deps_recursive ${b}); do
			if ! [ -e /proc/${pids_db[${dep}]} ]; then
				pids_db[${dep}]=""
				continue
			fi

			wait_for_deps+="${pids_db[${dep}]} "
		done

		{
			for p in ${wait_for_deps}; do
				tail -s 0.01 --pid=${p} -f /dev/null &
			done
			[ "${wait_for_deps}" != "" ] && wait

			for p in configure build install; do
				if [ "$(type -t ove-${p})" == "function" ] && \
					! eval ove-${p} ${b} ${OVE_REDIRECT_OUTPUT}; then
					ove_echo_error_noprefix "${FUNCNAME[0]}: ${p} ${b} failed"
					kill -USR1 $$
				fi
			done
		} &
		pid=$!
		pids_db[${b}]=${pid}
		pids+=" ${pid}"

		while true; do
			if [ $(pgrep -f 'tail -s 0.01' | wc -l) -gt ${inotify_max_user_instances} ]; then
				sleep 0.1
				continue
			fi
			break
		done
	done

	wait ${pids}

	return 0
}

# diff-check:[OPTIONS]:git diff --check [OPTIONS]
function ove-diff-check {
	local cmd

	cmd="echo \${PWD}; git --no-pager -C \${git} diff --check $* -- \$(git -C \${git} diff --name-only)"
	ove_revtab_forall "${cmd}"
}

# list-repositories: :list all git repositories
function ove-list-repositories {
	ove_revtab_list
}

# env:[PATTERN]:show OVE env
function ove-env {
	local e
	local str
	local v

	if [ $# -eq 0 ]; then
		v=$(compgen -A variable | grep OVE_)
	else
		v=$(compgen -A variable | grep OVE_ | grep -i $1)
	fi

	for e in ${v}; do
		str+="${e}:${!e}\n"
	done

	printf "${str}" | \
		sort | \
		column -t -s:
}

# status:[GIT...]:git status -zbs -uno for all/specified repositories
function ove-status {
	# turn off monitor mode to get rid of "Done" messages
	set +m

	ove_revtab_status "$@" | \
		grep -v '^\['

	# turn on monitor mode
	set -m
}

# news:[GIT...]:list upstream changes for all/specified repositories
function ove-news {
	if [ -w "${OVE_PROJECT_STATE_DIR}" ]; then
		ove_revtab_status_parse behind "$@" | tee ${OVE_PROJECT_STATE_DIR}/revtab-news
	else
		ove_revtab_status_parse behind "$@"
	fi
}

# show-news:[GIT...]:run 'ove show' on upstream changes for all/specified repositories
function ove-show-news {
	local sha_list

	# refresh news
	ove-news "$@" > /dev/null

	sha_list="$(grep -o '^[a-f0-9]\+' ${OVE_PROJECT_STATE_DIR}/revtab-news | tac)"
	[ "${sha_list}" == "" ] && return

	ove-show ${sha_list}
}

# ahead:[GIT...]:list local commits not yet published for all/specified repositories
function ove-ahead {
	if [ -w "${OVE_PROJECT_STATE_DIR}" ]; then
		ove_revtab_status_parse ahead "$@" | tee ${OVE_PROJECT_STATE_DIR}/revtab-ahead
	else
		ove_revtab_status_parse ahead "$@"
	fi
}

# show-ahead:[GIT...]:run 'ove show' on local commits not yet published for all/specified repositories
function ove-show-ahead {
	local sha_list

	# refresh ahead
	ove-ahead "$@" > /dev/null

	sha_list="$(grep -o '^[a-f0-9]\+' ${OVE_PROJECT_STATE_DIR}/revtab-ahead | tac)"
	[ "${sha_list}" == "" ] && return

	ove-show ${sha_list}
}

# reset-ahead: :git reset --hard HEAD~N where N is #commits ahead for ALL repositories
function ove-reset-ahead {
	ove-ahead | \
		sed -r \
		-e "s/\x1b\[1;3[0-9];7m//g" \
		-e "s/\x1b\[[0-9]+m//g" \
		-e "s/\x1b\[m//g" | \
		grep --color=never ': [0-9]\+ new commit' | \
		while IFS=' ' read -r repo n foo bar; do
			repo=${repo/:/}
			git -C ${OVE_BASE_DIR}/${repo} reset --hard HEAD~${n} |& sed -e "s/^/${repo}: /g"
		done
}

# format-patch:[NAME]:create a bz2 archive for all local commits not yet published
function ove-format-patch {
	local d
	local file

	d="${OVE_PROJECT_TMP_DIR}/format-patch"
	mkdir -p ${d}
	find ${d} -mindepth 1 -maxdepth 1 -type d -exec rm -rf {} \;

	ove-ahead | \
		sed -r \
		-e "s/\x1b\[1;3[0-9];7m//g" \
		-e "s/\x1b\[[0-9]+m//g" \
		-e "s/\x1b\[m//g" | \
		grep --color=never ': [0-9]\+ new commit' | \
		while IFS=' ' read -r repo n foo bar; do
			repo=${repo/:/}
			mkdir -p ${d}/${repo}
			git -C ${OVE_BASE_DIR}/${repo} format-patch -q -${n} -o ${d}/${repo}
		done

	[ $(find ${d} -type f | wc -l) -eq 0 ] && return || tree -a "${d}"

	echo
	if [ $# -eq 1 ]; then
		file="$1"
	else
		file="${PWD}/${OVE_PROJECT_NAME}-patches-$(date '+%Y%m%d-%H%M%S').tar.bz2"
	fi

	tar -C "${d}" -cjf "${file}" .
	ls -lh "${file}"
}

# am:FILE:apply a bz2 archive file created with 'format-patch'
function ove-am {
	local d
	local r
	local repos

	[ $# -eq 1 ] || return 1
	[ -e $1 ] || return 2

	d="${OVE_PROJECT_TMP_DIR}/am"
	mkdir -p ${d}
	find ${d} -mindepth 1 -maxdepth 1 -type d -exec rm -rf {} \;

	# unpack
	tar -C "${d}" -xf "$1" || return 3

	repos=$(find ${d} -type f -print0 | xargs -0 dirname | sort -u)
	[ "${repos}" == "" ] && return 4
	for r in ${repos}; do
		r=${r/${d}\/}

		ove_echo_yellow_noprefix ${r}
		# apply patch(es)
		if ! git -C ${OVE_BASE_DIR}/${r} am ${d}/${r}/*; then
			git -C ${OVE_BASE_DIR}/${r} am --abort
		fi
	done
}

# pull:[GIT...]:git pull --rebase for all/specified repositories
function ove-pull {
	local git
	local repos

	# turn off monitor mode to get rid of "Done" messages
	set +m

	if [ $# -ge 1 ]; then
		repos=$(ove_validate_repo_list ${*//${OVE_BASE_DIR}\/})
	elif [ -e ${OVE_PROJECT_STATE_DIR}/revtab-status ] && grep -q 'behind.*]' ${OVE_PROJECT_STATE_DIR}/revtab-status; then
		repos=$(grep 'behind.*]' ${OVE_PROJECT_STATE_DIR}/revtab-status | \
			cut -d: -f1 | \
			xargs)
	else
		repos=${OVE_REPO_LIST//${OVE_BASE_DIR}\/}
	fi

	for git in ${repos}; do
		ove_revtab_pull_one ${git} | grep -v '^\['

		if [ "${git##*/}" == "${OVE_PROJECT_NAME}" ]; then
			ove_revtab_check
		fi
	done

	if [ "${repos}" != "" ]; then
		ove_revtab_status ${repos} | grep -v '^\['
	fi

	# turn on monitor mode
	set -m
}

# apply:PATCH:apply one OVE patch
function ove-apply {
	local git_basename
	local lineno
	local p
	local patches
	local q

	if [ $# -ne 1 ]; then
		ove-help "^${FUNCNAME/ove-/} "
		return 1
	fi

	if ! command -v csplit > /dev/null; then
		ove_echo_error_noprefix "command 'csplit' not found"
		return 1
	fi

	if ! [ -e "$1" ]; then
		ove_echo_error_noprefix "'$1' patch file not found"
		return 1
	fi

	if ! [ -s "$1" ]; then
		ove_echo_error_noprefix "'$1' is empty"
		return 1
	fi

	cp -a "$1" "${OVE_PROJECT_TMP_DIR}"
	cd ${OVE_PROJECT_TMP_DIR} || return 1
	p="${OVE_PROJECT_TMP_DIR}/$(basename $1)"

	# get a list of line numbers where to split the file
	lineno=$(grep -n "${ove_yellow_x}" "${p}"| tail -n +2 | cut -d: -f1 | xargs)

	# remove color codes
	sed -i \
		-r \
		-e "s/\x1b\[1;3[0-9];7m//g" \
		-e "s/\x1b\[[0-9]+m//g" \
		-e "s/\x1b\[m//g" ${p}

	if ! file "${p}" | grep -q "unified diff"; then
		ove_echo_error_noprefix "'${p}' is not a unified diff"
		return 1
	fi

	# remove any old patch file(s)
	find ${PWD} -maxdepth 1 -name 'ove-apply-patch*' -exec rm {} \;

	if [ "${lineno}" == "" ]; then
		patches=${p}
	else
		# one patch per git
		if ! csplit -s -z --prefix ove-apply-patch ${p} ${lineno}; then
			ove_echo_error_noprefix "ops, csplit failed"
			return 1
		fi

		patches=$(find ${PWD} -maxdepth 1 -name 'ove-apply-patch*' | sort)
	fi

	for p in ${patches}; do
		git_basename=$(head -1 -q ${p})
		git_basename=${git_basename/${OVE_BASE_DIR}\/}
		git_fullpath=$(ove_git2fullpath ${git_basename})
		if [ "${git_fullpath}" == "" ] || ! [ -d "${git_fullpath}" ]; then
			ove_echo_error_noprefix "'${git_basename}': unknown git, next..."
			continue
		fi

		# rename the patch
		q="${OVE_PROJECT_TMP_DIR}/ove-apply-${git_basename////-}.patch"
		mv ${p} ${q}
		if [ -d "${git_fullpath}" ] && \
			[ -d ${git_fullpath}/.git ]; then
			# Run 'git apply --check' and if ok, apply the patch
			if ! git -C "${git_fullpath}" apply --check ${q} 2> /dev/null; then
				ove_echo_yellow_noprefix "${git_basename}: patch '${ove_yellow}${q}${ove_blank}' does not apply without errors"
				continue
			fi

			# apply the patch
			git -C "${git_fullpath}" apply ${q}
		fi
	done

	return 0
}

function ove_patch_repositories {
	! [ -d ${OVE_PROJECT_DIR}/patches ] && return

	# shellcheck disable=SC2016
	ove_revtab_forall '[ -d ${OVE_PROJECT_DIR}/patches/${git_basename} ] &&
		for p in $(find ${OVE_PROJECT_DIR}/patches/${git_basename} -name "*.patch"); do
			if git -C ${git} apply --check $p 2> /dev/null; then
				echo "${git_basename}: apply patch: $p"
				git -C ${git} apply $p 2> /dev/null
			fi
		done'
}

# gitmodules2revtab: :import git submodules
function ove-gitmodules2revtab {
	local repo
	local repos_with_submodules
	local sha
	local submodule

	for repo in ${OVE_REPO_LIST}; do
		[ -s ${repo}/.gitmodules ] && repos_with_submodules+="${repo} "
	done

	[ "${repos_with_submodules}" == "" ] && return

	for repo in ${repos_with_submodules}; do
		for submodule in $(git -C ${repo} submodule--helper list | awk '{print $4}'); do
			url=$(git -C ${repo} config --file .gitmodules --list | \
				grep "^submodule.${submodule}.url=" | \
				cut -d= -f2)
			[ "${url}" == "" ] && continue

			sha=$(git -C ${repo} submodule--helper list | \
				awk '{print $4,$2}' | \
				grep "^${submodule} " | awk '{print $2}')
			[ "${sha}" == "" ] && continue

			echo "${repo//${OVE_BASE_DIR}\/}/${submodule} ${url} ${url} ${sha}"
		done
	done >> ${OVE_PROJECT_DIR}/revtab

	# sort and prettify
	LC_ALL="C" sort -u -o ${OVE_PROJECT_DIR}/revtab <(column -t ${OVE_PROJECT_DIR}/revtab)
}

# do:DIR COMMAND:run a command within DIR relative to ${OVE_BASE_DIR}
function ove-do {
	local cmd
	local dir

	dir=${1/${OVE_BASE_DIR}}
	cmd="${*:2}"

	if ! [ -d "${OVE_BASE_DIR}/${dir}" ]; then
		ove_echo_error_noprefix "'${OVE_BASE_DIR}/${dir}' is not a directory"
		return 1
	fi

	cd ${OVE_BASE_DIR}/${dir} && eval "${cmd}"
}

# fetch:[GIT...]:git fetch --all for all/specified repositories, ends with ove status
function ove-fetch {
	local repos

	if [ $# -ne 0 ]; then
		repos=$(ove_validate_repo_list "$@")
		[ "${repos}" == "" ] && return 1
	fi

	if ! ove_revtab_fetch ${repos}; then
		return $?
	fi

	[ $# -eq 0 ] && ove_patch_repositories

	echo
	ove-status ${repos}
}

# tag: :list all project tags
function ove-tag {
	git -C "${OVE_PROJECT_DIR}" log --tags --simplify-by-decoration --pretty="format:%ai %D"
}

# log: :project commit log for branch '${OVE_PROJECT_CI_BRANCH}'
function ove-log {
	local b

	if git -C "${OVE_PROJECT_DIR}" branch -r | grep -q ${OVE_PROJECT_CI_BRANCH}; then
		b="${OVE_PROJECT_CI_BRANCH}"
	fi

	git -C "${OVE_PROJECT_DIR}" log --decorate ${b}
}

# checkout:[rev[ [purge|autostash]]]:git checkout -p for all git repositories OR checkout a new project revision, use 'purge' with care
function ove-checkout {
	local cmd
	local dirty_repos
	local m
	local proj
	local repo
	local rev

	rev="$1"

	if [ $# -eq 0 ]; then
		dirty_repos=$(ove_dirty_repos)

		# shellcheck disable=SC2016
		cmd='git -C ${git} diff --quiet || (ove_echo_yellow_noprefix ${git_basename}; git -C ${git} checkout -p)'
		ove_revtab_forsome "${cmd}" "${dirty_repos}"

		[[ "${dirty_repos}" =~ ${OVE_PROJECT_NAME} ]] && ove_reinit
	elif [ $# -eq 1 ] || [ $# -eq 2 ]; then
		if [ "$2" == "purge" ]; then
			# shellcheck disable=SC2016
			cmd='git -C ${git} reset; git -C ${git} checkout .'

			read -p "Proceed to run '${cmd}' for all git repositories? (y/N) " -r
			echo
			if [[ ${REPLY} =~ ^[Yy]$ ]]; then
				read -p "Are you really sure? (y/N) " -r
				echo
				if [[ ${REPLY} =~ ^[Yy]$ ]]; then
					ove_revtab_forall "${cmd}"
				fi
			fi
		elif [ "$2" == "autostash" ]; then
			dirty_repos=$(ove_dirty_repos)

			for repo in ${dirty_repos}; do
				git -C "${repo}" stash save -q "stashed by ove-checkout"
			done
		else
			dirty_repos=$(ove_dirty_repos)

			if [ "${dirty_repos}" != "" ]; then
				ove_echo_error_noprefix "you have staged/unstaged changes in the following repositories:"
				ove-status ${dirty_repos}
				return 1
			fi
		fi

		git -C "${OVE_PROJECT_DIR}" fetch --all

		m=$(xargs -n1 <<<${OVE_REPO_LIST//${OVE_BASE_DIR}\/} | wc -L)
		git -C "${OVE_PROJECT_DIR}" -c advice.detachedHead=false checkout "${rev}" |& \
			sed -e "1s|^|$(ove_echo_yellow_noprefix ${OVE_PROJECT_NAME})$(printf "%0.s " $(eval echo {1..$((${m} + 2 - ${#OVE_PROJECT_NAME}))}))|g" \
			-e "2s|^|$(printf "%0.s " $(eval echo {1..$((${m} + 2))}))|g"
		if [ ${PIPESTATUS[0]} -ne 0 ]; then
			# cleanup
			if [ "$2" == "autostash" ]; then
				for repo in ${dirty_repos}; do
					git -C "${repo}" stash pop -q
				done
			fi

			return 1
		fi

		echo ---

		# init everything
		ove_init

		# clone and checkout
		ove_revtab_clone_and_checkout

		# validate revtab revision
		ove_revtab_check

		if [ "$2" == "autostash" ]; then
			for repo in ${dirty_repos}; do
				git -C "${repo}" stash pop -q
			done
		fi

		ove_patch_repositories
	fi
}

# list-commands: :list commands
function ove-list-commands {
	local a
	local b

	a=$(grep -B1 "^function ove-" "${OVE_BASE_DIR}"/ove | \
		grep '\#' | \
		cut -b3-| \
		sort)
	b=$(set | \
		grep helptext | \
		grep -v '\$'| \
		cut -d'"' -f2)

	printf "${a}\n${b}" | \
		sort | \
		column -s: -t
}

# help:[PATTERN]:OVE help
function ove-help {
	local h
	local longest_argument
	local longest_function
	local longest_function_project
	local nbr_of_hypens

	if [ $# -ne 0 ]; then
		for h in "$@"; do
			ove-help | grep -E --color=always "${h}"
		done
		return 0
	fi

	longest_function=$(grep -B1 "^function ove-" ${OVE_SELF} | \
		grep '\#' | \
		cut -b3- | \
		cut -d: -f1 | \
		wc -L)
	longest_function_project=$(set | \
		grep helptext | \
		grep -v '\$' | \
		cut -d'"' -f2 | \
		cut -d: -f1 | \
		wc -L)
	longest_argument=$(grep -B1 "^function ove-" ${OVE_SELF} | \
		grep '\#' | \
		cut -b3- | \
		cut -d: -f2 | \
		wc -L)
	longest_argument_project=$(set | \
		grep helptext | \
		grep -v '\$' | \
		cut -d'"' -f2 | \
		cut -d: -f2 | \
		wc -L)
	longest=${longest_function}
	longest_a=${longest_argument}
	[ ${longest_function_project} -gt ${longest_function} ] && longest=${longest_function_project}
	[ ${longest_argument_project} -gt ${longest_argument} ] && longest_a=${longest_argument_project}
	nbr_of_hypens=$((longest + longest_a + 15))
	printf "%-"$((longest + 2))"s%-"$((longest_a + 2))"s%7s%s\n" "Command" "Arguments" "Description"
	printf "%0.s-" $(eval echo {1..${nbr_of_hypens}})
	echo
	ove-list-commands
	echo
	cat <<EOF

Examples
=====

Build
-----
# Do the initial build
#
# Steps performed for each project: bootstrap, configure, build, install

	$ ove buildme

# Build all projects in order. 'clean' will be performed if needed.
#
# Steps performed for each project: [clean], build, install

	$ ove make

# Build a specific project and all project dependencies. 'clean' will be performed if needed.
#
# Steps performed for each project: [clean], make, make install

	$ ove make projA

# Clean all projects.
#
# Steps performed for each project: clean

	$ ove clean

# Properly remove all files for all git repositories.
#
# Steps performed for each repository: git clean -dffx

	$ ove mrproper

Source control
--------------
# Status of all git repositories
#
# Steps performed for each repository: git status -zbs -uno

	$ ove status

# Synchronize with the outside world
#
# Steps performed for each repository: git fetch --all

	$ ove fetch

# Curious mind? List patches your friends have upstreamed since your last pull.

	$ ove news

# Checkout revision

	$ ove checkout 1.0.2

# Search all git repositories
#
# Steps performed for each repository: git grep

	$ ove grep DEADBEEF
EOF

	# Project specific help text
	if [ -e "${OVE_PROJECT_DIR}"/help ]; then
		echo
		echo "Project '${OVE_PROJECT_NAME}' help"
		printf "%0.s-" $(eval echo {1..$(($(echo ${OVE_PROJECT_NAME} | wc -L) + 15))})
		echo
		cat "${OVE_PROJECT_DIR}/help"
	fi
}

# ag:PATTERN:search OVE workspace using The Silver Searcher [duckduckgo.com/?q=The+Silver+Searcher]
function ove-ag {
	if ! command -v ag > /dev/null; then
		return 1
	fi

	[ $# -eq 0 ] && echo "No pattern, try again" && return 1

	ove_revtab_forall_parallel 'ag --color "'"$*"'" | sed -e 's@^@\${PWD}/@g''
}

# grep:PATTERN:grep OVE workspace
function ove-grep {
	[ $# -eq 0 ] && echo "No pattern, try again" && return 1
	# shellcheck disable=SC2016
	ove_revtab_forall_parallel 'git --no-pager -C ${git} grep --color=always "'"$*"'" | sed -e 's@^@\${PWD}/@g''
}

# blame-history:PATTERN:git log -S for all git repositories
function ove-blame-history {
	[ $# -eq 0 ] && echo "No pattern, try again" && return 1
	# shellcheck disable=SC2016
	ove_revtab_forall 'git --no-pager -C ${git} log --color=always -p -S "'"$*"'"'
}

# blame:PATTERN:git grep-blame-log combo
function ove-blame {
	local file
	local git
	local i
	local line
	local res
	local s
	local sha
	local str

	[ $# -eq 0 ] && ove_echo_error_noprefix "no pattern, try again" && return 1

	s="$*"

	if [ "${OVE_REPO_LIST}" == "" ]; then
		echo "run 'ove fetch' first!"
		return 1
	fi

	for git in ${OVE_REPO_LIST}; do
		! [ -d "${git}" ] && continue
		mapfile -t res < <(git -C "${git}" --no-pager grep --no-color -I -n "${s}" | cut -d: -f1,2)

		for i in "${res[@]}"; do
			file=$(cut -d: -f1 <<<"${i}")
			line=$(cut -d: -f2 <<<"${i}")
			sha=$(git -C "${git}" --no-pager blame -L"${line}","${line}" "${file}" | cut -d' ' -f1)
			str="${git}/${file}:${line}"
			if [ "${sha}" == "00000000" ]; then
				str+=" [ Not Committed Yet ]"
			fi
			if [ "${sha}" != "00000000" ]; then
				git -C "${git}" --no-pager log --color=always -1 "${sha}"
			fi
			echo
			head -"${line}" "${git}"/"${file}" | \
				tail -1 | \
				grep --color=always "${s}" | \
				sed -e 's/^/    /g'
			echo
			echo "    File: ${str}"
			echo
		done
	done
}

# config:[CONFIG]:show or manipulate .oveconfig
function ove-config {
	local cfg
	local cfg_diff
	local d
	local grep_pattern
	local var

	if [ -e "${HOME}/.oveconfig" ]; then
		cfg=${HOME}/.oveconfig
		cfg_diff="$(diff -y --suppress-common-lines ${HOME}/.oveconfig <(git -C ${OVE_PROJECT_DIR} show HEAD:.oveconfig) \
			| awk '{print $1}')"
	elif [ -e "${OVE_PROJECT_DIR}/.oveconfig" ]; then
		cfg=${OVE_PROJECT_DIR}/.oveconfig
		cfg_diff="$(git -C ${OVE_PROJECT_DIR} diff --no-color -U1 --raw ${OVE_PROJECT_DIR}/.oveconfig | \
			grep '^+[A-Z]\+'| \
			cut -b2- | \
			awk '{print $1}')"
	else
		return
	fi

	grep_pattern="$"
	for d in ${cfg_diff}; do
		grep_pattern+="|${d} "
	done

	if [ $# -eq 0 ]; then
			grep -v '^#' ${cfg} | \
				grep -v '^$' | \
				sort | \
				grep -E --color "${grep_pattern}"
	elif [ $# -eq 1 ]; then
		if ! grep -q -i $1 ${cfg}; then
			echo "error: pattern '$1' not found"
		else
			grep_pattern+="|$1"
			grep -v '^#' ${cfg} | \
				grep -v '^$' | \
				grep -i $1 | \
				grep -E --color "${grep_pattern}"
		fi
	elif [ $# -gt 1 ]; then
		var=$1
		shift
		if grep -q -w ${var} ${cfg}; then
			sed -i -e "s|\(^${var}\s\+\).*|\1$*|g" ${cfg}
			ove_config_init
			ove-config ${var}
		else
			echo "error: config '${var}' not found"
		fi
	fi
}

# ls-files:[PATTERN]:git ls-files for all git repositories
function ove-ls-files {
	local cmd

	if [ $# -eq 0 ]; then
		# shellcheck disable=SC2016
		cmd='git -C ${git} ls-files | while read line; do echo -e ${PWD}/${line}; done'
	else
		# shellcheck disable=SC2016
		cmd="re=$*; git -C \${git} ls-files | while read line; do [[ \${PWD}/\${line} =~ \${re} ]] && echo -e \${PWD}/\${line}; done"
	fi

	ove_revtab_forall_parallel "${cmd}" | sort
}

# list-modified-files: :list modified files
function ove-list-modified-files {
	local cmd

	# shellcheck disable=SC2016
	cmd='git --no-pager -C ${git} diff-index --quiet HEAD || git -C ${git} diff --name-only HEAD | sed -e "s|^|${git}/|g"'

	ove_revtab_forsome_parallel "${cmd}" "$(ove_dirty_repos)" | LC_ALL="C" sort -u
}

# list-committed-files:[DAYS]:list committed files within 7 or DAYS day(s)
function ove-list-committed-files {
	local cmd
	local days

	[ $# -eq 1 ] && days="$1" || days=7

	# shellcheck disable=SC2016
	cmd='git --no-pager -C ${git} log --all --no-merges --author="$(git config --get user.name)" --name-only --pretty=format:"" --since="'${days}' days" | while read line; do [ -f ${PWD}/${line} ] && echo -e ${PWD}/${line}; done'

	ove_revtab_forall "${cmd}" | sort -u
}

function ove_edit {
	declare -A f_hash
	local editor
	local f
	local files
	local files_by_epoch

	files=$(ove-list-modified-files)

	[ "${files}" == "" ] && return

	editor="$1"
	shift

	# sanity check
	if ! command -v ${editor} > /dev/null; then
		ove_echo_stderr_noprefix "${editor} is not installed?"
		return 1
	fi

	# stat every file
	files_by_epoch=$(for f in ${files}; do echo $(stat --format '%Y' ${f}):${f}; done | \
		sort -r | \
		cut -d: -f2)

	if [ $# -eq 0 ]; then
		files="${files_by_epoch}"
	else
		f=
		while [ $# -ne 0 ]; do
			test "${f_hash["${1}"]+isset}" && shift && continue
			f_hash["${1}"]=1
			f+=$(printf "${files_by_epoch}" | \
				sed -e "s|${OVE_BASE_DIR}/||g" | \
				grep -i $1 | \
				sed -e "s|^|${OVE_BASE_DIR}/|g")
			f+=" "
			shift
		done

		files="${f}"
	fi

	if [ "${files}" != "" ]; then
		if [ "${editor}" == "vi" ]; then
			vi -o ${files} -c "wincmd H"
		elif [ "${editor}" == "emacs" ]; then
			emacs ${files}
		else
			ove_echo_stderr_noprefix "unknown editor"
		fi
	fi
}

# emacs:[PATTERN|FILE...]:open modified files in emacs
function ove-emacs {
	ove_edit emacs "$@"
}

# vi:[PATTERN|FILE...]:open modified files in vi
function ove-vi {
	ove_edit vi "$@"
}

# mrproper:[y|Y]:remove untracked files AND removes '${OVE_STAGE_DIR}/*' AND removes '${OVE_ARCHIVE_DIR}/*', use with care
function ove-mrproper {
	local archive_dir_size
	local directories
	local directories_uniq
	local nbr_untracked_files
	local o
	local objects
	local repo_sub_dirs
	local stage_dir_size

	nbr_untracked_files=$(ove_revtab_forall_parallel 'git clean -dffxn'| wc -l)
	stage_dir_size="$(tree ${OVE_STAGE_DIR} | tail -1)"
	archive_dir_size="$(tree ${OVE_ARCHIVE_DIR} | tail -1)"

	if [ "$1" == "y" ] || [ "$1" == "Y" ]; then
		# shellcheck disable=SC2016
		ove_revtab_forall 'git --no-pager -C ${git} clean -dffx > /dev/null'
		! [ "${OVE_STAGE_DIR}" == "" ] && rm -rf ${OVE_STAGE_DIR:?}/*
		! [ "${OVE_ARCHIVE_DIR}" == "" ] && rm -rf ${OVE_ARCHIVE_DIR:?}/*

		if [ "$1" == "Y" ]; then
			# untracked directories

			# list of sub directories where we have git repositories
			sub_dirs=$(for a in ${OVE_REPO_LIST}; do echo ${a/${OVE_BASE_DIR}\//}; done | grep '/')

			if [ "${sub_dirs}" != "" ]; then
				repo_sub_dirs=$(echo ${sub_dirs} | \
					xargs -n1 dirname | \
					sort -u | \
					sed -e "s|^|${OVE_BASE_DIR}/|g")
			fi

			# find some directories
			directories=$(find $(readlink -f ${OVE_BASE_DIR}) ${repo_sub_dirs} -maxdepth 1 -mindepth 1 -type d | \
				sort)


			if [ "${sub_dirs}" == "" ]; then
				directories_uniq=$(find $(readlink -f ${OVE_BASE_DIR}) -maxdepth 1 -mindepth 1 -type d | sort)
			else
				# remove common paths
				directories_uniq=$(comm -3 \
					<(printf "%s\n" ${repo_sub_dirs}) \
					<(printf "%s\n" ${directories}) | \
					xargs -n1)
			fi

			# now we can start to identify directories that can be removed
			for o in $(comm -3 \
				<(echo ${OVE_REPO_LIST} | tr ' ' '\n' | xargs readlink -f | sort) \
				<(printf "%s\n" ${directories_uniq}) | \
				grep -Ev "archives$|stage$|${OVE_DIR}"); do
				[ -d ${o} ] && objects+="${o} "
			done

			# untracked files
			for o in $(find $(readlink -f ${OVE_BASE_DIR}) ${repo_sub_dirs} -maxdepth 1 -mindepth 1 -type f); do
				objects+="${o} "
			done

			if [ "${objects}" != "" ]; then
				echo ${objects} | \
					tr ' ' '\n' | \
					sort | \
					xargs file
				echo
				read -p "Proceed to remove $(echo ${objects} | wc -w) files/directories (list above) using 'rm -rf'? (y/N) " -r
				echo
				if [[ ${REPLY} =~ ^[Yy]$ ]]; then
					read -p "Are you really sure? (y/N) " -r
					echo
					if [[ ${REPLY} =~ ^[Yy]$ ]]; then
						rm -rfv ${objects}
					fi
				fi
			fi
		fi

		return
	fi

	if [ "${nbr_untracked_files}" -ne 0 ]; then
		# dry-run first
		# shellcheck disable=SC2016
		ove_revtab_forall 'a=$(git --no-pager -C ${git} clean -dffxn); [ "${a}" != "" ] && printf "${a}\n" | sed -e "s|Would remove \(.*\)$|${PWD}/\1|g"'
		echo
		read -p "Proceed to remove ${nbr_untracked_files} untracked files/directories (list above) using 'git clean -dffx'? (y/N) " -r
		if [[ ${REPLY} =~ ^[Yy]$ ]]; then
			echo
			read -p "Are you really sure? (y/N) " -r
			echo
			if [[ ${REPLY} =~ ^[Yy]$ ]]; then
				# shellcheck disable=SC2016
				ove_revtab_forall 'git --no-pager -C ${git} clean -dffx'
			fi
		fi
	fi

	if [ "${stage_dir_size}" != "0 directories, 0 files" ]; then
		# all but the last line
		tree -C ${OVE_STAGE_DIR} | head -n -1

		read -p "Proceed to remove ${stage_dir_size} (list above) from '${OVE_STAGE_DIR}' using 'rm -rf'? (y/N) " -r
		echo
		if [[ ${REPLY} =~ ^[Yy]$ ]]; then
			echo "$ rm -rf ${OVE_STAGE_DIR}/*"
			echo
			read -p "Are you really sure you want to run the above command? (y/N) " -r
			echo
			if [[ ${REPLY} =~ ^[Yy]$ ]]; then
				if ! [ "${OVE_STAGE_DIR}" == "" ]; then
					rm -rf ${OVE_STAGE_DIR:?}/*
				fi
			fi
		fi
	fi

	if [ "${archive_dir_size}" != "0 directories, 0 files" ]; then
		# all but the last line
		tree -C ${OVE_ARCHIVE_DIR} | head -n -1

		read -p "Proceed to remove ${archive_dir_size} (list above) from '${OVE_ARCHIVE_DIR}' using 'rm -rf'? (y/N) " -r
		echo
		if [[ ${REPLY} =~ ^[Yy]$ ]]; then
			echo "$ rm -rf ${OVE_ARCHIVE_DIR}/*"
			echo
			read -p "Are you really sure you want to run the above command? (y/N) " -r
			echo
			if [[ ${REPLY} =~ ^[Yy]$ ]]; then
				if ! [ "${OVE_ARCHIVE_DIR}" == "" ]; then
					rm -rf ${OVE_ARCHIVE_DIR:?}/*
				fi
			fi
		fi
	fi
}

# !:[PATTERN]:view last command output in pager (=${OVE_PAGER}) or print lines matching PATTERN
function ove-! {
	[ -f "${OVE_LAST_COMMAND}" ] || return

	if [ $# -eq 0 ]; then
		${OVE_PAGER} ${OVE_LAST_COMMAND}
		return $?
	fi

	if command -v ag > /dev/null; then
		ag -H -i "$@" ${OVE_LAST_COMMAND}
	else
		echo ${OVE_LAST_COMMAND}
		grep -i "$@" ${OVE_LAST_COMMAND}
	fi
}

# describe:[GIT...]:git describe+log+status combo for all/specified git repositories
function ove-describe {
	local func

	func=ove_revtab_forall_parallel

	[ $# -gt 0 ] && func=ove_revtab_forsome

	# shellcheck disable=SC2016
	${func} 'echo $(echo ${git} | sed -e "s|${OVE_BASE_DIR}/||g")@$(git describe --tags --always --dirty --long)@"$(git log --format="%<(20,trunc)%s" -1)"@"$(git -c color.status=never status -s -uno | tr "\n" " ")"' "$@" |\
		column -t -s'@' | \
		LC_ALL="C" sort
}

# list-heads:[GIT...]:git log for all/specified git repositories
function ove-list-heads {
	local cmd

	# shellcheck disable=SC2016
	cmd='echo $(echo -n "$(echo ${git} | sed -e "s|${OVE_BASE_DIR}/||g")?" && '
	# shellcheck disable=SC2016
	cmd+='git --no-pager -C ${git} log -1 --no-merges --format=%h?%ar?%ae?%s 2> /dev/null)'

	while true; do
		if [ $# -eq 0 ]; then
			ove_revtab_forall_parallel "${cmd}"
		else
			ove_revtab_forsome "${cmd}" "$*"
		fi

		break
	done | LC_ALL="C" sort | column -t -s? 2> /dev/null
}

# ls-remote: :git ls-remote <URL> HEAD for all git repositories
function ove-ls-remote {
	local count
	local git
	local ret
	local sha
	local str
	local url

	count=0
	ret=0
	while ((count < ove_revtab_num_repositories)); do
		git="${ove_revtab_git_name[${count}]}"
		url="${ove_revtab_fetch_url[${count}]}"
		[ "${url}" == "noremote" ] && (( count+=1 )) && continue

		sha=$(git ls-remote ${url} HEAD | awk '{print $1}')
		if [ "${sha}" == "" ]; then
			ove_echo_error_noprefix "ls-remote failed for '${url}'"
			(( ret+=1 ))
		else
			str+="${git}:${sha}\n"
		fi
		(( count+=1 ))
	done

	url=$(git -C "${OVE_PROJECT_DIR}" config --get remote.origin.url)
	if [ "${url}" == "" ] || [ "${url}" == "noremote" ]; then
		:
	else
		sha=$(git -C "${OVE_PROJECT_DIR}" ls-remote ${url} HEAD | awk '{print $1}')
		if [ "${sha}" == "" ]; then
			ove_echo_error_noprefix "ls-remote failed for '${url}'"
			(( ret+=1 ))
		else
			str+="${OVE_PROJECT_NAME}:${sha}\n"
		fi
	fi

	printf "${str}" | \
		LC_ALL="C" sort | \
		column -t -s:

	return ${ret}
}

# heads2revtab:[GIT...]:update 'revtab' with current SHA-1
function ove-heads2revtab {
	local git
	local repos
	local sha_1

	if [ $# -eq 0 ]; then
		repos=$(ove_revtab_list_basename)
	else
		repos=$*
	fi

	for git in ${repos}; do
		sha_1=$(git -C "${OVE_BASE_DIR}"/${git} rev-parse HEAD)
		sed -i -e 's|^'${git}'\(\s\+.*\s\+.*\s\+\)\(.*\)$|'${git}'\1'${sha_1}'|g' "${OVE_PROJECT_DIR}"/revtab
	done

	git --no-pager -C "${OVE_PROJECT_DIR}" diff revtab
}

# head-tail:FILE [NUM]:display first/last 3(=NUM) lines of a text file
function ove-head-tail {
	local c
	local f
	local n

	if [[ $# -eq 0 || $# -gt 2 || ( $# -eq 2 && ! "$2" =~ ^[0-9]+$ ) ]]; then
		ove-help "^${FUNCNAME/ove-/} "
		return 1
	fi

	f=$1
	if ! [ -e ${f} ]; then
		ove_echo_error_noprefix "file '${f}' not found"
		return 1
	fi

	if ! file -bL --mime ${f} |grep -q '^text'; then
		ove_echo_error_noprefix "'${f}' is not a text file, use xxd/hexdump"
		return 1
	fi

	[ $# -eq 1 ] && c=3 || c=$2
	n=$(wc -l <${f})
	if [ ${n} -gt $((c + c)) ]; then
		cat -n ${f} | head -${c}
		echo -e "\t..."
		cat -n ${f} | tail -${c}
	else
		cat -n ${f}
	fi
}

# what-is:DIRECTORY...:classify files using 'file' within a directory
function ove-what-is {
	local dir

	for dir in "$@"; do
		[ ! -d "${dir}" ] && continue
		echo "${dir}":
		find "${dir}" -not -path '*.git*' -print0 | \
			xargs -0 -P"$(nproc)" file | \
			awk '{$1=""; print $0}' | \
			sort | \
			uniq -c | \
			sort -nr
	done
}

# show:[revision...]:ove list-heads or search for 'revision' within all git repositories. If found run 'git show SHA-1|TAG'
function ove-show {
	local SHA

	if [ $# -eq 0 ]; then
		# shellcheck disable=SC2119
		ove-list-heads
		return
	fi

	for SHA in "$@"; do
		# remove dirty tags
		SHA=${SHA%-dirty}
		ove_revtab_forall "git --no-pager -C \${git} show ${SHA} -- &> /dev/null && \
			clear && \
			GIT_PAGER=\"less -Ps'\${git_basename} ${SHA}'\" git -C \${git} show --color=always ${SHA} --"
	done
}

# cd: :helper for 'cd ${OVE_BASE_DIR}'
function ove-cd {
	cd "${OVE_BASE_DIR}"
}

# version: :print OVE version
function ove-version {
	echo "OVE [SHA-1: ${OVE_SHA} @ ${OVE_OS} ${OVE_OS_VER}]"
}

# loglevel:[LEVEL] :show or change loglevel [0-6]
function ove-loglevel {
	local prefix
	local sysctl_f

	set +x
	if [ $# -eq 1 ] && ! [[ "${1}" =~ ^[0-6]$ ]]; then
		echo "error: try 0-6"
		return 1
	elif [ $# -eq 1 ]; then
		if [ $1 -gt 2 ] && [ $1 -lt 7 ]; then
			if ! command -v strace > /dev/null; then
				ove_echo_error_noprefix "'strace' is not found"
				return 1
			fi

			if [ -e /proc/sys/kernel/yama/ptrace_scope ] && [ $(cat /proc/sys/kernel/yama/ptrace_scope) -ne 0 ]; then
				ove_echo_error_noprefix "the kernel does not allow you to trace all processes"
				echo
				echo "To fix this for now:"
				[ $(id -u) != 0 ] && prefix="sudo"
				echo " ${prefix} bash -c 'echo 0 > /proc/sys/kernel/yama/ptrace_scope'"
				echo
				echo "To fix this permanently:"
				sysctl_f=$(grep -l kernel.yama.ptrace_scope /etc/sysctl.d/*)
				if [ "${sysctl_f}" != "" ]; then
					echo " ${prefix} bash -c 'echo 0 > /proc/sys/kernel/yama/ptrace_scope; sed -i -e \"s/kernel.yama.ptrace_scope.*/kernel.yama.ptrace_scope = 0/g\" ${sysctl_f}'"
				else
					echo " ${prefix} bash -c 'echo 0 > /proc/sys/kernel/yama/ptrace_scope; echo \"kernel.yama.ptrace_scope = 0\" > /etc/sysctl.d/10-ptrace.conf'"
				fi
				return 1
			fi
		fi

		OVE_LOGLEVEL=$1
		if [ -w "${OVE_PROJECT_STATE_DIR}" ]; then
			if ! [ -e ${OVE_PROJECT_STATE_DIR}/.oveconfig ]; then
				echo "OVE_LOGLEVEL $1" > ${OVE_PROJECT_STATE_DIR}/.oveconfig
			else
				sed -i "s/^OVE_LOGLEVEL.*/OVE_LOGLEVEL $1/g" ${OVE_PROJECT_STATE_DIR}/.oveconfig
			fi
		fi
	fi

	while true; do
		echo "0: silence is golden"
		echo "1: normal"
		echo "2: debug"
		echo "3: execve timeline"
		echo "4: execve time analysis"
		echo "5: connect analysis"
		echo "6: graph analysis"
		break
	done | grep -E --color "$|${OVE_LOGLEVEL}"

	if [ $# -eq 1 ]; then
		OVE_REDIRECT_OUTPUT=""
		if [ $1 -eq 0 ]; then
			OVE_REDIRECT_OUTPUT="> /dev/null"
		elif [ $1 -eq 1 ]; then
			set +x
		elif [ $1 -eq 2 ]; then
			set -x
		fi
	fi
}

# dry-run:[0|1]:toggle or set OVE_DRY_RUN
function ove-dry-run {
	if [ $# -eq 1 ] && ! [[ "$1" =~ ^[0-1]$ ]]; then
		ove-help ^${FUNCNAME/ove-/}
		return 1
	fi

	if [ $# -eq 0 ]; then
		OVE_DRY_RUN=$((OVE_DRY_RUN ^= 1))
	else
		OVE_DRY_RUN=$1
	fi

	# shellcheck disable=SC2119
	ove-env | grep ^OVE_DRY_RUN
}

# lastlog:[cmin]:list OVE logs created within last 60 min or cmin min
function ove-lastlog {
	local cmin=60

	if [ $# -eq 1 ]; then
		if ! [[ "${1}" =~ ^[0-9]+$ ]]; then
			echo "error: just numbers"
			return 1
		fi

		cmin=$1
	fi

	find ${OVE_LOG_DIR} -type f -cmin -${cmin} -print0 | \
		xargs -0 stat --format '%Y:%n:%s' | \
		sort -nr | \
		cut -d: -f2- | \
		grep -v ${FUNCNAME[0]} | \
		sed "s/\(^.*-ove-\(.*\)-${HOSTNAME}-\(.*\).log\):\(.*\)/\3@\2@\1@\4/g" | \
		column -t -s@
}

# authors: :list author summary for all git repositories
function ove-authors {
	local git

	declare -A urls

	if [ "${OVE_REPO_LIST}" == "" ]; then
		echo "run 'ove fetch' first!"
		return 1
	fi

	for git in ${OVE_REPO_LIST}; do
		if [ ! -d "${git}" ] || [ "${git}" == "${OVE_DIR}" ]; then
			continue
		fi

		# Try to avoid that a git is counted more than one time
		url=$(git --no-pager -C "${git}" remote -v | \
			grep fetch | \
			cut -f2 | \
			cut -d' ' -f1 | \
			uniq | \
			sed -e 's/[^a-zA-Z0-9\-]/_/g' | \
			sed -e 's/_git$//g')

		if [ "${url}" != "" ]; then
			test "${urls["${url}"]+isset}" && continue
			urls["${url}"]=1
		fi

		git --no-pager -C "${git}" log --pretty="%ae"
	done | \
		sort | \
		uniq -c | \
		sort -nr
}

# domains: :list email domain summary for all git repositories
function ove-domains {
	ove-authors | grep '@' | cut -d@ -f2 | sort | uniq -c | sort -nr
}

function ove_bash_complete {
	local cmd
	local cur
	local opts
	local size
	local subcommand
	local wordlist

	# sanity check
	if ! ove_get_base_dir &> /dev/null; then
		return 1
	fi

	if [ "$(type -t ove_verify_checksums)" == "function" ] && ! ove_verify_checksums; then
		return 1
	fi

	COMPREPLY=()

	cur="${COMP_WORDS[COMP_CWORD]}"
	subcommand="${COMP_WORDS[1]}"
	size=$((${#COMP_WORDS[@]} - 1))

	# project commands
	for cmd in ${OVE_PROJECT_COMMANDS}; do
		if [ "${cmd}" == "${subcommand}" ] ||
			[ "${cmd}-parallel" == "${subcommand}" ]; then
			if [ ${size} -ge 2 ]; then
				COMPREPLY=( $(compgen -W "${OVE_PROJECT_LIST}" -- "${cur}") )
				return
			fi
		fi
	done

	# scripts
	for cmd in ${OVE_SCRIPTS_LIST}; do
		if [ "${cmd}" == "${subcommand}" ] && [ -e "${ove_scripts_name2path[${cmd}]}/${cmd}.complete" ]; then
			source "${ove_scripts_name2path[${cmd}]}/${cmd}.complete"
			return
		fi
	done

	# commands without arguments: do nothing
	if [ ${size} -eq 2 ]; then
		if echo ${OVE_BUILT_INS_WITHOUT_ARGS} | tr ' ' '\n' | grep -q ^${subcommand}$; then
			return
		fi
	fi

	wordlist=""
	if [ "${subcommand}" == "make" ]; then
		if [ ${size} -eq 2 ]; then
			wordlist=${OVE_PROJECT_LIST}
		elif [ ${size} -gt 2 ]; then
			return
		fi
	elif [ "${subcommand}" == "buildme" ] ||
		[ "${subcommand}" == "buildme-parallel" ]; then
		wordlist=${OVE_PROJECT_LIST}
	elif [ "${subcommand}" == "run" ]; then
		if [ ${size} -eq 2 ]; then
			wordlist="TIMEOUT"
		elif [ ${size} -eq 3 ]; then
			wordlist="${OVE_ALL_COMMANDS}"
		else
			return
		fi
	elif [ "${subcommand}" == "loop" ]; then
		if [ ${size} -eq 2 ]; then
			wordlist="TIMEOUT"
		elif [ ${size} -eq 3 ]; then
			wordlist="INOTIFY"
		elif [ ${size} -eq 4 ]; then
			wordlist="MAX-COUNT"
		elif [ ${size} -eq 5 ]; then
			wordlist="${OVE_ALL_COMMANDS}"
		else
			return
		fi
	elif [ "${subcommand}" == "checkout" ]; then
		if [ ${size} -eq 2 ]; then
			wordlist=$(ove_list_tags_and_branches)
		elif [ ${size} -eq 3 ]; then
			wordlist="purge autostash"
		else
			return
		fi
	elif [ "${subcommand}" == "list-projects" ]; then
		[ ${size} -ne 2 ] && return
		wordlist="verbose"
	elif [ "${subcommand}" == "fzf" ]; then
		[ ${size} -ne 2 ] && return
		wordlist="loop"
	elif [ "${subcommand}" == "stash" ]; then
		if [ ${size} -eq 2 ]; then
			wordlist="drop list pop show"
		else
			return
		fi
	elif [ "${subcommand}" == "show" ]; then
		if [ ${size} -ge 2 ]; then
			wordlist="$(ove_revtab_forall_parallel 'git tag') HEAD FETCH_HEAD ORIG_HEAD MERGE_HEAD CHERRY_PICK_HEAD"
			wordlist+=" $(ove-list-heads | awk '{print $2}')"
			if [ -e ${OVE_PROJECT_STATE_DIR}/revtab-news ]; then
				wordlist+=" $(grep -o '^[a-f0-9]\+' ${OVE_PROJECT_STATE_DIR}/revtab-news)"
			fi
			if [ -e ${OVE_PROJECT_STATE_DIR}/revtab-ahead ]; then
				wordlist+=" $(grep -o '^[a-f0-9]\+' ${OVE_PROJECT_STATE_DIR}/revtab-ahead)"
			fi
		fi
	elif [ "${subcommand}" == "diff-project" ] ||
		[ "${subcommand}" == "log-project" ] ||
		[ "${subcommand}" == "shortlog-project" ]; then
		if [ ${size} -lt 4 ]; then
			wordlist=$(ove_list_tags_and_branches)
		else
			return
		fi
	elif [ "${subcommand}" == "do" ]; then
		if [ ${size} -eq 2 ]; then
			wordlist=$(ove_revtab_list_basename)
		elif [ ${size} -eq 3 ]; then
			[ -d ${OVE_BASE_DIR}/${COMP_WORDS[2]} ] &&
				wordlist=$(find $(readlink -f ${OVE_BASE_DIR}/${COMP_WORDS[2]}) -perm -u=x -not -path '*.git*' -type f)
		elif [ ${size} -gt 3 ]; then
			return
		fi
	elif [ "${subcommand}" == "switch" ]; then
		if [ ${size} -eq 2 ]; then
			wordlist=$(ove-locate | \
				grep -v '^\s' | \
				xargs -n1 basename)
		elif [ ${size} -gt 2 ]; then
			return
		fi
	elif [ "${subcommand}" == "vi" ] ||
		[ "${subcommand}" == "emacs" ]; then
		if [ ${size} -ge 2 ] && [ "$(ove-list-modified-files)" != "" ]; then
			wordlist=$(ove-list-modified-files | \
				xargs -n1 basename)
		else
			return
		fi
	elif [ "${subcommand}" == "config" ]; then
		if [ ${size} -eq 2 ]; then
			wordlist=$(ove-config | awk '{print $1}')
		elif [ ${size} -gt 2 ]; then
			return
		fi
	elif [ "${subcommand}" == "add" ] ||
		[ "${subcommand}" == "diff" ] ||
		[ "${subcommand}" == "diff-cached" ] ||
		[ "${subcommand}" == "reset" ] ||
		[ "${subcommand}" == "reset-hard" ] ||
		[ "${subcommand}" == "wdiff" ] ||
		[ "${subcommand}" == "wdiff-cached" ]; then
		if [ ${size} -ge 2 ]; then
			wordlist=$(ove_dirty_repos)
		fi
	elif [ "${subcommand}" == "branch" ] ||
		[ "${subcommand}" == "describe" ] ||
		[ "${subcommand}" == "fsck" ] ||
		[ "${subcommand}" == "heads2revtab" ] ||
		[ "${subcommand}" == "list-stash" ] ||
		[ "${subcommand}" == "readme" ] ||
		[ "${subcommand}" == "remote" ] ||
		[ "${subcommand}" == "show-dangling" ]; then
		if [ ${size} -ge 2 ]; then
			wordlist=$(ove_revtab_list_basename)
		fi
	elif [ "${subcommand}" == "news" ] ||
		[ "${subcommand}" == "show-news" ] ||
		[ "${subcommand}" == "pull" ]; then
		if [ -e ${OVE_PROJECT_STATE_DIR}/revtab-status ] && grep -q 'behind.*]' ${OVE_PROJECT_STATE_DIR}/revtab-status; then
			wordlist=$(grep 'behind.*]' ${OVE_PROJECT_STATE_DIR}/revtab-status | \
				cut -d: -f1 | \
				xargs)
		else
			wordlist=$(ove_revtab_list_basename)
		fi
	elif [ "${subcommand}" == "ahead" ] ||
		[ "${subcommand}" == "show-ahead" ]; then
		subcommand=${subcommand##show-}
		if [ -e ${OVE_PROJECT_STATE_DIR}/revtab-status ] && grep -q "${subcommand}.*]" ${OVE_PROJECT_STATE_DIR}/revtab-status; then
			wordlist=$(grep "${subcommand}.*]" ${OVE_PROJECT_STATE_DIR}/revtab-status | \
				cut -d: -f1 | \
				xargs)
		else
			wordlist=$(ove_revtab_list_basename)
		fi
	elif [ "${subcommand}" == "fetch" ] ||
		[ "${subcommand}" == "list-heads" ] ||
		[ "${subcommand}" == "status" ]; then
		wordlist=$(ove_revtab_list_basename)
	elif [ "${subcommand}" == "systest" ] ||
		[ "${subcommand}" == "systest-parallel" ]; then
		if [ ${size} -ge 2 ]; then
			wordlist=$(ove-list-systests)
		fi
	elif [ "${subcommand}" == "export" ]; then
		if [ ${size} -ge 2 ]; then
			wordlist=${OVE_PROJECT_LIST}
		fi
	elif [ "${subcommand}" == "apply" ]; then
		if [ ${size} -ge 2 ]; then
			return
		fi
	elif [ "${subcommand}" == "env" ]; then
		if [ ${size} -eq 2 ]; then
			wordlist=$(compgen -A variable | grep OVE_)
		else
			return
		fi
	elif [ "${subcommand}" == "unittest" ]; then
		if [ ${size} -ge 2 ]; then
			wordlist=$(find ${OVE_DIR}/tests -maxdepth 1 -mindepth 1 -name "t*.test" -type f -exec basename {} .test \;)
		fi
	elif [ "${subcommand}" == "what-is" ]; then
		if [ ${size} -ge 2 ]; then
			wordlist=$(find $(readlink -f ${PWD}) -maxdepth 1 -mindepth 1 -not -path '*.git' -type d -exec basename {} \;)
		fi
	elif [ "${subcommand}" == "head-tail" ]; then
		if [ ${size} -ge 2 ]; then
			wordlist=$(find $(readlink -f ${PWD}) -maxdepth 1 -mindepth 1 -not -path '*.git' -type f -exec basename {} \;)
		fi
	elif [ "${subcommand}" == "select-configuration" ]; then
		if [ ${size} -eq 2 ]; then
			wordlist="default $(find "${OVE_PROJECT_DIR}/projects" -name "configure-*" -type l -exec basename {} \; | sed 's/configure-//g')"
		else
			return
		fi
	elif [ "${subcommand}" == "replicate" ]; then
		if [ "$(type -t _known_hosts_real)" == "function" ]; then
			_known_hosts_real -a -- "$cur"
			return
		fi
	elif [ "${subcommand}" == "tail-lastlog" ] ||
		[ "${subcommand}" == "less-lastlog" ]; then
		if [ ${size} -eq 2 ]; then
			# shellcheck disable=SC2015
			wordlist=$([ -d /var/tmp ] && cd /var/tmp || cd /tmp; \
				find ./*/ove/logs -maxdepth 0 -type d | \
				cut -d/ -f2)
		else
			return
		fi
	fi

	if [ "${wordlist}" != "" ]; then
		COMPREPLY=( $(compgen -W "${wordlist}" -- ${cur}) )
	else
		opts="${OVE_ALL_COMMANDS}"
		if compgen -W "${opts}" -- "${cur}" &> /dev/null; then
			COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
		fi
	fi
}

function ove_get_built_ins {
	grep -o '^function ove-.* ' ${OVE_SELF} | \
		sed -e ':a;N;$!ba;s/function ove-//g' | \
		sort | \
		tr '\n' ' ' | \
		xargs "${OVE_ECHO}"
}

function ove_update_tab_complete {
	local array
	local cmd
	local oldIFS

	OVE_BUILT_INS_WITHOUT_ARGS=$(grep -B1 '^function ove-' ${OVE_SELF} | \
		grep ': :' | \
		cut -b3- | \
		cut -d: -f1 | \
		sort | \
		tr '\n' ' ' | \
		xargs "${OVE_ECHO}")

	export OVE_BUILT_INS_WITHOUT_ARGS

	OVE_BUILT_INS=$(ove_get_built_ins)

	# project commands
	OVE_ALL_COMMANDS=${OVE_PROJECT_COMMANDS}

	# built-in functions
	OVE_ALL_COMMANDS+=" ${OVE_BUILT_INS}"

	# scripts
	if [ "${OVE_SCRIPTS_LIST}" != "" ];then
		OVE_ALL_COMMANDS+=" ${OVE_SCRIPTS_LIST}"
	fi

	# parallel project commands
	for cmd in ${OVE_PROJECT_COMMANDS}; do
		OVE_ALL_COMMANDS+=" ${cmd}-parallel"
	done

	array=(${OVE_ALL_COMMANDS})
	oldIFS=${IFS}
	IFS=$'\n' OVE_ALL_COMMANDS=$(xargs "${OVE_ECHO}" <<<$(sort <<<"${array[*]}"))
	IFS=${oldIFS}

	export OVE_ALL_COMMANDS

	complete -o bashdefault -o default -F ove_bash_complete ove
	for cmd in ${OVE_PROJECT_COMMANDS}; do
		complete -W "${OVE_PROJECT_LIST}" "ove-${cmd}"
	done
}

function ove_add_script_func {
	local htext
	local script
	local script_dir

	script_dir=$1
	script=$2

	ove_scripts_name2path[${script}]=${script_dir}

	if [ -f ${script_dir}/${script}.help ]; then
		htext=$(<${script_dir}/${script}.help)
		eval "ove-${script}() {
		local helptext=\"${htext}\"
		local __scriptname=ove-${script}
		\"${script_dir}\"/${script} \$*
		}"
	else
		eval "ove-${script}() {
		local helptext=\"${script}: :run '${script_dir}/${script}'\"
		local __scriptname=ove-${script}
		\"${script_dir}\"/${script} \$*
		}"
	fi
}

function ove_scripts_init {
	local array
	local oldIFS
	local prev_scripts
	local repo
	local script
	local script_list
	declare -A -g ove_scripts_name2path

	OVE_SCRIPTS_LIST=

	# unset any ove- functions marked with "__scriptname"
	prev_scripts=$(set | grep '^    local __scriptname=.*')
	prev_scripts=${prev_scripts//    local __scriptname=}
	prev_scripts=${prev_scripts//;}
	[ "${prev_scripts}" != "" ] && unset -f ${prev_scripts}

	# project scripts
	if [ -d "${OVE_PROJECT_DIR}/scripts" ]; then
		script_list=$(find ${OVE_PROJECT_DIR}/scripts -perm -u=x -not -name '*.help' -type f)
		for script in ${script_list}; do
			ove_add_script_func ${OVE_PROJECT_DIR}/scripts ${script##*/}
			OVE_SCRIPTS_LIST+="${script##*/} "
		done
	fi

	# OVE scripts
	if [ -d "${OVE_DIR}/scripts" ]; then
		script_list=$(find ${OVE_DIR}/scripts -perm -u=x -not -name '*.help' -type f)
		for script in ${script_list}; do
			ove_add_script_func ${OVE_DIR}/scripts ${script##*/}
			OVE_SCRIPTS_LIST+="${script##*/} "
		done
	fi

	# repo scripts
	for repo in $(ove_revtab_list_fullpath); do
		! [ -d "${repo}/.ove/scripts" ] && continue
		script_list=$(find -L ${repo}/.ove/scripts -perm -u=x -not -name '*.help' -type f)
		for script in ${script_list}; do
			ove_add_script_func ${repo}/.ove/scripts ${script##*/}
			OVE_SCRIPTS_LIST+="${script##*/} "
		done
	done

	array=(${OVE_SCRIPTS_LIST})
	oldIFS=${IFS}
	IFS=$'\n' OVE_SCRIPTS_LIST=$(xargs "${OVE_ECHO}" <<<$(sort <<<"${array[*]}"))
	IFS=${oldIFS}
}

# show-configuration: :show current build configuration for each project
function ove-show-configuration {
	[ -d "${OVE_PROJECT_DIR}/projects" ] && \
		tree -l -P 'configure' -I 'configure-*' ${OVE_PROJECT_DIR}/projects
}

# select-configuration:[PATTERN|default]:select build configuration for each project
function ove-select-configuration {
	local c
	local configs
	local iter
	local nbr_of_configs
	local p
	local projects

	# list of projects
	projects=${OVE_PROJECT_LIST}
	iter=1
	for p in ${projects}; do
		# ignore projects without a project directory
		[ ! -d "${OVE_PROJECT_DIR}/projects/${p}" ] && continue

		# multiple configurations, ask which one to select
		configs=$(find "${OVE_PROJECT_DIR}/projects/${p}" -name "configure-*" -type l)
		nbr_of_configs=$(find "${OVE_PROJECT_DIR}/projects/${p}" -name "configure-*" -type l| wc -l)
		if [ "${nbr_of_configs}" -gt 1 ]; then
			# pattern, select config
			if [ $# -eq 1 ]; then
				# use the default configuration
				if [ $1 == "default" ]; then
					git -C ${OVE_PROJECT_DIR} checkout ${OVE_PROJECT_DIR}/projects/${p}/configure
					continue
				fi

				for c in ${configs}; do
					if basename ${c} | grep -w -q configure-$1; then
						ove_echo_green_noprefix ${p}:
						pushd ${OVE_PROJECT_DIR}/projects/${p} &>/dev/null
						ln -sfv configure-$1 configure
						popd &>/dev/null
						break
					fi
				done
				continue
			fi

			# no pattern, ask user
			ove_echo_green_noprefix ${p}:
			echo "0: default"
			(( iter=1 ))
			for c in ${configs}; do
				echo -n "${iter}: "
				basename $(echo ${c} | sed 's/configure-//g')
				(( iter+=1 ))
			done
			echo
			read -p "Select configuration? " -r
			echo
			if [[ ${REPLY} =~ ^[0-9]+$ ]] && [[ ${REPLY} -le ${nbr_of_configs} ]]; then
				if [[ ${REPLY} == 0 ]]; then
					git -C ${OVE_PROJECT_DIR} checkout ${OVE_PROJECT_DIR}/projects/${p}/configure
				else
					cfg=$(echo ${configs} | cut -d' ' -f${REPLY})
					cfg_basename=$(basename ${cfg})
					pushd ${OVE_PROJECT_DIR}/projects/${p} &>/dev/null
					ln -sfv ${cfg_basename} configure
					popd &>/dev/null
				fi
			fi
		fi
	done

	ove-show-configuration
}

function ove_dirs_init {
	local OVE_STATE_LINK_NAME
	local OVE_TMP_LINK_NAME

	OVE_STATE_LINK_NAME="${OVE_BASE_DIR}/.ove.state"
	OVE_TMP_LINK_NAME="${OVE_BASE_DIR}/.ove.tmp"

	# global state
	[ -d /var/tmp ] && OVE_GLOBAL_STATE_DIR=/var${OVE_TMP} || OVE_GLOBAL_STATE_DIR=${OVE_TMP}
	export OVE_GLOBAL_STATE_DIR

	# project state
	if ! [ -h ${OVE_STATE_LINK_NAME} ] || [ "$(readlink -f ${OVE_STATE_LINK_NAME})" == "" ]; then
		[ -h ${OVE_STATE_LINK_NAME} ] && rm ${OVE_STATE_LINK_NAME}
		OVE_PROJECT_STATE_DIR=$(mktemp -u -d -p ${OVE_GLOBAL_STATE_DIR}/${OVE_PROJECT_NAME} state-XXXXXXXXXX)

		mkdir -p ${OVE_PROJECT_STATE_DIR}
		ln -s ${OVE_PROJECT_STATE_DIR} ${OVE_STATE_LINK_NAME}

		# always re-create tmp link
		[ -h ${OVE_TMP_LINK_NAME} ] && rm ${OVE_TMP_LINK_NAME}
	else
		OVE_PROJECT_STATE_DIR=$(readlink -f ${OVE_STATE_LINK_NAME})
		! [ -e "${OVE_STATE_LINK_NAME}" ] && mkdir -p ${OVE_PROJECT_STATE_DIR}
	fi
	export OVE_PROJECT_STATE_DIR

	# project tmp
	if ! [ -h ${OVE_TMP_LINK_NAME} ] || [ "$(readlink -f ${OVE_TMP_LINK_NAME})" == "" ]; then
		[ -h ${OVE_TMP_LINK_NAME} ] && rm ${OVE_TMP_LINK_NAME}
		# re-use last 10 characters from OVE_PROJECT_STATE_DIR
		OVE_PROJECT_TMP_DIR="${OVE_TMP}/${OVE_PROJECT_NAME}/tmp-${OVE_PROJECT_STATE_DIR: -10}"
		mkdir -p ${OVE_PROJECT_TMP_DIR}
		ln -s ${OVE_PROJECT_TMP_DIR} ${OVE_TMP_LINK_NAME}
	else
		OVE_PROJECT_TMP_DIR=$(readlink -f ${OVE_TMP_LINK_NAME})
		! [ -e "${OVE_TMP_LINK_NAME}" ] && mkdir -p ${OVE_PROJECT_TMP_DIR}
	fi
	export OVE_PROJECT_TMP_DIR
}

function ove_config_init {
	# own config has precedence over project config
	if [ -e ${HOME}/.oveconfig ]; then
		ove_read_config ${HOME}/.oveconfig
	elif [ -e ${OVE_PROJECT_DIR}/.oveconfig ]; then
		ove_read_config ${OVE_PROJECT_DIR}/.oveconfig
	fi

	# project state config?
	[ -e ${OVE_PROJECT_STATE_DIR}/.oveconfig ] && ove_read_config ${OVE_PROJECT_STATE_DIR}/.oveconfig
}

# re-initialize
function ove_reinit {
	if ! ove_init; then
		return 1
	fi

	ove_post_checks
}

# init:initialize OVE project
function ove_init {
	local base_dir

	if ! base_dir=$(ove_get_base_dir); then
		return 1
	fi
	OVE_BASE_DIR="${base_dir}"

	OVE_ECHO=$(which echo)
	OVE_PROJECT_DIR=$(readlink -f ${OVE_BASE_DIR}/.owel)
	OVE_PROJECT_NAME=${OVE_PROJECT_DIR##*/}
	OVE_PROJECT_LIST=$(ove_list_projects)
	OVE_PROJECT_COMMANDS=$(ove_project_commands_list)
	OVE_DIR="$(cd "$(dirname "$(readlink -f ${OVE_BASE_DIR}/${BASH_SOURCE[0]##*/})")"; pwd -P)"
	OVE_BASENAME="$(basename $(readlink -f ${OVE_BASE_DIR}/${BASH_SOURCE[0]##*/}))"
	OVE_SELF="${OVE_DIR}/${OVE_BASENAME}"
	if ! ( for i in {1..205} ; do echo -n 123456789, ; done ; echo ) | column -t -s "," &> /dev/null; then
		OVE_COLUMN_WRAP_BUG=1
	else
		OVE_COLUMN_WRAP_BUG=0
	fi

	ove_dirs_init
	ove_config_init
	ove_revtab_init
	if ! ove_revtab_parse; then
		return 1
	fi
	ove_projects_init
	if ! ove_projects_parse; then
		return 1
	fi
	ove_scripts_init

	if [ "${OVE_LOGLEVEL}" == "2" ]; then
		set -x
	fi

	if [ -n "${OVE_ANALYZE_EXECVE+x}" ]; then
		echo ${BASHPID} > ${OVE_PROJECT_TMP_DIR}/strace.pid
		while true; do
			[ -e ${OVE_PROJECT_TMP_DIR}/strace.cont ] && break
		done
	fi

	[ "$1" == "quick" ] && return 0

	ove_update_checksum

	if ! ove_validate_self; then
		return 1
	fi

	if ! [ -L ${OVE_BASE_DIR}/README ]; then
		if [ -s ${OVE_PROJECT_DIR}/README ]; then
			( cd ${OVE_BASE_DIR} && ln -s -r ${OVE_PROJECT_DIR}/README .)
		elif [ -s ${OVE_PROJECT_DIR}/README.md ]; then
			( cd ${OVE_BASE_DIR} && ln -s -r ${OVE_PROJECT_DIR}/README.md README )
		fi
	fi

	ove_update_tab_complete

	if [ -z "${OVE_DRY_RUN+x}" ]; then
		OVE_DRY_RUN=0
		export OVE_DRY_RUN
	fi

	if [ -z "${OVE_FETCH_MAX_PARALLEL+x}" ]; then
		OVE_FETCH_MAX_PARALLEL=0
		export OVE_FETCH_MAX_PARALLEL
	fi

	if [ -z "${OVE_LOCATE_SEARCH_DIR+x}" ]; then
		OVE_LOCATE_SEARCH_DIR=$(readlink -f $(dirname ${HOME}))
		export OVE_LOCATE_SEARCH_DIR
	fi
	if [ -z "${OVE_PROJECT_CI_BRANCH+x}" ]; then
		OVE_PROJECT_CI_BRANCH="origin/master"
		export OVE_PROJECT_CI_BRANCH
	fi
	if [ -z "${OVE_LOGLEVEL+x}" ]; then
		OVE_LOGLEVEL=1
		OVE_REDIRECT_OUTPUT=""
		export OVE_REDIRECT_OUTPUT
		export OVE_LOGLEVEL
	fi
	if [ -z "${OVE_AUTOCORRECT+x}" ]; then
		OVE_AUTOCORRECT=0
		export OVE_AUTOCORRECT
	fi
	export OVE_REPO_LIST
	export OVE_ECHO
	export OVE_BUILD_ORDER
	export OVE_BASE_DIR
	export OVE_PROJECT_DIR
	export OVE_PROJECT_LIST
	export OVE_PROJECT_COMMANDS
	export OVE_DIR
	export OVE_BASENAME
	export OVE_SELF
	export OVE_PROJECT_NAME

	OVE_LOG_DIR="${OVE_GLOBAL_STATE_DIR}/logs"
	export OVE_LOG_DIR
	! [ -d "${OVE_LOG_DIR}" ] && mkdir -p "${OVE_LOG_DIR}"

	OVE_STAGE_DIR=${OVE_BASE_DIR}/stage
	export OVE_STAGE_DIR
	OVE_ARCHIVE_DIR=${OVE_BASE_DIR}/archives
	export OVE_ARCHIVE_DIR
	OVE_PREFIX="/usr"
	export OVE_PREFIX
	OVE_LDFLAGS=" -L${OVE_STAGE_DIR}${OVE_PREFIX}/lib -Wl,-rpath-link=${OVE_STAGE_DIR}${OVE_PREFIX}/lib"
	export OVE_LDFLAGS
	OVE_CPPFLAGS=" -I${OVE_STAGE_DIR}${OVE_PREFIX}/include"
	export OVE_CPPFLAGS
	OVE_SHA=$(git -C ${OVE_DIR} rev-parse --short HEAD)
	export OVE_SHA
	OVE_LAST_COMMAND=
	export OVE_LAST_COMMAND
	# shellcheck disable=SC2016
	OVE_INIT_STRING='eval source ${OVE_BASE_DIR}/ove; ove_init quick'
	export OVE_INIT_STRING
	OVE_PAGER="less -R"
	export OVE_PAGER

	# Update executable and run-time library paths
	PATH=${PATH}:${OVE_STAGE_DIR}${OVE_PREFIX}/bin
	export PATH

	LD_LIBRARY_PATH=${OVE_STAGE_DIR}${OVE_PREFIX}/lib
	export LD_LIBRARY_PATH

	return 0
}

function ove_corrupt_repos {
	local git

	for git in ${OVE_REPO_LIST}; do
		# ignore repos not yet fetched
		[ -d ${git} ] || continue
		# repos without a .git directory
		[ -d ${git}/.git ] || echo -n "${git/${OVE_BASE_DIR}\/} "
	done
}

function ove_post_checks {
	local c
	local corrupt_repos
	local doublets
	local f
	local res
	local script

	# check for systest doublets
	if [ -e ${OVE_PROJECT_DIR}/systests ]; then
		# yes, this is ugly
		mapfile -t doublets < <(grep -E -v '#|^$' ${OVE_PROJECT_DIR}/systests | \
			awk '{print $1}' | \
			cut -d: -f1 | \
			sort | \
			uniq -d)
		if [ "${doublets[*]}" != "" ]; then
			echo
			ove_echo_yellow_noprefix "warning: found ${#doublets[*]} systest duplicate(s):"
			for c in ${doublets[*]}; do
				grep -H -n -w ^${c} ${OVE_PROJECT_DIR}/systests
			done
		fi
	fi

	# inform the user if .oveconfig was updated within the project
	if [ -e ${HOME}/.oveconfig ] && [ -e ${OVE_PROJECT_DIR}/.oveconfig ]; then
		res=$(comm -3 <(grep -E -v '(^#.*$)|(^$)' ${HOME}/.oveconfig | awk '{ print $1 }' | sort) \
			<(grep -E -v '(^#.*$)|(^$)' ${OVE_PROJECT_DIR}/.oveconfig | awk '{ print $1 }' | sort))
		if [ "${res}" != "" ]; then
			echo
			echo "--->"
			ove_echo_yellow_noprefix "warning: the two files:"
			echo
			echo "${HOME}/.oveconfig"
			echo "${OVE_PROJECT_DIR}/.oveconfig"
			echo
			echo "...are different. Do a merge!?"
			echo
			diff <(grep -E -v '(^#.*$)|(^$)' ${HOME}/.oveconfig | awk '{ print $1 }' | sort) \
				<(grep -E -v '(^#.*$)|(^$)' ${OVE_PROJECT_DIR}/.oveconfig | awk '{ print $1 }' | sort)
			echo "<---"
		fi
	fi

	# check for config doublets
	for f in ${HOME}/.oveconfig ${OVE_PROJECT_DIR}/.oveconfig; do
		[ -e ${f} ] || continue

		mapfile -t doublets < <(grep -E -v '#|^$' ${f} | awk '{print $1}' | sort | uniq -d)
		if [ "${doublets[*]}" != "" ]; then
			echo
			ove_echo_yellow_noprefix "warning: found ${#doublets[*]} config duplicate(s):"
			for c in ${doublets[*]}; do
				grep -H -n -w ${c} ${f}
			done
		fi
	done

	# keep ${HOME}/.ove.bash up-to-date
	if [ -e "${HOME}/.ove.bash" ] && ! diff -q "${OVE_DIR}/ove.bash" "${HOME}/.ove.bash"; then
		cp -b -v "${OVE_DIR}/ove.bash" "${HOME}/.ove.bash"
	fi

	# check for script doublets
	mapfile -t doublets < <(for script in $(ove-list-scripts); do echo ${script##*/}; done | \
		sort | \
		uniq -d)
	if [ "${doublets[*]}" != "" ]; then
		echo
		ove_echo_yellow_noprefix "warning: found ${#doublets[*]} script duplicate(s):"
		for script in ${doublets[*]}; do
			ove-list-scripts | grep "/${script}$"
		done
	fi

	# check for corrupt repos
	corrupt_repos="$(ove_corrupt_repos)"
	if [ "${corrupt_repos}" != "" ]; then
		echo
		ove_echo_error_noprefix "corrupt repo(s): ${corrupt_repos}"
		echo
		ove_echo_red_noprefix "fix this by running the following two commands:"
		echo
		echo -e "\t$ rm -rf ${corrupt_repos}"
		echo -e "\t$ ove fetch ${corrupt_repos}"
		echo
	fi

	# validate revtab revision
	ove_revtab_check
}

function ove_buildable_projects {
	local deps
	local index
	local proj
	local proj_path
	local projs_and_deps_not_buildable
	local projs_not_buildable
	local q
	local re
	declare -A projs_hash

	# remove projects with paths within git repos not yet fetched
	for proj in ${OVE_PROJECT_LIST}; do
		index=${ove_projects_name2index[${proj}]}
		proj_path="${OVE_BASE_DIR}/${ove_projects_path[${index}]}"
		for q in ${OVE_REPO_LIST}; do
			if [[ ${proj_path} == *"${q}"* ]] && ! [ -d "${q}" ]; then
				test "${projs_hash["${proj}"]+isset}" && continue
				projs_hash["${proj}"]=1
				projs_not_buildable+="${proj} "
			fi
		done
	done

	if [ "${projs_not_buildable}" == "" ]; then
		unset OVE_PROJECT_LIST_BUILDABLE
		return
	fi

	# remove none buildable projects and its dependencies
	projs_and_deps_not_buildable="${projs_not_buildable}"
	for proj in ${OVE_PROJECT_LIST}; do
		deps=$(ove_get_deps_recursive ${proj})
		for q in ${projs_not_buildable}; do
			re=\\b${q}\\b
			if [[ "${deps}" =~ ${re} ]]; then
				re=\\b${proj}\\b
				# already marked as removed?
				if [[ "${projs_and_deps_not_buildable}" =~ ${re} ]]; then
					continue
				fi
				projs_and_deps_not_buildable+="${proj} "
			fi
		done
	done

	OVE_PROJECT_LIST_BUILDABLE=$(comm -3 \
		<(echo ${OVE_PROJECT_LIST} | xargs -n1 | sort) \
		<(xargs -n1 <<<"${projs_and_deps_not_buildable}" | sort) |
		xargs)
	export OVE_PROJECT_LIST_BUILDABLE
}

# init:|[DIR]|[DIR NAME]:scan directories and look for git repositories, if found create/update a OVE workspace
function ove-init {
	local d
	local dir
	local do_init_git
	local doublets
	local fetch_url
	local git
	local i
	local name
	local ove_link
	local owel_default
	local owel_name
	local push_url
	local rev
	local revtabs
	local revtab_file
	local str

	if [ $# -eq 0 ]; then
		while true; do
			read -r -p "Directory to scan for git repositories? Leave blank to search in '$PWD': "
			if [ "${REPLY}" == "" ]; then
				if ove_is_base_dir "${PWD}"; then
					ove_echo_error_noprefix "'${PWD}' is already a OVE workspace. Remove the symblic link '${PWD}/.owel' to be able to re-init this directory."
					continue
				fi

				dir=${PWD}
				break
			fi

			if ! [ -d ${REPLY} ]; then
				ove_echo_error_noprefix "'${REPLY}' is not a directory, try again"
				continue
			fi

			if ove_is_base_dir "${REPLY}"; then
				ove_echo_error_noprefix "'${REPLY}' is already a OVE workspace. Remove the symbolic link '${REPLY%/}/.owel' to be able to re-init this directory."
				continue
			fi
			dir=${REPLY}
			break
		done

	elif [ $# -lt 3 ]; then
		if ! [ -d ${1} ]; then
			ove_echo_error_noprefix "'${1}' is not a directory"
			return 1
		fi
		if ove_is_base_dir "${1}"; then
			ove_echo_error_noprefix "'${1}' is already a OVE workspace. Remove the symbolic link '${1%/}/.owel' to be able to re-init this directory."
			return 1
		fi
		dir=${1}
	fi

	# remove any trailing slash
	[ ${#dir} -ne 1 ] && dir="${dir%/}"

	if ! [ -w "${dir}" ]; then
		ove_echo_error_noprefix "sorry you are not allowed to create files/directories here: '${dir}'"
		return 1
	fi

	if [ -e ${dir}/ove ] && ! [ -L ${dir}/ove ]; then
		ove_echo_error_noprefix "you already have a file/directory named '${dir}/ove', rename/remove to proceed"
		return 1
	fi

	mapfile -t revtabs < <(find ${dir} -mindepth 2 -maxdepth 2 -name revtab)
	if [ $# -lt 2 ] && [ ${#revtabs[*]} -eq 1 ]; then
		owel_default="$(basename $(dirname ${revtabs[0]}))"
	else
		owel_default="top"
	fi

	if [ $# -eq 0 ] || [ $# -eq 1 ]; then
		while true; do
			read -r -p "Top level repo name? Leave blank to name it '${owel_default}': "
			if [ "${REPLY}" == "" ]; then
				owel_name="${owel_default}"
			else
				owel_name="${REPLY}"
			fi
			break
		done
	elif [ $# -eq 2 ]; then
		owel_name=${2}
	fi

	dir=$(readlink -f ${dir})
	i=0
	do_init_git=0

	# updating an existing git repo?
	if [ -d ${dir}/${owel_name}/.git ]; then
		owel_remote=$(git -C "${dir}/${owel_name}" remote -v | \
			grep fetch | \
			awk '{print $2}')
	else
		do_init_git=1
	fi

	while read -r git; do
		if ! git -C ${git} log -1 --oneline &> /dev/null; then
			continue
		fi

		name=$(dirname "${git}")
		name=${name/${dir}\//}

		fetch_url=$(git -C "${git}" remote -v | \
			grep fetch | \
			awk '{print $2}')
		[ "${fetch_url}" == "" ] && fetch_url="noremote"
		# ignore OWEL remote
		[ "${fetch_url}" == "${owel_remote}" ] && continue

		push_url=$(git -C "${git}" remote -v | \
			grep push | \
			awk '{print $2}')
		[ "${push_url}" == "" ] && push_url="noremote"

		# detached?
		if ! git -C "${git}" symbolic-ref -q HEAD > /dev/null; then
			rev=$(git -C "${git}" rev-parse --short HEAD)
		else
			rev=$(git -C "${git}" branch | \
				cut -d' ' -f2 | \
				tr -d '\n')
		fi

		((i++))
		echo -en "Scanning '${dir}'. #repos: ${i}\r"
		str+="${name} ${fetch_url} ${push_url} ${rev}\n"
	done < <(find "${dir}" -type d -name .git 2>/dev/null)

	if [ ${i} -eq 0 ]; then
		ove_echo_error_noprefix "no git repositories found here: '${dir}'"
		return 1
	fi

	echo
	mkdir -p ${dir}/${owel_name}

	if [ ${do_init_git} -eq 1 ]; then
		git -C ${dir}/${owel_name} init || return 2
	fi

	# owel symlink
	(cd ${dir} && ln -s ${owel_name} .owel)

	# symlink self
	if ! [ -L ${dir}/ove ]; then
		if [ "${OVE_SELF}" == "" ]; then
			ove_link=$(readlink -f ${BASH_SOURCE[0]})
		else
			ove_link=${OVE_SELF}
		fi
		(cd ${dir} && ln -s ${ove_link} ove)
	fi

	# create a revtab file
	revtab_file="${dir}/${owel_name}/revtab"
	printf "${str}" | \
		column -t | \
		sort > ${revtab_file}

	# inform user on repos with same fetch url
	mapfile -t doublets < <(awk '{print $2}' ${revtab_file} | grep -v noremote | sort | uniq -d)
	if [ "${doublets[*]}" != "" ]; then
		ove_echo_yellow_noprefix "NOTE: found a few repos with the same fetch url:"
		for d in ${doublets[*]}; do
			grep -H -n "${d}" ${revtab_file}
			echo "--"
		done | column -t
	fi

	echo "---"
	echo "Init summary:"
	echo "* created/updated '${revtab_file}' and with ${i} repositories"
	if [ "${ove_link}" != "" ]; then
		echo "* created a symbolic link '${dir}/ove' -> '${ove_link}'"
	fi
	echo "* created a symbolic link '${dir}/.owel' -> '${dir}/${owel_name}'"

	if [ ${do_init_git} -eq 1 ]; then
		echo "* created a empty git repository here: '${dir}/${owel_name}'"
	fi
	if [ ${#doublets[*]} -ne 0 ]; then
		echo "* found that a few repos are mentioned more than one time in '${revtab_file}', details above"
	fi
	if [ ${dir} != "${PWD}" ]; then
		cd ${dir} || return 1
		echo "* changed current working directory to ${dir}"
	fi
}

# $1: command
function ove_command_to_package {
	local package

	# column
	if [ "$1" == "column" ]; then
		if [[ ${OVE_OS} == *"Ubuntu"* ]] || \
			[[ ${OVE_OS} == *"Debian"* ]]; then
			package="bsdmainutils"
		elif [[ ${OVE_OS} == *"Alpine"* ]] || \
			[[ ${OVE_OS} == *"Fedora"* ]]; then
			package="util-linux"
		elif [[ ${OVE_OS} == *"Gentoo"* ]] || \
			[[ ${OVE_OS} == *"CentOS"* ]]; then
			package=""
		else
			package="$1"
		fi
	# file
	elif [ "$1" == "file" ]; then
		package="$1"
	# git
	elif [ "$1" == "git" ]; then
		if [[ ${OVE_OS} == *"Alpine"* ]]; then
			package="git git-perl"
		elif [[ ${OVE_OS} == *"Gentoo"* ]]; then
			package="dev-vcs/git"
		else
			package="git"
		fi
	# locate
	elif [ "$1" == "locate" ]; then
		package="mlocate"
	# pgrep
	elif [ "$1" == "pgrep" ]; then
		if [[ ${OVE_OS} == *"Ubuntu"* ]] || \
			[[ ${OVE_OS} == *"Debian"* ]]; then
			package="procps"
		fi
	# script
	elif [ "$1" == "script" ]; then
		if [[ ${OVE_OS} == *"Ubuntu"* ]] || \
			[[ ${OVE_OS} == *"Debian"* ]]; then
			package="bsdutils"
		elif [[ ${OVE_OS} == *"Gentoo"* ]]; then
			package="sys-apps/util-linux"
		fi
	# tree
	elif [ "$1" == "tree" ]; then
		if [[ ${OVE_OS} == *"Gentoo"* ]]; then
			package="app-text/tree"
		fi
	# tsort
	elif [ "$1" == "tsort" ]; then
		package="coreutils"
	# xz
	elif [ "$1" == "xz" ]; then
		if [[ ${OVE_OS} == *"Ubuntu"* ]] || \
			[[ ${OVE_OS} == *"Debian"* ]]; then
			package="xz-utils"
		elif [[ ${OVE_OS} == *"Gentoo"* ]]; then
			package="app-arch/xz"
		else
			package="xz"
		fi
	fi

	[ "${package}" != "" ] && echo ${package} || echo $1
}

function ove_deps {
	local dep
	local deps
	local pack
	local str_cmds
	local str_packs

	str_packs=""
	str_cmds=""

	deps=()
	deps+=('bzip2')
	deps+=('column')
	deps+=('file')
	deps+=('git')
	deps+=('gzip')
	deps+=('pgrep')
	deps+=('script')
	deps+=('tree')
	deps+=('tsort')
	deps+=('which')

	for dep in "${deps[@]}"; do
		if ! command -v ${dep} > /dev/null; then
			str_cmds+="${dep} "
			pack=$(ove_command_to_package ${dep})
			if [ "${pack}" != "" ]; then
				str_packs+="${pack} "
			fi
		fi
	done

	if [ "${str_cmds}" != "" ]; then
		ove_echo_error_noprefix "missing command(s):"
		echo
		for dep in ${str_cmds}; do
			echo -e "\t${dep}"
		done | sort
		echo
		echo "To fix this, run the following command:"
		echo
		echo -e "\t${OVE_OS_PACKAGE_MANAGER} ${OVE_OS_PACKAGE_MANAGER_ARGS} ${str_packs}"
		echo
		return 1
	fi
}

# $*: list of packages
# returns a list of packages NOT installed
function ove_packages_not_installed {
	local p_sort

	[ $# -eq 0 ] && return

	p_sort=$(xargs -n1 <<<"$@" | sort -u)

	if [[ ${OVE_OS} == *"Arch Linux"* ]]; then
		comm -2 -3 <(xargs -n1 <<<${p_sort}) <(pacman -Q | awk '{print $1}')
	elif [[ ${OVE_OS} == *"Alpine"* ]]; then
		comm -2 -3 <(xargs -n1 <<<${p_sort}) <(apk info | sort)
	elif [[ ${OVE_OS} == *"CentOS"* ]] || \
		[[ ${OVE_OS} == *"Fedora"* ]] || \
		[[ ${OVE_OS} == *"RedHatEnterpriseServer"* ]]; then
		comm -2 -3 <(xargs -n1 <<<${p_sort}) <(rpm -qa --qf "%{NAME}\n"| sort)
	elif [[ ${OVE_OS} == *"Debian"* ]] || \
		[[ ${OVE_OS} == *"Raspbian"* ]] || \
		[[ ${OVE_OS} == *"Ubuntu"* ]]; then
		dpkg-query -W -f='${Package}:${Status}\n' ${p_sort} 2>&1 | \
			grep -v ":install ok installed" | \
			sed -e 's/dpkg-query: no packages found matching //g' -e 's/:.*//g' | \
			xargs
	elif [[ ${OVE_OS} == *"void"* ]]; then
		comm -2 -3 \
			<(xargs -n1 <<<${p_sort}) \
			<(xbps-query --list-pkgs | awk '{print $2}' | rev | cut -d- -f2- | rev | sort | xargs -n1)
	else
		ove_echo_error_noprefix "function '${FUNCNAME[0]}' is not implemented for ${OVE_OS}"
	fi
}

function ove_determine_dist_version_and_pack_manager {
	if [ -e /etc/os-release ]; then
		OVE_OS=$(source /etc/os-release; echo ${NAME})
		OVE_OS_VER=$(source /etc/os-release; echo ${VERSION_ID})
	elif command -v lsb_release > /dev/null; then
		OVE_OS=$(lsb_release --id --short)
		OVE_OS_VER=$(lsb_release --release --short)
	else
		ove_echo_warning_noprefix "unable to determine distro"
		OVE_OS=$(uname -s)
		OVE_OS_VER=$(uname -r)
	fi


	if [[ ${OVE_OS} == *"Alpine"* ]]; then
		OVE_OS_PACKAGE_MANAGER="apk"
		OVE_OS_PACKAGE_MANAGER_ARGS="add"
	elif [[ ${OVE_OS} == *"Arch Linux"* ]]; then
		OVE_OS_PACKAGE_MANAGER="pacman"
		OVE_OS_PACKAGE_MANAGER_ARGS="-S"
	elif [[ ${OVE_OS} == *"CentOS"* ]]; then
		OVE_OS_PACKAGE_MANAGER="yum"
		OVE_OS_PACKAGE_MANAGER_ARGS="install"
	elif [[ ${OVE_OS} == *"Debian"* ]] || \
		[[ ${OVE_OS} == *"Raspbian"* ]] || \
		[[ ${OVE_OS} == *"Ubuntu"* ]]; then
		OVE_OS_PACKAGE_MANAGER="apt"
		OVE_OS_PACKAGE_MANAGER_ARGS="install"
	elif [[ ${OVE_OS} == *"Fedora"* ]] || \
		[[ ${OVE_OS} == *"RedHatEnterpriseServer"* ]]; then
		OVE_OS_PACKAGE_MANAGER="dnf"
		OVE_OS_PACKAGE_MANAGER_ARGS="install"
	elif [[ ${OVE_OS} == *"Gentoo"* ]]; then
		OVE_OS_PACKAGE_MANAGER="emerge"
		OVE_OS_PACKAGE_MANAGER_ARGS=""
	elif [[ ${OVE_OS} == *"openSUSE"* ]] || \
		[[ ${OVE_OS} == *"SLES"* ]]; then
		OVE_OS_PACKAGE_MANAGER="zypper"
		OVE_OS_PACKAGE_MANAGER_ARGS="install"
	elif [[ ${OVE_OS} == *"void"* ]]; then
		OVE_OS_PACKAGE_MANAGER="xbps-install"
		OVE_OS_PACKAGE_MANAGER_ARGS=""
	else
		OVE_OS_PACKAGE_MANAGER="unknown"
		OVE_OS_PACKAGE_MANAGER_ARGS=""
	fi

	export OVE_OS
	export OVE_OS_VER
	export OVE_OS_PACKAGE_MANAGER
	export OVE_OS_PACKAGE_MANAGER_ARGS
}

# fsck:[GIT...]:git fsck --full for all/specified git repositories
function ove-fsck {
	local cmd

	cmd="ove_echo_yellow_noprefix \$(pwd -P) && \
		git -C \${git} fsck --full || \
		ove_echo_error_noprefix \'git -C \$(pwd -P) fsck --full\' returned != 0, corrupt repo?; echo"

	if [ $# -eq 0 ]; then
		ove_revtab_forall "${cmd}"
	else
		ove_revtab_forsome "${cmd}" "$*"
	fi
}

# show-dangling:[GIT...]:show dangling git objects (=blob|commit|tag|tree) for all/specified git repositories
function ove-show-dangling {
	local sha_list

	sha_list=$(ove-fsck "$@" | grep '^dangling' | awk '{print $3}')
	[ "${sha_list}" == "" ] || ove-show ${sha_list}
}

# readme:[GIT...]:display README files for all/specified git repositories
function ove-readme {
	local cmd

	# shellcheck disable=SC2016
	cmd='find ${PWD} -maxdepth 1 -name "README*" -print0 | '
	cmd+='xargs -r -0 head -v |'
	# shellcheck disable=SC2016
	cmd+='sed -e "1 i$(ove_echo_yellow_noprefix $(pwd -P))" -e "s/^/\t/g"'

	if [ $# -eq 0 ]; then
		ove_revtab_forall "${cmd}"
	else
		ove_revtab_forsome "${cmd}" "$*"
	fi
}

# replicate:HOST:replicate OVE workspace on HOST
function ove-replicate {
	local d
	local host
	local p
	local s

	if [ $# -ne 1 ]; then
		ove-help ^${FUNCNAME/ove-/}
		return 1
	fi

	s="$(ove-setup)"
	if [ "${s}" == "" ]; then
		ove_echo_error_noprefix "'${OVE_PROJECT_DIR}/SETUP' file not found"
		return 2
	fi

	host="$1"
	if ! ssh -q ${host} exit; then
		ove_echo_error_noprefix "'${host}' is not reachable via ssh"
		return 3
	fi

	# remote directory
	d=$(ssh ${host} mktemp -d)

	# only diffs relative to the index is included (for now)
	p=$(mktemp -p ${OVE_PROJECT_TMP_DIR})
	ove-diff > ${p}
	if [ -s "${p}" ]; then
		p_remote="${d}/${OVE_PROJECT_NAME}.patch"
		if ! scp -q ${p} ${host}:${p_remote}; then
			ove_echo_error_noprefix "not possible to transfer patch file to '${host}'"
			rm ${p}
			return 4
		fi
	fi

	if ! ssh ${host} "
		echo $ ssh ${host};
		echo $ cd ${d}; cd ${d};
		echo $ '${s}'; eval ${s};
		cd \$(find \${PWD} -maxdepth 1 -mindepth 1 -type d);
		echo $ pwd; echo \${PWD};
		echo $ source ove; source ove;
		ove_init;
		echo $ ove fetch; ove-fetch;
		[ -e ${p_remote} ] && echo '$ ove apply ${p_remote}' && ove-apply ${p_remote};
		echo $ ove status; ove-status"; then
		ove_echo_error_noprefix "trying to replicate OVE workspace on '${host}'"
	else
		echo
		echo "OVE workspace has been replicated to '${host}:${d}'"
	fi

	rm ${p}
}

function ove_unittest_preparations {
	local nbr_of_files
	local nbr_of_projs
	local nbr_of_repos
	local nbr_of_systests

	nbr_of_files=$1
	nbr_of_projs=$2
	nbr_of_repos=$3
	nbr_of_systests=$4

	unittest_dir="${OVE_PROJECT_TMP_DIR}/unittest"

	echo "${unittest_dir}"
	[ -d ${unittest_dir} ] && \
		rm -rf ${unittest_dir}
	mkdir -p ${unittest_dir}/.ove

	cd ${unittest_dir} || return 1
	ln -s ${OVE_SELF} ove
	ln -s ${OVE_DIR}/tests .

	# remotes
	mkdir -p remotes

	# create some remote bare repos
	for a in $(seq 1 ${nbr_of_repos}) top; do
		mkdir -p ${unittest_dir}/remotes/git-${a}
		if ! [ -d .git ]; then
			git init -q --bare ${unittest_dir}/remotes/git-${a}
		fi
	done

	# clone all repositories
	mkdir -p testing/src
	for a in $(seq 1 ${nbr_of_repos}); do
		if [ $((a%2)) -eq 0 ]; then
			git clone -q remotes/git-${a} ${unittest_dir}/testing/src/git-${a} &> /dev/null
		else
			git clone -q remotes/git-${a} ${unittest_dir}/git-${a} &> /dev/null
		fi
	done
	git clone -q ${unittest_dir}/remotes/git-top &> /dev/null
	ln -s git-top .owel

	# add some files
	for a in $(seq 1 ${nbr_of_repos}); do
		if [ $((a%2)) -eq 0 ]; then
			cd ${unittest_dir}/testing/src/git-${a}
		else
			cd ${unittest_dir}/git-${a}
		fi

		for i in $(seq 1 ${nbr_of_files}); do
			filename=$(head /dev/urandom | tr -dc A-Za-z0-9 | head -c 13 ; echo '')
			touch ${filename}
			git add ${filename}
			git commit -q -m "${filename}"
			git tag 0.0.${i}
			git push -q origin master
			git push -q --tags
		done
	done

	# create revtab
	for a in $(seq 1 ${nbr_of_repos}); do
		if [ $((a%2)) -eq 0 ]; then
			echo "testing/src/git-${a} ${unittest_dir}/remotes/git-${a} ${unittest_dir}/remotes/git-${a} master" >> ${unittest_dir}/git-top/revtab
		else
			echo "git-${a} ${unittest_dir}/remotes/git-${a} ${unittest_dir}/remotes/git-${a} master" >> ${unittest_dir}/git-top/revtab
		fi
	done

	# create projs
	for a in $(seq 1 ${nbr_of_projs}); do
		echo "p${a}:" >> ${unittest_dir}/git-top/projs
		echo "  path: .owel" >> ${unittest_dir}/git-top/projs
		if [ ${a} -lt ${nbr_of_projs} ]; then
			echo "  deps: p$((a+1))" >> ${unittest_dir}/git-top/projs
		fi
		echo >> ${unittest_dir}/git-top/projs
		mkdir -p ${unittest_dir}/git-top/projects/p${a}
		for b in bootstrap configure build install; do
			echo "#!/bin/bash" > ${unittest_dir}/git-top/projects/p${a}/${b}
			echo "echo ${b} p${a}" >> ${unittest_dir}/git-top/projects/p${a}/${b}
			chmod +x ${unittest_dir}/git-top/projects/p${a}/${b}
		done
	done

	# create systests
	for a in $(seq 1 ${nbr_of_systests}); do
		echo "ok${a} 10 0 \"\" true" >> ${unittest_dir}/git-top/systests
		echo "nok${a} 10 0 \"\" false" >> ${unittest_dir}/git-top/systests
	done
	# create systests-groups
	echo "all:" >> ${unittest_dir}/git-top/systests-groups
	for a in $(seq 1 ${nbr_of_systests}); do
		echo "- ok${a}" >> ${unittest_dir}/git-top/systests-groups
		echo "- nok${a}" >> ${unittest_dir}/git-top/systests-groups
	done

	# commit and push
	git -C ${unittest_dir}/git-top add .
	git -C ${unittest_dir}/git-top commit -q -m "test"
	git -C ${unittest_dir}/git-top push -q origin master
}

# unittest:[TEST...]:run all/specific unit tests
function ove-unittest {
	local a
	local b
	local do_preparations
	local i
	local nbr_of_files
	local nbr_of_projs
	local nbr_of_repos
	local nbr_of_systests
	local tests

	if ! command -v shelltest > /dev/null; then
		echo "shelltestrunner is not found. Version 1.9 or greater is needed"
		return 1
	fi

	if [ $# -eq 0 ]; then
		tests="tests/t*.test"
	else
		for a in "$@"; do
			if ! [ -e "${OVE_DIR}/tests/${a}.test" ]; then
				continue
			fi
			tests+="tests/${a}.test "
		done

		if [ "${tests}" == "" ]; then
			echo "error: select test(s) from:"
			find ${OVE_DIR}/tests -name 't*.test' -type f -exec basename {} .test \; | sort
			return 1
		fi
	fi

	nbr_of_files=3
	nbr_of_projs=400
	nbr_of_repos=100
	nbr_of_systests=3

	do_preparations=1
	if [ -t 1 ] && [ -d ${OVE_PROJECT_TMP_DIR}/unittest ]; then
		do_preparations=0
		read -p "reuse '${OVE_PROJECT_TMP_DIR}/unittest'? (Y/n) " -r
		if [[ ${REPLY} =~ ^[Nn]$ ]]; then
			do_preparations="1"
		fi
	fi

	[ ${do_preparations} -eq 1 ] && \
		GIT_TRACE=1 ove_unittest_preparations ${nbr_of_files} ${nbr_of_projs} ${nbr_of_repos} ${nbr_of_systests}

	# launch shelltestrunner
	cd ${OVE_PROJECT_TMP_DIR}/unittest || return 2
	shelltest=$(command -v shelltest)
	if [ ${OVE_LOGLEVEL} -eq 2 ]; then
		shelltest_opts=" --debug "
	fi

	env -i - HOME=${HOME} USER=${USER} \
		${shelltest} ${tests} \
		${shelltest_opts} \
		--color \
		--diff \
		-a \
		-DOVE_TEST_STRING="source ove > /dev/null; ove_init > /dev/null; ove-loglevel 0 > /dev/null" \
		-Dnbr_of_systests=$(((nbr_of_systests * 2) + 1)) \
		-Dnbr_of_repos=$((nbr_of_repos + 1 )) \
		-Dnbr_of_files=$((nbr_of_files * nbr_of_repos + (4 * nbr_of_projs) + 4)) \
		-DOVE_DIR=${OVE_DIR} \
		-DOVE_TEST_BASE="$(sed -e 's|/|\\/|g' <<<${OVE_PROJECT_TMP_DIR}/unittest)"
}

# less-lastlog:[USER]:peek into user(s) last OVE log using less
function ove-less-lastlog {
	ove_watch_logs "less" "$@"
}

# tail-lastlog:[USER]:peek into user(s) last OVE log using tail -f
function ove-tail-lastlog {
	ove_watch_logs "tail" "$@"
}

# $1: tail|less
# ${@:2}: users
function ove_watch_logs {
	local cmd
	local _cmd
	local d
	local i
	local ignore
	local log
	local u
	local users

	cmd=$1
	if [ "${cmd}" == "tail" ]; then
		cmd="tail -f"
	elif [ "${cmd}" == "less" ]; then
		cmd="less"
	else
		return 1
	fi
	shift

	if [ -d /var/tmp ]; then
		d="/var/tmp"
	else
		d="/tmp"
	fi

	# shellcheck disable=SC2164
	mapfile -t users < <(cd ${d}; find ./*/ove/logs -maxdepth 0 -type d | cut -d/ -f2)

	[ "${users[*]}" == "" ] && return 2

	ignore="tail-lastlog|less-lastlog"
	if [ -n "${TMUX}" ]; then
		for u in ${users[*]}; do
			[ $# -eq 1 ] && [ "${u}" != "${1}" ] && continue

			log=$(find ${d}/${u}/ove/logs/current/ -type f | \
				grep -v -E "${ignore}" | \
				sort | \
				tail -1)

			if [ "${cmd}" == "less" ]; then
				_cmd="less -Ps\"${log}\""
			else
				_cmd=${cmd}
			fi

			tmux split-window -h "${_cmd} ${log}"
			[ $# -eq 1 ] && return
			tmux select-layout tiled
		done
	else
		if [ $# -eq 1 ]; then
			u=$1
		elif [ ${#users[*]} -eq 1 ]; then
			u=${users[0]}
		else
			i=1
			for u in ${users[*]}; do
				echo "$i:$u"
				((i++))
			done
			read -r -p "user: "
			if ! [[ "${REPLY}" =~ ^[0-9]+$ ]] || [ "${REPLY}" -gt ${#users[*]} ]; then
				return 1
			fi
			echo
			u=${users[$((REPLY - 1))]}
		fi

		[ -d "${d}/${u}" ] || return 3
		log=$(find ${d}/${u}/ove/logs/current/ -type f | \
			grep -v -E "${ignore}" | \
			sort | \
			tail -1)
		${cmd} ${log}
	fi
}

# generate-doc: :generate OVE documentation (ove-cmd-list.md/ove.bash)
function ove-generate-doc {
	local a
	local b
	local header
	local sorted

	a=$(grep -B1 "^function ove-" "${OVE_BASE_DIR}"/ove | \
		grep '\#' | \
		cut -b3-)
	b=$(set | \
		grep helptext | \
		grep -v '\$'| \
		cut -d'"' -f2 | \
		grep -v -f<(xargs -n1 <<<${OVE_SCRIPTS_LIST}))

	header="| Command:| Arguments:| Description: |"
	sorted=$(printf "${a}\n${b}" | \
		sed \
		-e 's/|/@/g' \
		-e 's/:/ :| /g' \
		-e 's/^/| /g' \
		-e 's/$/: |/g' | \
		LC_ALL="C" sort)

	printf "${header}\n|-|-|-|\n${sorted}\n" | \
		sed -e 's/\@/\\|/g' | \
		column -s: -t \
		> ${OVE_DIR}/ove-cmd-list.md

	sed -i "s/^ove_built_ins=.*/ove_built_ins=\"$(ove_get_built_ins)\"/g" ${OVE_DIR}/ove.bash

	return 0
}

# shell-check: :run shellcheck on OVE
function ove-shell-check {
	local exclude

	if ! command -v shellcheck > /dev/null; then
		ove_echo_error_noprefix "'shellcheck' is not found"
		return 1
	fi

	# this {/} is literal...
	exclude+="SC1083,"

	# can't follow non-constant source
	exclude+="SC1090,"

	# quote this to prevent word splitting
	exclude+="SC2046,"

	# double quote to prevent globbing and word splitting
	exclude+="SC2086,"

	# use foo "$@" if function's $1 should mean script's $1
	exclude+="SC2119,"

	# foo references arguments, but none are ever passed
	exclude+="SC2120"

	(cd "${OVE_DIR}" && shellcheck -x -e ${exclude} "${OVE_SELF}" > "${OVE_TMP}/shell-check")
	grep -c -o ' SC[0-9]\+.*' "${OVE_TMP}/shell-check" > "${OVE_TMP}/shellcheck.summary"
	grep -o ' SC[0-9]\+.*' "${OVE_TMP}/shell-check" | sort | uniq -c | sort -nr >> "${OVE_TMP}/shellcheck.summary"
	cp -a "${OVE_TMP}/shellcheck.summary" "${OVE_DIR}/tests/.shellcheck"
	git --no-pager -C "${OVE_DIR}" diff -- tests/.shellcheck

	if git diff-files  --quiet -- tests/.shellcheck; then
		return 0
	else
		return 1
	fi
}

# pre-push: :shell-check+unittest+generate-doc combo
function ove-pre-push {
	ove_echo "shell-check"
	ove-shell-check
	ove_echo "unittest"
	ove-unittest
	ove_echo "generate-doc"
	ove-generate-doc
	ove_echo "diff"
	ove-diff .ove
	ove_echo "ove-blame"
	ove-blame "${USER}"
}

ove_main "$@"
