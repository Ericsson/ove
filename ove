#!/usr/bin/env bash
# SPDX-License-Identifier: MIT
#
# MIT License
#
# Copyright (c) 2019 Ericsson
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is furnished
# to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice (including the next
# paragraph) shall be included in all copies or substantial portions of the
# Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
# FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS
# OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
# OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

function ove_read_config {
	local p
	local p_arr
	local val
	local var

	if [ -e "$1" ]; then
		while read p; do
			# ignore comments
			[[ ${p} == \#* ]] && continue
			# ignore empty lines
			[[ ${p} == '' ]] && continue
			p_arr=( ${p} )
			var=${p_arr[0]}
			if [ "$2" == "clean" ]; then
				unset ${var}
			else
				val=${p_arr[*]:1}
				eval ${var}=\"${val}\"
				export ${var}
			fi
		done <$1
	fi
}

function ove_unsource {
	# remove stage string from ${PATH}
	if [ "${OVE_STAGE_DIR}" != "" ] && \
		[[ ${PATH} == *"${OVE_STAGE_DIR}"* ]]; then
		PATH=${PATH/:${OVE_STAGE_DIR}${OVE_PREFIX}\/bin/}
		export PATH
	fi

	unset LD_LIBRARY_PATH

	# clean config variables
	if [ -e ${HOME}/.oveconfig ]; then
		ove_read_config ${HOME}/.oveconfig clean
	elif [ "${OVE_PROJECT_DIR}" != "" ] && \
		[ -e "${OVE_PROJECT_DIR}/.oveconfig" ]; then
		ove_read_config ${OVE_PROJECT_DIR}/.oveconfig clean
	fi

	# unset old ove[-_] functions
	unset -f $(compgen -A function | \
		grep -E '^ove($|[-_])' | \
		grep -E -v "ove_read_config|ove-unsource|${FUNCNAME[0]}" | \
		awk '{print $1}')

	# unset old ove_/OVE_ variables
	unset $(set -o posix ; set | \
		grep -i ^ove_ | \
		cut -d= -f1)

	# unset completion for ove
	if complete -p | grep -q ' ove$'; then
		complete -r ove
	fi
}

# unsource: :clean up all OVE vars/funcs from this shell
function ove-unsource {
	ove_unsource
	# unset leftovers and myself
	unset -f $(compgen -A function | \
		grep -E '^ove($|[-_])' | \
		awk '{print $1}') \
		${FUNCNAME[0]}
}

# interactive shell? clean up
[[ $- == *i* ]] && ove_unsource

function ove_welcome_msg {
	local script_ver

	ove-version
	echo
	echo "This script will do a few things:"
	echo

	echo "* add $(set | grep -c ^ove-) bash functions:"
	set | \
		grep ^ove- | \
		cut -d' ' -f1 | \
		column
	echo
	( set -o posix ; set ) | \
		cut -d= -f1 > ${OVE_TMP}/bash-vars-after

	ove_bash_vars_diff=($(comm -1 -3 <(sort ${OVE_TMP}/bash-vars-before) <(sort ${OVE_TMP}/bash-vars-after) | sort ))
	rm ${OVE_TMP}/bash-vars-after ${OVE_TMP}/bash-vars-before
	echo "* add ${#ove_bash_vars_diff[@]} bash variables:"
	echo ${ove_bash_vars_diff[*]} | \
		xargs -n1 | \
		column
	unset ove_bash_vars_diff

	echo
	echo "* enable tab completion for ove"

	if ! [ -e "${HOME}/.ove.bash" ]; then
		echo
		echo "Do you want to skip the initial 'source ove' step? Run this:"
		echo " cp ${OVE_DIR}/ove.bash ${HOME}/.ove.bash && echo '[ -f ~/.ove.bash ] && source ~/.ove.bash' >> ${HOME}/.bashrc"
	fi

	script_ver=$(script --version | awk '{print $NF}')
	if [[ ${script_ver} =~ ^2.3[12] ]]; then
		echo
		echo "NOTE: due to a bug in $(which script) 2.31/2.32 (you have ${script_ver}), it's not possible to Ctrl-C any ove command."
	fi

	echo
	echo "Now what? Run 'ove fetch' to sync with the outside world or 'ove help' for more information."
}

function ove_main {
	/proc/self/exe --version | grep -q 'GNU bash'
	test $? -ne 0 && echo 'error: run this in bash' && return 1

	if [ ${BASH_VERSINFO[0]} -lt 4 ]; then
		echo "error: bash ${BASH_VERSINFO[0]}.${BASH_VERSINFO[1]} is way too old. I need bash 4.3+"
		return 1
	elif [ ${BASH_VERSINFO[0]} -eq 4 ] && [ ${BASH_VERSINFO[0]} -lt 3 ]; then
		echo "error: bash ${BASH_VERSINFO[0]}.${BASH_VERSINFO[1]} is too old. I need bash 4.3+"
		return 1
	fi

	# pretty terminals
	if [ -t 1 ]; then
		ove_green='\033[0;32m'
		ove_cyan='\033[0;36m'
		ove_yellow='\033[1;33m'
		ove_red='\033[0;31m'
		ove_blank='\033[0m'
	else
		ove_green=''
		ove_cyan=''
		ove_yellow=''
		ove_red=''
		ove_blank=''
	fi

	OVE_TMP=/tmp/${USER}/ove
	export OVE_TMP
	! [ -d "${OVE_TMP}" ] && mkdir -p "${OVE_TMP}"

	# set OVE_OS_* variables
	ove_determine_dist_version_and_pack_manager

	# interactive shell?
	if [[ $- == *i* ]]; then
		# turn off monitor mode to get rid of "Done" messages
		set +m

		if [[ "$*" == *"hush"* ]]; then
			:
		else
			( set -o posix ; set ) | \
				cut -d= -f1 | \
				grep -v ^OVE > ${OVE_TMP}/bash-vars-before
		fi

		if ! ove_deps; then
			ove-unsource
			return 1
		fi

		if [[ "$*" == *"crawl"* ]]; then
			ove_crawl
			return 0
		fi

		if [ -e ".owel" ] && [ -e ove ]; then
			:
		else
			ove_echo_error_noprefix "you have to source this script from a OVE root"
			ove-unsource
			return 1
		fi

		if ! ove_init; then
			ove-unsource
			return 1
		fi

		if [ ${OVE_LOGLEVEL} -eq 0 ] || [[ "$*" == *"hush"* ]]; then
			:
		else
			ove_welcome_msg
		fi

		ove_post_checks

		# turn on monitor mode
		set -m
	fi
}

# $1: pid
function ove_strace_execve_one_pid {
	local cmd
	local exit_code
	local line
	local syscall
	local t0

	cmd=
	pid=$1
	while read -r line; do
		[ "${line}" == "" ] && continue
		syscall=${line#* }
		syscall=${syscall%%(*}

		if [ "${syscall}" == "execve" ]; then
			[[ "${line}" == *"ENOENT"* ]] && continue
			cmd=${line##* [\"}
			cmd=${cmd%%\"]*}
			cmd=${cmd//\", \"/ }
			t0=$(ove_strace_get_t0 ${pid})
			[ "${cmd}" == "" ] && continue
			exit_code=$(ove_strace_get_exit_code ${pid})
			if [ ${OVE_LOGLEVEL} -eq 3 ]; then
				echo "${t0}:${pid}:${exit_code}:${cmd}"
			elif [ ${OVE_LOGLEVEL} -eq 4 ]; then
				echo "$(ove_strace_get_duration_s ${pid}):${pid}:${exit_code}:${cmd}"
			fi
			continue
		fi
	done <<< "${all_files[$1]}"
}

# $1: directory with strace pid files
function ove_analyze_strace_execve_timing {
	local all_files
	local f
	local pid

	! [ -d "$1" ] && return 1

	declare -A all_files
	while true; do
		for f in $(find $1 -type f); do
			pid=${f##*.}
			all_files[${pid}]="$(<${f})"
			ove_strace_execve_one_pid ${pid} &
		done
		wait
		break
	done | sort -n$([ ${OVE_LOGLEVEL} -eq 4 ] && echo r)
}

function ove_line2ipv4 {
	echo ${*} | \
		grep -E -o '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}'
}

# $1: IPv4 address
function ove_ip2host {
	local ip
	local ip_lookup

	if ! command -v dig > /dev/null; then
		ove_echo_error_noprefix "'dig' is not found"
		return 1
	fi

	if ! command -v whois > /dev/null; then
		ove_echo_error_noprefix "'whois' is not found"
		return 1
	fi

	ip=${1}

	if [[ ${ip} == 127* ]]; then
		ip_lookup="localhost"
	else
		ip_lookup=$(dig +short -x ${ip} | \
			tr '\n' ' ' | \
			xargs)

		if [ "${ip_lookup}" == "" ]; then
			ip_lookup="NA"
		else
			ip_lookup=${ip_lookup::-1}
		fi
	fi

	echo ${ip_lookup}
}

# $1: IPv4 address
function ove_ip2org {
	local ip
	local org

	if ! command -v whois > /dev/null; then
		ove_echo_error_noprefix "'whois' is not found"
		return 1
	fi

	ip=${1}

	if [[ ${ip} == 127* ]]; then
		org="NA"
	else
		org=$(timeout 3 whois ${ip} 2> /dev/null | \
			grep -E -i 'netrange:|netname|parent')
		[ "${org}" == "" ] && return
	fi

	printf "${org}"
}

# $1: port
function ove_port2service {
	local port
	local port_service

	port=${1}

	if [ -e /etc/services ]; then
		port_service=$(grep -m1 -w ${port} /etc/services | \
			awk '{print $1}')
	fi

	[ "${port_service}" == "" ] && port_service="NA"
	echo "${port_service}"
}

# $1: pid
function ove_strace_connect_one_pid {
	local cmd
	local ip
	local ip_lookup
	local line
	local port
	local port_service
	local ret
	local sa_family
	local str
	local sun_path
	local syscall

	cmd=
	pid=$1
	while read -r line; do
		[ "${line}" == "" ] && continue
		syscall=${line#* }
		syscall=${syscall%%(*}

		if [ "${syscall}" == "bind" ] ||
			[ "${syscall}" == "connect" ]; then
			sa_family=${line##*sa_family=}
			sa_family=${sa_family%%,*}
			t0=${line%% *}

			ret=${line##* =}
			ret=${ret% <*}
			if [[ "${ret}" == " -1"* ]] && ! [[ "${ret}" != "EINPROGRESS"* ]]; then
				continue
			fi

			if [ "${sa_family}" == "AF_LOCAL" ] || \
				[ "${sa_family}" = "AF_UNIX" ]; then
				sun_path=${line#*\"}
				sun_path=${sun_path%\"*}

				# abstract sockets
				[[ "${line}" == *"=@"* ]] && sun_path="@${sun_path}"

				cmd=$(ove_strace_get_execve ${pid})

				str+="${t0}:${syscall}:${sa_family}:${sun_path}:${cmd}\n"
			elif [ "${sa_family}" == "AF_INET" ]; then
				ip=$(ove_line2ipv4 ${line})
				port=$(echo ${line} | \
					cut -d'(' -f3- | \
					cut -d')' -f1)

				ip_lookup=${ove_ip2host_db["${ip}"]}
				port_service=${ove_port2service_db["${port}"]}
				cmd=$(ove_strace_get_execve ${pid})

				str+="${t0}:${syscall}:${sa_family}:${ip}:${ip_lookup}:${port}:${port_service}:${cmd}\n"
			fi
		fi
	done <<< "${all_files[${pid}]}"

	[ "${str}" != "" ] && printf "${str}"
}

function ove_read_connect_cache {
	local line

	declare -A -g ove_ip2host_db
	declare -A -g ove_ip2org_db
	declare -A -g ove_port2service_db

	if [ -e ${OVE_GLOBAL_STATE_DIR}/ip2host.cache ]; then
		for line in $(cat ${OVE_GLOBAL_STATE_DIR}/ip2host.cache); do
			ove_ip2host_db["${line%%:*}"]="${line##*:}"
		done
	fi

	if [ -e ${OVE_GLOBAL_STATE_DIR}/port2service.cache ]; then
		for line in $(cat ${OVE_GLOBAL_STATE_DIR}/port2service.cache); do
			ove_port2service_db["${line%%:*}"]="${line##*:}"
		done
	fi

	if [ -e ${OVE_GLOBAL_STATE_DIR}/ip2org.cache ]; then
		while read -r line; do
			ove_ip2org_db["${line%%:*}"]="$(echo ${line#*:} | tr '@' '\n')"
		done < <(cat ${OVE_GLOBAL_STATE_DIR}/ip2org.cache)
	fi
}

# $1: directory with strace pid files
function ove_update_connect_db {
	local host
	local ip
	local line
	local org
	local port
	local service

	ove_read_connect_cache

	if command -v ag > /dev/null; then
		ag --nobreak --nofilename -o --nonumbers 'AF_INET,.* =' $1 | \
			sort -u > ${OVE_PROJECT_TMP_DIR}/af_inet
	else
		grep -E -R -o -h 'AF_INET,.* =' $1 | \
			sort -u > ${OVE_PROJECT_TMP_DIR}/af_inet
	fi

	if ! [ -s "${OVE_PROJECT_TMP_DIR}/af_inet" ]; then
		rm ${OVE_PROJECT_TMP_DIR}/af_inet
		return
	fi

	while read -r line; do
		ip=$(ove_line2ipv4 ${line})
		[ "${ip}" == "" ] && continue
		port=$(echo ${line} | \
			cut -d'(' -f2- | \
			cut -d')' -f1)
		[ "${port}" == "" ] && continue

		if ! test "${ove_ip2host_db["${ip}"]+isset}"; then
			host="$(ove_ip2host ${ip})"
			ove_ip2host_db["${ip}"]="${host}"
			echo "${ip}:${host}" >> ${OVE_GLOBAL_STATE_DIR}/ip2host.cache
		fi

		if ! test "${ove_ip2org_db["${ip}"]+isset}"; then
			org="$(ove_ip2org ${ip} | tr '\n' '@')"
			ove_ip2org_db["${ip}"]="$(echo ${org} | tr '@' '\n')"
			echo "${ip}:${org}" >> ${OVE_GLOBAL_STATE_DIR}/ip2org.cache
		fi

		if ! test "${ove_port2service_db["${port}"]+isset}"; then
			service="$(ove_port2service ${port})"
			ove_port2service_db["${port}"]=${service}
			echo "${port}:${service}" >> ${OVE_GLOBAL_STATE_DIR}/port2service.cache
		fi
	done <${OVE_PROJECT_TMP_DIR}/af_inet

	rm ${OVE_PROJECT_TMP_DIR}/af_inet

	for line in ${OVE_GLOBAL_STATE_DIR}/{ip2host,ip2org,port2service}.cache; do
		sort -V -o ${line} ${line} &
	done
	wait
}

# $1: directory with strace pid files
function ove_analyze_strace_connect {
	local all_files
	local f
	local pid

	! [ -d "$1" ] && return 1

	declare -A all_files
	ove_update_connect_db $1
	while true; do
		for f in $(find $1 -type f); do
			pid=${f##*.}
			all_files[${pid}]="$(<${f})"
			ove_strace_connect_one_pid ${pid} &
		done
		wait
		break
	done | sort -n
}

# $1: pid
function ove_strace_get_exit_code {
	local exit_code
	local strace_file

	strace_file=${all_files[$1]}
	exit_code=${strace_file##*$'\n'}
	if [[ "${exit_code}" == *"killed by"* ]]; then
		exit_code=${exit_code##* killed by }
		exit_code=${exit_code%% +++}
	elif [[ "${exit_code}" == *"exited with"* ]]; then
		exit_code=${exit_code##* exited with }
		exit_code=${exit_code%% +++}
	else
		exit_code="alive"
	fi

	echo ${exit_code}
}

# $1: pid
function ove_strace_get_duration_s {
	local diff
	local strace_file
	local t0
	local t1

	strace_file=${all_files[$1]}
	t0=${strace_file%% *}
	t1=${strace_file##*$'\n'}
	t1=${t1%% *}

	[ "${t0}" == "${t1}" ] && echo "0.000000" && return

	diff=$(awk "BEGIN{printf \"%.6f\n\", (${t1} - ${t0})}")
	echo ${diff}
}

# $1: pid
function ove_strace_get_duration_ms {
	local diff
	local strace_file
	local t0
	local t1

	strace_file=${all_files[$1]}
	t0=${strace_file%% *}
	t1=${strace_file##*$'\n'}
	t1=${t1%% *}

	[ "${t0}" == "${t1}" ] && echo "0" && return

	diff=$(awk "BEGIN{printf \"%.0f\n\", (${t1} - ${t0}) * 1000}")
	echo ${diff}
}

# $1: pid
function ove_strace_get_t0 {
	local strace_file
	local t0

	strace_file=${all_files[$1]}
	t0=${strace_file%% *}
	echo ${t0}
}

# $1: pid
function ove_strace_get_execve {
	local cmd
	local line
	local syscall

	while read -r line; do
		[ "${line}" == "" ] && continue
		syscall=${line#* }
		syscall=${syscall%%(*}

		[ "${syscall}" != "execve" ] && continue
		[[ "${line}" == *"ENOENT"* ]] && continue
		cmd=${line##* [\"}
		cmd=${cmd%%\"]*}
		cmd=${cmd//\", \"/ }
	done <<< "${all_files[$1]}"

	[ "${cmd}" == "" ] && cmd="NA"
	echo -e "${cmd}"
}

# $1: pid
function ove_strace_one_pid {
	local cmd
	local duration_ms
	local duration_s
	local ip
	local ip_lookup
	local ip_org
	local key
	local line
	local out_1
	local out_2
	local p
	local pid
	local port
	local port_service
	local ret
	local sa_family
	local suffix
	local sun_path
	local t

	pid=$1

	duration_ms=$(ove_strace_get_duration_ms ${pid})
	duration_s=$(ove_strace_get_duration_s ${pid})
	t=$(ove_strace_get_t0 ${pid})

	# label START
	out_1="    ${pid} [label=\"p: ${pid}\l\nt: ${t}\l\nd: ${duration_ms} ms (${duration_s} s)\l\n"

	# exit code
	exit_code=$(ove_strace_get_exit_code ${pid})
	if [[ "${exit_code}" =~ ^[0-9]+$ ]]; then
		if [ ${exit_code} -ne 0 ]; then
			out_1+="e: ${exit_code}\l\n"
			border_color=$(echo "\"red\"")
		else
			border_color=$(echo "\"green\"")
		fi
	elif [ "${exit_code}" == "alive" ]; then
		border_color=$(echo "\"blue\"")
	else
		out_1+="e: ${exit_code}\l\n"
		border_color=$(echo "\"black\"")
	fi

	cmd=
	out_2=
	declare -A ip_port_cnt
	while read -r line; do
		[ "${line}" == "" ] && continue
		syscall=${line#* }
		syscall=${syscall%%(*}
		! [[ "${syscall}" =~ ^[a-z]+$ ]] && continue

		echo "${t}:${syscall}:${pid}:${duration_ms}:${duration_s}" >> ${OVE_PROJECT_TMP_DIR}/timing
		if [ "${syscall}" == "clone" ] ||
			[ "${syscall}" == "fork" ] ||
			[ "${syscall}" == "vfork" ]; then
			p=${line##* = }
			p=${p%% *}
			! [[ "${p}" =~ ^[0-9]+$ ]] && continue
			out_2+="    ${pid} -> ${p} [label=${syscall}];"
			continue
		elif [ "${syscall}" == "execve" ]; then
			[[ "${line}" == *"ENOENT"* ]] && continue
			cmd=${line##* [\"}
			cmd=${cmd%%\"]*}
			cmd=${cmd//\", \"/ }
			continue
		elif [ "${syscall}" == "bind" ] ||
			[ "${syscall}" == "connect" ]; then
			sa_family=${line##*sa_family=}
			sa_family=${sa_family%%,*}

			ret=${line##* =}
			ret=${ret% <*}
			if [[ "${ret}" == " -1"* ]] && ! [[ "${ret}" != "EINPROGRESS"* ]]; then
				continue
			fi

			if [ "${sa_family}" == "AF_LOCAL" ] || \
				[ "${sa_family}" = "AF_UNIX" ]; then
				sun_path=${line#*\"}
				sun_path=${sun_path%\"*}

				# abstract sockets
				[[ "${line}" == *"=@"* ]] && sun_path="@${sun_path}"

				out_2+="    \"${sun_path}\" [label=\"${sun_path}\l\n\" shape=box3d,fontsize=20,style=filled,fillcolor=\"cyan\"];"
				out_2+="    ${pid} -> \"${sun_path}\" [label=\"${syscall}\"];"
			elif [ "${sa_family}" == "AF_INET" ]; then
				ip=$(ove_line2ipv4 ${line})
				[ "${ip}" == "" ] && continue
				port=$(echo ${line} | \
					cut -d'(' -f3- | \
					cut -d')' -f1)
				[ "${port}" == "" ] && continue

				if test "${ip_port_cnt["${ip}:${port}"]+isset}"; then
					ip_port_cnt["${ip}:${port}"]=$((${ip_port_cnt["${ip}:${port}"]} + 1))
				else
					ip_port_cnt["${ip}:${port}"]=1
				fi

				ip_lookup=${ove_ip2host_db["${ip}"]}
				ip_org=${ove_ip2org_db["${ip}"]}
				port_service=${ove_port2service_db["${port}"]}

				org=$(echo "${ip_org}" | sed -e 's/$/ \\l\\n/g' | tr '\n' ' ' | tr \" \')

				out_2+="    \"${ip}\" [label=\"t: ${t}\l\nIP: ${ip}\l\n${ip_lookup}\l\n${org}\l\n\" shape=box3d,fontsize=20,style=filled, fillcolor=\"yellow\"];"
				out_2+="    ${pid} -> \"${ip}\" [label=\"${syscall} ${port} ${port_service["${port}"]}\"];"
			else
				continue
			fi
		fi
	done <<< "${all_files[$1]}"

	for key in "${!ip_port_cnt[@]}"; do
		ip=${key%%:*}
		port=${key##*:}
		ip_lookup="${ove_ip2host_db["${ip}"]}"
		port_service=${ove_port2service_db["${port}"]}
		if [ ${ip_port_cnt[${ip}:${port}]} -gt 1 ]; then
			suffix="(repeated ${ip_port_cnt[${ip}:${port}]} time(s))"
		fi
		out_1+="c: ${ip}|${ip_lookup}|${port}|${port_service} ${suffix}\l\n"
	done

	# penwidth based on duration
	penwidth=${duration_ms}
	if [ ${duration_ms} -gt 20 ]; then
		penwidth=20
	elif [ ${duration_ms} -eq 0 ]; then
		penwidth=1
	fi

	[ "${cmd}" != "" ] && \
		out_1+="x: $(echo -e ${cmd} | fold -w 80 -s | sed -e 's/$/ \\l\\n/g' | tr '\n' ' ' | tr \" \')"

	# label END
	out_1+="\",color=${border_color},penwidth=${penwidth},fontsize=14,fontcolor=black];"

	echo "${out_1}"
	[ "${out_2}" != "" ] && echo "${out_2}"
}

# strace-graph:DIR:run strace graph analysis on DIR
function ove-strace-graph {
	if [ $# -ne 1 ]; then
		ove-help "^${FUNCNAME/ove-/} "
		return 1
	fi

	ove_strace_create_graph $1 $(basename $1)
}

# strace-execve-timeline:DIR:run strace execve timeline analysis on DIR
function ove-strace-execve-timeline {
	if [ $# -ne 1 ]; then
		ove-help "^${FUNCNAME/ove-/} "
		return 1
	fi

	OVE_LOGLEVEL=3 ove_analyze_strace_execve_timing $1

}

# strace-execve-time:DIR:run strace execve time analysis on DIR
function ove-strace-execve-time {
	if [ $# -ne 1 ]; then
		ove-help "^${FUNCNAME/ove-/} "
		return 1
	fi

	OVE_LOGLEVEL=4 ove_analyze_strace_execve_timing $1
}

# strace-execve-connect:DIR:run strace connect time analysis on DIR
function ove-strace-connect {
	if [ $# -ne 1 ]; then
		ove-help "^${FUNCNAME/ove-/} "
		return 1
	fi

	ove_analyze_strace_connect $1
}

# $1: directory with strace pid files
# $2: append string to output files
function ove_strace_create_graph {
	local all_files
	local f
	local o_base
	local o_dot
	local o_svg
	local o_timing
	local pid

	! [ -d "$1" ] && return 1
	[ $# -ne 2 ] && return 2

	o_base="${OVE_PROJECT_TMP_DIR}/strace-${2}"
	o_dot=${o_base}.dot
	o_svg=${o_base}.svg
	o_timing=${o_base}.timing

	echo "strict digraph $(echo ${OVE_PROJECT_NAME} | tr '-' '_' | tr -d '.') {" > ${o_dot}
	echo "    nodesep=2" >> ${o_dot}
	echo "    ranksep=5" >> ${o_dot}
	echo "    node [margin=1,shape=octagon,nodesep=10];" >> ${o_dot}

	# remove leftovers
	find ${OVE_PROJECT_TMP_DIR} -name "strace-${2}.dot.*" -print0 | xargs -0 rm &> /dev/null

	declare -A all_files
	> ${OVE_PROJECT_TMP_DIR}/timing
	ove_update_connect_db $1
	for f in $(find $1 -type f); do
		pid=${f##*.}
		all_files[${pid}]="$(<${f})"
		ove_strace_one_pid ${pid} >> ${o_dot}.${pid} &
	done
	wait

	# merge all files into one
	find ${OVE_PROJECT_TMP_DIR} -name "strace-${2}.dot.*" -print0 | xargs -0 cat >> ${o_dot}
	find ${OVE_PROJECT_TMP_DIR} -name "strace-${2}.dot.*" -print0 | xargs -0 rm

	echo "}" >> ${o_dot}

	sort -u ${OVE_PROJECT_TMP_DIR}/timing > ${o_timing}
	rm ${OVE_PROJECT_TMP_DIR}/timing

	du -sh ${1} ${o_dot}
	if command -v dot > /dev/null; then
		if ! dot -Tsvg ${o_dot} > ${o_svg}; then
			return 1
		fi
		du -sh ${o_svg}
	fi
}

# $1: timeout in seconds
# $2: files to watch. Passed on to inotifywait --fromfile
function ove_inotifywait {
	local ret

	! [ -e ${2} ] && return 1
	[ $(wc -l < ${2}) -eq 0 ] && return 1

	sleep 0.01
	inotifywait \
		-t ${1} \
		-qq \
		--event modify \
		--event delete_self \
		--event create \
		--event delete \
		--fromfile ${2}
	ret=$?

	sleep 0.01
	[ ${ret} -eq 1 ] && return 1 || return 0
}

function ove_inotify_cleanup {
	find ${OVE_PROJECT_TMP_DIR}/ -name "inotifywait-*-${1}*" -exec rm {} \;
}

# $1: timeout in sec
# $2: use inotifywait (0 or 1)
# $3: max count
# $*: command
function ove_loop_command {
	local all_files
	local cmd
	local counter
	local f
	local files_modified_by_command
	local max_count
	local read_args
	local inotifywait_pid
	local timeout
	local use_inotify

	[ $# -lt 4 ] && return 1

	timeout=$1
	use_inotify=$2
	max_count=$3
	shift 3
	let counter=0
	while true; do
		let counter+=1
		[ ${max_count} -ne 0 ] && [ ${counter} -gt ${max_count} ] && break
		clear
		ove_echo_cyan_error "ove-${*} [c:${counter} t:${timeout} i:${use_inotify} m:${max_count}]"

		# inotify: first iteration?
		if [ ${use_inotify} -eq 1 ] && [ ${counter} -eq 1 ]; then
			all_files=$(mktemp -u -p ${OVE_PROJECT_TMP_DIR} inotifywait-fromfile-XXXXXXXXXX)

			# trap to be able to cleanup files
			trap "ove_inotify_cleanup ${all_files: -10}" EXIT

			# start inotifywait in monitor mode in the background
			# monitor all files (for now)
			cmd='for f in $(git ls-files); do [ -f ${f} ] && echo ${PWD}/${f}; done; echo ${PWD}/.git'
			ove_revtab_forall_parallel "${cmd}" > ${all_files}
			files_modified_by_command=${OVE_PROJECT_TMP_DIR}/inotifywait-${1}-${all_files: -10}

			if [ $(cat /proc/sys/fs/inotify/max_user_watches) -lt $(wc -l < ${all_files}) ]; then
				ove_echo_error_noprefix "you need to increase the number of inotify user watches. Try:"
				echo
				echo "$ sudo bash -c 'echo $(wc -l < ${all_files}) > /proc/sys/fs/inotify/max_user_watches'"
				read -p ""
				return 1
			fi

			inotifywait \
				-q \
				-m \
				--format '%w%f' \
				--fromfile ${all_files} > ${files_modified_by_command} &
			inotifywait_pid=${!}
			# let inotify start up
			sleep 1

			# still running?
			if ! kill -0 ${inotifywait_pid} > /dev/null 2>&1; then
				return 1
			fi
		fi

		# run the command
		OVE_PAGER='tee /dev/null' ove-${1} ${*:2}

		# inotify: first iteration?
		if [ ${use_inotify} -eq 1 ] && [ ${counter} -eq 1 ]; then
			sleep 1
			kill -9 ${inotifywait_pid} &> /dev/null
			wait &> /dev/null
			rm ${all_files}

			# remove doublets and only regular files
			for f in $(sort -u ${files_modified_by_command}); do
				[ -f ${f} ] && echo ${f};
			done > ${files_modified_by_command}.uniq
			rm ${files_modified_by_command}
			if [ $(wc -l < ${files_modified_by_command}.uniq) -eq 0 ]; then
				use_inotify=0
				ove_echo_cyan_error "0 files touched, not using inotifywait"
			else
				echo
				echo "$(wc -l < ${files_modified_by_command}.uniq) uniq file(s) was touched by '${1} ${*:2}': ${files_modified_by_command}.uniq"
			fi
		fi

		echo -
		if [ ${use_inotify} -eq 1 ]; then
			if ! ove_inotifywait ${timeout} ${files_modified_by_command}.uniq; then
				break
			fi
		else
			[ "${timeout}" -gt 0 ] && read_args="-t ${timeout}"
			read -n 1 -s -r -p '' ${read_args}
			[[ ${REPLY} =~ ^[Qq]$ ]] && break
		fi
	done
}

# run:|TIMEOUT COMMAND:run one OVE command in terminal|tmux
function ove-run {
	local _cmd
	local cmd
	local read_args

	if [ $# -eq 1 ]; then
		ove-help "^${FUNCNAME/ove-/} "
		return 1
	fi

	if [ $# -eq 0 ]; then
		read -p "command timeout in sec (default 0 = no timeout): "
		[ "${REPLY}" == "" ] && timeout=0 || timeout=${REPLY}
		read -p "command: "
		[ "${REPLY}" == "" ] && return || cmd=${REPLY}
	else
		timeout=$1
		shift
		cmd=$*
	fi

	if ! [[ "${timeout}" =~ ^[0-9]+$ ]]; then
		echo "error: timeout: just numbers"
		return 1
	fi

	cmd=${cmd#ove }
	cmd=${cmd#ove-}
	_cmd=$(echo ${cmd} | cut -d' ' -f1)
	if [ "$(type -t ove-"${_cmd}")" != "function" ]; then
		ove_echo_red_noprefix "error: '${_cmd}' unknown command"
		return 1
	fi

	# turn off monitor mode to get rid of "Done" messages
	set +m
	[ "${timeout}" -gt 0 ] && read_args="-t ${timeout}"

	if [ -n "${TMUX}" ]; then
		tmux split-window -h "\
			source ${OVE_BASE_DIR}/ove; \
			ove_init; \
			ove_echo_cyan_error \"ove-${cmd}\"; \
			OVE_PAGER='tee /dev/null' ove-${cmd}; \
			echo -; \
			read -n 1 -s -r -p '' ${read_args}"

		tmux select-layout main-vertical
		tmux select-pane -t 0
	else
		ove_echo_cyan_error "ove-${cmd}"
		OVE_PAGER='tee /dev/null' ove-${cmd}
		echo -
		read -n 1 -s -r -p '' ${read_args}
	fi

	# turn on monitor mode
	set -m
}

# loop:|[TIMEOUT|?] [INOTIFY|?] [MAX-COUNT|?] COMMAND]:loop one OVE command
function ove-loop {
	local _cmd
	local cmd
	local max_count
	local timeout
	local use_inotify

	if [ $# -gt 0 ] && [ $# -lt 4 ]; then
		ove-help "^${FUNCNAME/ove-/} "
		return 1
	fi

	if [ $# -eq 0 ]; then
		read -p "command timeout in sec (default 0 = no timeout): "
		[ "${REPLY}" == "" ] && timeout=0 || timeout=${REPLY}
		read -p "inotify 0=no 1=yes (default 0): "
		[ "${REPLY}" == "" ] && use_inotify=0 || use_inotify=${REPLY}
		read -p "max count: (default 0 = forever): "
		[ "${REPLY}" == "" ] && max_count=0 || max_count=${REPLY}
		read -p "command: "
		[ "${REPLY}" == "" ] && return || cmd=${REPLY}
	else
		if [ "$1" == "?" ]; then
			read -p "command timeout in sec (0=no timeout): "
			[ "${REPLY}" == "" ] && timeout=0 || timeout=${REPLY}
		else
			timeout=$1
		fi

		if [ "$2" == "?" ]; then
			read -p "inotify 0=no 1=yes (default 0): "
			[ "${REPLY}" == "" ] && use_inotify=0 || use_inotify=${REPLY}
		else
			use_inotify=$2
		fi

		if [ "$3" == "?" ]; then
			read -p "max count: (default 0 = forever): "
			[ "${REPLY}" == "" ] && max_count=0 || max_count=${REPLY}
		else
			max_count=$3
		fi

		shift 3
		cmd=$*
	fi

	if ! [[ "${timeout}" =~ ^[0-9]+$ ]]; then
		echo "error: timeout: just numbers"
		return 1
	fi

	if ! [[ "${use_inotify}" =~ ^[0-1]$ ]]; then
		echo "error: inotify: 0 or 1"
		return 1
	fi

	if [ "${use_inotify}" -eq 1 ] && ! command -v inotifywait > /dev/null; then
		echo "duckduckgo.com/?q=inotifywait"
		return 1
	fi

	if ! [[ "${max_count}" =~ ^[0-9]+$ ]]; then
		echo "error: max count: just numbers"
		return 1
	fi

	cmd=${cmd#ove }
	cmd=${cmd#ove-}
	_cmd=$(echo ${cmd} | cut -d' ' -f1)
	if [ "$(type -t ove-"${_cmd}")" != "function" ]; then
		ove_echo_red_noprefix "error: '${_cmd}' unknown command"
		return 1
	fi

	if [ -n "${TMUX}" ]; then
		tmux split-window -h "\
			source ${OVE_BASE_DIR}/ove; \
			ove_init; \
			ove_loop_command ${timeout} ${use_inotify} ${max_count} ${cmd}"

		tmux select-layout main-vertical
		tmux select-pane -t 0
	else
		ove_loop_command ${timeout} ${use_inotify} ${max_count} ${cmd}
	fi
}

function ove {
	local args
	local candidates
	local cmd
	local re
	local ret
	local script_help
	local script_opts
	local strace_expression

	cmd="$1"
	if [ "$#" -eq 0 ]; then
		ove-fzf || ove-help
	elif [ "$(type -t ove-"${cmd}")" != "function" ]; then
		re=\\b${cmd}
		if ! [[ "${OVE_ALL_COMMANDS}" =~ ${re} ]]; then
			ove_echo_red_noprefix "error: '${cmd}' unknown command"
			return 1
		fi

		candidates=$(ove-help $(echo ${OVE_ALL_COMMANDS} | \
			xargs -n1 | \
			grep --color=never ^${cmd} | \
			sed -e 's/^/^/g' -e 's/$/\\s/g'))

		if [ ${OVE_AUTOCORRECT} -eq 1 ] && [ $(printf "${candidates}\n" | wc -l) -eq 1 ]; then
			cmd=$(printf "${candidates}\n" | \
				sed -e "s/\x1B\[[0-9;]*[mK]//g" | \
				awk '{print $1}')
			ove ${cmd} ${*:2}
			return $?
		fi

		ove_echo_red_noprefix "error: '${cmd}' unknown command"
		echo
		echo "Did you mean?"
		printf "${candidates}\n"

		return 1
	elif [ "${cmd}" == "!" ] || \
		[ "${cmd}" == "cd" ] || \
		[ "${cmd}" == "dry-run" ] || \
		[ "${cmd}" == "loglevel" ] || \
		[ "${cmd}" == "checkout" ] || \
		[ "${cmd}" == "switch" ] || \
		[ "${cmd}" == "unsource" ]; then
		ove-${cmd} ${@:2}
	else
		# sanity check
		if ! ove_get_base_dir > /dev/null; then
			return 1
		fi

		args="${*:2}"
		mkdir -p ${OVE_LOG_DIR}/${OVE_SHA}
		(cd ${OVE_LOG_DIR} && ln -sfn ${OVE_SHA} current)
		OVE_LAST_COMMAND="${OVE_LOG_DIR}/${OVE_SHA}/$(date '+%Y%m%d-%H%M%S%N')-ove-${cmd}-$(hostname)-${OVE_PROJECT_NAME}.log"

		if [ -t 1 ]; then
			script_help=$(2>&1 script --help)
			if [[ "${script_help}" != *"invalid option"* ]] && \
				[[ "${script_help}" == *"-e"* ]]; then
				script_opts+="-e "
			fi

			if [ ${OVE_LOGLEVEL} -gt 2 ] && [ ${OVE_LOGLEVEL} -lt 7 ]; then
				[ -e ${OVE_PROJECT_TMP_DIR}/strace-${cmd} ] && \
					rm -rf ${OVE_PROJECT_TMP_DIR}/strace-${cmd}
				mkdir -p ${OVE_PROJECT_TMP_DIR}/strace-${cmd}

				if [ ${OVE_LOGLEVEL} -eq 5 ]; then
					strace_expression="connect,bind,execve"
				elif [ ${OVE_LOGLEVEL} -eq 6 ]; then
					strace_expression="execve,clone,fork,vfork,connect,bind"
				else
					strace_expression="execve"
				fi

				OVE_ANALYZE_EXECVE="strace \
					-s 1024 \
					-q \
					-o ${OVE_PROJECT_TMP_DIR}/strace-${cmd}/strace-${cmd} \
					-ff \
					-T \
					-e ${strace_expression} \
					-ttt"
				export OVE_ANALYZE_EXECVE
			else
				unset OVE_ANALYZE_EXECVE
			fi

			if ! [ -z "${OVE_ANALYZE_EXECVE+x}" ]; then
				[ -e ${OVE_PROJECT_TMP_DIR}/strace.pid ] && \
					rm ${OVE_PROJECT_TMP_DIR}/strace.pid
				[ -e ${OVE_PROJECT_TMP_DIR}/strace.cont ] && \
					rm ${OVE_PROJECT_TMP_DIR}/strace.cont

				{
					while true; do [ -e ${OVE_PROJECT_TMP_DIR}/strace.pid ] && break; done

					# launch strace in background and let strace start up
					(${OVE_ANALYZE_EXECVE} -p $(cat ${OVE_PROJECT_TMP_DIR}/strace.pid) &)
					sleep 1
					> ${OVE_PROJECT_TMP_DIR}/strace.cont
				} &
			fi

			# turn off monitor mode to get rid of "Done" messages
			set +m
			SHELL=$(command -v bash) \
				script ${script_opts} -q -c \
				"source ${OVE_BASE_DIR}/ove; ove_init quick; ove-${cmd} ${args}" \
				${OVE_LAST_COMMAND}
			ret=$?

			if ! [ -z "${OVE_ANALYZE_EXECVE+x}" ]; then
				pkill -SIGTERM -f strace
				[ -e ${OVE_PROJECT_TMP_DIR}/strace.pid ] && \
					rm ${OVE_PROJECT_TMP_DIR}/strace.pid
				[ -e ${OVE_PROJECT_TMP_DIR}/strace.cont ] && \
					rm ${OVE_PROJECT_TMP_DIR}/strace.cont

				while true; do
					if [ ${OVE_LOGLEVEL} -eq 3 ] || [ ${OVE_LOGLEVEL} -eq 4 ]; then
						ove_analyze_strace_execve_timing ${OVE_PROJECT_TMP_DIR}/strace-${cmd}
					elif [ ${OVE_LOGLEVEL} -eq 5 ]; then
						ove_analyze_strace_connect ${OVE_PROJECT_TMP_DIR}/strace-${cmd}
					elif [ ${OVE_LOGLEVEL} -eq 6 ]; then
						ove_strace_create_graph ${OVE_PROJECT_TMP_DIR}/strace-${cmd} ${cmd}
					fi
					break
				done | tee -a ${OVE_LAST_COMMAND}
			fi

			sed -i -e 's/\r$//' -e 's/\x0//' ${OVE_LAST_COMMAND}
			ln -s -f ${OVE_LAST_COMMAND} ${OVE_LOG_DIR}/last

			return ${ret}
		else
			{
				ove-"${cmd}" ${args}
			} 2>&1 | tee -i ${OVE_LAST_COMMAND}
			ret=${PIPESTATUS[0]}
			sed -i 's/\x0//g' ${OVE_LAST_COMMAND}
			ln -s -f ${OVE_LAST_COMMAND} ${OVE_LOG_DIR}/last
			return ${ret}
		fi
	fi
}

# fzf:[loop]:OVE fzf [duckduckgo.com/?q=fzf]
function ove-fzf {
	local args
	local cmd

	if ! command -v fzf > /dev/null; then
		return 1
	fi

	# sanity check
	if ! ove_get_base_dir > /dev/null; then
		return 1
	fi

	if [ $# -gt 1 ]; then
		ove-help "^${FUNCNAME/ove-/} "
		return 1
	fi

	while true; do
		cmd=$(echo ${OVE_ALL_COMMANDS} | \
			xargs -n 1 | \
			grep -v '!' | \
			fzf \
			--cycle \
			--preview '${OVE_INIT_STRING}; ove-help ^{1}\\s' \
			--preview-window=down:1 \
		)
		[ "${cmd}" == "" ] && break

		if echo ${OVE_BUILT_INS_WITHOUT_ARGS} | tr ' ' '\n' | grep -q ^${cmd}$; then
			if [ "$1" == "loop" ]; then
				echo "$ ove-loop ? ? ? ${cmd}"
				ove-loop ? ? ? ${cmd}
				echo -
			else
				ove-run 0 ${cmd}
			fi
			continue
		fi

		COMP_WORDS=(ove ${cmd} ' ')
		COMP_LINE="ove ${cmd}"
		COMP_CWORD=3
		COMP_POINT=${#COMP_LINE}
		ove_bash_complete
		if [ ${#COMPREPLY[@]} -eq 0 ]; then
			if [ $1 == "loop" ]; then
				echo "$ ove-loop ? ? ? ${cmd}"
				ove-loop ? ? ? ${cmd}
				echo -
			else
				ove-run 0 ${cmd}
			fi
		else
			args=$(printf '%s\n' "${COMPREPLY[@]}" | \
				sort -u | \
				fzf \
					--cycle \
					--preview "echo ESC\|CTRL+C to skip args $ ove ${cmd} {}" \
					--preview-window=down:1)

			if [ "$1" == "loop" ]; then
				echo "$ ove-loop ? ? ? ${cmd} ${args}"
				ove-loop ? ? ? ${cmd} ${args}
				echo -
			else
				ove-run 0 ${cmd} ${args}
			fi
		fi
	done
}

function ove_projects_init {
	unset ove_projects_name
	unset ove_projects_deps
	unset ove_projects_path
	unset ove_projects_needs
	unset ove_projects_version
	unset ove_projects_name2index

	declare -a -g ove_projects_name
	declare -a -g ove_projects_deps
	declare -a -g ove_projects_path
	declare -a -g ove_projects_needs
	declare -a -g ove_projects_version
	declare -A -g ove_projects_name2index

	ove_number_of_projects=0
}

# not really a complete YAML parser
function ove_parse_yaml {
	local line

	while IFS=: read line; do
		[[ ${line} == "---" ]] && continue
		(echo ${line#*: } | sed -e 's/: /:/g' -e "s/\([a-z]\+\):/\" ove_${line%%:*}_\1=\"/g" -e "s/$/\"/g" -e "s/^\" //g" -e "s/ \"/\"/g" & )
	done < <(sed -e 's/^\([a-z]\+:$\)/\n\1/g' -e 's/#.*//g' $1 | awk NF=NF RS= OFS=' ')
	wait
}

# uniq list of project commands
function ove_project_commands_list {
	local f
	local proj
	local search_dirs

	# for each project, look for executable files
	# ignore files with hyphens and underscore
	for proj in ${OVE_PROJECT_LIST} common; do
		# ignore projects without a project directory
		[ ! -d ${OVE_PROJECT_DIR}/projects/${proj} ] && continue

		search_dirs+="${proj} "
	done

	[ "${search_dirs}" == "" ] && return

	for f in $(cd ${OVE_PROJECT_DIR}/projects; find -L ${search_dirs} -perm -u=x -type f); do
		echo ${f#*/}
	done | \
		grep -v '[-_]' | \
		sort -u | \
		xargs
}

# uniq list of mandatory attributes
function ove_projects_attributes {
	if [ -f "${OVE_PROJECT_DIR}"/projs ]; then
		grep -E -o '  \w+:' "${OVE_PROJECT_DIR}"/projs | \
			cut -d: -f1 | \
			tr -d ' ' | \
			sort -u
	fi
}

# list of project tags and branches
function ove_project_tags_and_branches {
	(
	git -C "${OVE_PROJECT_DIR}" tag
	git -C "${OVE_PROJECT_DIR}" branch --no-color --all --list | \
		grep -v HEAD | \
		tr -d '*' | \
		xargs | \
		tr ' ' '\n'
	) | sort -V
}

# iterate through projects
function ove_projects_parse {
	local i
	local m
	local projects
	local tmp_var

	ove_number_of_projects=0

	[ ! -e "${OVE_PROJECT_DIR}/projs" ] && return

	eval $(ove_parse_yaml "${OVE_PROJECT_DIR}/projs")

	# create ove-functions for all project commands
	for m in ${OVE_PROJECT_COMMANDS}; do
		eval "ove-${m}() {
			local count
			local helptext=\"${m}:[PROJECT...]:run the '${m}' step for all or individual projects\"
			local p

			if ! ove_build_pre \$*; then
				return 1
			fi

			if [ \$# -eq 0 ]; then
				count=0
				while ((count < ove_number_of_projects)); do
					if ! ove_projects_cmd "\${ove_projects_name[\${count}]}" ${m}; then
						return 1
					fi
					let count+=1
				done
			else
				for p in \$@; do
					if ! ove_projects_cmd \${p} ${m}; then
						return 1
					fi
				done
			fi

		}"
	done

	# create parallel ove-functions for all project commands
	for m in ${OVE_PROJECT_COMMANDS}; do
		eval "ove-${m}-parallel() {
			local count
			local helptext=\"${m}-parallel:[PROJECT...]:run the '${m}' step for all or individual projects (in parallel)\"
			local p

			if ! ove_build_pre \$*; then
				return 1
			fi

			if [ \$# -eq 0 ]; then
				count=0
				while ((count < ove_number_of_projects)); do
					{
						if ! ove_projects_cmd "\${ove_projects_name[\${count}]}" ${m}; then
							kill -USR1 \$\$
						fi
					} &
					let count+=1
				done
			else
				for p in \$@; do
					{
						if ! ove_projects_cmd \${p} ${m}; then
							kill -USR1 \$\$
						fi
					} &
				done
			fi

			wait
		}"
	done

	projects=(${OVE_PROJECT_LIST})
	ove_number_of_projects=${#projects[@]}

	# set projects deps|name|path|needs|version
	i=0
	while ((i < ove_number_of_projects)); do
		# name
		ove_projects_name[${i}]=${projects[${i}]}
		unset ove_${projects[${i}]}

		# index
		ove_projects_name2index[${projects[${i}]}]=${i}

		# deps
		tmp_var="ove_${projects[${i}]}_deps"
		ove_projects_deps[${i}]=${!tmp_var}
		unset ${tmp_var}

		# path
		tmp_var="ove_${projects[${i}]}_path"
		ove_projects_path[${i}]=${!tmp_var}
		unset ${tmp_var}

		# needs
		tmp_var="ove_${projects[${i}]}_needs"
		ove_projects_needs[${i}]=${!tmp_var}
		unset ${tmp_var}

		# version
		tmp_var="ove_${projects[${i}]}_version"
		ove_projects_version[${i}]=${!tmp_var}
		unset ${tmp_var}

		let i+=1
	done
}

function ove_list_projects_without_deps {
	local i

	i=0
	while ((i < ove_number_of_projects)); do
		if [ "${ove_projects_deps[${i}]}" == "" ]; then
			echo -n "${ove_projects_name[${i}]} "
		fi
		let i+=1
	done
}

function ove_list_projects_with_deps {
	local i

	i=0
	while ((i < ove_number_of_projects)); do
		if [ "${ove_projects_deps[${i}]}" != "" ]; then
			echo -n "${ove_projects_name[${i}]} "
		fi
		let i+=1
	done
}

function ove_list_projects_paths {
	local i
	local s

	i=0
	while ((i < ove_number_of_projects)); do
		s+="${OVE_BASE_DIR}/${ove_projects_path[${i}]} "
		let i+=1
	done

	echo -n "${s}"
}

# $1: target
# $2: command
function ove_projects_cmd {
	local cmd
	local index
	local path
	local ret
	local target

	target=$1
	cmd=$2
	ret=0

	# sanity check
	! [ -e "${OVE_PROJECT_DIR}/projects/${target}/${cmd}" ] && return

	index=${ove_projects_name2index[${target}]}

	# create dir if needed
	[ ! -d "${OVE_BASE_DIR}"/"${ove_projects_path[${index}]}" ] \
		&& mkdir -vp "${OVE_BASE_DIR}"/"${ove_projects_path[${index}]}"

	path="${OVE_BASE_DIR}/${ove_projects_path[${index}]}"

	if [ ${OVE_LOGLEVEL} -ne 0 ]; then
		ove_echo_cyan_error "${target}: ${cmd}"
	fi

	if [ "${OVE_DRY_RUN}" -eq 0 ]; then
		pushd "${path}" &>/dev/null
	fi

	# common for this command?
	if [ -e "${OVE_PROJECT_DIR}/projects/common/${cmd}" ]; then
		source "${OVE_PROJECT_DIR}/projects/common/${cmd}"
		# preserve return code
		ret="$?"
	fi

	if [ ${ret} -eq 0 ]; then
		# "$1"/$2 is no longer needed
		shift 2

		if [ ${OVE_DRY_RUN} -eq 0 ]; then
			# run it
			eval "${target}_version=${ove_projects_version[${index}]} \
				${OVE_PROJECT_DIR}/projects/${target}/${cmd} \
				${OVE_REDIRECT_OUTPUT}"
		else
			# dry: print the command
			ove_echo_stderr_noprefix "cd ${path} && ${OVE_PROJECT_DIR}/projects/${target}/${cmd}"
		fi

		# preserve return code
		ret="$?"
	fi

	# exit directory
	[ "${OVE_DRY_RUN}" -eq 0 ] && popd &>/dev/null

	if [ "${ret}" -ne 0 ]; then
		ove_echo_error "${target}: ${cmd}"
	else
		if [ ${OVE_LOGLEVEL} -ne 0 ]; then
			ove_echo_cyan_error "${target}: ${cmd}: done"
		fi
	fi

	return "${ret}"
}

function ove_revtab_init {
	unset ove_revtab_fetch_url
	unset ove_revtab_push_url
	unset ove_revtab_rev
	unset ove_revtab_git_name

	declare -a -g ove_revtab_fetch_url
	declare -a -g ove_revtab_push_url
	declare -a -g ove_revtab_rev
	declare -a -g ove_revtab_git_name
	declare -A -g ove_revtab_basename2index

	ove_revtab_num_repositories=0
}

function ove_revtab_parse {
	local array
	local line

	[ ! -e "${OVE_PROJECT_DIR}/revtab" ] && return

	ove_revtab_num_repositories=0

	while read line; do
		# skip comments and blank lines
		[ "${line:0:1}" == "#" ] && continue
		[ "${line}" == "" ] && continue

		array=(${line})

		ove_revtab_git_name[${ove_revtab_num_repositories}]=${array[0]}
		ove_revtab_fetch_url[${ove_revtab_num_repositories}]=${array[1]}
		ove_revtab_push_url[${ove_revtab_num_repositories}]=${array[2]}
		ove_revtab_rev[${ove_revtab_num_repositories}]=${array[3]}
		ove_revtab_basename2index[${array[0]##*/}]=${ove_revtab_num_repositories}

		let ove_revtab_num_repositories+=1
	done < "${OVE_PROJECT_DIR}/revtab"
}

# $1: git (either basename, sub dir or fullpath)
function ove_git2fullpath {
	local git_basename
	local git_fullpath
	local index

	git_basename=${1##*/}
	index=${ove_revtab_basename2index[${git_basename}]}

	# product repo?
	if [ "${index}" == "" ] && [ "${git_basename}" == "${OVE_PROJECT_NAME}" ]; then
		git_fullpath="${OVE_BASE_DIR}/${OVE_PROJECT_NAME}"
	elif [ "${index}" != "" ]; then
		git_fullpath="${OVE_BASE_DIR}/${ove_revtab_git_name[${index}]}"
	fi

	echo ${git_fullpath}
}

# $1: git (either basename, sub dir or fullpath)
function ove_git2shortpath {
	local git_basename
	local git_shortpath
	local index

	git_basename=${1##*/}
	index=${ove_revtab_basename2index[${git_basename}]}

	# product repo?
	if [ "${index}" == "" ] && [ "${git_basename}" == "${OVE_PROJECT_NAME}" ]; then
		git_shortpath="${OVE_PROJECT_NAME}"
	elif [ "${index}" != "" ]; then
		git_shortpath="${ove_revtab_git_name[${index}]}"
	fi

	echo ${git_shortpath}
}

# $1: git
function ove_status_one_repo {
	local git_fullpath

	git_fullpath=$(ove_git2fullpath $1)
	if [ "${git_fullpath}" == "" ] || ! [ -d "${git_fullpath}" ]; then
		return
	fi

	printf "$(ove_git2shortpath $1):$(git -c color.status=always -C "${git_fullpath}" status -zbs -uno | tr '\0' ' ')\n"
}

function ove_validate_repo_list {
	local git_basename
	local repos

	while true; do
		git_basename=${1##*/}
		[ $# -eq 0 ] && break
		if [ "$1" == "${OVE_PROJECT_NAME}" ] || [ -v ove_revtab_basename2index[${git_basename}] ]; then
			repos+="$(ove_git2shortpath $1)\n"
		fi
		shift
	done

	echo -e "${repos}" | sort -u | xargs -n1
}

function ove_revtab_status {
	local f
	local git
	local repos

	if [ $# -ge 1 ]; then
		repos=$(ove_validate_repo_list $*)
	else
		repos=${OVE_REPO_LIST}
	fi

	[ "${repos}" == "" ] && return

	f="${OVE_PROJECT_STATE_DIR}/$(date '+%Y%m%d-%H%M%S%N')-revtab-status"

	> ${f}
	for git in ${repos}; do
		ove_status_one_repo ${git} >> ${f} &
	done

	wait

	LC_ALL="C" sort ${f} | \
		column -t -s:

	mv "${f}" "${OVE_PROJECT_STATE_DIR}/revtab-status"
}

# $1: ahead|behind
function ove_revtab_status_parse_one {
	local git_args
	local git_fmt
	local git_fullpath
	local git_status
	local i
	local nbr_commits
	local tense

	tense=$1
	shift

	git_fmt='%h?%ar?%ae?%s'
	git_fullpath=$(ove_git2fullpath $1)

	if [ "${git_fullpath}" == "" ] || ! [ -d "${git_fullpath}" ]; then
		return
	fi

	git_status=$(git -C "${git_fullpath}" status -zbs -uno | tr '\0' ' ')
	nbr_commits=0

	# keep 'ahead X, behind Y'
	git_status=${git_status##*[}
	git_status=${git_status%%]*}

	if [[ "${git_status}" == *"${tense}"* ]]; then
		if [ "${tense}" == "ahead" ]; then
			git_status=${git_status%%,*}
			nbr_commits=${git_status##${tense} }
		elif [ "${tense}" == "behind" ]; then
			nbr_commits=${git_status##*${tense} }
			git_args="FETCH_HEAD"
		else
			return 1
		fi

		ove_echo_yellow_noprefix "$(ove_git2shortpath $1): ${nbr_commits} new commit(s):"
		git --no-pager -C "${git_fullpath}" log ${git_args} -n ${nbr_commits} --format="${git_fmt}" | \
			column -t -s?
		echo
	fi
}

# $1: ahead|behind
function ove_revtab_status_parse {
	local git
	local repos
	local tense

	[ $# -eq 0 ] && return 1

	tense="$1"
	shift

	# turn off monitor mode to get rid of "Done" messages
	set +m

	if [ $# -ge 1 ]; then
		repos=$(ove_validate_repo_list $*)
	elif [ -e ${OVE_PROJECT_STATE_DIR}/revtab-status ] && grep -q "\[.*${tense}.*\]" ${OVE_PROJECT_STATE_DIR}/revtab-status; then
		repos=$(grep "\[.*${tense}.*\]" ${OVE_PROJECT_STATE_DIR}/revtab-status | \
			cut -d: -f1 | \
			xargs)
	else
		repos=${OVE_REPO_LIST}
	fi

	for git in ${repos}; do
		ove_revtab_status_parse_one ${tense} ${git}
	done

	# turn on monitor mode
	set -m
}

function ove_revtab_list {
	local count
	local str
	local url

	count=0

	if [ "${ove_revtab_num_repositories}" == 0 ]; then
		echo "run 'ove fetch' first!"
		return 1
	fi

	while ((count < ove_revtab_num_repositories)); do
		str+="${ove_revtab_git_name[${count}]} ${ove_revtab_fetch_url[${count}]} ${ove_revtab_push_url[${count}]} ${ove_revtab_rev[${count}]}\n"
		let count+=1
	done

	url=$(git -C "${OVE_PROJECT_DIR}" config --get remote.origin.url)
	str+="${OVE_PROJECT_NAME} ${url} ${url} $(git -C "${OVE_PROJECT_DIR}" rev-parse --abbrev-ref HEAD)\n"

	printf "${str}" | \
		sort | \
		column -t
}

# $1: name
# $2: rev
function ove_revtab_check_one {
	local a
	local b
	local name
	local rev

	name=$1
	rev=$2

	if [ -d "${OVE_BASE_DIR}/${name}" ]; then
		a=$(git -C ${OVE_BASE_DIR}/${name} rev-list -n 1 --abbrev-commit HEAD --)
		b=$(git -C ${OVE_BASE_DIR}/${name} rev-list -n 1 --abbrev-commit ${rev} --)
		[ $? -ne 0 ] &&  b=""

		if [ "${a}" != "${b}" ]; then
			ove_echo_cyan_noprefix "${name}: HEAD (${a} = $(git -C ${OVE_BASE_DIR}/${name} describe --tags --always)) is different from the revtab revision (${b} = ${rev})"

			if test -z "$(git -C ${OVE_BASE_DIR}/${name} --no-pager status --porcelain -uno)"; then
				ove_echo_cyan_noprefix "${name}: checkout '${rev}'"
				ove_revtab_checkout ${name}
				ove_patch_repositories
			else
				ove_echo_yellow_noprefix "${name}: cannot checkout '${rev}' as repo is dirty:"
			fi
		fi
	fi
}

function ove_revtab_check {
	local count

	[ "${ove_revtab_num_repositories}" == 0 ] && return 1

	set +m

	count=0
	while ((count < ove_revtab_num_repositories)); do
		ove_revtab_check_one ${ove_revtab_git_name[${count}]} ${ove_revtab_rev[${count}]} &
		let count+=1
	done | grep -v '^\['
	wait
}

function ove_revtab_list_fullpath {
	local git
	local s

	for git in "${ove_revtab_git_name[@]}" $(readlink ${OVE_BASE_DIR}/.owel); do
		s+="${OVE_BASE_DIR}/${git} "
	done

	echo ${s}
}

function ove_revtab_list_basename {
	local git
	local s

	for git in "${ove_revtab_git_name[@]}" $(readlink ${OVE_BASE_DIR}/.owel); do
		s+="${git} "
	done

	echo ${s}
}

function ove_revtab_forall {
	local git
	local git_basename

	for git in ${OVE_REPO_LIST}; do
		! [ -d "${git}" ] && continue
		git_basename=${git##*/}
		eval "pushd ${git} &>/dev/null && $1; popd&>/dev/null"
	done
}

function ove_revtab_forall_parallel {
	(
	local git

	for git in ${OVE_REPO_LIST}; do
		! [ -d "${git}" ] && continue
		pushd "${git}" &>/dev/null && eval "$1" &
	done
	wait
	)
}

function ove_revtab_forsome {
	local git
	local i

	for i in ${*:2}; do
		for git in ${OVE_REPO_LIST}; do
			! [ -d "${git}" ] && continue
			if [ "${git}" == "${OVE_BASE_DIR}/${i}" ]; then
				eval "pushd ${git} &>/dev/null && $1; popd&>/dev/null"
			fi
		done
	done
}

function ove_revtab_forsome_parallel {
	(
	local git
	local i

	for i in ${*:2}; do
		for git in ${OVE_REPO_LIST}; do
			! [ -d "${git}" ] && continue
			if [ "${git}" == "${OVE_BASE_DIR}/${i}" ]; then
				eval "pushd ${git} &>/dev/null; $1; popd&>/dev/null" &
			fi
		done
	done
	wait
	)
}

# $*: optional list of repositories
function ove_revtab_clone_and_checkout {
	(
	local count
	local git_basename
	local index
	local repo

	if [ $# -gt 0 ]; then
		for repo in $*; do
			git_basename=${1##*/}
			index=${ove_revtab_basename2index[${git_basename}]}

			if [ ! -d "${OVE_BASE_DIR}/${repo}" ]; then
				git clone "${ove_revtab_fetch_url[${index}]}" "${OVE_BASE_DIR}/${ove_revtab_git_name[${index}]}" && ove_revtab_checkout ${git_basename} &
			fi
			shift
		done
	else
		count=0
		while ((count < ove_revtab_num_repositories)); do
			if [ ! -d "${OVE_BASE_DIR}/${ove_revtab_git_name[${count}]}" ]; then
				git clone "${ove_revtab_fetch_url[${count}]}" "${OVE_BASE_DIR}/${ove_revtab_git_name[${count}]}" && ove_revtab_checkout ${ove_revtab_git_name[${count}]} &
			fi
			let count+=1
		done
	fi

	wait
	)
}

# $*: optional list of repositories
function ove_revtab_checkout {
	(
	local count
	local git_basename
	local index
	local repo

	if [ $# -gt 0 ]; then
		for repo in $*; do
			git_basename=${1##*/}
			index=${ove_revtab_basename2index[${git_basename}]}
			git -C "${OVE_BASE_DIR}/${ove_revtab_git_name[${index}]}" -c advice.detachedHead=false checkout "${ove_revtab_rev[${index}]}" &
			shift
		done
	else
		count=0
		while ((count < ove_revtab_num_repositories)); do
			git -C "${OVE_BASE_DIR}/${ove_revtab_git_name[${count}]}" -c advice.detachedHead=false checkout "${ove_revtab_rev[${count}]}" &
			let count+=1
		done
	fi

	wait
	)
}

function ove_revtab_pull_one {
	local base
	local cmd
	local git
	local git_fullpath
	local loc
	local remote
	local upstream

	git="$1"
	upstream="@{u}"

	git_fullpath=$(ove_git2fullpath $1)
	if [ "${git_fullpath}" == "" ] || ! [ -d "${git_fullpath}" ]; then
		return
	fi

	# check if detached
	if ! git -C "${git_fullpath}" rev-parse -q "${upstream}" &> /dev/null; then
		return
	fi

	loc=$(git -C "${git_fullpath}" rev-parse @)
	remote=$(git -C "${git_fullpath}" rev-parse "${upstream}")
	base=$(git -C "${git_fullpath}" merge-base @ "${upstream}")

	if [ "${loc}" = "${remote}" ]; then
		# up-to-date
		:
	elif [ "${remote}" = "${base}" ]; then
		# need to push
		:
	else
		ove_echo_yellow_noprefix "${git}"
		cmd="git -C ${git_fullpath} pull --rebase"
		if ! ${cmd}; then
			ove_echo_error_noprefix "${cmd}"
		fi
	fi
}

# $*: optional list of repositories
function ove_revtab_fetch {
	local co_list
	local count

	ove_revtab_parse

	if [ $# -ge 1 ]; then
		ove_revtab_clone_and_checkout $*
		ove_revtab_forsome_parallel 'git -C ${git} fetch --all --tags | sed -e "s|$| for ${i}|g"' $*
		return $?
	fi

	count=0
	while ((count < ove_revtab_num_repositories)); do
		if [ ! -d "${OVE_BASE_DIR}/${ove_revtab_git_name[${count}]}" ]; then
			co_list+="${ove_revtab_git_name[${count}]} "
		fi
		let count+=1
	done

	[ "${co_list}" != "" ] && ove_revtab_clone_and_checkout ${co_list}

	ove_revtab_forall_parallel 'git -C ${git} fetch --all --tags | sed -e "s|$| for $(ove_git2shortpath ${git})|g"'
	return $?
}

function ove_get_base_dir {
	local s

	pushd . &> /dev/null
	s=$(pwd -P)
	while [ "${s}" != "" ]; do
		if [[ -L ${s}/ove && -L ${s}/.owel && ( -d ${s}/.ove || -d ${s}/owel ) ]]; then
			echo "${s}"
			break
		fi
		s=${s%/*}
	done

	popd > /dev/null

	# base directory found?
	if [ "${s}" == "" ]; then
		ove_echo_error_noprefix "not in an OVE workspace. Try 'ove cd'"
		return 1

	# First time? Do nothing
	elif [ -z "${OVE_BASE_DIR+x}" ]; then
		:

	# Have we moved to another OVE workspace? source that project
	elif [ "${s}" != "${OVE_BASE_DIR}" ] && [[ $- == *i* ]]; then
		cd ${s} && . ove > /dev/null && cd -
	fi
}
export -f ove_get_base_dir

function ove_list_projects {
	if [ -f "${OVE_PROJECT_DIR}"/projs ]; then
		grep -o '^[a-zA-Z0-9_]\+' ${OVE_PROJECT_DIR}/projs | \
			sort | \
			xargs "${OVE_ECHO}"
	fi
}
export -f ove_list_projects

function ove_stage_dir_md5sum_parallel {
	local f

	for f in $(find ${OVE_STAGE_DIR} -type f); do
		md5sum ${f} &
	done
	wait
}

function ove_stage_dir_fingerprint {
	[ "${OVE_DRY_RUN}" -eq 1 ] && echo && return

	ove_stage_dir_md5sum_parallel | \
		sort -k 2 | \
		md5sum | \
		cut -d' ' -f1
}

# make:[PROJECT[-nodeps]]:build project(s)
function ove-make {
	local fingerprint_a
	local fingerprint_b
	local index
	local proj
	local stage_dir_updated_by
	local target
	local withdeps

	target=$*
	withdeps="true"

	[ $# -eq 0 ] && target="all"

	if [[ ${target} == *-nodeps ]]; then
		withdeps="false"
		target=${target%-nodeps}
	fi

	# build all?
	if [ "${target}" == "all" ]; then
		if ! ove_build_pre; then
			return 1
		fi

		for proj in ${OVE_BUILD_ORDER}; do
			index=${ove_projects_name2index[${proj}]}

			# does proj have any dependencies?
			if [ "${ove_projects_deps[${index}]}" != "" ]; then
				# check if some of the deps has modified the stage dir
				for dep in ${ove_projects_deps[${index}]}; do
					if [[ "${stage_dir_updated_by}" == *"${dep}"* ]]; then
						ove_projects_cmd "${proj}" clean
						break
					fi
				done
			fi

			fingerprint_a=$(ove_stage_dir_fingerprint)
			ove_projects_cmd "${proj}" build
			ove_projects_cmd "${proj}" install
			fingerprint_b=$(ove_stage_dir_fingerprint)

			# remember if project modified the stage dir
			if [ "${fingerprint_a}" != "${fingerprint_b}" ]; then
				stage_dir_updated_by+="${proj} "
			fi
		done
	else
		if ! ove_build_pre ${target}; then
			return 1
		fi

		if [ "${withdeps}" == "false" ]; then
			ove_projects_cmd "${target}" build
		else
			if [[ "$(caller 0)" != *"ove-make"* ]]; then
				# keep track of projects built
				_ove_projects_built=""
			fi

			index=${ove_projects_name2index[${target}]}
			[ "${index}" == "" ] && echo "${FUNCNAME[0]}: unknown target '${target}'" && return 1

			# has deps?
			if [ "${ove_projects_deps[${index}]}" != "" ]; then
				fingerprint_a=$(ove_stage_dir_fingerprint)

				for dep in ${ove_projects_deps[${index}]}; do
					# already built? next!
					if [[ "${_ove_projects_built}" == *"${dep}"* ]]; then
						continue
					fi

					if ! ove-make "${dep}"; then
						return 1
					fi
				done

				fingerprint_b=$(ove_stage_dir_fingerprint)

				# clean the project if OVE_STAGE_DIR was updated
				if [ "${fingerprint_a}" != "${fingerprint_b}" ]; then
					ove_projects_cmd "${target}" clean
				fi
			fi

			if ! ove_projects_cmd "${target}" build; then
				return 1
			fi

			if ! ove_projects_cmd "${target}" install; then
				return 1
			fi

			# remember projects built
			_ove_projects_built+="${target} "

			# cleanup
			if [[ "$(caller 0)" != *"ove-make"* ]]; then
				unset _ove_projects_built
			fi
		fi
	fi
}

# list-projects:[long]:list projects
function ove-list-projects {
	local f
	local f_basename
	local p
	local projects

	if [ "$1" != 'long' ]; then
		echo ${OVE_PROJECT_LIST} | \
			xargs -n1
	else
		projects=${OVE_PROJECT_LIST}
		for p in ${projects}; do
			# ignore projects without a project directory
			[ ! -d "${OVE_PROJECT_DIR}"/projects/${p} ] && continue

			for f in $(find "${OVE_PROJECT_DIR}"/projects/${p} -perm -u=x -type f); do
				echo
				f_basename=${f##*/}
				ove_echo_green_noprefix ${p}:${f_basename}
				cat ${OVE_PROJECT_DIR}/projects/${p}/${f_basename}
			done
		done
	fi
}

# digraph: :create a DOT directed graph for all projects
function ove-digraph {
	local i

	[ ${ove_number_of_projects} -eq 0 ] && return

	echo "digraph $(echo ${OVE_PROJECT_NAME} | tr '-' '_') {"

	i=0
	while ((i < ove_number_of_projects)); do
		if [ "${ove_projects_deps[${i}]}" != "" ]; then
			for d in ${ove_projects_deps[${i}]}; do
				echo "    ${ove_projects_name[${i}]} -> ${d};"
			done
		else
			echo "    ${ove_projects_name[${i}]};"
		fi
		let i+=1
	done

	echo "}"
}

function ove_build_topology {
	local i

	i=0
	while ((i < ove_number_of_projects)); do
		if [ "${ove_projects_deps[${i}]}" != "" ]; then
			for d in ${ove_projects_deps[${i}]}; do
				echo "${ove_projects_name[${i}]} ${d}"
			done
		fi
		let i+=1
	done | tsort | tac | xargs
}

# build-order: :show build order
function ove-build-order {
	local autonomous_projs
	local topology

	[ ${ove_number_of_projects} -eq 0 ] && return

	# just a bunch of projects without deps?
	if [ "$(ove_list_projects_with_deps)" == "" ]; then
		ove_list_projects_without_deps
		return
	fi

	topology=$(ove_build_topology)
	autonomous_projs=$(comm -3 \
		<(printf "%s\n" ${OVE_PROJECT_LIST}) \
		<(echo ${topology} | tr ' ' '\n' | sort))

	echo ${autonomous_projs} ${topology}
}

# forowel:COMMAND:run 'COMMAND' for all OVE workspaces on this host
function ove-forowel {
	local cmd
	local i
	local projs

	[ $# -eq 0 ] && return

	i=0
	projs=($(ove-locate | \
		grep -v '^\s'))
	while ((i < ${#projs[@]})); do
		cmd+=$(printf "
			echo '# %s'
			cd %s
			ove_init
			$*
			" $(ove_echo_green_noprefix $(basename ${projs[i]})) ${projs[i]})
		let i+=1
	done
	eval "${cmd}"
}

# forowel-parallel:COMMAND:run 'COMMAND' in parallel for all OVE workspaces on this host
function ove-forowel-parallel {
	local cmd
	local i
	local projs

	[ $# -eq 0 ] && return

	i=0
	projs=($(ove-locate | \
		grep -v '^\s'))
	while ((i < ${#projs[@]})); do
		cmd=$(printf "
			cd %s
			ove_init
			$*
			" ${projs[i]})
		let i+=1
		{
			eval "${cmd}"
		} &
	done
	wait
}

# forall:COMMAND:run 'COMMAND' for all git repositories
function ove-forall {
	[ $# -ne 0 ] && ove_revtab_forall "$*"
}

# forall-parallel:COMMAND:run 'COMMAND' in parallel for all git repositories
function ove-forall-parallel {
	[ $# -ne 0 ] && ove_revtab_forall_parallel "$*"
}

# list-systests: :list available system tests
function ove-list-systests {
	! [ -e ${OVE_PROJECT_DIR}/systests ] && return
	(
	grep -E -v '^$|^\s*\#|.*:|^#.*' "${OVE_PROJECT_DIR}"/systests | \
		awk '{print $1}'
	grep : "${OVE_PROJECT_DIR}"/systests | \
		grep -v '#' | \
		cut -d: -f1

	if [ -e ${OVE_PROJECT_DIR}/systests-groups ]; then
		grep : "${OVE_PROJECT_DIR}"/systests-groups | \
			sed 's|[-:[:space:]]||g'
	fi) | sort
}

# list-systests-aliases: :list available system test aliases
function ove-list-systests-aliases {
	! [ -e ${OVE_PROJECT_DIR}/systests ] && return

	grep : "${OVE_PROJECT_DIR}"/systests | \
		grep -v '#' | \
		cut -d: -f1 | \
		sort
}

# list-scripts: :list available scripts
function ove-list-scripts {
	local p
	local repo

	# project scripts
	if [ -d "${OVE_PROJECT_DIR}/scripts" ]; then
		find ${OVE_PROJECT_DIR}/scripts -perm -u=x -not -name '*.help' -type f
	fi

	# OVE scripts
	if [ -d "${OVE_DIR}/scripts" ]; then
		find ${OVE_DIR}/scripts -perm -u=x -not -name '*.help' -type f
	fi

	# repo scripts
	for repo in $(ove_revtab_list_fullpath); do
		! [ -d "${repo}/.ove/scripts" ] && continue
		p+="${repo}/.ove/scripts "
	done
	[ "${p}" != "" ] && \
		find -L ${p} -perm -u=x -not -name '*.help' -type f
}

function ove_echo {
	local diff
	local diff_ns
	local diff_s
	local now
	local now_ns
	local now_s

	diff="00:00:00"
	diff_ns="000000000"

	now=$(date +%s:%N)
	now_s=${now%:*}
	now_ns=${now#*:}
	# remove leading zeros
	now_ns=$((10#${now_ns}))

	if [ "${OVE_PREV_S}" != "" ]; then
		diff_ns="$((now_ns - OVE_PREV_NS))"
		diff_s=$((now_s - OVE_PREV_S))
		if [ "${diff_ns}" -lt 0 ]; then
			let diff_s-=1
			diff_ns="$((1000000000 + diff_ns))"
		fi

		diff="$(echo ${diff_s} | \
			awk '{printf "%02d:%02d:%02d\n", int($1/3600),int(($1%3600)/60),int($1%60)}')"
	fi

	echo -e "$(date -d @${now_s} +'%Y-%m-%d %H:%M:%S').$(printf "%09d" ${now_ns}) (+${diff}:$(printf "%09d" ${diff_ns})):$*"

	OVE_PREV_S=${now_s}
	OVE_PREV_NS=${now_ns}
}

function ove_echo_cyan {
	ove_echo "${ove_cyan}""$*""${ove_blank}"
}

function ove_echo_cyan_error {
	ove_echo "${ove_cyan}""$*""${ove_blank}" 1>&2;
}

function ove_echo_yellow {
	ove_echo "${ove_yellow}""$*""${ove_blank}"
}

function ove_echo_green_noprefix {
	echo -e "${ove_green}""$*""${ove_blank}"
}

function ove_echo_red {
	ove_echo "${ove_red}""$*""${ove_blank}"
}

function ove_echo_red_noprefix {
	echo -e "${ove_red}""$*""${ove_blank}"
}

function ove_echo_yellow_noprefix {
	echo -e "${ove_yellow}""$*""${ove_blank}"
}

function ove_echo_warning {
	ove_echo_yellow "warning: $*" 1>&2;
}

function ove_echo_cyan_noprefix {
	echo -e "${ove_cyan}""$*""${ove_blank}"
}

function ove_echo_error {
	ove_echo_red "error: $*" 1>&2;
}

function ove_echo_error_noprefix {
	ove_echo_red_noprefix "error: $*" 1>&2;
}

function ove_echo_warning_noprefix {
	ove_echo_yellow_noprefix "warning: $*" 1>&2;
}

function ove_echo_stderr {
	ove_echo "$@" 1>&2;
}
function ove_echo_stderr_noprefix {
	echo "$@" 1>&2;
}

# systest:[TEST|GROUP...]:run one or more system tests/groups described in ${OVE_PROJECT_DIR}/systests-groups and ${OVE_PROJECT_DIR}/systests
function ove-systest {
	local exit_status
	local groups
	local i
	local match
	local nbr_tests
	local new_test_list
	local q
	local result
	local summary
	local systest_cmd
	local systest_exit_code
	local systest_path
	local systest_row
	local systest_timeout
	local systest_type
	local test_list
	local test_name

	if [ $# -eq 0 ]; then
		echo "Need arguments, plz see ove help systest"
		return 1
	fi

	if ! [ -e ${OVE_PROJECT_DIR}/systests-groups ]; then
		test_list="$*"
	else
		groups=$(grep : ${OVE_PROJECT_DIR}/systests-groups | \
			sed 's|[-:[:space:]]||g'| \
			sort)

		if [ "${groups}" == "" ]; then
			test_list="$*"
		elif ! command -v python3 > /dev/null; then
			ove_echo_yellow_noprefix "python3 not found, not possible to launch 'yex'"
			test_list="$*"
		else
			for test_name in $*; do
				if echo ${groups} | grep -w -q ${test_name}; then
					test_list+=" $(${OVE_DIR}/yex ${OVE_PROJECT_DIR}/systests-groups -s -r --groups "${test_name}")"
				else
					test_list+=" ${test_name}"
				fi
			done
		fi
	fi

	[ "${test_list}" == "" ] && echo "error: no tests found" && return 1

	# repeat?
	if ! [ -z "${OVE_SYSTEST_REPEAT+x}" ] && \
		[ "${OVE_SYSTEST_REPEAT}" -gt 1 ]; then

		for test_name in ${test_list}; do
			for q in $(seq 1 ${OVE_SYSTEST_REPEAT}); do
				new_test_list+=" ${test_name}"
			done
		done

		test_list=${new_test_list}
	fi

	# skip tests
	if ! [ -z "${OVE_SYSTEST_SKIP+x}" ] && \
		[ "${OVE_SYSTEST_SKIP}" -gt 1 ]; then

		i=0
		for test_name in ${test_list}; do
			if (( i % OVE_SYSTEST_SKIP == 0 )); then
				new_test_list+=" ${test_name}"
			fi
			let i=i+1
		done

		test_list=${new_test_list}
	fi

	nbr_tests=$(echo ${test_list} | \
		wc -w)
	if [ ${nbr_tests} -gt 1 ]; then
		echo "${FUNCNAME[0]}:Will run ${nbr_tests} test cases:"
		i=0
		for test_name in ${test_list}; do
			let i=i+1
			printf "${FUNCNAME[0]}:[%03d/%03d    ]:${test_name}\n" ${i} ${nbr_tests}
		done
		echo
	fi

	# trap SIGINT to allow user to press CTRL+C
	trap true SIGINT

	i=0
	for test_name in ${test_list}; do
		let i=i+1

		# alias?
		match=$(grep -c ^${test_name}: "${OVE_PROJECT_DIR}"/systests)
		if [ ${match} -eq 1 ]; then
			test_name=$(grep ^${test_name}: "${OVE_PROJECT_DIR}"/systests | \
				cut -d: -f2)
		else
			match=$(grep -c -w ^${test_name} "${OVE_PROJECT_DIR}"/systests)
			if [ ${match} -eq 0 ]; then
				ove_echo_error_noprefix "${FUNCNAME[0]}:can not find '${test_name}'"
				continue
			elif [ ${match} -gt 1 ]; then
				ove_echo_error_noprefix "${FUNCNAME[0]}:${match} match(es) for '${test_name}'"
				grep ^${test_name} "${OVE_PROJECT_DIR}"/systests
				continue
			fi
		fi

		systest_row=($(grep -w ^${test_name} "${OVE_PROJECT_DIR}"/systests))
		test_name=${systest_row[0]}
		systest_timeout=${systest_row[1]}
		systest_type=${systest_row[2]}
		systest_path=${OVE_BASE_DIR}/${systest_row[3]//\"}
		systest_cmd=${systest_row[*]:4}
		systest_cmd=${systest_cmd//\"}

		if ! [ -d "${systest_path}" ]; then
			ove_echo_error_noprefix "'${systest_path}' is not a valid path for systest: '${test_name}'"
			continue
		fi

		pushd "${systest_path}" &> /dev/null
		shift
		printf "${FUNCNAME[0]}:[%03d/%03d    ]:${test_name}\n" ${i} ${nbr_tests}

		OVE_SYSTEST_ACTIVE_TEST_CASE=${test_name}
		OVE_SYSTEST_ITERATION=${i}
		OVE_SYSTEST_NBR_TESTS=${nbr_tests}
		export OVE_SYSTEST_ACTIVE_TEST_CASE
		export OVE_SYSTEST_ITERATION
		export OVE_SYSTEST_NBR_TESTS

		if [ "${OVE_DRY_RUN}" -eq 1 ]; then
			# dry run
			result=$(printf "${FUNCNAME[0]}:[%03d/%03d ${ove_green}OK${ove_blank}]:${test_name}" ${i} ${nbr_tests})
		else
			if timeout --foreground --kill-after 30s ${systest_timeout} ${systest_cmd}; then
				# test passed
				result=$(printf "${FUNCNAME[0]}:[%03d/%03d ${ove_green}OK${ove_blank}]:${test_name}" ${i} ${nbr_tests})
			else
				systest_exit_code=$?

				if [ ${systest_exit_code} -eq 124 ]; then
					exit_status="TIMEOUT"
				elif [ ${systest_exit_code} -eq 126 ]; then
					exit_status="PERMISSION_DENIED"
				elif [ ${systest_exit_code} -eq 127 ]; then
					exit_status="CAN_NOT_FIND_CMD"
				elif [ ${systest_exit_code} -gt 128 ] && [ ${systest_exit_code} -lt 166 ]; then
					exit_status="SIG$(kill -l ${systest_exit_code})"
				elif [ -e /usr/include/sysexits.h ] && \
					grep -P -q "#define EX_[A-Z]+\s+${systest_exit_code}" /usr/include/sysexits.h; then
					exit_status=$(grep -P "#define EX_[A-Z]+\s${systest_exit_code}" /usr/include/sysexits.h | \
						grep -o -P 'EX_[A-Z]+')
				elif [ -e ${OVE_PROJECT_DIR}/${OVE_PROJECT_NAME}-sysexits.h ] && \
					grep -P -q "#define [A-Z0-9_]+\s+${systest_exit_code}$" ${OVE_PROJECT_DIR}/${OVE_PROJECT_NAME}-sysexits.h; then
					exit_status=$(grep -P "#define [A-Z0-9_]+\s+${systest_exit_code}$" ${OVE_PROJECT_DIR}/${OVE_PROJECT_NAME}-sysexits.h | \
						cut -f1 | \
						cut -d' ' -f2)
				else
					exit_status="${systest_exit_code}"
				fi

				# test failed
				result=$(printf "${FUNCNAME[0]}:[%03d/%03d ${ove_yellow}NOK${ove_blank} ${exit_status}]:${test_name}"  ${i} ${nbr_tests})

				# type 1 systest or SIGINT => stop loop
				if [ ${systest_type} -eq 1 ] || [ ${exit_status} == "SIGINT" ] ; then
					echo ${result}
					summary+="${result}\n"
					popd &> /dev/null
					break
				fi
			fi
		fi

		summary+="${result}\n"
		echo -e ${summary}
		popd &> /dev/null
	done
	echo
	if [ ${nbr_tests} -gt 1 ]; then
		echo ${FUNCNAME[0]}:Summary:
		echo -e ${summary}
	fi
	echo "OVE log: ${OVE_LAST_COMMAND}"

	return ${systest_exit_code}
}

# helper function for a few revtab functions below
function ove_revtab_sanity_check {
	if [ $# -ne 2 ]; then
		ove_echo_error_noprefix "please provide two revisions for '${OVE_PROJECT_DIR}'"
		return 1
	fi

	if [ "$1" == "$2" ]; then
		ove_echo_error_noprefix "please provide two different revisions for '${OVE_PROJECT_DIR}'"
		return 2
	fi

	if ! git -C "${OVE_PROJECT_DIR}" cat-file -e "$1" &> /dev/null; then
		ove_echo_error_noprefix "'$1' is not a valid revision"
		return 3
	fi

	if ! git -C "${OVE_PROJECT_DIR}" cat-file -e "$2" &> /dev/null; then
		ove_echo_error_noprefix "'$2' is not a valid revision"
		return 4
	fi
}

# revtab-diff:<rev> <rev>:print changes between two '${OVE_PROJECT_NAME}' revisions
function ove-revtab-diff {
	local a
	local b
	local r
	local sha_1
	local sha_2

	ove_revtab_sanity_check $* || return $?

	# save revtab for rev A and rev B
	a=$(git -C "${OVE_PROJECT_DIR}" --no-pager show $1:revtab | \
		grep -v \# | \
		xargs -n4)
	b=$(git -C "${OVE_PROJECT_DIR}" --no-pager show $2:revtab | \
		grep -v \# | \
		xargs -n4)

	# extract repo/push/pull
	printf "${a}" | \
		awk '{print $1,$2,$3}' | \
		LC_ALL="C" sort > ${OVE_PROJECT_TMP_DIR}/repos_A
	printf "${b}" | \
		awk '{print $1,$2,$3}' | \
		LC_ALL="C" sort > ${OVE_PROJECT_TMP_DIR}/repos_B

	# extract repo/rev
	printf "${a}" | \
		awk '{print $1,$4}' | \
		LC_ALL="C" sort > ${OVE_PROJECT_TMP_DIR}/rev_A
	printf "${b}" | \
		awk '{print $1,$4}' | \
		LC_ALL="C" sort  > ${OVE_PROJECT_TMP_DIR}/rev_B

	# for repos common for A and B
	for r in $(LC_COLLATE="C" comm -1 -2 ${OVE_PROJECT_TMP_DIR}/repos_A ${OVE_PROJECT_TMP_DIR}/repos_B | awk '{print $1}'); do
		sha_1=$(grep "^${r} " ${OVE_PROJECT_TMP_DIR}/rev_A | \
			awk '{print $2}')
		sha_2=$(grep "^${r} " ${OVE_PROJECT_TMP_DIR}/rev_B | \
			awk '{print $2}')
		[ "${sha_1}" == "${sha_2}" ] && continue
		echo ${r} ${sha_1} ${sha_2}
	done | column -t

	# cleanup
	rm ${OVE_PROJECT_TMP_DIR}/repos_A \
		${OVE_PROJECT_TMP_DIR}/repos_B \
		${OVE_PROJECT_TMP_DIR}/rev_A \
		${OVE_PROJECT_TMP_DIR}/rev_B
}

# diff-project:<rev> <rev>:git diff the '${OVE_PROJECT_NAME}' project
function ove-diff-project {
	local cmd
	local diff
	local line
	local repo
	local sha_1
	local sha_2

	ove_revtab_sanity_check $* || return $?

	cmd="git -C ${OVE_PROJECT_DIR} diff --color=always $1 $2"
	diff=$(${cmd})
	if [ "${diff}" != "" ]; then
		echo -e "${diff}" | ${OVE_PAGER} -Ps"${OVE_PROJECT_NAME}\:$(echo ${cmd} | sed -e 's/\./\\./g')"
	fi

	while IFS= read -r line; do
		[ "${line}" == "" ] && break
		repo=$(echo ${line} | awk '{print $1}')
		sha_1=$(echo ${line} | awk '{print $2}')
		sha_2=$(echo ${line} | awk '{print $3}')
		cmd="git -C ${OVE_BASE_DIR}/${repo} diff --color=always ${sha_1} ${sha_2}"
		diff=$(${cmd})
		if [ "${diff}" != "" ]; then
			echo -e "${diff}" | ${OVE_PAGER} -Ps"${repo}\:$(echo ${cmd} | sed -e 's/\./\\./g')"
		fi
	done <<<"$(ove-revtab-diff "$1" "$2")"
}

# log-project:<rev> <rev>:git log the project '${OVE_PROJECT_NAME}'
function ove-log-project {
	local diff
	local line
	local repo
	local sha_1
	local sha_2

	ove_revtab_sanity_check $* || return $?

	diff=$(git --no-pager -C "${OVE_PROJECT_DIR}" log --oneline --pretty="    %C(auto)%h %s" "$1".."$2")
	if [ "${diff}" != "" ]; then
		ove_echo_yellow_noprefix "  ${OVE_PROJECT_NAME}:"
		echo -e "${diff}"
		echo
	fi

	while IFS= read -r line; do
		[ "${line}" == "" ] && break
		repo=$(echo ${line} | awk '{print $1}')
		sha_1=$(echo ${line} | awk '{print $2}')
		sha_2=$(echo ${line} | awk '{print $3}')
		diff=$(git --no-pager -C ${OVE_BASE_DIR}/${repo} log --oneline --pretty="    %C(auto)%h %s" ${sha_1}..${sha_2})
		if [ "${diff}" != "" ]; then
			ove_echo_yellow_noprefix "  ${repo}:"
			echo -e "${diff}"
			echo
		fi
	done <<<"$(ove-revtab-diff "$1" "$2")"
}

# shortlog-project:<rev> <rev>:git shortlog the project '${OVE_PROJECT_NAME}'
function ove-shortlog-project {
	local diff
	local line
	local repo
	local sha_1
	local sha_2

	ove_revtab_sanity_check $* || return $?

	diff=$(git --no-pager -C "${OVE_PROJECT_DIR}" shortlog --email --oneline "$1".."$2")
	if [ "${diff}" != "" ]; then
		ove_echo_yellow_noprefix ${OVE_PROJECT_NAME}:
		echo -e "${diff}"
		echo
	fi

	while IFS= read -r line; do
		[ "${line}" == "" ] && break
		repo=$(echo ${line} | awk '{print $1}')
		sha_1=$(echo ${line} | awk '{print $2}')
		sha_2=$(echo ${line} | awk '{print $3}')
		diff=$(git --no-pager -C ${OVE_BASE_DIR}/${repo} shortlog --email --oneline ${sha_1}..${sha_2})
		if [ "${diff}" != "" ]; then
			ove_echo_yellow_noprefix "${repo}:"
			echo -e "${diff}"
			echo
		fi
	done <<<"$(ove-revtab-diff "$1" "$2")"
}

# help function that will print OVE project info
#
# $1 = path to OVE project directory
function ove_locate_print {
	local num_projs
	local num_repos
	local ove_dir

	ove_dir=$1

	! [ -d ${ove_dir} ] && return

	num_repos=$(awk '{print $1}' ${ove_dir}/revtab | \
		sed -e 's/#.*$//' -e '/^$/d' | \
		wc -l)
	OVE_PROJECT_DIR=${ove_dir} num_projs=$(ove_list_projects | \
		wc -w)
	dirname ${ove_dir}
	[ -e "${ove_dir}/SETUP" ] && echo "  $(cat ${ove_dir}/SETUP)"
	echo "  repos [${num_repos}]: $(awk '{print $1}' ${ove_dir}/revtab | \
		sed -e 's/#.*$//' -e '/^$/d' | \
		tr '\n' ' ')"
	OVE_PROJECT_DIR=${ove_dir} echo "  projs [${num_projs}]: $(ove_list_projects)"
	echo
}

# setup: :print how to set this project up
function ove-setup {
	[ -e "${OVE_PROJECT_DIR}/SETUP" ] && cat "${OVE_PROJECT_DIR}/SETUP"
}

# refresh: :refresh projects found by ove-locate
function ove-refresh {
	local i
	local projs
	local str

	i=0
	projs=($(ove-locate | grep -v '^\s'))
	while ((i < ${#projs[@]})); do
		str+=$(printf "
			echo '$ # %s'
			echo '$ cd %s'
			cd %s
			ove_init
			echo '$ ove fetch'
			ove fetch
			if ove news > /dev/null; then
				ove news
				while true; do
					read -p '%s [c,d,n,p,q,x,?]? ' -r -n1
					echo
					if [[ \${REPLY} =~ ^[Pp]$ ]]; then
						echo '$ ove pull'
						ove pull
						echo
					elif [[ \${REPLY} =~ ^[Cc]$ ]]; then
						echo '$ ove checkout'
						ove checkout
						echo '$ ove status'
						ove status
						echo
					elif [[ \${REPLY} =~ ^[Dd]$ ]]; then
						echo '$ ove diff'
						ove diff
						echo
						echo '$ ove status'
						ove status
						echo
					elif [[ \${REPLY} =~ ^[Xx]$ ]]; then
						echo '$ ove pull'
						if ove pull; then
							break
						fi
						echo
					elif [[ \${REPLY} =~ ^[Qq]$ ]]; then
						return
					elif [[ \${REPLY} =~ ^[Nn]$ ]]; then
						break
					elif [[ \${REPLY} =~ ^[?]$ ]]; then
						echo 'c - checkout'
						echo 'd - diff'
						echo 'n - next'
						echo 'p - pull'
						echo 'q - quit'
						echo 'x - pull and next'
						echo '? - this help'
						continue
					fi
				done
			fi
			echo" $(ove_echo_green_noprefix $(basename ${projs[i]})) ${projs[i]} ${projs[i]} $(ove_echo_green_noprefix $(basename ${projs[i]})))
		let i+=1
	done
	eval "${str}"
}

function ove_locate_owels {
	local a
	local b
	local diff
	local invalidate_cache
	local o
	local owels

	if [ -e "${OVE_GLOBAL_STATE_DIR}/owel.cache" ]; then
		a=$(stat --format '%Y' "${OVE_GLOBAL_STATE_DIR}/owel.cache")
		b=$(date +%s)
		if [ $((b-a)) -lt 600 ]; then
			for o in $(cat "${OVE_GLOBAL_STATE_DIR}/owel.cache"); do
				if ! [ -d ${o} ]; then
					invalidate_cache=true
				fi

			done

			if ! [ "${invalidate_cache}" = true ]; then
				cat "${OVE_GLOBAL_STATE_DIR}/owel.cache"
				return
			fi
		fi
	fi

	if command -v locate > /dev/null; then
		owels=$(locate -e -r '\.owel$')
	else
		owels=$(find ${OVE_LOCATE_SEARCH_DIR} -type l -name .owel 2> /dev/null)
	fi

	if [ "${owels}" == "" ]; then
		return 1
	fi

	for o in ${owels}; do
		if ! [ -e ${o}/revtab ]; then
			owels=${owels/${o}/}
		fi
	done

	echo ${owels} | \
		xargs -n1 | \
		tee "${OVE_GLOBAL_STATE_DIR}/owel.cache"
}

# locate: :print OVE workspaces owned by '${USER}' on this host using either 'locate' or 'find ${OVE_LOCATE_SEARCH_DIR}'
function ove-locate {
	local owel
	local owels

	owels=$(ove_locate_owels)

	if [ "${owels}" == "" ]; then
		ove_echo_error_noprefix "no OVE projects found"
		return 1
	fi

	for owel in ${owels}; do
		if [ "$(stat -c %u ${owel})" == "$(id -u)" ]; then
			ove_locate_print ${owel}
		fi
	done
}

# locate-all: :print OVE workspaces on this host using either 'locate' or 'find ${OVE_LOCATE_SEARCH_DIR}'
function ove-locate-all {
	local owel
	local owels

	owels=$(ove_locate_owels)

	if [ "${owels}" == "" ]; then
		ove_echo_error_noprefix "no OVE project(s) found"
		return 1
	fi

	for owel in ${owels}; do
		ove_locate_print ${owel}
	done
}

# switch:[PATTERN]:switch to another OVE project
function ove-switch {
	local i
	local projs

	i=0
	projs=($(ove-locate | grep -v '^\s'))
	if [ $# -eq 0 ]; then
		while ((i < ${#projs[@]})); do
			printf "%d: %s # %s\n" $((i + 1)) ${projs[i]} $(ove_echo_green_noprefix $(basename ${projs[i]}))
			let i+=1
		done | column -t -s#

		echo
		read -p "Proj: "
		if ! [[ "${REPLY}" =~ ^[0-9]+$ ]]; then
			[ "${REPLY}" != "" ] && \
				echo "error: just numbers"
			return 1
		fi

		if [ ${REPLY} -gt ${#projs[@]} ] || [ ${REPLY} -eq 0 ]; then
			echo "error: out of bounds"
			return 2
		fi

		eval $(printf "cd %s; . ove > /dev/null\n" ${projs[$((REPLY - 1))]})
	elif [ $# -eq 1 ]; then
		while ((i < ${#projs[@]})); do
			if basename ${projs[i]} | grep -i -q $1; then
				eval $(printf "cd %s; . ove > /dev/null\n" ${projs[i]})
				return
			fi
			let i+=1
		done

		echo "error: project '$1' not found"
		return 1
	fi
}

# branch:[GIT...]:git branch -v for all/specified git repositories
function ove-branch {
	local cmd

	cmd='ove_echo_yellow_noprefix ${PWD} && git --no-pager branch -v'

	if [ $# -eq 0 ]; then
		ove_revtab_forall "${cmd}"
	else
		ove_revtab_forsome "${cmd}" "$*"
	fi
}

# remote:[GIT...]:git remote -v for all/specified git repositories
function ove-remote {
	local cmd

	cmd='ove_echo_yellow_noprefix ${PWD} && git --no-pager remote -v'

	if [ $# -eq 0 ]; then
		ove_revtab_forall "${cmd}"
	else
		ove_revtab_forsome "${cmd}" "$*"
	fi
}

# remote-check: :sanity check that all remotes are online
function ove-remote-check {
	local count

	count=0
	while ((count < ove_revtab_num_repositories)); do
		if ! git ls-remote ${ove_revtab_fetch_url[${count}]} HEAD > /dev/null; then
			return 1
		fi

		let count+=1
	done
}

function ove_dirty_repos {
	local repo

	for repo in $(ove_revtab_forall_parallel 'test -z "$(git --no-pager status --porcelain -uno)" || echo ${PWD}'); do
		ove_git2shortpath ${repo}
	done
}

function ove_stashed_repos {
	local repo

	for repo in $(ove_revtab_forall_parallel 'test -z "$(git --no-pager stash show 2> /dev/null)" || echo ${PWD}'); do
		ove_git2shortpath ${repo}
	done
}

# $1: drop or pop
function ove_stash_forsome {
	local cmd

	! [ -f ${OVE_PROJECT_STATE_DIR}/ove-stashed-repos ] && return
	cmd="git stash $1 -q"
	ove_revtab_forsome "${cmd}" "$(sed "s|${OVE_BASE_DIR}/||g" ${OVE_PROJECT_STATE_DIR}/ove-stashed-repos | xargs)"
	rm ${OVE_PROJECT_STATE_DIR}/ove-stashed-repos
}

function ove_stash_pop {
	ove_stash_forsome pop
}

function ove_stash_drop {
	ove_stash_forsome drop
}

function ove_stash_save {
	local cmd
	local dirty_repos
	local git
	local now

	[ -f ${OVE_PROJECT_STATE_DIR}/ove-stashed-repos ] && return

	dirty_repos=$(ove_dirty_repos)
	[ "${dirty_repos}" == "" ] && return

	> ${OVE_PROJECT_STATE_DIR}/ove-stashed-repos
	now=$(date '+%Y%m%d-%H%M%S')
	cmd="git stash save -q stashed by OVE@${now} && echo \${git} >> ${OVE_PROJECT_STATE_DIR}/ove-stashed-repos"

	for git in ${dirty_repos}; do
		ove_revtab_forsome "${cmd}" "${git}"
	done
}

function ove_stash_inspect {
	local cmd
	local stashed_repos

	stashed_repos=$(ove_stashed_repos)
	[ "${stashed_repos}" == "" ] && return

	cmd="git --no-pager stash"
	if [ "$1" == "show" ]; then
		cmd+=" show -p"
	elif [ "$1" == "list" ]; then
		cmd+=" list"
	else
		return
	fi

	ove_revtab_forsome "ove_echo_yellow_noprefix \${PWD}: && ${cmd}" "${stashed_repos}"
}

function ove_stash_show {
	ove_stash_inspect show
}

function ove_stash_list {
	ove_stash_inspect list
}

# stash:[drop|list|pop|show]:git stash [drop|list|pop|show] for all git repositories
function ove-stash {
	if [ "$1" == "pop" ] ||
		[ "$1" == "list" ] ||
		[ "$1" == "show" ] ||
		[ "$1" == "drop" ]; then
		ove_stash_$1
	elif [ $# -eq 0 ]; then
		ove_stash_save
	else
		ove-help "^${FUNCNAME/ove-/} "
		return 1
	fi
}

# diff:[GIT...]:git diff for all/specified git repositories
function ove-diff {
	local cmd
	local git

	cmd="git --no-pager diff-files --quiet || \
		(ove_echo_yellow_noprefix \${PWD} && \
		git --no-pager diff --color=always ${OVE_DIFF_OPTIONS})"

	if [ $# -eq 0 ]; then
		for git in $(ove_dirty_repos); do
			ove_revtab_forsome "${cmd}" "${git}"
		done | ${OVE_PAGER}
	else
		ove_revtab_forsome "${cmd}" "$*" | ${OVE_PAGER}
	fi
}

# wdiff:[GIT...]:git diff (word diff) for all/specified git repositories
function ove-wdiff {
	local OVE_DIFF_OPTIONS

	OVE_DIFF_OPTIONS="--color-words=."
	ove-diff $*
}

# diff-cached:[GIT...]:git diff --cached for all/specified repositories
function ove-diff-cached {
	local cmd
	local git

	cmd="git --no-pager diff-index --quiet --cached HEAD -- || \
		(ove_echo_yellow_noprefix \${PWD} && \
		git --no-pager diff --color=always --cached)"

	if [ $# -eq 0 ]; then
		for git in $(ove_dirty_repos); do
			ove_revtab_forsome "${cmd}" "${git}"
		done | ${OVE_PAGER}
	else
		ove_revtab_forsome "${cmd}" "$*" | ${OVE_PAGER}
	fi
}

# reset:[GIT...]:git reset -p for all/specified repositories
function ove-reset {
	local cmd

	cmd='git --no-pager diff-index --quiet --cached HEAD -- || \
		(ove_echo_yellow_noprefix ${PWD} && git reset -p)'

	if [ $# -eq 0 ]; then
		ove_revtab_forall "${cmd}"
	else
		ove_revtab_forsome "${cmd}" "$*"
	fi
}

# add:[GIT...]:git add -p for all/specified repositories
function ove-add {
	local cmd
	local git

	cmd='git --no-pager diff-files --quiet || \
		(ove_echo_yellow_noprefix ${PWD} && git --no-pager add -p)'

	if [ $# -eq 0 ]; then
		for git in $(ove_dirty_repos); do
			ove_revtab_forsome "${cmd}" "${git}"
		done
	else
		ove_revtab_forsome "${cmd}" "$*"
	fi
}

# commit:[GIT...]:git commit for all/specified git repositories
function ove-commit {
	local cmd
	local git

	cmd="git --no-pager diff --cached --quiet || \
		(ove_echo_yellow_noprefix \${PWD} && git commit -t <(echo; echo \# git: \${git}; echo \#; git diff --cached -U0 | sed 's/^/# /g'))"

	if [ $# -eq 0 ]; then
		for git in $(ove_dirty_repos); do
			ove_revtab_forsome "${cmd}" "${git}"
		done
	else
		ove_revtab_forsome "${cmd}" "$*"
	fi
}

# $1 = proj
function ove_get_deps_recursive {
	local dep
	local index

	index=${ove_projects_name2index[$1]}
	for dep in ${ove_projects_deps[${index}]}; do
		echo -n "${dep} "
		ove_get_deps_recursive ${dep}
	done
}

# $1 = proj
function ove_get_paths_recursive {
	local dep
	local index

	if [ $# -ne 1 ]; then
		ove_echo_error_noprefix "${FUNCNAME[0]}: need one arg"
		return 1
	fi

	index=${ove_projects_name2index[$1]}
	if [ "${ove_projects_deps[${index}]}" == "" ]; then
		echo -n "${OVE_BASE_DIR}/${ove_projects_path[${index}]} "
		return
	fi

	for dep in ${ove_projects_deps[${index}]}; do
		echo -n "${OVE_BASE_DIR}/${ove_projects_path[${index}]} "
		ove_get_paths_recursive ${dep}
	done
}

function ove_validate_revtab {
	local d
	local doublets

	[ ! -e "${OVE_PROJECT_DIR}/revtab" ] && return

	doublets="$(grep -E -v '^$|^#' ${OVE_PROJECT_DIR}/revtab | \
		awk 'a[$1]++{print $1}')"

	# check for doublets
	if [ "${doublets}" != "" ]; then
		ove_echo_error_noprefix "found repo doublet(s) in '${OVE_PROJECT_DIR}/revtab':"

		for d in ${doublets}; do
			grep -n "^${d} " ${OVE_PROJECT_DIR}/revtab
		done
		return 1
	fi
}

function ove_validate_self {
	if grep ^function ${OVE_SELF} | grep -q -v 'function ove'; then
		ove_echo_error_noprefix "functions need to start with 'ove-' or 'ove_'"
		grep ^function ${OVE_SELF} | grep -v 'function ove'
		return 1
	fi

	if [ "$(grep -B1 '^function ove-' ${OVE_SELF} | \
		grep '^$' -A1 | \
		awk '{print $2}' | \
		xargs)" != "" ]; then
		ove_echo_error_noprefix "add help for the following function(s):"
		grep -B1 '^function ove-.*' ${OVE_SELF} |
			grep '^$' -A1 | \
			awk '{print $2}' | \
			xargs
		return 1
	fi
}

function ove_validate_projs {
	local d
	local doublets
	local i

	[ ! -e "${OVE_PROJECT_DIR}/projs" ] && return

	i=0
	while ((i < ove_number_of_projects)); do
		if [ "${ove_projects_deps[${i}]}" != "" ]; then
			for d in ${ove_projects_deps[${i}]}; do
				echo "${ove_projects_name[${i}]} ${d}"
			done
		fi
		let i+=1
	done | tsort > /dev/null

	if [ $? -ne 0 ]; then
		ove_echo_error_noprefix "circular dependency in '${OVE_PROJECT_DIR}/projs', see output from 'tsort' above"
		return 1
	fi

	doublets=$(grep -o '^[a-zA-Z0-9_]\+' ${OVE_PROJECT_DIR}/projs | \
		awk 'a[$1]++{print $1}')

	if [ "${doublets}" != "" ]; then
		ove_echo_error_noprefix "found project doublet(s) in '${OVE_PROJECT_DIR}/projs':"

		for d in ${doublets}; do
			grep -n "^${d}:" ${OVE_PROJECT_DIR}/projs
		done
		return 1
	fi
}

# $*: a list of packages
function ove_install_packages {
	local cmd
	local missing_packages
	local missing_packages_sorted

	missing_packages=$(ove_packages_not_installed $*)

	# no missing packages?
	[ "${missing_packages}" == "" ] && return

	# sort the list
	missing_packages_sorted="$(echo ${missing_packages} | \
		xargs -n1 "${OVE_ECHO}" | \
		sort -u | \
		xargs "${OVE_ECHO}")"

	if [ "${OVE_DRY_RUN}" -eq 1 ]; then
		ove_echo_yellow "would prompt to install this/these package(s):"
		echo ${missing_packages_sorted} | xargs -n1
		return
	fi

	if [ "${OVE_OS_PACKAGE_MANAGER}" == "unknown" ]; then
		ove_echo_error_noprefix "${FUNCNAME[0]}: fatal: package manager is not set"
		return 1
	fi

	if ! command -v ${OVE_OS_PACKAGE_MANAGER} > /dev/null; then
		ove_echo_error_noprefix "${FUNCNAME[0]}: fatal: '${OVE_OS_PACKAGE_MANAGER}' not found"
		return 2
	fi

	cmd="${OVE_OS_PACKAGE_MANAGER} ${OVE_OS_PACKAGE_MANAGER_ARGS} ${missing_packages_sorted}"

	echo "missing package(s):"
	echo
	echo "To fix this, run the following command:"
	echo
	echo -e "\t${cmd}"
	echo
	return 1
}

# export:[PROJECT...]:export project(s)
function ove-export {
	local attr
	local b
	local deps
	local index
	local paths
	local projs
	local tmp_var

	mkdir -p ${OVE_PROJECT_TMP_DIR}/export ${OVE_PROJECT_TMP_DIR}/export/projects
	> ${OVE_PROJECT_TMP_DIR}/export/revtab
	> ${OVE_PROJECT_TMP_DIR}/export/projs
	[ -d ${OVE_PROJECT_TMP_DIR}/export/projects ] && rm -rf ${OVE_PROJECT_TMP_DIR}/export/projects

	while true; do
		if [ $# -ge 1 ]; then
			if ! [[ -v ove_projects_name2index[$1] ]]; then
				ove_echo_error_noprefix "unknown project '$1'"
				shift
				[ $# -eq 0 ] && break
				continue
			fi

			deps=$(ove_get_deps_recursive $1)
		fi

		for b in $(echo ${OVE_BUILD_ORDER} | xargs -n1 | sort); do
			if [ "$#" -ge 1 ]; then
				re=\\b${b}\\b
				if ! [[ "${deps}" =~ ${re} ]] && [ "${b}" != "$1" ]; then
					continue
				fi
			fi

			# already exported?
			if grep -q ^${b}: ${OVE_PROJECT_TMP_DIR}/export/projs; then
				continue
			fi

			projs+="${b} "
			str+="${b}:\n"
			index=${ove_projects_name2index[${b}]}
			for attr in $(ove_projects_attributes); do
				tmp_var="ove_projects_${attr}[${index}]"
				[ "${!tmp_var}" != "" ] && \
					str+="  ${attr}:\n$(echo ${!tmp_var} | \
					tr ' ' '\n' | \
					sort -u | \
					sed -e 's|^|    |g')\n"

				paths+="${OVE_BASE_DIR}/${ove_projects_path[${index}]} "
			done
			str+="\n"
		done

		printf "${str}" | sed '$ d' > ${OVE_PROJECT_TMP_DIR}/export/projs

		for b in ${projs}; do
			mkdir -p ${OVE_PROJECT_TMP_DIR}/export/projects/${b}
			if find ${OVE_PROJECT_DIR}/projects/${b} -mindepth 1 -print -quit 2> /dev/null | grep -q .; then
				cp -ar ${OVE_PROJECT_DIR}/projects/${b}/* ${OVE_PROJECT_TMP_DIR}/export/projects/${b}
			fi
		done

		shift
		[ $# -eq 0 ] && break
	done

	! [ -s ${OVE_PROJECT_TMP_DIR}/export/projs ] && return 1

	# YAML header
	sed -i '1i ---' ${OVE_PROJECT_TMP_DIR}/export/projs

	for b in $(echo ${paths} | tr ' ' '\n' | sort -u); do
		while true; do
			[ "${b}" == "" ] && break
			if echo ${OVE_REPO_LIST} | xargs -n 1 2> /dev/null | grep -q ^${b}$; then
				ove-list-repositories | grep "^$(ove_git2shortpath ${b}) " >> ${OVE_PROJECT_TMP_DIR}/export/revtab
				break
			fi
			b="${b%/*}"
		done
	done
	LC_ALL="C" sort -u -o ${OVE_PROJECT_TMP_DIR}/export/revtab ${OVE_PROJECT_TMP_DIR}/export/revtab

	tree ${OVE_PROJECT_TMP_DIR}/export
	tar -C "${OVE_PROJECT_TMP_DIR}/export" -cjf "${OVE_PROJECT_TMP_DIR}/export.tar.bz2" .
	echo
	echo "${OVE_PROJECT_TMP_DIR}/export.tar.bz2"

	return 0
}

# import:[file]:import project(s), see export
function ove-import {
	local f

	if [ $# -eq 0 ]; then
		f="${OVE_PROJECT_TMP_DIR}/export.tar.bz2"
	elif [ $# -eq 1 ]; then
		f="$1"
	else
		echo "error: too many args"
		return 1
	fi

	if ! [ -s "${f}" ]; then
		echo "error: file '${f}' is not found or file size is 0"
		return 2
	fi

	tar -C "${OVE_PROJECT_DIR}" -xf "${f}"
}

function ove_build_pre {
	local missing_repos
	local p
	local paths
	local q

	if [ $# -eq 0 ]; then
		paths=$(ove_list_projects_paths)
	else
		while true; do
			p+="$(ove_get_paths_recursive $1) "
			shift
			[ $# -eq 0 ] && break
		done

		paths="$(echo ${p} | xargs -n1 | sort -u | xargs)"
	fi

	for p in ${paths}; do
		for q in ${OVE_REPO_LIST}; do
			if [[ ${p} == *"${q}"* ]] && ! [ -d "${q}" ]; then
				missing_repos+="$(ove_git2shortpath ${q}) "
			fi
		done
	done

	if [ "${missing_repos}" != "" ]; then
		missing_repos=$(echo ${missing_repos} | xargs -n1 | sort -u | xargs)
		ove_echo_error_noprefix "repo(s) '${missing_repos}' is not yet fetched, try:"
		echo
		echo -e "\t$ ove fetch ${missing_repos}"
		echo
		return 1
	fi

	# create stage/archive directories if needed
	[ ! -d "${OVE_STAGE_DIR}" ] && mkdir -p "${OVE_STAGE_DIR}"
	[ ! -d "${OVE_ARCHIVE_DIR}" ] && mkdir -p "${OVE_ARCHIVE_DIR}"

	return 0
}

# buildme:[PROJECT]:build projects from scratch (=bootstrap, configure, build, install)
function ove-buildme {
	local b
	local deps
	local index
	local n
	local pack_list

	if [ $# -eq 1 ]; then
		if ! [[ -v ove_projects_name2index[$1] ]]; then
			ove_echo_error_noprefix "unknown project '$1'"
			return 1
		fi

		deps=$(ove_get_deps_recursive $1)
	fi

	if ! ove_build_pre $*; then
		return 1
	fi

	for b in ${OVE_BUILD_ORDER}; do
		if [ "$#" -eq 1 ]; then
			re=\\b${b}\\b
			if ! [[ "${deps}" =~ ${re} ]] && [ "${b}" != "$1" ]; then
				continue
			fi
		fi

		index=${ove_projects_name2index[${b}]}
		for n in ${ove_projects_needs[${index}]}; do
			pack_list+="${n} "
		done
	done

	# install packages
	if [ "${pack_list}" != "" ]; then
		if ! ove_install_packages ${pack_list}; then
			ove_echo_error_noprefix "${FUNCNAME[0]}: missing package(s)"
			return 1
		fi
	fi

	# bootstrap
	for b in ${OVE_BUILD_ORDER}; do
		if [ "$#" -eq 1 ]; then
			re=\\b${b}\\b
			if ! [[ "${deps}" =~ ${re} ]] && [ "${b}" != "$1" ]; then
				continue
			fi
		fi

		! [ -e "${OVE_PROJECT_DIR}/projects/${b}/bootstrap" ] && continue

		if [ "$(type -t ove-bootstrap)" == "function" ] && \
			! eval ove-bootstrap ${b} ${OVE_REDIRECT_OUTPUT}; then
			ove_echo_error_noprefix "${FUNCNAME[0]}: bootstrap ${b} failed"
			return 1
		fi
	done

	for b in ${OVE_BUILD_ORDER}; do
		if [ "$#" -eq 1 ]; then
			re=\\b${b}\\b
			if ! [[ "${deps}" =~ ${re} ]] && [ "${b}" != "$1" ]; then
				continue
			fi
		fi

		if [ "$(type -t ove-configure)" == "function" ] && \
			! eval ove-configure ${b} ${OVE_REDIRECT_OUTPUT}; then
			ove_echo_error_noprefix "${FUNCNAME[0]}: configure ${b} failed"
			return 1
		fi

		if ! eval ove-make "${b}"-nodeps ${OVE_REDIRECT_OUTPUT}; then
			ove_echo_error_noprefix "${FUNCNAME[0]}: make ${b}-nodeps failed"
			return 1
		fi

		if [ "$(type -t ove-install)" == "function" ] && \
			! eval ove-install ${b} ${OVE_REDIRECT_OUTPUT}; then
			ove_echo_error_noprefix "${FUNCNAME[0]}: install ${b} failed"
			return 1
		fi

		if [ "$#" -eq 1 ]; then
			[ "${b}" == "$1" ] && return 0
		fi
	done

	return 0
}

# buildme-parallel:[PROJECT]:build projects from scratch (=bootstrap, configure, build, install)
function ove-buildme-parallel {
	local b
	local dep
	local inotify_max_user_instances
	local n
	local p
	local pack_list
	local pid
	local pids
	local project_index
	local project_dependency
	local wait_for_deps

	if ! ove_build_pre $*; then
		return 1
	fi

	if [ $# -eq 1 ]; then
		if ! [[ -v ove_projects_name2index[$1] ]]; then
			ove_echo_error_noprefix "unknown project '$1'"
			return 1
		fi

		project_dependency=$(ove_get_deps_recursive $1)
	fi

	for b in ${OVE_BUILD_ORDER}; do
		if [ "$#" -eq 1 ]; then
			re=\\b${b}\\b
			if ! [[ "${project_dependency}" =~ ${re} ]] && [ "${b}" != "$1" ]; then
				continue
			fi
		fi

		index=${ove_projects_name2index[${b}]}
		for n in ${ove_projects_needs[${index}]}; do
			pack_list+="${n} "
		done
	done

	# install packages
	if [ "${pack_list}" != "" ]; then
		if ! ove_install_packages ${pack_list}; then
			ove_echo_error_noprefix "${FUNCNAME[0]}: missing package(s)"
			return 1
		fi
	fi

	# bootstrap
	for b in ${OVE_BUILD_ORDER}; do
		if [ "$#" -eq 1 ]; then
			re=\\b${b}\\b
			if ! [[ "${project_dependency}" =~ ${re} ]] && [ "${b}" != "$1" ]; then
				continue
			fi
		fi

		! [ -e "${OVE_PROJECT_DIR}/projects/${b}/bootstrap" ] && continue

		{
			if [ "$(type -t ove-bootstrap)" == "function" ] && \
				! eval ove-bootstrap ${b} ${OVE_REDIRECT_OUTPUT}; then
				ove_echo_error_noprefix "${FUNCNAME[0]}: bootstrap ${b} failed"
				kill -USR1 $$
			fi
		} &
		pids+="$! "
	done

	wait ${pids}
	pids=""

	# pids db
	declare -A pids_db=()

	let project_index=1

	inotify_max_user_instances=$(($(cat /proc/sys/fs/inotify/max_user_instances) - 20))
	for b in ${OVE_BUILD_ORDER}; do
		let project_index+=1

		if [ "$#" -eq 1 ]; then
			re=\\b${b}\\b
			if ! [[ "${project_dependency}" =~ ${re} ]] && [ "${b}" != "$1" ]; then
				continue
			fi
		fi

		wait_for_deps=""
		for dep in $(ove_get_deps_recursive ${b}); do
			if ! [ -e /proc/${pids_db[${dep}]} ]; then
				pids_db[${dep}]=""
				continue
			fi

			wait_for_deps+="${pids_db[${dep}]} "
		done

		{
			for p in ${wait_for_deps}; do
				tail -s 0.01 --pid=${p} -f /dev/null &
			done
			[ "${wait_for_deps}" != "" ] && wait

			if [ "$(type -t ove-configure)" == "function" ] && \
				! eval ove-configure ${b} ${OVE_REDIRECT_OUTPUT}; then
				ove_echo_error_noprefix "${FUNCNAME[0]}: configure ${b} failed"
					kill -USR1 $$
			fi

			if ! eval ove-make "${b}"-nodeps ${OVE_REDIRECT_OUTPUT}; then
				ove_echo_error_noprefix "${FUNCNAME[0]}: make ${b}-nodeps failed"
				kill -USR1 $$
			fi

			if [ "$(type -t ove-install)" == "function" ] && \
				! eval ove-install ${b} ${OVE_REDIRECT_OUTPUT}; then
				ove_echo_error_noprefix "${FUNCNAME[0]}: install ${b} failed"
				kill -USR1 $$
			fi

			if [ "$#" -eq 1 ]; then
				[ "${b}" == "$1" ] && return 101
			fi
		} &
		pid=$!
		pids_db[${b}]=${pid}
		pids+=" ${pid}"

		while true; do
			if [ $(pgrep -f tail | wc -l) -gt ${inotify_max_user_instances} ]; then
				sleep 0.1
				continue
			fi
			break
		done
	done

	wait ${pids}
	return 0
}

# diff-check:[OPTIONS]:git diff --check [OPTIONS]
function ove-diff-check {
	local cmd

	cmd="echo \${PWD}; git --no-pager diff --check $* -- \$(git diff --name-only)"
	ove_revtab_forall "${cmd}"
}

# list-repositories: :list all git repositories
function ove-list-repositories {
	ove_revtab_list
}

# env:[PATTERN]:show OVE env
function ove-env {
	local e
	local str
	local v

	if [ $# -eq 0 ]; then
		v=$(compgen -A variable | grep OVE_)
	else
		v=$(compgen -A variable | grep OVE_ | grep -i $1)
	fi

	for e in ${v}; do
		str+="${e}:${!e}\n"
	done

	printf "${str}" | \
		sort | \
		column -t -s:
}

# status:[GIT...]:git status -zbs -uno for all/specified repositories
function ove-status {
	# turn off monitor mode to get rid of "Done" messages
	set +m

	ove_revtab_status $* | \
		grep -v '^\['

	# turn on monitor mode
	set -m
}

# news:[GIT...]:list upstream changes for all/specified repositories
function ove-news {
	ove_revtab_status_parse behind $* | tee ${OVE_PROJECT_STATE_DIR}/revtab-news
}

# ahead:[GIT...]:list local commits not yet published for all/specified repositories
function ove-ahead {
	ove_revtab_status_parse ahead $* | tee ${OVE_PROJECT_STATE_DIR}/revtab-ahead
}

# pull:[GIT...]:git pull --rebase for all/specified repositories
function ove-pull {
	local git
	local repos

	# turn off monitor mode to get rid of "Done" messages
	set +m

	if [ $# -ge 1 ]; then
		repos=$(ove_validate_repo_list $*)
	elif [ -e ${OVE_PROJECT_STATE_DIR}/revtab-status ] && grep -q 'behind.*]' ${OVE_PROJECT_STATE_DIR}/revtab-status; then
		repos=$(grep 'behind.*]' ${OVE_PROJECT_STATE_DIR}/revtab-status | \
			cut -d: -f1 | \
			xargs)
	else
		repos=${OVE_REPO_LIST}
	fi

	for git in ${repos}; do
		ove_revtab_pull_one ${git} | grep -v '^\['

		# product repo?
		if [ "${git##*/}" == "${OVE_PROJECT_NAME}" ]; then
			ove_revtab_check
		fi
	done

	if [ "${repos}" != "" ]; then
		ove_revtab_status | grep -v '^\['
	fi

	# turn on monitor mode
	set -m
}

# apply:PATCH:apply one OVE patch
function ove-apply {
	local git_basename
	local p
	local q

	if [ $# -ne 1 ]; then
		ove-help "^${FUNCNAME/ove-/} "
		return 1
	fi

	if ! command -v csplit > /dev/null; then
		ove_echo_error_noprefix "command 'csplit' not found"
		return 1
	fi

	if ! [ -e "$1" ]; then
		ove_echo_error_noprefix "'$1' patch file not found"
		return 1
	fi

	cp -a "$1" "${OVE_PROJECT_TMP_DIR}"
	cd ${OVE_PROJECT_TMP_DIR}
	p="${OVE_PROJECT_TMP_DIR}/$(basename $1)"

	# remove color codes
	sed -i \
		-r \
		-e "s/\x1b\[1;3[1,3]m//g" \
		-e "s/\x1b\[[0-9]+m//g" \
		-e "s/\x1b\[m//g" ${p}

	if ! file "${p}" | grep -q "unified diff"; then
		ove_echo_error_noprefix "'${p}' is not a unified diff"
		return 1
	fi

	# remove any old patch file(s)
	find -maxdepth 1 -name 'ove-apply-patch*' -exec rm {} \;

	# one patch per git
	if ! csplit -s -z --prefix ove-apply-patch ${p} /^\// {*}; then
		ove_echo_error_noprefix "ops, csplit failed"
		return 1
	fi

	for p in $(find ${PWD} -maxdepth 1 -name 'ove-apply-patch*' | sort); do
		git_basename=$(basename $(head -1 -q ${p}))
		git_fullpath=$(ove_git2fullpath ${git_basename})
		if [ "${git_fullpath}" == "" ] || ! [ -d "${git_fullpath}" ]; then
			ove_echo_error_noprefix "'${git_basename}': unknown git, next..."
			continue
		fi

		# rename the patch
		q="${OVE_PROJECT_TMP_DIR}/ove-apply-${git_basename}.patch"
		mv ${p} ${q}
		if [ -d "${git_fullpath}" ] && \
			[ -d ${git_fullpath}/.git ]; then
			# Run 'git apply --check' and if ok, apply the patch
			if ! git -C "${git_fullpath}" apply --check ${q} 2> /dev/null; then
				ove_echo_yellow_noprefix "${git_basename}: patch '${ove_yellow}${q}${ove_blank}' does not apply without errors"
				continue
			fi

			# apply the patch
			git -C "${git_fullpath}" apply ${q}
		fi
	done

	return 0
}

function ove_patch_repositories {
	! [ -d ${OVE_PROJECT_DIR}/patches ] && return

	ove_revtab_forall '[ -d ${OVE_PROJECT_DIR}/patches/${git_basename} ] && \
		git -C ${git} apply ${OVE_PROJECT_DIR}/patches/${git_basename}/*.patch &> /dev/null || :'
}

# do:DIR COMMAND:run a command within DIR relative to ${OVE_BASE_DIR}
function ove-do {
	local cmd
	local dir

	dir=$1
	cmd="${*:2}"

	! [ -d "${OVE_BASE_DIR}/${dir}" ] && return 1

	cd ${OVE_BASE_DIR}/${dir} && eval "${cmd}"
}

# fetch:[GIT...]:git fetch --all for all/specified repositories, ends with ove status
function ove-fetch {
	local repos

	if [ $# -ne 0 ]; then
		repos=$(ove_validate_repo_list $*)
		[ "${repos}" == "" ] && return 1
	fi

	ove_revtab_fetch ${repos}

	[ $# -eq 0 ] && ove_patch_repositories

	ove-status ${repos}
}

# tag: :list all project tags
function ove-tag {
	git -C "${OVE_PROJECT_DIR}" log --tags --simplify-by-decoration --pretty="format:%ai %D"
}

# log: :project '${OVE_PROJECT_NAME}' commit log for branch '${OVE_PROJECT_CI_BRANCH}'
function ove-log {
	local b

	if git -C "${OVE_PROJECT_DIR}" branch -r | grep -q ${OVE_PROJECT_CI_BRANCH}; then
		b="${OVE_PROJECT_CI_BRANCH}"
	fi

	git -C "${OVE_PROJECT_DIR}" log --decorate ${b}
}

# checkout:[rev[ [purge|autostash]]]:git checkout -p for all git repositories OR checkout a new project revision, use 'purge' with care
function ove-checkout {
	local cmd
	local dirty_repos
	local git
	local proj
	local repo
	local rev

	rev="$1"

	if [ $# -eq 0 ]; then
		for git in $(ove_dirty_repos); do
			cmd='git diff --quiet || (echo ${PWD}; git checkout -p)'
			ove_revtab_forsome "${cmd}" "${git}"
		done
	elif [ "$#" -eq 1 ] || [ "$#" -eq 2 ]; then
		if [ "$2" == "purge" ]; then
			cmd='git reset; git checkout .'

			read -p "Proceed to run '${cmd}' for all git repositories? (y/N) " -r
			echo
			if [[ ${REPLY} =~ ^[Yy]$ ]]; then
				read -p "Are you really sure? (y/N) " -r
				echo
				if [[ ${REPLY} =~ ^[Yy]$ ]]; then
					ove_revtab_forall "${cmd}"
				fi
			fi
		elif [ "$2" == "autostash" ]; then
			dirty_repos=$(ove_dirty_repos)

			for repo in ${dirty_repos}; do
				git -C "${repo}" stash save -q "stashed by ove-checkout"
			done
		else
			dirty_repos=$(ove_dirty_repos)

			if [ "${dirty_repos}" != "" ]; then
				ove_echo_error_noprefix "you have staged/unstaged changes in the following repositories:"
				ove-status "${dirty_repos}"
				return 1
			fi
		fi

		git -C "${OVE_PROJECT_DIR}" fetch --all

		if ! git -C "${OVE_PROJECT_DIR}" -c advice.detachedHead=false checkout "${rev}"; then
			ove_echo_error_noprefix "git checkout '${rev}' failed"
			echo
			echo "available tags:"
			git -C "${OVE_PROJECT_DIR}" tag
			echo
			echo "available branches:"
			git -C "${OVE_PROJECT_DIR}" branch --no-color --all | grep -v detached

			# cleanup
			if [ "$2" == "autostash" ]; then
				for repo in ${dirty_repos}; do
					git -C "${repo}" stash pop -q
				done
			fi

			return 1
		fi

		# init everything
		ove_init

		# clone and checkout
		ove_revtab_clone_and_checkout

		# validate revtab revision
		ove_revtab_check

		if [ "$2" == "autostash" ]; then
			for repo in ${dirty_repos}; do
				git -C "${repo}" stash pop -q
			done
		fi

		ove_patch_repositories
	fi
}

# list-commands: :list commands
function ove-list-commands {
	local a
	local b

	a=$(grep -B1 "^function ove-" "${OVE_BASE_DIR}"/ove | \
		grep '\#' | \
		cut -b3-| \
		sort | \
		envsubst)
	b=$(set | \
		grep helptext | \
		grep -v '\$'| \
		cut -d'"' -f2)

	printf "${a}\n${b}" | \
		sort | \
		column -s: -t
}

# help:[PATTERN]:OVE help
function ove-help {
	local h
	local longest_argument
	local longest_function
	local longest_function_project
	local nbr_of_hypens

	if [ $# -ne 0 ]; then
		for h in $*; do
			ove-help | grep -E --color=always "${h}"
		done
		return 0
	fi

	longest_function=$(grep -B1 "^function ove-" ${OVE_SELF} | \
		grep '\#' | \
		cut -b3- | \
		cut -d: -f1 | \
		wc -L)
	longest_function_project=$(set | \
		grep helptext | \
		grep -v '\$' | \
		cut -d'"' -f2 | \
		cut -d: -f1 | \
		wc -L)
	longest_argument=$(grep -B1 "^function ove-" ${OVE_SELF} | \
		grep '\#' | \
		cut -b3- | \
		cut -d: -f2 | \
		wc -L)
	longest_argument_project=$(set | \
		grep helptext | \
		grep -v '\$' | \
		cut -d'"' -f2 | \
		cut -d: -f2 | \
		wc -L)
	longest=${longest_function}
	longest_a=${longest_argument}
	[ ${longest_function_project} -gt ${longest_function} ] && longest=${longest_function_project}
	[ ${longest_argument_project} -gt ${longest_argument} ] && longest_a=${longest_argument_project}
	nbr_of_hypens=$((longest + longest_a + 15))
	printf "%-"$((longest + 2))"s%-"$((longest_a + 2))"s%7s%s\n" "Command" "Arguments" "Description"
	printf "%0.s-" $(eval echo {1..${nbr_of_hypens}})
	echo
	ove-list-commands
	echo
	cat <<EOF

Examples
=====

Build
-----
# Do the initial build
#
# Steps performed for each project: bootstrap, configure, build, install

	$ ove buildme

# Build all projects in order. 'clean' will be performed if needed.
#
# Steps performed for each project: [clean], build, install

	$ ove make

# Build a specific project and all project dependencies. 'clean' will be performed if needed.
#
# Steps performed for each project: [clean], make, make install

	$ ove make projA

# Clean all projects.
#
# Steps performed for each project: clean

	$ ove clean

# Properly remove all files for all git repositories.
#
# Steps performed for each repository: git clean -dffx

	$ ove mrproper

Source control
--------------
# Status of all git repositories
#
# Steps performed for each repository: git status -zbs -uno

	$ ove status

# Synchronize with the outside world
#
# Steps performed for each repository: git fetch --all

	$ ove fetch

# Curious mind? List patches your friends have upstreamed since your last pull.

	$ ove news

# Checkout revision

	$ ove checkout 1.0.2

# Search all git repositories
#
# Steps performed for each repository: git grep

	$ ove grep DEADBEEF
EOF

	# Project specific help text
	if [ -e "${OVE_PROJECT_DIR}"/help ]; then
		echo
		echo "Project '${OVE_PROJECT_NAME}' help"
		printf "%0.s-" $(eval echo {1..$(($(echo ${OVE_PROJECT_NAME} | wc -L) + 15))})
		echo
		cat "${OVE_PROJECT_DIR}/help"
	fi
}

# ag:PATTERN:search OVE workspace using The Silver Searcher [duckduckgo.com/?q=The+Silver+Searcher]
function ove-ag {
	if ! command -v ag > /dev/null; then
		return 1
	fi

	[ $# -eq 0 ] && echo "No pattern, try again" && return 1

	ove_revtab_forall_parallel 'ag --color "'"$*"'" | sed -e 's@^@\${PWD}/@g''
}

# grep:PATTERN:grep OVE workspace
function ove-grep {
	[ $# -eq 0 ] && echo "No pattern, try again" && return 1

	ove_revtab_forall_parallel 'git --no-pager grep --color=always "'"$*"'" | sed -e 's@^@\${PWD}/@g''
}

# blame-history:PATTERN:git log -S for all git repositories
function ove-blame-history {
	[ $# -eq 0 ] && echo "No pattern, try again" && return 1
	ove_revtab_forall 'git --no-pager log --color=always -p -S "'"$*"'"'
}

# blame:PATTERN:git grep-blame-log combo
function ove-blame {
	local file
	local git
	local i
	local line
	local res
	local s
	local sha
	local str

	[ $# -eq 0 ] && ove_echo_error_noprefix "no pattern, try again" && return 1

	s="$*"

	if [ "${OVE_REPO_LIST}" == "" ]; then
		echo "run 'ove fetch' first!"
		return 1
	fi

	for git in ${OVE_REPO_LIST}; do
		! [ -d "${git}" ] && continue
		res=($(git -C "${git}" --no-pager grep --no-color -I -n "${s}" | cut -d: -f1,2))

		for i in "${res[@]}"; do
			file=$(echo "${i}" | cut -d: -f1)
			line=$(echo "${i}" | cut -d: -f2)
			sha=$(git -C "${git}" --no-pager blame -L"${line}","${line}" "${file}" | cut -d' ' -f1)
			str="${git}/${file}:${line}"
			if [ "${sha}" == "00000000" ]; then
				str+=" [ Not Committed Yet ]"
			fi
			if [ "${sha}" != "00000000" ]; then
				git -C "${git}" --no-pager log --color=always -1 "${sha}"
			fi
			echo
			head -"${line}" "${git}"/"${file}" | \
				tail -1 | \
				grep --color=always "${s}" | \
				sed -e 's/^/    /g'
			echo
			echo "    File: ${str}"
			echo
		done
	done
}

# config:[CONFIG]:show or manipulate .oveconfig
function ove-config {
	local cfg
	local cfg_diff
	local d
	local grep_pattern
	local var

	if [ -e "${HOME}/.oveconfig" ]; then
		cfg=${HOME}/.oveconfig
		cfg_diff="$(diff -y --suppress-common-lines ${HOME}/.oveconfig <(git -C ${OVE_PROJECT_DIR} show HEAD:.oveconfig) \
			| awk '{print $1}')"
	elif [ -e "${OVE_PROJECT_DIR}/.oveconfig" ]; then
		cfg=${OVE_PROJECT_DIR}/.oveconfig
		cfg_diff="$(git -C ${OVE_PROJECT_DIR} diff --no-color -U1 --raw ${OVE_PROJECT_DIR}/.oveconfig | \
			grep '^+[A-Z]\+'| \
			cut -b2- | \
			awk '{print $1}')"
	else
		return
	fi

	grep_pattern="$"
	for d in ${cfg_diff}; do
		grep_pattern+="|${d} "
	done

	if [ $# -eq 0 ]; then
			grep -v '^#' ${cfg} | \
				grep -v '^$' | \
				sort | \
				grep -E --color "${grep_pattern}"
	elif [ $# -eq 1 ]; then
		if ! grep -q -i $1 ${cfg}; then
			echo "error: config '$1' not found"
		else
			grep_pattern+="|$1"
			grep -v '^#' ${cfg} | \
				grep -v '^$' | \
				grep -i $1 | \
				grep -E --color "${grep_pattern}"
		fi
	elif [ $# -gt 1 ]; then
		var=$1
		shift
		if grep -q -w ${var} ${cfg}; then
			sed -i -e "s|\(^${var}\s\+\).*|\1$*|g" ${cfg}
			ove-config ${var}
		else
			echo "error: config '${var}' not found"
		fi
	fi
}

# ls-files:[PATTERN]:git ls-files for all git repositories
function ove-ls-files {
	local cmd

	if [ $# -eq 0 ]; then
		cmd='git ls-files | while read line; do echo -e ${PWD}/${line}; done'
	else
		cmd="re="$*"; git ls-files | while read line; do [[ \${PWD}/\${line} =~ \${re} ]] && echo -e \${PWD}/\${line}; done"
	fi

	ove_revtab_forall_parallel "${cmd}" | sort
}

# list-modified-files: :list modified files
function ove-list-modified-files {
	local cmd
	local git

	cmd='git --no-pager diff-index --quiet HEAD || git diff --name-only HEAD | sed -e "s|^|${git}/|g"'

	for git in $(ove_dirty_repos); do
		ove_revtab_forsome "${cmd}" "${git}"
	done | sort -u
}

# list-committed-files:[DAYS]:list committed files within 7 or DAYS day(s)
function ove-list-committed-files {
	local cmd
	local days

	[ $# -eq 1 ] && days="$1" || days=7

	cmd='git --no-pager -C ${git} log --no-merges --author="$(git config --get user.name)" --name-only --pretty=format:"" --since="'${days}' days" | while read line; do [ -f ${PWD}/${line} ] && echo -e ${PWD}/${line}; done'

	ove_revtab_forall "${cmd}" | sort -u
}

function ove_edit {
	local editor
	local f
	local files
	local files_by_epoch

	files=$(ove-list-modified-files)

	[ "${files}" == "" ] && return

	editor="$1"
	shift

	# sanity check
	if ! command -v ${editor} > /dev/null; then
		ove_echo_stderr_noprefix "${editor} is not installed?"
		return 1
	fi

	# stat every file
	files_by_epoch=$(for f in ${files}; do echo $(stat --format '%Y' ${f}):${f}; done | \
		sort -r | \
		cut -d: -f2)

	if [ $# -eq 1 ]; then
		files_by_epoch=$(printf "${files_by_epoch}" | \
			sed -e "s|${OVE_BASE_DIR}/||g" | \
			grep -i $1 | \
			sed -e "s|^|${OVE_BASE_DIR}/|g")
	fi

	if [ "${files_by_epoch}" != "" ]; then
		if [ "${editor}" == "vi" ]; then
			vi -o ${files_by_epoch} -c "wincmd H"
		elif [ "${editor}" == "emacs" ]; then
			emacs ${files_by_epoch}
		else
			ove_echo_stderr_noprefix "unknown editor"
		fi
	fi
}

# emacs:[PATTERN]:open modified files in emacs
function ove-emacs {
	ove_edit emacs $*
}

# vi:[PATTERN]:open modified files in vi
function ove-vi {
	ove_edit vi $*
}

# mrproper:[y|Y]:remove untracked files AND removes '${OVE_STAGE_DIR}/*' AND removes '${OVE_ARCHIVE_DIR}/*'
function ove-mrproper {
	local archive_dir_size
	local directories
	local directories_uniq
	local nbr_untracked_files
	local o
	local objects
	local repo_sub_dirs
	local stage_dir_size

	nbr_untracked_files=$(ove_revtab_forall_parallel 'git clean -dffxn'| wc -l)
	stage_dir_size="$(tree ${OVE_STAGE_DIR} | tail -1)"
	archive_dir_size="$(tree ${OVE_ARCHIVE_DIR} | tail -1)"

	if [ "$1" == "y" ] || [ "$1" == "Y" ]; then
		ove_revtab_forall 'git --no-pager clean -dffx > /dev/null'
		! [ "${OVE_STAGE_DIR}" == "" ] && rm -rf ${OVE_STAGE_DIR}/*
		! [ "${OVE_ARCHIVE_DIR}" == "" ] && rm -rf ${OVE_ARCHIVE_DIR}/*

		if [ "$1" == "Y" ]; then
			# untracked directories

			# list of sub directories where we have git repositories
			sub_dirs=$(for a in ${OVE_REPO_LIST}; do echo ${a} | \
				sed -e "s|${OVE_BASE_DIR}/||g"; done | \
				grep '/')

			if [ "${sub_dirs}" != "" ]; then
				repo_sub_dirs=$(echo ${sub_dirs} | \
					xargs -n1 dirname | \
					sort -u | \
					sed -e "s|^|${OVE_BASE_DIR}/|g")
			fi

			# find some directories
			directories=$(find $(readlink -f ${OVE_BASE_DIR}) ${repo_sub_dirs} -maxdepth 1 -mindepth 1 -type d | \
				sort)


			if [ "${sub_dirs}" == "" ]; then
				directories_uniq=$(find $(readlink -f ${OVE_BASE_DIR}) -maxdepth 1 -mindepth 1 -type d | sort)
			else
				# remove common paths
				directories_uniq=$(comm -3 \
					<(printf "%s\n" ${repo_sub_dirs}) \
					<(printf "%s\n" ${directories}) | \
					xargs -n1)
			fi

			# now we can start to identify directories that can be removed
			for o in $(comm -3 \
				<(echo ${OVE_REPO_LIST} | tr ' ' '\n' | xargs readlink -f | sort) \
				<(printf "%s\n" ${directories_uniq}) | \
				grep -Ev "archives$|stage$|${OVE_DIR}"); do
				[ -d ${o} ] && objects+="${o} "
			done

			# untracked files
			for o in $(find $(readlink -f ${OVE_BASE_DIR}) ${repo_sub_dirs} -maxdepth 1 -mindepth 1 -type f); do
				objects+="${o} "
			done

			if [ "${objects}" != "" ]; then
				echo ${objects} | \
					tr ' ' '\n' | \
					sort | \
					xargs file
				echo
				read -p "Proceed to remove $(echo ${objects} | wc -w) files/directories (list above) using 'rm -rf'? (y/N) " -r
				echo
				if [[ ${REPLY} =~ ^[Yy]$ ]]; then
					read -p "Are you really sure? (y/N) " -r
					echo
					if [[ ${REPLY} =~ ^[Yy]$ ]]; then
						rm -rfv ${objects}
					fi
				fi
			fi
		fi

		return
	fi

	if [ "${nbr_untracked_files}" -ne 0 ]; then
		# dry-run first
		ove_revtab_forall 'a=$(git --no-pager clean -dffxn); [ "$a" != "" ] && printf "$a\n" | sed -e "s|Would remove \(.*\)$|$PWD/\1|g"'
		echo
		read -p "Proceed to remove ${nbr_untracked_files} untracked files/directories (list above) using 'git clean -dffx'? (y/N) " -r
		if [[ ${REPLY} =~ ^[Yy]$ ]]; then
			echo
			read -p "Are you really sure? (y/N) " -r
			echo
			if [[ ${REPLY} =~ ^[Yy]$ ]]; then
				ove_revtab_forall 'git --no-pager clean -dffx'
			fi
		fi
	fi

	if [ "${stage_dir_size}" != "0 directories, 0 files" ]; then
		# all but the last line
		tree -C ${OVE_STAGE_DIR} | head -n -1

		read -p "Proceed to remove ${stage_dir_size} (list above) from '${OVE_STAGE_DIR}' using 'rm -rf'? (y/N) " -r
		echo
		if [[ ${REPLY} =~ ^[Yy]$ ]]; then
			echo "$ rm -rf ${OVE_STAGE_DIR}/*"
			echo
			read -p "Are you really sure you want to run the above command? (y/N) " -r
			echo
			if [[ ${REPLY} =~ ^[Yy]$ ]]; then
				if ! [ "${OVE_STAGE_DIR}" == "" ]; then
					rm -rf ${OVE_STAGE_DIR}/*
				fi
			fi
		fi
	fi

	if [ "${archive_dir_size}" != "0 directories, 0 files" ]; then
		# all but the last line
		tree -C ${OVE_ARCHIVE_DIR} | head -n -1

		read -p "Proceed to remove ${archive_dir_size} (list above) from '${OVE_ARCHIVE_DIR}' using 'rm -rf'? (y/N) " -r
		echo
		if [[ ${REPLY} =~ ^[Yy]$ ]]; then
			echo "$ rm -rf ${OVE_ARCHIVE_DIR}/*"
			echo
			read -p "Are you really sure you want to run the above command? (y/N) " -r
			echo
			if [[ ${REPLY} =~ ^[Yy]$ ]]; then
				if ! [ "${OVE_ARCHIVE_DIR}" == "" ]; then
					rm -rf ${OVE_ARCHIVE_DIR}/*
				fi
			fi
		fi
	fi
}

# !: :view last command in pager (=${OVE_PAGER})
function ove-! {
	[ -f "${OVE_LAST_COMMAND}" ] && ${OVE_PAGER} ${OVE_LAST_COMMAND}
}

# describe:[GIT...]:git describe+log+status combo for all/specified git repositories
function ove-describe {
	local func

	func=ove_revtab_forall_parallel

	[ $# -gt 0 ] && func=ove_revtab_forsome

	${func} 'echo $(echo ${git} | sed -e "s|${OVE_BASE_DIR}/||g")@$(git describe --tags --always --dirty --long)@"$(git log --format="%<(20,trunc)%s" -1)"@"$(git -c color.status=never status -s -uno | tr "\n" " ")"' $* |\
		column -t -s'@' | \
		sort
}

# list-heads:[GIT...]:git log for all/specified git repositories
function ove-list-heads {
	local cmd
	local f

	cmd='echo $(echo -n "$(echo ${git} | sed -e "s|${OVE_BASE_DIR}/||g")?" && git --no-pager log -1 --no-merges --format=%h?%ar?%ae?%s)'
	f="${OVE_PROJECT_TMP_DIR}/${FUNCNAME[0]}.tmp"

	> ${f}
	if [ $# -eq 0 ]; then
		ove_revtab_forall_parallel "${cmd}" > ${f}
	else
		ove_revtab_forsome "${cmd}" "$*" > ${f}
	fi
	sort ${f} | \
		column -t -s? 2> /dev/null

	rm ${f}
}

# ls-remote: :git ls-remote <URL> HEAD for all git repositories
function ove-ls-remote {
	local count
	local git
	local sha
	local str
	local url

	count=0
	while ((count < ove_revtab_num_repositories)); do
		git="${ove_revtab_git_name[${count}]}"
		url="${ove_revtab_fetch_url[${count}]}"

		sha=$(git ls-remote ${url} HEAD | awk {'print $1'})
		str+="${git}:${sha}\n"
		let count+=1
	done

	url=$(git -C "${OVE_PROJECT_DIR}" config --get remote.origin.url)
	sha=$(git -C "${OVE_PROJECT_DIR}" ls-remote ${url} HEAD | awk {'print $1'})
	git=${OVE_PROJECT_NAME}
	str+="${git}:${sha}\n"

	printf "${str}" | \
		sort | \
		column -t -s:
}

# heads2revtab:[GIT...]:update '${OVE_PROJECT_DIR}/revtab' with current SHA-1
function ove-heads2revtab {
	local git
	local repos
	local sha_1

	if [ $# -eq 0 ]; then
		repos=$(ove_revtab_list_basename)
	else
		repos=$*
	fi

	for git in ${repos}; do
		sha_1=$(git -C "${OVE_BASE_DIR}"/${git} rev-parse HEAD)
		sed -i -e 's|^'${git}'\(\s\+.*\s\+.*\s\+\)\(.*\)$|'${git}'\1'${sha_1}'|g' "${OVE_PROJECT_DIR}"/revtab
	done

	git --no-pager -C "${OVE_PROJECT_DIR}" diff revtab
}

# what-is:DIRECTORY...:classify files using 'file' within a directory
function ove-what-is {
	local dir

	for dir in "$@"; do
		[ ! -d "${dir}" ] && continue
		echo "${dir}":
		find "${dir}" -not -path '*.git*' -print0 | \
			xargs -0 -P"$(nproc)" file | \
			awk '{$1=""; print $0}' | \
			sort | \
			uniq -c | \
			sort -nr
	done
}

# show:[revision...]:ove list-heads or search for 'revision' within all git repositories. If found run 'git show SHA-1|TAG'
function ove-show {
	local SHA

	if [ $# -eq 0 ]; then
		ove-list-heads
		return
	fi

	for SHA in "$@"; do
		# remove dirty tags
		SHA=${SHA%-dirty}
		ove_revtab_forall 'git --no-pager show '"${SHA}"' -- &> /dev/null && \
			ove_echo_yellow_noprefix ${PWD} && \
			git show --color=always '"${SHA}"' -- && \
			echo'
	done
}

# cd: :helper for 'cd ${OVE_BASE_DIR}'
function ove-cd {
	cd "${OVE_BASE_DIR}"
}

# version: :print OVE version
function ove-version {
	echo "OVE [SHA-1: ${OVE_SHA} @ ${OVE_OS} ${OVE_OS_VER}]"
}

# loglevel:[LEVEL] :show or change loglevel [0-6]
function ove-loglevel {
	local sysctl_f

	set +x
	if [ $# -eq 1 ] && ! [[ "${1}" =~ ^[0-6]$ ]]; then
		echo "error: try 0-6"
		return 1
	elif [ $# -eq 1 ]; then
		if [ $1 -gt 2 ] && [ $1 -lt 7 ]; then
			if ! command -v strace > /dev/null; then
				ove_echo_error_noprefix "'strace' is not found"
				return 1
			fi

			if [ -e /proc/sys/kernel/yama/ptrace_scope ] && [ $(cat /proc/sys/kernel/yama/ptrace_scope) -ne 0 ]; then
				ove_echo_error_noprefix "the kernel does not allow you to trace all processes"
				echo
				echo "To fix this for now:"
				echo " sudo bash -c 'echo 0 > /proc/sys/kernel/yama/ptrace_scope'"
				echo
				echo "To fix this permanently:"
				sysctl_f=$(grep -l kernel.yama.ptrace_scope /etc/sysctl.d/*)
				if [ "${sysctl_f}" != "" ]; then
					echo " sudo bash -c 'echo 0 > /proc/sys/kernel/yama/ptrace_scope; sed -i -e \"s/kernel.yama.ptrace_scope.*/kernel.yama.ptrace_scope = 0/g\" ${sysctl_f}'"
				else
					echo " sudo bash -c 'echo 0 > /proc/sys/kernel/yama/ptrace_scope; echo \"kernel.yama.ptrace_scope = 0\" > /etc/sysctl.d/10-ptrace.conf'"
				fi
				return 1
			fi
		fi

		OVE_LOGLEVEL=$1
		if ! [ -e ${OVE_PROJECT_STATE_DIR}/.oveconfig ]; then
			echo "OVE_LOGLEVEL $1" > ${OVE_PROJECT_STATE_DIR}/.oveconfig
		else
			sed -i "s/^OVE_LOGLEVEL.*/OVE_LOGLEVEL $1/g" ${OVE_PROJECT_STATE_DIR}/.oveconfig
		fi
	fi

	while true; do
		echo "0: silence is golden"
		echo "1: normal"
		echo "2: debug"
		echo "3: execve timeline"
		echo "4: execve time analysis"
		echo "5: connect analysis"
		echo "6: graph analysis"
		break
	done | grep -E --color "$|${OVE_LOGLEVEL}"

	if [ $# -eq 1 ]; then
		OVE_REDIRECT_OUTPUT=""
		if [ $1 -eq 0 ]; then
			OVE_REDIRECT_OUTPUT="> /dev/null"
		elif [ $1 -eq 1 ]; then
			set +x
		elif [ $1 -eq 2 ]; then
			set -x
		fi
	fi
}

# dry-run:[0|1]:toggle or set OVE_DRY_RUN
function ove-dry-run {
	if [ $# -eq 1 ] && ! [[ "$1" =~ ^[0-1]$ ]]; then
		ove-help ^${FUNCNAME/ove-/}
		return 1
	fi

	if [ $# -eq 0 ]; then
		OVE_DRY_RUN=$((OVE_DRY_RUN ^= 1))
	else
		OVE_DRY_RUN=$1
	fi

	ove-env | grep ^OVE_DRY_RUN
}

# lastlog:[cmin]:list logs created within last 60 min or cmin min
function ove-lastlog {
	local cmin

	[ "$#" -eq 1 ] && cmin=$1 || cmin=60

	find ${OVE_LOG_DIR} -type f -cmin -${cmin} -print0 | \
		xargs -0 stat --format '%Y:%n' | \
		sort -nr | \
		cut -d: -f2 | \
		grep -v ${FUNCNAME[0]} | \
		sed "s/\(^.*-ove-\(.*\)-$(hostname)-\(.*\).log\)/\3@\2@\1/g" | \
		column -t -s@
}

# authors: :list author summary for all git repositories
function ove-authors {
	local git

	declare -A urls

	if [ "${OVE_REPO_LIST}" == "" ]; then
		echo "run 'ove fetch' first!"
		return 1
	fi

	for git in ${OVE_REPO_LIST}; do
		if [ ! -d "${git}" ] || [ "${git}" == "${OVE_DIR}" ]; then
			continue
		fi

		# Try to avoid that a git is counted more than one time
		url=$(git --no-pager -C "${git}" remote -v | \
			grep fetch | \
			cut -f2 | \
			cut -d' ' -f1 | \
			uniq | \
			sed -e 's/[^a-zA-Z0-9\-]/_/g' | \
			sed -e 's/_git$//g')

		if [ "${url}" != "" ]; then
			test "${urls["${url}"]+isset}" && continue
			urls["${url}"]=1
		fi

		git --no-pager -C "${git}" log --pretty="%ae"
	done | \
		sort | \
		uniq -c | \
		sort -nr
}

# domains: :list email domain summary for all git repositories
function ove-domains {
	ove-authors | grep '@' | cut -d@ -f2 | sort | uniq -c | sort -nr
}

function ove_bash_complete {
	local cmd
	local cur
	local opts
	local size
	local subcommand
	local wordlist

	COMPREPLY=()

	cur="${COMP_WORDS[COMP_CWORD]}"
	subcommand="${COMP_WORDS[1]}"
	size=$((${#COMP_WORDS[@]} - 1))

	# project commands
	for cmd in ${OVE_PROJECT_COMMANDS}; do
		if [ "${cmd}" == "${subcommand}" ] ||
			[ "${cmd}-parallel" == "${subcommand}" ]; then
			if [ ${size} -ge 2 ]; then
				COMPREPLY=( $(compgen -W "${OVE_PROJECT_LIST}" -- "${cur}") )
				return
			fi
		fi
	done

	# scripts
	for cmd in ${OVE_SCRIPTS_LIST}; do
		if [ "${cmd}" == "${subcommand}" ] && [ -e "${ove_scripts_name2path[${cmd}]}/${cmd}.complete" ]; then
			source "${ove_scripts_name2path[${cmd}]}/${cmd}.complete"
			return
		fi
	done

	# commands without arguments: do nothing
	if [ ${size} -eq 2 ]; then
		if echo ${OVE_BUILT_INS_WITHOUT_ARGS} | tr ' ' '\n' | grep -q ^${subcommand}$; then
			return
		fi
	fi

	wordlist=""
	if [ "${subcommand}" == "make" ] ||
		[ "${subcommand}" == "buildme-parallel" ] ||
		[ "${subcommand}" == "buildme" ]; then
		if [ ${size} -eq 2 ]; then
			wordlist=${OVE_PROJECT_LIST}
		elif [ ${size} -gt 2 ]; then
			return
		fi
	elif [ "${subcommand}" == "run" ]; then
		if [ ${size} -eq 2 ]; then
			wordlist="TIMEOUT"
		elif [ ${size} -eq 3 ]; then
			wordlist="${OVE_ALL_COMMANDS}"
		else
			return
		fi
	elif [ "${subcommand}" == "loop" ]; then
		if [ ${size} -eq 2 ]; then
			wordlist="TIMEOUT"
		elif [ ${size} -eq 3 ]; then
			wordlist="INOTIFY"
		elif [ ${size} -eq 4 ]; then
			wordlist="MAX-COUNT"
		elif [ ${size} -eq 5 ]; then
			wordlist="${OVE_ALL_COMMANDS}"
		else
			return
		fi
	elif [ "${subcommand}" == "checkout" ]; then
		if [ ${size} -eq 2 ]; then
			wordlist=$(ove_project_tags_and_branches)
		elif [ ${size} -eq 3 ]; then
			wordlist="purge autostash"
		else
			return
		fi
	elif [ "${subcommand}" == "fzf" ]; then
		[ ${size} -ne 2 ] && return
		wordlist="loop"
	elif [ "${subcommand}" == "stash" ]; then
		if [ ${size} -eq 2 ]; then
			wordlist="drop list pop show"
		else
			return
		fi
	elif [ "${subcommand}" == "show" ]; then
		if [ ${size} -ge 2 ]; then
			wordlist="$(ove_revtab_forall_parallel 'git tag') HEAD FETCH_HEAD ORIG_HEAD MERGE_HEAD CHERRY_PICK_HEAD"
			wordlist+=" $(ove-list-heads | awk '{print $2}')"
			if [ -e ${OVE_PROJECT_STATE_DIR}/revtab-news ]; then
				wordlist+=" $(grep -o '^[a-f0-9]\+' ${OVE_PROJECT_STATE_DIR}/revtab-news)"
			fi
			if [ -e ${OVE_PROJECT_STATE_DIR}/revtab-ahead ]; then
				wordlist+=" $(grep -o '^[a-f0-9]\+' ${OVE_PROJECT_STATE_DIR}/revtab-ahead)"
			fi
		fi
	elif [ "${subcommand}" == "diff-project" ] ||
		[ "${subcommand}" == "log-project" ] ||
		[ "${subcommand}" == "shortlog-project" ]; then
		if [ ${size} -lt 4 ]; then
			wordlist=$(ove_project_tags_and_branches)
		else
			return
		fi
	elif [ "${subcommand}" == "do" ]; then
		if [ ${size} -eq 2 ]; then
			wordlist=$(ove_revtab_list_basename)
		elif [ ${size} -eq 3 ]; then
			[ -d ${OVE_BASE_DIR}/${COMP_WORDS[2]} ] &&
				wordlist=$(find $(readlink -f ${OVE_BASE_DIR}/${COMP_WORDS[2]}) -perm -u=x -not -path '*.git*' -type f)
		elif [ ${size} -gt 3 ]; then
			return
		fi
	elif [ "${subcommand}" == "switch" ]; then
		if [ ${size} -eq 2 ]; then
			wordlist=$(ove-locate | \
				grep -v '^\s' | \
				xargs -n1 basename)
		elif [ ${size} -gt 2 ]; then
			return
		fi
	elif [ "${subcommand}" == "vi" ] ||
		[ "${subcommand}" == "emacs" ]; then
		if [ ${size} -eq 2 ] && [ "$(ove-list-modified-files)" != "" ]; then
			wordlist=$(ove-list-modified-files | \
				xargs -n1 basename)
		else
			return
		fi
	elif [ "${subcommand}" == "config" ]; then
		if [ ${size} -eq 2 ]; then
			wordlist=$(ove-config | awk '{print $1}')
		elif [ ${size} -gt 2 ]; then
			return
		fi
	elif [ "${subcommand}" == "add" ] ||
		[ "${subcommand}" == "branch" ] ||
		[ "${subcommand}" == "describe" ] ||
		[ "${subcommand}" == "diff" ] ||
		[ "${subcommand}" == "diff-cached" ] ||
		[ "${subcommand}" == "heads2revtab" ] ||
		[ "${subcommand}" == "list-stash" ] ||
		[ "${subcommand}" == "readme" ] ||
		[ "${subcommand}" == "remote" ] ||
		[ "${subcommand}" == "reset" ] ||
		[ "${subcommand}" == "wdiff" ]; then
		if [ ${size} -ge 2 ]; then
			wordlist=$(ove_revtab_list_basename)
		fi
	elif [ "${subcommand}" == "news" ] ||
		[ "${subcommand}" == "pull" ]; then
		if [ -e ${OVE_PROJECT_STATE_DIR}/revtab-status ] && grep -q 'behind.*]' ${OVE_PROJECT_STATE_DIR}/revtab-status; then
			wordlist=$(grep 'behind.*]' ${OVE_PROJECT_STATE_DIR}/revtab-status | \
				cut -d: -f1 | \
				xargs)
		else
			wordlist=$(ove_revtab_list_basename)
		fi
	elif [ "${subcommand}" == "ahead" ] ||
		[ "${subcommand}" == "pull" ]; then
		if [ -e ${OVE_PROJECT_STATE_DIR}/revtab-status ] && grep -q "${subcommand}.*]" ${OVE_PROJECT_STATE_DIR}/revtab-status; then
			wordlist=$(grep "${subcommand}.*]" ${OVE_PROJECT_STATE_DIR}/revtab-status | \
				cut -d: -f1 | \
				xargs)
		else
			wordlist=$(ove_revtab_list_basename)
		fi
	elif [ "${subcommand}" == "fetch" ] ||
		[ "${subcommand}" == "list-heads" ] ||
		[ "${subcommand}" == "status" ]; then
		wordlist=$(ove_revtab_list_basename)
	elif [ "${subcommand}" == "systest" ] ||
		[ "${subcommand}" == "systest-parallel" ]; then
		if [ ${size} -ge 2 ]; then
			wordlist=$(ove-list-systests)
		fi
	elif [ "${subcommand}" == "export" ]; then
		if [ ${size} -ge 2 ]; then
			wordlist=${OVE_PROJECT_LIST}
		fi
	elif [ "${subcommand}" == "apply" ]; then
		if [ ${size} -ge 2 ]; then
			return
		fi
	elif [ "${subcommand}" == "env" ]; then
		if [ ${size} -eq 2 ]; then
			wordlist=$(compgen -A variable | grep OVE_)
		else
			return
		fi
	elif [ "${subcommand}" == "unittest" ]; then
		if [ ${size} -ge 2 ]; then
			wordlist=$(find ${OVE_DIR}/tests -maxdepth 1 -mindepth 1 -name "t*" -type f -exec basename {} \;)
		fi
	elif [ "${subcommand}" == "what-is" ]; then
		if [ ${size} -ge 2 ]; then
			wordlist=$(find $(readlink -f ${PWD}) -maxdepth 1 -mindepth 1 -not -path '*.git' -type d -exec basename {} \;)
		fi
	elif [ "${subcommand}" == "select-configuration" ]; then
		if [ ${size} -eq 2 ]; then
			wordlist="default $(find "${OVE_PROJECT_DIR}/projects" -name "configure-*" -type l -exec basename {} \; | sed 's/configure-//g')"
		else
			return
		fi
	fi

	if [ "${wordlist}" != "" ]; then
		COMPREPLY=( $(compgen -W "${wordlist}" -- ${cur}) )
	else
		opts="${OVE_ALL_COMMANDS}"
		if compgen -W "${opts}" -- "${cur}" &> /dev/null; then
			COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
		fi
	fi
}

function ove_update_tab_complete {
	local array
	local cmd
	local oldIFS

	OVE_BUILT_INS_WITHOUT_ARGS=$(grep -B1 '^function ove-' ${OVE_SELF} | \
		grep ': :' | \
		cut -b3- | \
		cut -d: -f1 | \
		sort | \
		tr '\n' ' ' | \
		xargs "${OVE_ECHO}")

	export OVE_BUILT_INS_WITHOUT_ARGS

	OVE_BUILT_INS=$(grep -o '^function ove-.* ' ${OVE_SELF} | \
		sed -e ':a;N;$!ba;s/function ove-//g' | \
		sort | \
		tr '\n' ' ' | \
		xargs "${OVE_ECHO}")

	# project commands
	OVE_ALL_COMMANDS=${OVE_PROJECT_COMMANDS}

	# built-in functions
	OVE_ALL_COMMANDS+=" ${OVE_BUILT_INS}"

	# scripts
	if [ "${OVE_SCRIPTS_LIST}" != "" ];then
		OVE_ALL_COMMANDS+=" ${OVE_SCRIPTS_LIST}"
	fi

	# parallel project commands
	for cmd in ${OVE_PROJECT_COMMANDS}; do
		OVE_ALL_COMMANDS+=" ${cmd}-parallel"
	done

	array=(${OVE_ALL_COMMANDS})
	oldIFS=${IFS}
	IFS=$'\n' OVE_ALL_COMMANDS=$(xargs "${OVE_ECHO}" <<<$(sort <<<"${array[*]}"))
	IFS=${oldIFS}

	export OVE_ALL_COMMANDS

	complete -o bashdefault -o default -F ove_bash_complete ove
	for cmd in ${OVE_PROJECT_COMMANDS}; do
		complete -W "${OVE_PROJECT_LIST}" "ove-${cmd}"
	done
}

function ove_add_script_func {
	local htext
	local script
	local script_dir

	script_dir=$1
	script=$2

	ove_scripts_name2path[${script}]=${script_dir}

	if [ -f ${script_dir}/${script}.help ]; then
		htext=$(<${script_dir}/${script}.help)
		eval "ove-${script}() {
		local helptext=\"${htext}\"
		\"${script_dir}\"/${script} \$*
		}"
	else
		eval "ove-${script}() {
		local helptext=\"${script}: :run '${script_dir}/${script}'\"
		\"${script_dir}\"/${script} \$*
		}"
	fi
}

function ove_scripts_init {
	local array
	local oldIFS
	local repo
	local script
	local script_list
	declare -A -g ove_scripts_name2path

	OVE_SCRIPTS_LIST=

	# project scripts
	if [ -d "${OVE_PROJECT_DIR}/scripts" ]; then
		script_list=$(find ${OVE_PROJECT_DIR}/scripts -perm -u=x -not -name '*.help' -type f)
		for script in ${script_list}; do
			ove_add_script_func ${OVE_PROJECT_DIR}/scripts ${script##*/}
			OVE_SCRIPTS_LIST+="${script##*/} "
		done
	fi

	# OVE scripts
	if [ -d "${OVE_DIR}/scripts" ]; then
		script_list=$(find ${OVE_DIR}/scripts -perm -u=x -not -name '*.help' -type f)
		for script in ${script_list}; do
			ove_add_script_func ${OVE_DIR}/scripts ${script##*/}
			OVE_SCRIPTS_LIST+="${script##*/} "
		done
	fi

	# repo scripts
	for repo in $(ove_revtab_list_fullpath); do
		! [ -d "${repo}/.ove/scripts" ] && continue
		script_list=$(find -L ${repo}/.ove/scripts -perm -u=x -not -name '*.help' -type f)
		for script in ${script_list}; do
			ove_add_script_func ${repo}/.ove/scripts ${script##*/}
			OVE_SCRIPTS_LIST+="${script##*/} "
		done
	done

	array=(${OVE_SCRIPTS_LIST})
	oldIFS=${IFS}
	IFS=$'\n' OVE_SCRIPTS_LIST=$(xargs "${OVE_ECHO}" <<<$(sort <<<"${array[*]}"))
	IFS=${oldIFS}
}

# show-configuration: :show current build configuration for each project
function ove-show-configuration {
	[ -d "${OVE_PROJECT_DIR}/projects" ] && \
		tree -l -P 'configure' -I 'configure-*' ${OVE_PROJECT_DIR}/projects
}

# select-configuration:[PATTERN|default]:select build configuration for each project
function ove-select-configuration {
	local c
	local configs
	local iter
	local nbr_of_configs
	local p
	local projects

	# list of projects
	projects=${OVE_PROJECT_LIST}
	iter=1
	for p in ${projects}; do
		# ignore projects without a project directory
		[ ! -d "${OVE_PROJECT_DIR}/projects/${p}" ] && continue

		# multiple configurations, ask which one to select
		configs=$(find "${OVE_PROJECT_DIR}/projects/${p}" -name "configure-*" -type l)
		nbr_of_configs=$(find "${OVE_PROJECT_DIR}/projects/${p}" -name "configure-*" -type l| wc -l)
		if [ "${nbr_of_configs}" -gt 1 ]; then
			# pattern, select config
			if [ $# -eq 1 ]; then
				# use the default configuration
				if [ $1 == "default" ]; then
					git -C ${OVE_PROJECT_DIR} checkout ${OVE_PROJECT_DIR}/projects/${p}/configure
					continue
				fi

				for c in ${configs}; do
					if basename ${c} | grep -w -q configure-$1; then
						ove_echo_green_noprefix ${p}:
						pushd ${OVE_PROJECT_DIR}/projects/${p} &>/dev/null
						ln -sfv configure-$1 configure
						popd &>/dev/null
						break
					fi
				done
				continue
			fi

			# no pattern, ask user
			ove_echo_green_noprefix ${p}:
			echo "0: default"
			let iter=1
			for c in ${configs}; do
				echo -n "${iter}: "
				basename $(echo ${c} | sed 's/configure-//g')
				let iter+=1
			done
			echo
			read -p "Select configuration? " -r
			echo
			if [[ ${REPLY} =~ ^[0-9]+$ ]] && [[ ${REPLY} -le ${nbr_of_configs} ]]; then
				if [[ ${REPLY} == 0 ]]; then
					git -C ${OVE_PROJECT_DIR} checkout ${OVE_PROJECT_DIR}/projects/${p}/configure
				else
					cfg=$(echo ${configs} | cut -d' ' -f${REPLY})
					cfg_basename=$(basename ${cfg})
					pushd ${OVE_PROJECT_DIR}/projects/${p} &>/dev/null
					ln -sfv ${cfg_basename} configure
					popd &>/dev/null
				fi
			fi
		fi
	done

	ove-show-configuration
}

function ove_dirs_init {
	local OVE_STATE_LINK_NAME
	local OVE_TMP_LINK_NAME

	OVE_STATE_LINK_NAME="${OVE_BASE_DIR}/.ove.state"
	OVE_TMP_LINK_NAME="${OVE_BASE_DIR}/.ove.tmp"

	# global state
	[ -d /var/tmp ] && OVE_GLOBAL_STATE_DIR=/var${OVE_TMP} || OVE_GLOBAL_STATE_DIR=${OVE_TMP}
	export OVE_GLOBAL_STATE_DIR

	# project state
	if ! [ -h ${OVE_STATE_LINK_NAME} ]; then
		OVE_PROJECT_STATE_DIR=$(mktemp -u -d -p ${OVE_GLOBAL_STATE_DIR}/${OVE_PROJECT_NAME} state-XXXXXXXXXX)

		mkdir -p ${OVE_PROJECT_STATE_DIR}
		ln -s ${OVE_PROJECT_STATE_DIR} ${OVE_STATE_LINK_NAME}

		# always re-create tmp link
		[ -h ${OVE_TMP_LINK_NAME} ] && rm ${OVE_TMP_LINK_NAME}
	else
		OVE_PROJECT_STATE_DIR=$(readlink ${OVE_STATE_LINK_NAME})
		! [ -e "${OVE_STATE_LINK_NAME}" ] && mkdir -p ${OVE_PROJECT_STATE_DIR}
	fi
	export OVE_PROJECT_STATE_DIR

	# project tmp
	if ! [ -h ${OVE_TMP_LINK_NAME} ]; then
		# re-use last 10 characters from OVE_PROJECT_STATE_DIR
		OVE_PROJECT_TMP_DIR="${OVE_TMP}/${OVE_PROJECT_NAME}/tmp-${OVE_PROJECT_STATE_DIR: -10}"
		mkdir -p ${OVE_PROJECT_TMP_DIR}
		ln -s ${OVE_PROJECT_TMP_DIR} ${OVE_TMP_LINK_NAME}
	else
		OVE_PROJECT_TMP_DIR=$(readlink ${OVE_TMP_LINK_NAME})
		! [ -e "${OVE_TMP_LINK_NAME}" ] && mkdir -p ${OVE_PROJECT_TMP_DIR}
	fi
	export OVE_PROJECT_TMP_DIR
}

function ove_config_init {
	# own config has precedence over project config
	if [ -e ${HOME}/.oveconfig ]; then
		ove_read_config ${HOME}/.oveconfig
	elif [ -e ${OVE_PROJECT_DIR}/.oveconfig ]; then
		ove_read_config ${OVE_PROJECT_DIR}/.oveconfig
	fi

	# project state config?
	[ -e ${OVE_PROJECT_STATE_DIR}/.oveconfig ] && ove_read_config ${OVE_PROJECT_STATE_DIR}/.oveconfig
}

# init:initialize OVE project
function ove_init {
	local base_dir

	base_dir=$(ove_get_base_dir)
	[ $? -ne 0 ] && return 1
	OVE_BASE_DIR="${base_dir}"

	OVE_ECHO=$(which echo)
	OVE_PROJECT_DIR=$(readlink -f ${OVE_BASE_DIR}/.owel)
	OVE_PROJECT_NAME=${OVE_PROJECT_DIR##*/}
	OVE_PROJECT_LIST=$(ove_list_projects)
	OVE_PROJECT_COMMANDS=$(ove_project_commands_list)
	OVE_DIR="$(cd "$(dirname "$(readlink -f ${OVE_BASE_DIR}/${BASH_SOURCE[0]##*/})")"; pwd -P)"
	OVE_BASENAME="$(basename $(readlink -f ${OVE_BASE_DIR}/${BASH_SOURCE[0]##*/}))"
	OVE_SELF="${OVE_DIR}/${OVE_BASENAME}"

	ove_dirs_init
	ove_config_init
	ove_revtab_init
	ove_revtab_parse
	ove_projects_init
	ove_projects_parse
	ove_scripts_init

	if [ "${OVE_LOGLEVEL}" == "2" ]; then
		set -x
	fi

	if ! [ -z "${OVE_ANALYZE_EXECVE+x}" ]; then
		echo ${BASHPID} > ${OVE_PROJECT_TMP_DIR}/strace.pid
		while true; do
			[ -e ${OVE_PROJECT_TMP_DIR}/strace.cont ] && break
		done
	fi

	[ "$1" == "quick" ] && return 0

	if ! ove_validate_self; then
		return 1
	fi

	if ! ove_validate_projs; then
		return 1
	fi

	if ! ove_validate_revtab; then
		return 1
	fi

	if ! [ -L ${OVE_BASE_DIR}/README ]; then
		if [ -s ${OVE_PROJECT_DIR}/README ]; then
			ln -s -r ${OVE_PROJECT_DIR}/README ${OVE_BASE_DIR}/README
		elif [ -s ${OVE_PROJECT_DIR}/README.md ]; then
			ln -s -r ${OVE_PROJECT_DIR}/README.md ${OVE_BASE_DIR}/README
		fi
	fi

	ove_update_tab_complete

	if [ -z "${OVE_DRY_RUN+x}" ]; then
		OVE_DRY_RUN=0
		export OVE_DRY_RUN
	fi
	if [ -z "${OVE_LOCATE_SEARCH_DIR+x}" ]; then
		OVE_LOCATE_SEARCH_DIR=$(readlink -f $(dirname ${HOME}))
		export OVE_LOCATE_SEARCH_DIR
	fi
	if [ -z "${OVE_PROJECT_CI_BRANCH+x}" ]; then
		OVE_PROJECT_CI_BRANCH="origin/master"
		export OVE_PROJECT_CI_BRANCH
	fi
	if [ -z "${OVE_LOGLEVEL+x}" ]; then
		OVE_LOGLEVEL=1
		OVE_REDIRECT_OUTPUT=""
		export OVE_REDIRECT_OUTPUT
		export OVE_LOGLEVEL
	fi
	if [ -z "${OVE_AUTOCORRECT+x}" ]; then
		OVE_AUTOCORRECT=0
		export OVE_AUTOCORRECT
	fi
	OVE_REPO_LIST=$(ove_revtab_list_fullpath)
	export OVE_REPO_LIST
	OVE_BUILD_ORDER="$(ove-build-order)"
	export OVE_ECHO
	export OVE_BUILD_ORDER
	export OVE_BASE_DIR
	export OVE_PROJECT_DIR
	export OVE_PROJECT_LIST
	export OVE_PROJECT_COMMANDS
	export OVE_DIR
	export OVE_BASENAME
	export OVE_SELF
	export OVE_PROJECT_NAME

	OVE_LOG_DIR="${OVE_GLOBAL_STATE_DIR}/logs"
	export OVE_LOG_DIR
	! [ -d "${OVE_LOG_DIR}" ] && mkdir -p "${OVE_LOG_DIR}"

	OVE_STAGE_DIR=${OVE_BASE_DIR}/stage
	export OVE_STAGE_DIR
	OVE_ARCHIVE_DIR=${OVE_BASE_DIR}/archives
	export OVE_ARCHIVE_DIR
	OVE_PREFIX="/usr"
	export OVE_PREFIX
	OVE_LDFLAGS=" -L${OVE_STAGE_DIR}${OVE_PREFIX}/lib -Wl,-rpath-link=${OVE_STAGE_DIR}${OVE_PREFIX}/lib"
	export OVE_LDFLAGS
	OVE_CPPFLAGS=" -I${OVE_STAGE_DIR}${OVE_PREFIX}/include"
	export OVE_CPPFLAGS
	OVE_SHA=$(git -C ${OVE_DIR} rev-parse --short HEAD)
	export OVE_SHA
	OVE_LAST_COMMAND=
	export OVE_LAST_COMMAND
	OVE_INIT_STRING='eval source ${OVE_BASE_DIR}/ove; ove_init quick'
	export OVE_INIT_STRING
	OVE_PAGER="less -R"
	export OVE_PAGER

	# Update executable and run-time library paths
	PATH=${PATH}:${OVE_STAGE_DIR}${OVE_PREFIX}/bin
	export PATH

	LD_LIBRARY_PATH=${OVE_STAGE_DIR}${OVE_PREFIX}/lib
	export LD_LIBRARY_PATH

	return 0
}

function ove_post_checks {
	local corrupt_repos
	local doublets
	local res
	local script

	# check for systest doublets
	if [ -e ${OVE_PROJECT_DIR}/systests ]; then
		# yes, this is ugly
		doublets=$(grep -E -v '#|^$' ${OVE_PROJECT_DIR}/systests | \
			awk '{print $1}' | \
			cut -d: -f1 | \
			sort | \
			uniq -c -d)
		if [ "${doublets}" != "" ]; then
			echo
			ove_echo_red_noprefix "error: doublet systests identified in '${OVE_PROJECT_DIR}/systests':"
			ove_echo_red_noprefix ${doublets}
		fi
	fi

	# inform the user if .oveconfig was updated within the project
	if [ -e ${HOME}/.oveconfig ] && [ -e ${OVE_PROJECT_DIR}/.oveconfig ]; then
		res=$(comm -3 <(grep -E -v '(^#.*$)|(^$)' ${HOME}/.oveconfig | awk '{ print $1 }' | sort) \
			<(grep -E -v '(^#.*$)|(^$)' ${OVE_PROJECT_DIR}/.oveconfig | awk '{ print $1 }' | sort))
		if [ "${res}" != "" ]; then
			echo
			echo "--->"
			ove_echo_yellow_noprefix "warning: the two files:"
			echo
			echo "${HOME}/.oveconfig"
			echo "${OVE_PROJECT_DIR}/.oveconfig"
			echo
			echo "...are different. Do a merge!?"
			echo
			diff <(grep -E -v '(^#.*$)|(^$)' ${HOME}/.oveconfig | awk '{ print $1 }' | sort) \
				<(grep -E -v '(^#.*$)|(^$)' ${OVE_PROJECT_DIR}/.oveconfig | awk '{ print $1 }' | sort)
			echo "<---"
		fi
	fi

	# check for script doublets
	doublets=$(for script in $(ove-list-scripts); do echo ${script##*/}; done | \
		sort | \
		uniq -d)
	if [ "${doublets}" != "" ]; then
		echo
		ove_echo_yellow_noprefix "warning: found script duplicates:"
		for script in ${doublets}; do
			ove-list-scripts| grep -w "${script}$"
		done
	fi

	# check for repos without a '.git' directory
	corrupt_repos=$(ove_revtab_forall_parallel '[ -d .git ] || ove_git2shortpath $(pwd)' | xargs)
	if [ "${corrupt_repos}" != "" ]; then
		echo
		ove_echo_error_noprefix "corrupt repo(s): ${corrupt_repos}"
		echo
		ove_echo_red_noprefix "fix this by running the following two commands:"
		echo
		echo -e "\t$ rm -rf ${corrupt_repos}"
		echo -e "\t$ ove fetch ${corrupt_repos}"
		echo
	fi

	# vaidate revtab revision
	ove_revtab_check
}

# create a '.owel/revtab' file from current directory
function ove_crawl {
	local fetch_url
	local git
	local name
	local push_url
	local rev
	local str

	str=""
	for git in $(find -type d -name .git 2>/dev/null); do
		if ! git -C ${git} log -1 --oneline &> /dev/null; then
			continue
		fi
		name=$(dirname "${git}" | cut -b3-)
		fetch_url=$(git -C "${git}" remote -v | \
			grep fetch | \
			awk '{print $2}' | \
			tr -d '\n')
		push_url=$(git -C "${git}" remote -v | \
			grep push | \
			awk '{print $2}' | \
			tr -d '\n')
		if git -C "${git}" branch | grep -q detached; then
			rev=$(git -C "${git}" rev-parse --short HEAD| tr -d '\n')
		else
			rev=$(git -C "${git}" branch | \
				cut -d' ' -f2 | \
				tr -d '\n')
		fi

		str+="${name} ${fetch_url} ${push_url} ${rev}\n"
	done
	mkdir -vp .owel
	printf "${str}" | \
		column -t | \
		sort > .owel/revtab

	echo "Created '.owel/revtab' and populated the file with $(wc -l .owel/revtab) repositories, run 'source ove' again"
}

# $1: command
function ove_command_to_package {
	local package

	# column
	if [ "$1" == "column" ]; then
		if [[ ${OVE_OS} == *"Ubuntu"* ]] || \
			[[ ${OVE_OS} == *"Debian"* ]]; then
			package="bsdmainutils"
		elif [[ ${OVE_OS} == *"Alpine"* ]] || \
			[[ ${OVE_OS} == *"Fedora"* ]]; then
			package="util-linux"
		elif [[ ${OVE_OS} == *"Gentoo"* ]] || \
			[[ ${OVE_OS} == *"CentOS"* ]]; then
			package=""
		else
			package="$1"
		fi
	# envsubst
	elif [ "$1" == "envsubst" ]; then
		if [[ ${OVE_OS} == *"Ubuntu"* ]] || \
			[[ ${OVE_OS} == *"Debian"* ]]; then
			package="gettext-base"
		else
			package="gettext"
		fi
	# file
	elif [ "$1" == "file" ]; then
		package="$1"
	# git
	elif [ "$1" == "git" ]; then
		if [[ ${OVE_OS} == *"Alpine"* ]]; then
			package="git git-perl"
		elif [[ ${OVE_OS} == *"Gentoo"* ]]; then
			package="dev-vcs/git"
		else
			package="git"
		fi
	# hostname
	elif [ "$1" == "hostname" ]; then
		if [[ ${OVE_OS} == *"Alpine"* ]]; then
			package="net-tools"
		else
			package="hostname"
		fi
	# locate
	elif [ "$1" == "locate" ]; then
		package="mlocate"
	# pgrep
	elif [ "$1" == "pgrep" ]; then
		if [[ ${OVE_OS} == *"Ubuntu"* ]] || \
			[[ ${OVE_OS} == *"Debian"* ]]; then
			package="procps"
		fi
	# script
	elif [ "$1" == "script" ]; then
		if [[ ${OVE_OS} == *"Ubuntu"* ]] || \
			[[ ${OVE_OS} == *"Debian"* ]]; then
			package="bsdutils"
		elif [[ ${OVE_OS} == *"Gentoo"* ]]; then
			package="sys-apps/util-linux"
		fi
	# tree
	elif [ "$1" == "tree" ]; then
		if [[ ${OVE_OS} == *"Gentoo"* ]]; then
			package="app-text/tree"
		fi
	# tsort
	elif [ "$1" == "tsort" ]; then
		package="coreutils"
	# xz
	elif [ "$1" == "xz" ]; then
		if [[ ${OVE_OS} == *"Ubuntu"* ]] || \
			[[ ${OVE_OS} == *"Debian"* ]]; then
			package="xz-utils"
		elif [[ ${OVE_OS} == *"Gentoo"* ]]; then
			package="app-arch/xz"
		else
			package="xz"
		fi
	fi

	[ "${package}" != "" ] && echo ${package} || echo $1
}

function ove_deps {
	local dep
	local deps
	local pack
	local str_cmds
	local str_packs

	str_packs=""
	str_cmds=""

	deps=()
	deps+=('column')
	deps+=('file')
	deps+=('envsubst')
	deps+=('git')
	deps+=('hostname')
	deps+=('pgrep')
	deps+=('script')
	deps+=('tree')
	deps+=('tsort')

	for dep in "${deps[@]}"; do
		if ! command -v ${dep} > /dev/null; then
			str_cmds+="${dep} "
			pack=$(ove_command_to_package ${dep})
			if [ "${pack}" != "" ]; then
				str_packs+="${pack} "
			fi
		fi
	done

	if [ "${str_cmds}" != "" ]; then
		ove_echo_error_noprefix "missing command(s):"
		echo
		for dep in ${str_cmds}; do
			echo -e "\t${dep}"
		done | sort
		echo
		echo "To fix this, run the following command:"
		echo
		echo -e "\t${OVE_OS_PACKAGE_MANAGER} ${OVE_OS_PACKAGE_MANAGER_ARGS} ${str_packs}"
		echo
		return 1
	fi
}

# $*: list of packages
# returns a list of packages NOT installed
function ove_packages_not_installed {
	[ $# -eq 0 ] && return

	if [[ ${OVE_OS} == *"Arch Linux"* ]]; then
		comm -2 -3 <(echo $* | xargs -n1 | sort) <(pacman -Q | awk '{print $1}')
	elif [[ ${OVE_OS} == *"Alpine"* ]]; then
		comm -2 -3 <(echo $* | xargs -n1 | sort) <(apk info | sort)
	elif [[ ${OVE_OS} == *"CentOS"* ]] || \
		[[ ${OVE_OS} == *"Fedora"* ]] || \
		[[ ${OVE_OS} == *"RedHatEnterpriseServer"* ]]; then
		comm -2 -3 <(echo $* | xargs -n1 | sort) <(rpm -qa --qf "%{NAME}\n"| sort)
	elif [[ ${OVE_OS} == *"Debian"* ]] || \
		[[ ${OVE_OS} == *"Raspbian"* ]] || \
		[[ ${OVE_OS} == *"Ubuntu"* ]]; then
		dpkg-query -W -f='${Package}:${Status}\n' $* 2>&1 | \
			grep -v ":install ok installed" | \
			sed -e 's/dpkg-query: no packages found matching //g' -e 's/:.*//g' | \
			xargs
	else
		ove_echo_error_noprefix "function '${FUNCNAME[0]}' is not implemented for ${OVE_OS}"
	fi
}

function ove_determine_dist_version_and_pack_manager {
	if [ -e /etc/os-release ]; then
		OVE_OS=$(source /etc/os-release; echo ${NAME})
		OVE_OS_VER=$(source /etc/os-release; echo ${VERSION_ID})
	elif command -v lsb_release > /dev/null; then
		OVE_OS=$(lsb_release --id --short)
		OVE_OS_VER=$(lsb_release --release --short)
	else
		ove_echo_warning_noprefix "unable to determine distro"
		OVE_OS=$(uname -s)
		OVE_OS_VER=$(uname -r)
	fi


	if [[ ${OVE_OS} == *"Alpine"* ]]; then
		OVE_OS_PACKAGE_MANAGER="apk"
		OVE_OS_PACKAGE_MANAGER_ARGS="add"
	elif [[ ${OVE_OS} == *"Arch Linux"* ]]; then
		OVE_OS_PACKAGE_MANAGER="pacman"
		OVE_OS_PACKAGE_MANAGER_ARGS="-S"
	elif [[ ${OVE_OS} == *"CentOS"* ]]; then
		OVE_OS_PACKAGE_MANAGER="yum"
		OVE_OS_PACKAGE_MANAGER_ARGS="install"
	elif [[ ${OVE_OS} == *"Debian"* ]] || \
		[[ ${OVE_OS} == *"Raspbian"* ]] || \
		[[ ${OVE_OS} == *"Ubuntu"* ]]; then
		OVE_OS_PACKAGE_MANAGER="apt"
		OVE_OS_PACKAGE_MANAGER_ARGS="install"
	elif [[ ${OVE_OS} == *"Fedora"* ]] || \
		[[ ${OVE_OS} == *"RedHatEnterpriseServer"* ]]; then
		OVE_OS_PACKAGE_MANAGER="dnf"
		OVE_OS_PACKAGE_MANAGER_ARGS="install"
	elif [[ ${OVE_OS} == *"Gentoo"* ]]; then
		OVE_OS_PACKAGE_MANAGER="emerge"
		OVE_OS_PACKAGE_MANAGER_ARGS=""
	else
		OVE_OS_PACKAGE_MANAGER="unknown"
		OVE_OS_PACKAGE_MANAGER_ARGS=""
	fi

	export OVE_OS
	export OVE_OS_VER
	export OVE_OS_PACKAGE_MANAGER
	export OVE_OS_PACKAGE_MANAGER_ARGS
}

# readme:[GIT...]:display README files for all/specified git repositories
function ove-readme {
	local cmd

	cmd='find -maxdepth 1 -name "README*" -print0 | \
		xargs -r -0 head -v | \
		sed -e "1 i$(ove_echo_yellow_noprefix $(pwd -P))" -e "s/^/\t/g"'

	if [ $# -eq 0 ]; then
		ove_revtab_forall "${cmd}"
	else
		ove_revtab_forsome "${cmd}" "$*"
	fi
}

# replicate:HOST:replicate OVE workspace on HOST
function ove-replicate {
	local d
	local host
	local p
	local s

	if [ $# -ne 1 ]; then
		ove-help ^${FUNCNAME/ove-/}
		return 1
	fi

	s="$(ove-setup)"
	if [ "${s}" == "" ]; then
		ove_echo_error_noprefix "'${OVE_PROJECT_DIR}/SETUP' file not found"
		return 2
	fi

	host="$1"
	if ! ssh -q ${host} exit; then
		ove_echo_error_noprefix "'${host}' is not reachable via ssh"
		return 3
	fi

	# remote directory
	d=$(ssh ${host} mktemp -d)

	# only diffs relative to the index is included (for now)
	p=$(mktemp -p ${OVE_PROJECT_TMP_DIR})
	ove-diff > ${p}
	if [ -s "${p}" ]; then
		p_remote="${d}/${OVE_PROJECT_NAME}.patch"
		if ! scp -q ${p} ${host}:${p_remote}; then
			ove_echo_error_noprefix "not possible to transfer patch file to '${host}'"
			rm ${p}
			return 4
		fi
	fi

	if ! ssh ${host} "
		echo $ ssh ${host};
		echo $ cd ${d}; cd ${d};
		echo $ '${s}'; eval ${s};
		cd *;
		echo $ pwd; pwd;
		echo $ source ove; source ove;
		ove_init;
		echo $ ove fetch; ove-fetch;
		[ -e ${p_remote} ] && echo '$ ove apply ${p_remote}' && ove-apply ${p_remote};
		echo $ ove status; ove-status"; then
		ove_echo_error_noprefix "trying to replicate OVE workspace on '${host}'"
	else
		echo
		echo "OVE workspace has been replicated to '${host}:${d}'"
	fi

	rm ${p}
}

function ove_unittest_preparations {
	local nbr_of_files
	local nbr_of_projs
	local nbr_of_repos
	local nbr_of_systests

	nbr_of_files=$1
	nbr_of_projs=$2
	nbr_of_repos=$3
	nbr_of_systests=$4

	unittest_dir="${OVE_PROJECT_TMP_DIR}/unittest"

	echo -n "Preparing ${unittest_dir}..."
	[ -d ${unittest_dir} ] && \
		rm -rf ${unittest_dir}
	mkdir -p ${unittest_dir}/.ove

	cd ${unittest_dir}
	ln -s ${OVE_SELF} ove
	ln -s ${OVE_DIR}/tests

	# remotes
	mkdir -p remotes

	# create some remote bare repos
	for a in $(seq 1 ${nbr_of_repos}) top; do
		mkdir -p ${unittest_dir}/remotes/git-${a}
		if ! [ -d .git ]; then
			git init -q --bare ${unittest_dir}/remotes/git-${a}
			echo -n .
		fi
	done

	# clone all repositories
	mkdir -p testing/src
	for a in $(seq 1 ${nbr_of_repos}); do
		if [ $((a%2)) -eq 0 ]; then
			git clone -q remotes/git-${a} ${unittest_dir}/testing/src/git-${a} &> /dev/null
		else
			git clone -q remotes/git-${a} ${unittest_dir}/git-${a} &> /dev/null
		fi
		echo -n .
	done
	git clone -q ${unittest_dir}/remotes/git-top &> /dev/null
	ln -s git-top .owel

	# add some files
	for a in $(seq 1 ${nbr_of_repos}); do
		if [ $((a%2)) -eq 0 ]; then
			cd ${unittest_dir}/testing/src/git-${a}
		else
			cd ${unittest_dir}/git-${a}
		fi

		for i in $(seq 1 ${nbr_of_files}); do
			echo -n .
			filename=$(head /dev/urandom | tr -dc A-Za-z0-9 | head -c 13 ; echo '')
			touch ${filename}
			git add ${filename}
			git commit -q -m "${filename}"
			git tag 0.0.${i}
			git push -q origin master
			git push -q --tags
		done
	done

	# create revtab
	for a in $(seq 1 ${nbr_of_repos}); do
		if [ $((a%2)) -eq 0 ]; then
			echo "testing/src/git-${a} ${unittest_dir}/remotes/git-1 ${unittest_dir}/remotes/git-1 master" >> ${unittest_dir}/git-top/revtab
		else
			echo "git-${a} ${unittest_dir}/remotes/git-1 ${unittest_dir}/remotes/git-1 master" >> ${unittest_dir}/git-top/revtab
		fi
	done

	# create projs
	for a in $(seq 1 ${nbr_of_projs}); do
		echo "p${a}:" >> ${unittest_dir}/git-top/projs
		echo "  path: .owel" >> ${unittest_dir}/git-top/projs
		if [ ${a} -lt ${nbr_of_projs} ]; then
			echo "  deps: p$((a+1))" >> ${unittest_dir}/git-top/projs
		fi
		echo >> ${unittest_dir}/git-top/projs
		mkdir -p ${unittest_dir}/git-top/projects/p${a}
		for b in bootstrap configure build install; do
			echo "echo ${b} p${a}" > ${unittest_dir}/git-top/projects/p${a}/${b}
			chmod +x ${unittest_dir}/git-top/projects/p${a}/${b}
		done
	done

	# create systests
	for a in $(seq 1 ${nbr_of_systests}); do
		echo "ok${a} 10 0 \"\" true" >> ${unittest_dir}/git-top/systests
		echo "nok${a} 10 0 \"\" false" >> ${unittest_dir}/git-top/systests
	done
	# create systests-groups
	echo "all:" >> ${unittest_dir}/git-top/systests-groups
	for a in $(seq 1 ${nbr_of_systests}); do
		echo "- ok${a}" >> ${unittest_dir}/git-top/systests-groups
		echo "- nok${a}" >> ${unittest_dir}/git-top/systests-groups
	done

	# commit and push
	git -C ${unittest_dir}/git-top add .
	git -C ${unittest_dir}/git-top commit -q -m "test"
	git -C ${unittest_dir}/git-top push -q origin master

	echo -n "..done"
	echo
}

# unittest:[TEST...]:run all/specific unit tests
function ove-unittest {
	local a
	local b
	local do_preparations
	local i
	local nbr_of_files
	local nbr_of_projs
	local nbr_of_repos
	local nbr_of_systests
	local tests

	if ! command -v shelltest > /dev/null; then
		echo "shelltestrunner is not found. Version 1.9 or greater is needed"
		return 1
	fi

	nbr_of_files=3
	nbr_of_projs=400
	nbr_of_repos=100
	nbr_of_systests=3

	do_preparations="1"
	if [ -t 1 ] && [ -d ${OVE_PROJECT_TMP_DIR}/unittest ]; then
		read -p "Setup? (y/N) " -r
		echo
		if ! [[ ${REPLY} =~ ^[Yy]$ ]]; then
			do_preparations="0"
		fi
	fi

	[ "${do_preparations}" == "1" ] && \
		ove_unittest_preparations ${nbr_of_files} ${nbr_of_projs} ${nbr_of_repos} ${nbr_of_systests}

	# launch shelltestrunner
	if [ $# -eq 0 ]; then
		tests="tests/t*"
	else
		for a in $*; do
			tests+="tests/${a} "
		done
	fi

	cd ${OVE_PROJECT_TMP_DIR}/unittest
	shelltest=$(command -v shelltest)
	if [ ${OVE_LOGLEVEL} -eq 2 ]; then
		shelltest_opts=" --debug "
	fi

	env -i - HOME=${HOME} USER=${USER} \
		${shelltest} ${tests} \
		${shelltest_opts} \
		--color \
		-j $(nproc) \
		--diff \
		-DOVE_TEST_STRING="source ove > /dev/null; ove_init > /dev/null" \
		-Dnbr_of_systests=$(((nbr_of_systests * 2) + 1)) \
		-Dnbr_of_repos=$((nbr_of_repos + 1 )) \
		-Dnbr_of_files=$((nbr_of_files * nbr_of_repos + (4 * nbr_of_projs) + 4)) \
		-DOVE_TEST_BASE="$(echo ${OVE_PROJECT_TMP_DIR}/unittest| sed -e 's|/|\\/|g')"
}

# generate-doc: :generate OVE documentation (e.g. ${OVE_DIR}/ove-cmd-list.md)
function ove-generate-doc {
	local a
	local b
	local header
	local sorted

	a=$(grep -B1 "^function ove-" "${OVE_BASE_DIR}"/ove | \
		grep '\#' | \
		cut -b3-)
	b=$(set | \
		grep helptext | \
		grep -v '\$'| \
		cut -d'"' -f2 | \
		grep -v -f<(echo ${OVE_SCRIPTS_LIST} | xargs -n1))

	header="| Command:| Arguments:| Description: |"
	sorted=$(printf "${a}\n${b}" | \
		sed \
		-e 's/|/@/g' \
		-e 's/:/ :| /g' \
		-e 's/^/| /g' \
		-e 's/$/: |/g' | \
		LC_ALL="C" sort)

	printf "${header}\n|-|-|-|\n${sorted}\n" | \
		column -s: -t | \
		sed -e 's/\@/\\|/g' \
		> ${OVE_DIR}/ove-cmd-list.md

	return 0
}

ove_main "$@"
