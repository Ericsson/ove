#!/usr/bin/env bash
# SPDX-License-Identifier: MIT
#
# MIT License
#
# Copyright (c) 2019 Ericsson
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is furnished
# to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice (including the next
# paragraph) shall be included in all copies or substantial portions of the
# Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
# FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS
# OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
# OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

function ove_read_config {
	local p
	local p_arr
	local val
	local var

	if [ -e "$1" ]; then
		while read -r p; do
			# ignore comments
			[[ ${p} == \#* ]] && continue
			# ignore empty lines
			[[ ${p} == '' ]] && continue
			p_arr=( ${p} )
			var=${p_arr[0]}
			if [ "$2" == "clean" ]; then
				unset ${var}
			else
				val=${p_arr[*]:1}
				eval ${var}=\"${val}\"
				# shellcheck disable=SC2163
				export ${var}
			fi
		done <$1
	fi
}

function ove_unsource {
	local f

	# remove stage string from ${PATH}
	if [ "${OVE_STAGE_DIR}" != "" ] && \
		[[ ${PATH} == *"${OVE_STAGE_DIR}"* ]]; then
		PATH=${PATH/:${OVE_STAGE_DIR}${OVE_PREFIX}\/bin/}
		export PATH
	fi

	unset LD_LIBRARY_PATH

	for f in ${OVE_ALL_CONFIG_FILES}; do
		[ -e "${f}" ] && ove_read_config ${f} clean
	done

	# unset old ove[-_] functions
	unset -f $(compgen -A function | \
		\grep -E '^ove($|[-_])' | \
		\grep -E -v "ove_read_config|ove-unsource|${FUNCNAME[0]}" | \
		\awk '{print $1}')

	# unset old ove_/OVE_ variables
	unset $(set -o posix ; set | \
		\grep -i ^ove_ | \
		\cut -d= -f1)

	# unset completion for ove
	if complete -p | \grep -q ' ove$'; then
		complete -r ove
	fi
}

# unsource: :clean up all OVE vars/funcs from this shell
function ove-unsource {
	ove_unsource
	# unset leftovers and myself
	unset -f $(compgen -A function | \
		\grep -E '^ove($|[-_])' | \
		\awk '{print $1}') \
		${FUNCNAME[0]}
	echo "OVE has been removed from this bash shell [pid:${BASHPID}]" 1>&2
}

# interactive shell? clean up
[[ $- == *i* ]] && ove_unsource

function ove_welcome_msg {
	local script_ver

	ove-version
	if ! [ -e "${HOME}/.ove.bash" ]; then
		echo
		echo "Do you want to skip the initial 'source ove' step? Run this:"
		echo " cp ${OVE_DIR}/ove.bash ${HOME}/.ove.bash && echo '[ -f ~/.ove.bash ] && source ~/.ove.bash' >> ${HOME}/.bashrc"
	fi

	script_ver=$(\script --version | \awk '{print $NF}')
	if [[ ${script_ver} =~ ^2.3[12] ]]; then
		echo
		ove_echo_note_noprefix "due to a bug in $(command -v script) 2.31/2.32 (you have ${script_ver}), it's not possible to Ctrl-C any OVE command. Upgrade package: '$(ove_command_to_package script)'."
	fi
}

function ove_version_check_early {
	local ret=0

	if command -v dpkg > /dev/null; then
		\dpkg --compare-versions ${BASH_VERSINFO[0]}.${BASH_VERSINFO[1]} ge 4.3 || ret=1
	else
		if [ ${BASH_VERSINFO[0]} -lt 4 ]; then
			ret=1
		elif [ ${BASH_VERSINFO[0]} -eq 4 ] && [ ${BASH_VERSINFO[1]} -lt 3 ]; then
			ret=1
		fi
	fi

	[ ${ret} -eq 0 ] || echo "error: bash ${BASH_VERSINFO[0]}.${BASH_VERSINFO[1]} is too old. I need bash>=4.3"
	return ${ret}
}

function ove_version_check {
	local ret=0
	local git_arr
	local git_ver

	git_ver=$(\git --version)
	git_ver=${git_ver/git version /}
	IFS='.' read -r -a git_arr <<< "${git_ver}"
	if command -v dpkg > /dev/null; then
		\dpkg --compare-versions ${git_arr[0]}.${git_arr[1]}.${git_arr[2]} ge 1.8.5 || ret=1
	else
		if [ ${git_arr[0]} -lt 2 ]; then
			if [ ${git_arr[0]} -eq 1 ] && [ ${git_arr[1]} -lt 8 ]; then
				ret=1
			elif [ ${git_arr[0]} -eq 1 ] && [ ${git_arr[1]} -eq 8 ] && [ ${git_arr[2]} -lt 5 ]; then
				ret=1
			elif [ ${git_arr[0]} -eq 0 ]; then
				ret=1
			fi
		fi
	fi

	[ ${ret} -eq 0 ] || ove_echo_error_noprefix "git ${git_ver} is too old. I need >=1.8.5"
	return ${ret}
}

function ove_main {
	/proc/self/exe --version | \grep -q 'GNU bash'
	test $? -ne 0 && echo 'error: run this in bash' && return 1

	ove_version_check_early || return 1

	ove_green="\033[1;32;7m"
	ove_cyan="\033[1;36;7m"
	ove_yellow_x="1;33;7m"
	ove_yellow="\033[${ove_yellow_x}"
	ove_red="\033[1;31;7m"
	ove_blank="\033[0m"

	OVE_TMP=/tmp/${USER}/ove
	export OVE_TMP
	! [ -d "${OVE_TMP}" ] && \mkdir -p "${OVE_TMP}"

	# set OVE_OS_* variables
	ove_determine_dist_version_and_pack_manager

	# interactive shell?
	if [[ $- == *i* ]]; then
		# turn off monitor mode to get rid of "Done" messages
		set +m

		if ! ove_deps; then
			ove-unsource
			return 1
		fi

		if [ -e ".owel" ] && [ -e ove ]; then
			:
		else
			ove-init
		fi

		if ! ove_init; then
			ove-unsource
			return 1
		fi

		if [ ${OVE_LOGLEVEL} -eq 0 ] || [[ "$*" == *"hush"* ]]; then
			:
		else
			ove_welcome_msg
		fi

		ove_post_checks

		# turn on monitor mode
		set -m
	fi
}

# $1: pid
function ove_strace_execve_one_pid {
	local cmd
	local exit_code
	local line
	local syscall
	local t0

	cmd=
	pid=$1
	while read -r line; do
		[ "${line}" == "" ] && continue
		syscall=${line#* }
		syscall=${syscall%%(*}

		if [ "${syscall}" == "execve" ]; then
			[[ "${line}" == *"ENOENT"* ]] && continue
			cmd=${line##* [\"}
			cmd=${cmd%%\"]*}
			cmd=${cmd//\", \"/ }
			t0=$(ove_strace_get_t0 ${pid})
			[ "${cmd}" == "" ] && continue
			exit_code=$(ove_strace_get_exit_code ${pid})
			if [ ${OVE_LOGLEVEL} -eq 3 ]; then
				echo "${t0}:${pid}:${exit_code}:${cmd}"
			elif [ ${OVE_LOGLEVEL} -eq 4 ]; then
				echo "$(ove_strace_get_duration_s ${pid}):${pid}:${exit_code}:${cmd}"
			fi
			continue
		fi
	done <<< "${all_files[$1]}"
}

# $1: directory with strace pid files
function ove_analyze_strace_execve_timing {
	local all_files
	local f
	local pid

	! [ -d "$1" ] && return 1

	declare -A all_files
	while true; do
		for f in $(\find $1 -type f); do
			pid=${f##*.}
			all_files[${pid}]="$(<${f})"
			ove_strace_execve_one_pid ${pid} &
		done
		wait
		break
	done | LC_ALL="C" \sort -n$([ ${OVE_LOGLEVEL} -eq 4 ] && echo r)
}

function ove_line2ipv4 {
	\grep -E -o '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}' <<<"$@"
}

# $1: IPv4 address
function ove_ip2host {
	local ip
	local ip_lookup

	if ! command -v dig > /dev/null; then
		ove_echo_command_not_found "dig"
		return 1
	fi

	if ! command -v whois > /dev/null; then
		ove_echo_command_not_found "whois"
		return 1
	fi

	ip=${1}

	if [[ ${ip} == 127* ]]; then
		ip_lookup="localhost"
	else
		ip_lookup=$(\dig +short -x ${ip} | \
			\tr '\n' ' ' | \
			\xargs)

		if [ "${ip_lookup}" == "" ]; then
			ip_lookup="NA"
		else
			ip_lookup=${ip_lookup::-1}
		fi
	fi

	echo ${ip_lookup}
}

# $1: IPv4 address
function ove_ip2org {
	local ip
	local org

	if ! command -v whois > /dev/null; then
		ove_echo_command_not_found "whois"
		return 1
	fi

	ip=${1}

	if [[ ${ip} == 127* ]]; then
		org="NA"
	else
		org=$(\timeout 3 whois ${ip} 2> /dev/null | \
			\grep -E -i 'netrange:|netname|parent')
		[ "${org}" == "" ] && return
	fi

	printf "${org}"
}

# $1: port
function ove_port2service {
	local port
	local port_service

	port=${1}

	if [ -e /etc/services ]; then
		port_service=$(\grep -m1 -w ${port} /etc/services | \
			\awk '{print $1}')
	fi

	[ "${port_service}" == "" ] && port_service="NA"
	echo "${port_service}"
}

# $1: pid
function ove_strace_connect_one_pid {
	local cmd
	local ip
	local ip_lookup
	local line
	local port
	local port_service
	local ret
	local sa_family
	local str
	local sun_path
	local syscall

	cmd=
	pid=$1
	while read -r line; do
		[ "${line}" == "" ] && continue
		syscall=${line#* }
		syscall=${syscall%%(*}

		if [ "${syscall}" == "bind" ] ||
			[ "${syscall}" == "connect" ]; then
			sa_family=${line##*sa_family=}
			sa_family=${sa_family%%,*}
			t0=${line%% *}

			ret=${line##* =}
			ret=${ret% <*}
			if [[ "${ret}" == " -1"* ]] && ! [[ "${ret}" != "EINPROGRESS"* ]]; then
				continue
			fi

			if [ "${sa_family}" == "AF_LOCAL" ] || \
				[ "${sa_family}" = "AF_UNIX" ]; then
				sun_path=${line#*\"}
				sun_path=${sun_path%\"*}

				# abstract sockets
				[[ "${line}" == *"=@"* ]] && sun_path="@${sun_path}"

				cmd=$(ove_strace_get_execve ${pid})

				str+="${t0}:${syscall}:${sa_family}:${sun_path}:${cmd}\n"
			elif [ "${sa_family}" == "AF_INET" ]; then
				ip=$(ove_line2ipv4 ${line})
				port=$(\cut -d'(' -f3- <<<"${line}" | \
					\cut -d')' -f1)

				ip_lookup=${ove_ip2host_db["${ip}"]}
				port_service=${ove_port2service_db["${port}"]}
				cmd=$(ove_strace_get_execve ${pid})

				str+="${t0}:${syscall}:${sa_family}:${ip}:${ip_lookup}:${port}:${port_service}:${cmd}\n"
			fi
		fi
	done <<< "${all_files[${pid}]}"

	[ "${str}" != "" ] && printf "${str}"
}

function ove_read_connect_cache {
	local line

	declare -A -g ove_ip2host_db
	declare -A -g ove_ip2org_db
	declare -A -g ove_port2service_db

	if [ -e ${OVE_GLOBAL_STATE_DIR}/ip2host.cache ]; then
		for line in $(\cat ${OVE_GLOBAL_STATE_DIR}/ip2host.cache); do
			ove_ip2host_db["${line%%:*}"]="${line##*:}"
		done
	fi

	if [ -e ${OVE_GLOBAL_STATE_DIR}/port2service.cache ]; then
		for line in $(\cat ${OVE_GLOBAL_STATE_DIR}/port2service.cache); do
			ove_port2service_db["${line%%:*}"]="${line##*:}"
		done
	fi

	if [ -e ${OVE_GLOBAL_STATE_DIR}/ip2org.cache ]; then
		while read -r line; do
			ove_ip2org_db["${line%%:*}"]="$(\tr '@' '\n' <<<${line#*:})"
		done < <(\cat ${OVE_GLOBAL_STATE_DIR}/ip2org.cache)
	fi
}

# $1: directory with strace pid files
function ove_update_connect_db {
	local host
	local ip
	local line
	local org
	local port
	local service

	ove_read_connect_cache

	if command -v ag > /dev/null; then
		\ag --nobreak --nofilename -o --nonumbers 'AF_INET,.* =' $1 | \
			LC_ALL="C" \sort -u > ${OVE_PROJECT_TMP_DIR}/af_inet
	else
		\grep -E -R -o -h 'AF_INET,.* =' $1 | \
			LC_ALL="C" \sort -u > ${OVE_PROJECT_TMP_DIR}/af_inet
	fi

	if ! [ -s "${OVE_PROJECT_TMP_DIR}/af_inet" ]; then
		\rm ${OVE_PROJECT_TMP_DIR}/af_inet
		return
	fi

	while read -r line; do
		ip=$(ove_line2ipv4 ${line})
		[ "${ip}" == "" ] && continue
		port=$(\cut -d'(' -f2- <<<${line} | \
			\cut -d')' -f1)
		[ "${port}" == "" ] && continue

		if ! test "${ove_ip2host_db["${ip}"]+isset}"; then
			host="$(ove_ip2host ${ip})"
			ove_ip2host_db["${ip}"]="${host}"
			echo "${ip}:${host}" >> ${OVE_GLOBAL_STATE_DIR}/ip2host.cache
		fi

		if ! test "${ove_ip2org_db["${ip}"]+isset}"; then
			org="$(ove_ip2org ${ip} | \tr '\n' '@')"
			ove_ip2org_db["${ip}"]="$(echo ${org} | \tr '@' '\n')"
			echo "${ip}:${org}" >> ${OVE_GLOBAL_STATE_DIR}/ip2org.cache
		fi

		if ! test "${ove_port2service_db["${port}"]+isset}"; then
			service="$(ove_port2service ${port})"
			ove_port2service_db["${port}"]=${service}
			echo "${port}:${service}" >> ${OVE_GLOBAL_STATE_DIR}/port2service.cache
		fi
	done <${OVE_PROJECT_TMP_DIR}/af_inet

	\rm ${OVE_PROJECT_TMP_DIR}/af_inet

	for line in ${OVE_GLOBAL_STATE_DIR}/{ip2host,ip2org,port2service}.cache; do
		LC_ALL="C" \sort -V -o ${line} ${line} &
	done
	wait
}

# $1: directory with strace pid files
function ove_analyze_strace_connect {
	local all_files
	local f
	local pid

	! [ -d "$1" ] && return 1

	declare -A all_files
	ove_update_connect_db $1
	while true; do
		for f in $(\find $1 -type f); do
			pid=${f##*.}
			all_files[${pid}]="$(<${f})"
			ove_strace_connect_one_pid ${pid} &
		done
		wait
		break
	done | LC_ALL="C" \sort -n
}

# $1: pid
function ove_strace_get_exit_code {
	local exit_code
	local strace_file

	strace_file=${all_files[$1]}
	exit_code=${strace_file##*$'\n'}
	if [[ "${exit_code}" == *"killed by"* ]]; then
		exit_code=${exit_code##* killed by }
		exit_code=${exit_code%% +++}
	elif [[ "${exit_code}" == *"exited with"* ]]; then
		exit_code=${exit_code##* exited with }
		exit_code=${exit_code%% +++}
	else
		exit_code="alive"
	fi

	echo ${exit_code}
}

# $1: pid
function ove_strace_get_duration_s {
	local diff
	local strace_file
	local t0
	local t1

	strace_file=${all_files[$1]}
	t0=${strace_file%% *}
	t1=${strace_file##*$'\n'}
	t1=${t1%% *}

	[ "${t0}" == "${t1}" ] && echo "0.000000" && return

	diff=$(\awk "BEGIN{printf \"%.6f\n\", (${t1} - ${t0})}")
	echo ${diff}
}

# $1: pid
function ove_strace_get_duration_ms {
	local diff
	local strace_file
	local t0
	local t1

	strace_file=${all_files[$1]}
	t0=${strace_file%% *}
	t1=${strace_file##*$'\n'}
	t1=${t1%% *}

	[ "${t0}" == "${t1}" ] && echo "0" && return

	diff=$(\awk "BEGIN{printf \"%.0f\n\", (${t1} - ${t0}) * 1000}")
	echo ${diff}
}

# $1: pid
function ove_strace_get_t0 {
	local strace_file
	local t0

	strace_file=${all_files[$1]}
	t0=${strace_file%% *}
	echo ${t0}
}

# $1: pid
function ove_strace_get_execve {
	local cmd
	local line
	local syscall

	while read -r line; do
		[ "${line}" == "" ] && continue
		syscall=${line#* }
		syscall=${syscall%%(*}

		[ "${syscall}" != "execve" ] && continue
		[[ "${line}" == *"ENOENT"* ]] && continue
		cmd=${line##* [\"}
		cmd=${cmd%%\"]*}
		cmd=${cmd//\", \"/ }
	done <<< "${all_files[$1]}"

	[ "${cmd}" == "" ] && cmd="NA"
	echo -e "${cmd}"
}

# $1: pid
function ove_strace_one_pid {
	local cmd
	local duration_ms
	local duration_s
	local ip
	local ip_lookup
	local ip_org
	local key
	local line
	local out_1
	local out_2
	local p
	local pid
	local port
	local port_service
	local ret
	local sa_family
	local suffix
	local sun_path
	local t

	pid=$1

	duration_ms=$(ove_strace_get_duration_ms ${pid})
	duration_s=$(ove_strace_get_duration_s ${pid})
	t=$(ove_strace_get_t0 ${pid})

	# label START
	out_1="    ${pid} [label=\"p: ${pid}\l\nt: ${t}\l\nd: ${duration_ms} ms (${duration_s} s)\l\n"

	# exit code
	exit_code=$(ove_strace_get_exit_code ${pid})
	if [[ "${exit_code}" =~ ^[0-9]+$ ]]; then
		if [ ${exit_code} -ne 0 ]; then
			out_1+="e: ${exit_code}\l\n"
			border_color='"red"'
		else
			border_color='"green"'
		fi
	elif [ "${exit_code}" == "alive" ]; then
		border_color='"blue"'
	else
		out_1+="e: ${exit_code}\l\n"
		border_color='"black"'
	fi

	cmd=
	out_2=
	declare -A ip_port_cnt
	while read -r line; do
		[ "${line}" == "" ] && continue
		syscall=${line#* }
		syscall=${syscall%%(*}
		! [[ "${syscall}" =~ ^[a-z]+$ ]] && continue

		echo "${t}:${syscall}:${pid}:${duration_ms}:${duration_s}" >> ${OVE_PROJECT_TMP_DIR}/timing
		if [ "${syscall}" == "clone" ] ||
			[ "${syscall}" == "fork" ] ||
			[ "${syscall}" == "vfork" ]; then
			p=${line##* = }
			p=${p%% *}
			! [[ "${p}" =~ ^[0-9]+$ ]] && continue
			out_2+="    ${pid} -> ${p} [label=${syscall}];"
			continue
		elif [ "${syscall}" == "execve" ]; then
			[[ "${line}" == *"ENOENT"* ]] && continue
			cmd=${line##* [\"}
			cmd=${cmd%%\"]*}
			cmd=${cmd//\", \"/ }
			continue
		elif [ "${syscall}" == "bind" ] ||
			[ "${syscall}" == "connect" ]; then
			sa_family=${line##*sa_family=}
			sa_family=${sa_family%%,*}

			ret=${line##* =}
			ret=${ret% <*}
			if [[ "${ret}" == " -1"* ]] && ! [[ "${ret}" != "EINPROGRESS"* ]]; then
				continue
			fi

			if [ "${sa_family}" == "AF_LOCAL" ] || \
				[ "${sa_family}" = "AF_UNIX" ]; then
				sun_path=${line#*\"}
				sun_path=${sun_path%\"*}

				# abstract sockets
				[[ "${line}" == *"=@"* ]] && sun_path="@${sun_path}"

				out_2+="    \"${sun_path}\" [label=\"${sun_path}\l\n\" shape=box3d,fontsize=20,style=filled,fillcolor=\"cyan\"];"
				out_2+="    ${pid} -> \"${sun_path}\" [label=\"${syscall}\"];"
			elif [ "${sa_family}" == "AF_INET" ]; then
				ip=$(ove_line2ipv4 ${line})
				[ "${ip}" == "" ] && continue
				port=$(\cut -d'(' -f3- <<<${line} | \
					\cut -d')' -f1)
				[ "${port}" == "" ] && continue

				if test "${ip_port_cnt["${ip}:${port}"]+isset}"; then
					ip_port_cnt["${ip}:${port}"]=$((${ip_port_cnt["${ip}:${port}"]} + 1))
				else
					ip_port_cnt["${ip}:${port}"]=1
				fi

				ip_lookup=${ove_ip2host_db["${ip}"]}
				ip_org=${ove_ip2org_db["${ip}"]}
				port_service=${ove_port2service_db["${port}"]}

				org=$(\sed -e 's/$/ \\l\\n/g' <<<"${ip_org}" | \tr '\n' ' ' | \tr \" \')

				out_2+="    \"${ip}\" [label=\"t: ${t}\l\nIP: ${ip}\l\n${ip_lookup}\l\n${org}\l\n\" shape=box3d,fontsize=20,style=filled, fillcolor=\"yellow\"];"
				out_2+="    ${pid} -> \"${ip}\" [label=\"${syscall} ${port} ${port_service["${port}"]}\"];"
			else
				continue
			fi
		fi
	done <<< "${all_files[$1]}"

	for key in "${!ip_port_cnt[@]}"; do
		ip=${key%%:*}
		port=${key##*:}
		ip_lookup="${ove_ip2host_db["${ip}"]}"
		port_service=${ove_port2service_db["${port}"]}
		if [ ${ip_port_cnt[${ip}:${port}]} -gt 1 ]; then
			suffix="(repeated ${ip_port_cnt[${ip}:${port}]} time(s))"
		fi
		out_1+="c: ${ip}|${ip_lookup}|${port}|${port_service} ${suffix}\l\n"
	done

	# penwidth based on duration
	penwidth=${duration_ms}
	if [ ${duration_ms} -gt 20 ]; then
		penwidth=20
	elif [ ${duration_ms} -eq 0 ]; then
		penwidth=1
	fi

	[ "${cmd}" != "" ] && \
		out_1+="x: $(echo -e ${cmd} | \fold -w 80 -s | \sed -e 's/$/ \\l\\n/g' | \tr '\n' ' ' | \tr \" \')"

	# label END
	out_1+="\",color=${border_color},penwidth=${penwidth},fontsize=14,fontcolor=black];"

	echo "${out_1}"
	[ "${out_2}" != "" ] && echo "${out_2}"
}

# strace-graph:DIR:run strace graph analysis on DIR
function ove-strace-graph {
	if [ $# -ne 1 ]; then
		ove-help "^${FUNCNAME/ove-/} "
		return 1
	fi

	ove_strace_create_graph $1 ${1##*/}
}

# strace-execve-timeline:DIR:run strace execve timeline analysis on DIR
function ove-strace-execve-timeline {
	if [ $# -ne 1 ]; then
		ove-help "^${FUNCNAME/ove-/} "
		return 1
	fi

	OVE_LOGLEVEL=3 ove_analyze_strace_execve_timing $1

}

# strace-execve-time:DIR:run strace execve time analysis on DIR
function ove-strace-execve-time {
	if [ $# -ne 1 ]; then
		ove-help "^${FUNCNAME/ove-/} "
		return 1
	fi

	OVE_LOGLEVEL=4 ove_analyze_strace_execve_timing $1
}

# strace-connect:DIR:run strace connect time analysis on DIR
function ove-strace-connect {
	if [ $# -ne 1 ]; then
		ove-help "^${FUNCNAME/ove-/} "
		return 1
	fi

	ove_analyze_strace_connect $1
}

# $1: directory with strace pid files
# $2: append string to output files
function ove_strace_create_graph {
	local all_files
	local f
	local o_base
	local o_dot
	local o_svg
	local o_timing
	local pid

	! [ -d "$1" ] && return 1
	[ $# -ne 2 ] && return 2

	o_base="${OVE_PROJECT_TMP_DIR}/strace-${2}"
	o_dot=${o_base}.dot
	o_svg=${o_base}.svg
	o_timing=${o_base}.timing

	echo "strict digraph $(\tr '-' '_' <<<${OVE_PROJECT_NAME} | \tr -d '.') {" > ${o_dot}
	echo "    nodesep=2" >> ${o_dot}
	echo "    ranksep=5" >> ${o_dot}
	echo "    node [margin=1,shape=octagon,nodesep=10];" >> ${o_dot}

	# remove leftovers
	\find ${OVE_PROJECT_TMP_DIR} -name "strace-${2}.dot.*" -print0 | \xargs -0 rm &> /dev/null

	declare -A all_files
	true > ${OVE_PROJECT_TMP_DIR}/timing
	ove_update_connect_db $1
	for f in $(\find $1 -type f); do
		pid=${f##*.}
		all_files[${pid}]="$(<${f})"
		ove_strace_one_pid ${pid} >> ${o_dot}.${pid} &
	done
	wait

	# merge all files into one
	\find ${OVE_PROJECT_TMP_DIR} -name "strace-${2}.dot.*" -print0 | \xargs -0 cat >> ${o_dot}
	\find ${OVE_PROJECT_TMP_DIR} -name "strace-${2}.dot.*" -print0 | \xargs -0 rm

	echo "}" >> ${o_dot}

	LC_ALL="C" \sort -u ${OVE_PROJECT_TMP_DIR}/timing > ${o_timing}
	\rm ${OVE_PROJECT_TMP_DIR}/timing

	\du -sh ${o_dot}
	if command -v dot > /dev/null; then
		if ! \dot -Tsvg ${o_dot} > ${o_svg}; then
			return 1
		fi
		\du -sh ${o_svg}
	fi
}

# $1: timeout in seconds
# $2: files to watch. Passed on to inotifywait --fromfile
function ove_inotifywait {
	local ret

	! [ -e ${2} ] && return 1
	[ $(\wc -l < ${2}) -eq 0 ] && return 1

	sleep 0.01
	\inotifywait \
		-t ${1} \
		-qq \
		--event modify \
		--event delete_self \
		--event create \
		--event delete \
		--fromfile ${2}
	ret=$?

	sleep 0.01
	[ ${ret} -eq 1 ] && return 1 || return 0
}

function ove_inotify_cleanup {
	\find ${OVE_PROJECT_TMP_DIR}/ -name "inotifywait-*-${1}*" -exec rm {} \;
}

# $1  : timeout in sec
# $2  : use inotifywait (0 or 1)
# $3  : max count
# $4..: command
function ove_loop_command {
	local all_files
	local cmd
	local f
	local f_stderr
	local files_modified_by_command
	local i
	local max_count
	local prefix
	local read_args
	local inotifywait_pid
	local _timeout
	local use_inotify

	[ $# -lt 4 ] && return 1

	_timeout=$1
	use_inotify=$2
	max_count=$3
	shift 3
	(( i=0 ))
	while true; do
		(( i+=1 ))
		[ ${max_count} -ne 0 ] && [ ${i} -gt ${max_count} ] && break
		clear
		ove_echo_cyan_error "ove-${*} [c:${i} t:${_timeout} i:${use_inotify} m:${max_count}]"

		# inotify: first iteration?
		if [ ${use_inotify} -eq 1 ] && [ ${i} -eq 1 ]; then
			all_files=$(\mktemp -u -p ${OVE_PROJECT_TMP_DIR} inotifywait-fromfile-XXXXXXXXXX)

			# trap to be able to cleanup files
			# shellcheck disable=SC2064
			trap "ove_inotify_cleanup ${all_files: -10}" EXIT

			# start inotifywait in monitor mode in the background
			# monitor all files (for now)
			# shellcheck disable=SC2016
			cmd='for f in $(\git -C ${repo} ls-files); do [ -f ${f} ] && echo ${PWD}/${f}; done; echo ${PWD}/.git'
			ove_revtab_forall_parallel "${cmd}" > ${all_files}

			# extra files/directories to monitor?
			if [ -n "${OVE_LOOP_INOTIFY_EXTRA+x}" ]; then
				\find ${OVE_LOOP_INOTIFY_EXTRA//:/ } -type f >> ${all_files}
			fi

			files_modified_by_command=${OVE_PROJECT_TMP_DIR}/inotifywait-${1}-${all_files: -10}
			f_stderr=${OVE_PROJECT_TMP_DIR}/inotifywait-${1}-${all_files: -10}-stderr
			true > ${f_stderr}
			if [ $(\cat /proc/sys/fs/inotify/max_user_watches) -lt $(\wc -l < ${all_files}) ]; then
				ove_echo_error_noprefix "you need to increase the number of inotify user watches. Try:"
				echo
				[ ${EUID} != 0 ] && prefix="sudo"
				echo "$ ${prefix} bash -c 'echo $(\wc -l < ${all_files}) > /proc/sys/fs/inotify/max_user_watches'"
				[ -n "${TMUX}" ] && read -r -p ""
				return 1
			fi

			\inotifywait \
				-m \
				--format '%w%f' \
				--fromfile ${all_files} > ${files_modified_by_command} 2>> ${f_stderr} &
			inotifywait_pid=${!}

			# wait for inotifywait
			# shellcheck disable=SC2002
			\timeout 30 tail -f ${f_stderr} | \grep -E -q "Watches established.|Failed to watch" | { \cat; echo >> ${f_stderr}; }
			if [ ${PIPESTATUS[0]} -eq 124 ]; then
				[ -s "${f_stderr}" ] && \cat ${f_stderr}
				ove_echo_error_noprefix "inotifywait did not established watches within 30 sec"
				[ -n "${TMUX}" ] && read -r -p ""
				return 1
			fi

			if \grep -q "Failed to watch" ${f_stderr}; then
				[ -s "${f_stderr}" ] && \cat ${f_stderr}
				ove_echo_error_noprefix "inotifywait did not established watches"
				[ -n "${TMUX}" ] && read -r -p ""
				return 1
			fi

			# still running?
			if ! kill -0 ${inotifywait_pid} > /dev/null 2>&1; then
				return 1
			fi
		fi

		# run the command
		OVE_PAGER='\tee /dev/null' ove-${1} ${*:2}

		# inotify: first iteration?
		if [ ${use_inotify} -eq 1 ] && [ ${i} -eq 1 ]; then
			sleep 1
			kill -9 ${inotifywait_pid} &> /dev/null
			wait &> /dev/null
			\rm ${all_files}

			# remove doublets and only regular files
			for f in $(LC_ALL="C" \sort -u ${files_modified_by_command}); do
				[ -f ${f} ] && echo ${f};
			done > ${files_modified_by_command}.uniq
			\rm ${files_modified_by_command}
			if [ $(\wc -l < ${files_modified_by_command}.uniq) -eq 0 ]; then
				use_inotify=0
				ove_echo_cyan_error "0 files touched, not using inotifywait"
			else
				echo
				echo "$(\wc -l < ${files_modified_by_command}.uniq) file(s) was touched by '${1} ${*:2}'"
				echo "$ ove head-tail ${files_modified_by_command}.uniq"
				ove-head-tail ${files_modified_by_command}.uniq
			fi
		fi

		echo -
		if [ ${use_inotify} -eq 1 ]; then
			if ! ove_inotifywait ${_timeout} ${files_modified_by_command}.uniq; then
				break
			fi
		else
			[ "${_timeout}" -gt 0 ] && read_args="-t ${_timeout}"
			# shellcheck disable=SC2229
			read -n 1 -s -r -p '' ${read_args}
			[[ ${REPLY} =~ ^[Qq]$ ]] && break
		fi
	done
}

# run:|TIMEOUT COMMAND:run one OVE command in terminal|tmux
function ove-run {
	local _cmd
	local cmd
	local read_args
	local _timeout

	if [ $# -eq 1 ]; then
		ove-help "^${FUNCNAME/ove-/} "
		return 1
	fi

	if [ $# -eq 0 ]; then
		read -r -p "command timeout in sec (default 0 = no timeout): "
		[ "${REPLY}" == "" ] && _timeout=0 || _timeout=${REPLY}
		read -r -p "command: "
		[ "${REPLY}" == "" ] && return || cmd=${REPLY}
	else
		_timeout=$1
		shift
		cmd=$*
	fi

	if ! [[ "${_timeout}" =~ ^[0-9]+$ ]]; then
		echo "error: timeout: just numbers"
		return 1
	fi

	cmd=${cmd#ove }
	cmd=${cmd#ove-}
	_cmd=$(\cut -d' ' -f1 <<<${cmd})
	if [ "$(type -t ove-"${_cmd}")" != "function" ]; then
		ove_echo_red_noprefix "error: '${_cmd}' unknown command"
		return 1
	fi

	# turn off monitor mode to get rid of "Done" messages
	set +m
	[ "${_timeout}" -gt 0 ] && read_args="-t ${_timeout}"

	if [ -n "${TMUX}" ]; then
		tmux split-window -h "\
			source ${OVE_BASE_DIR}/ove; \
			ove_init; \
			ove_echo_cyan_error \"ove-${cmd}\"; \
			OVE_PAGER='\tee /dev/null' ove-${cmd}; \
			echo -; \
			read -n 1 -s -r -p '' ${read_args}"

		tmux select-layout main-vertical
		tmux select-pane -t 0
	else
		ove_echo_cyan_error "ove-${cmd}"
		OVE_PAGER='\tee /dev/null' ove-${cmd}
		echo -
		# shellcheck disable=SC2229
		read -n 1 -s -r -p '' ${read_args}
	fi

	# turn on monitor mode
	set -m
}

# loop:|[TIMEOUT|x] [INOTIFY|x] [MAX-COUNT|x] COMMAND]:loop one OVE command
function ove-loop {
	local _cmd
	local cmd
	local max_count
	local _timeout
	local use_inotify

	if [ $# -gt 0 ] && [ $# -lt 4 ]; then
		ove-help "^${FUNCNAME/ove-/} "
		return 1
	fi

	if [ $# -eq 0 ]; then
		read -r -p "command timeout in sec (default 0 = no timeout): "
		[ "${REPLY}" == "" ] && _timeout=0 || _timeout=${REPLY}
		read -r -p "inotify 0=no 1=yes (default 0): "
		[ "${REPLY}" == "" ] && use_inotify=0 || use_inotify=${REPLY}
		read -r -p "max count: (default 0 = forever): "
		[ "${REPLY}" == "" ] && max_count=0 || max_count=${REPLY}
		read -r -p "command: "
		[ "${REPLY}" == "" ] && return || cmd=${REPLY}
	else
		if [ "${1,}" == "x" ]; then
			read -r -p "command timeout in sec (0=no timeout): "
			[ "${REPLY}" == "" ] && _timeout=0 || _timeout=${REPLY}
		else
			_timeout=$1
		fi

		if [ "${2,}" == "x" ]; then
			read -r -p "inotify 0=no 1=yes (default 0): "
			[ "${REPLY}" == "" ] && use_inotify=0 || use_inotify=${REPLY}
		else
			use_inotify=$2
		fi

		if [ "${3,}" == "x" ]; then
			read -r -p "max count: (default 0 = forever): "
			[ "${REPLY}" == "" ] && max_count=0 || max_count=${REPLY}
		else
			max_count=$3
		fi

		shift 3
		cmd=$*
	fi

	if ! [[ "${_timeout}" =~ ^[0-9]+$ ]]; then
		echo "error: timeout: just numbers"
		return 1
	fi

	if ! [[ "${use_inotify}" =~ ^[0-1]$ ]]; then
		echo "error: inotify: 0 or 1"
		return 1
	fi

	if [ "${use_inotify}" -eq 1 ] && ! command -v inotifywait > /dev/null; then
		ove_echo_command_not_found "inotifywait"
		return 1
	fi

	if ! [[ "${max_count}" =~ ^[0-9]+$ ]]; then
		echo "error: max count: just numbers"
		return 1
	fi

	cmd=${cmd#ove }
	cmd=${cmd#ove-}
	_cmd=$(\cut -d' ' -f1 <<<${cmd})
	if [ "$(type -t ove-"${_cmd}")" != "function" ]; then
		ove_echo_red_noprefix "error: '${_cmd}' unknown command"
		return 1
	fi

	if [ -n "${TMUX}" ]; then
		tmux split-window -h "\
			source ${OVE_BASE_DIR}/ove; \
			ove_init; \
			ove_loop_command ${_timeout} ${use_inotify} ${max_count} ${cmd}"

		tmux select-layout main-vertical
		tmux select-pane -t 0
	else
		ove_loop_command ${_timeout} ${use_inotify} ${max_count} ${cmd}
	fi
}

# fix broken vars
function ove_sanitise_vars {
	local corrupt

	# corrupt OVE_LOGLEVEL?
	if [ -n "${OVE_LOGLEVEL}" ]; then
		corrupt=0
		if ! [ "${OVE_LOGLEVEL}" -eq "${OVE_LOGLEVEL}" ] 2> /dev/null; then
			corrupt=1
		elif ! [[ "${OVE_LOGLEVEL}" =~ ^[0-8]$ ]]; then
			corrupt=1
		fi

		[ ${corrupt} -eq 1 ] && ove-loglevel 1 > /dev/null
	fi

	return 0
}

function ove {
	local args
	local bcc_tool
	local candidates
	local cmd
	local re
	local ret
	local strace_expression

	cmd="$1"

	# keep this as early as possible
	if [ "${cmd}" == "cd" ] || [ "${cmd}" == "init" ]; then
		ove-${cmd} "${@:2}"
		return $?
	fi

	# sanity check
	if ! ove_get_base_dir > /dev/null; then
		return 1
	fi

	ove_sanitise_vars

	if ! ove_verify_checksums && ! ove_reinit; then
		return 1
	fi

	if [ $# -eq 0 ]; then
		ove-fzf || ove-help
	elif [ "$(type -t ove-"${cmd}")" != "function" ]; then
		re=\\b${cmd}
		if ! [[ "${OVE_ALL_COMMANDS}" =~ ${re} ]]; then
			ove_echo_red_noprefix "error: '${cmd}' unknown command"
			return 1
		fi

		candidates=$(ove-help $(\xargs -n1 <<<${OVE_ALL_COMMANDS} | \
			\grep --color=never ^${cmd} | \
			\sed -e 's/^/^/g' -e 's/$/\\s/g'))

		if [ ${OVE_AUTOCORRECT} -eq 1 ] && [ $(printf "${candidates}\n" | \wc -l) -eq 1 ]; then
			cmd=$(printf "${candidates}\n" | \
				\sed -e "s/\x1B\[[0-9;]*[mK]//g" | \
				\awk '{print $1}')
			ove ${cmd} ${*:2}
			return $?
		fi

		ove_echo_red_noprefix "error: '${cmd}' unknown command"
		echo
		echo "Did you mean?"
		printf "${candidates}\n"

		return 1
	elif [ "${cmd}" == "!" ] || \
		[ "${cmd}" == "add-config" ] || \
		[ "${cmd}" == "dry-run" ] || \
		[ "${cmd}" == "config" ] || \
		[ "${cmd}" == "loglevel" ] || \
		[ "${cmd}" == "revtab-check" ] || \
		[ "${cmd}" == "checkout" ] || \
		[ "${cmd}" == "unsource" ]; then
		ove-${cmd} "${@:2}"
	else
		args="${*:2}"
		\mkdir -p ${OVE_LOG_DIR}/${OVE_SHA}
		(cd ${OVE_LOG_DIR} && \ln -sfn ${OVE_SHA} current)
		OVE_LAST_COMMAND="${OVE_LOG_DIR}/${OVE_SHA}/$(\date '+%Y%m%d-%H%M%S%N')-ove-${cmd}-${HOSTNAME}-${OVE_PROJECT_NAME}.log"

		if [ -t 1 ]; then
			if [ ${OVE_LOGLEVEL} -gt 2 ] && [ ${OVE_LOGLEVEL} -lt 9 ]; then
				[ -e ${OVE_PROJECT_TMP_DIR}/trace-${cmd} ] && \
					\rm -rf ${OVE_PROJECT_TMP_DIR}/trace-${cmd}
				\mkdir -p ${OVE_PROJECT_TMP_DIR}/trace-${cmd}

				if [ ${OVE_LOGLEVEL} -eq 5 ]; then
					strace_expression="connect,bind,execve"
				elif [ ${OVE_LOGLEVEL} -eq 6 ]; then
					strace_expression="execve,clone,fork,vfork,connect,bind"
				else
					strace_expression="execve"
				fi

				if [ ${OVE_LOGLEVEL} -eq 7 ] || [ ${OVE_LOGLEVEL} -eq 8 ]; then
					if [ ${OVE_LOGLEVEL} -eq 7 ]; then
						bcc_tool="execsnoop"
					else
						bcc_tool="tcpconnect"
					fi

					if [ ${EUID} != 0 ]; then
						if ! sudo -n true; then
							if ! sudo true; then
								ove_echo_error_noprefix "'${bcc_tool}' need non-interactive 'sudo'"
								return 1
							fi
						fi
						OVE_TRACE_CMD="sudo "
					fi
					OVE_TRACE_CMD+="python3 /usr/share/bcc/tools/${bcc_tool} "
					OVE_TRACE_CMD+="-t "
					OVE_TRACE_CMD+="-u ${EUID} "
					OVE_TRACE_CMD+="> ${OVE_PROJECT_TMP_DIR}/trace-${cmd}/trace-${cmd} "
					OVE_TRACE_CMD+="2> /dev/null"
				else
					OVE_TRACE_CMD="strace "
					OVE_TRACE_CMD+="-s 1024 "
					OVE_TRACE_CMD+="-q "
					OVE_TRACE_CMD+="-o ${OVE_PROJECT_TMP_DIR}/trace-${cmd}/trace-${cmd} "
					OVE_TRACE_CMD+="-ff "
					OVE_TRACE_CMD+="-T "
					OVE_TRACE_CMD+="-e ${strace_expression} "
					OVE_TRACE_CMD+="-ttt "
				fi
				export OVE_TRACE_CMD
			else
				unset OVE_TRACE_CMD
			fi

			if [ -n "${OVE_TRACE_CMD+x}" ]; then
				[ -e ${OVE_PROJECT_TMP_DIR}/trace.pid ] && \
					\rm ${OVE_PROJECT_TMP_DIR}/trace.pid
				[ -e ${OVE_PROJECT_TMP_DIR}/trace.cont ] && \
					\rm ${OVE_PROJECT_TMP_DIR}/trace.cont

				{
					while true; do [ -e ${OVE_PROJECT_TMP_DIR}/trace.pid ] && break; done

					# launch trace in background and let it start up
					if [ ${OVE_LOGLEVEL} -eq 7 ] || [ ${OVE_LOGLEVEL} -eq 8 ]; then
						(eval ${OVE_TRACE_CMD} &)
						sleep 2
					else
						(${OVE_TRACE_CMD} -p $(\cat ${OVE_PROJECT_TMP_DIR}/trace.pid) &)
						sleep 1
					fi
					true > ${OVE_PROJECT_TMP_DIR}/trace.cont
				} &
			fi

			# turn off monitor mode to get rid of "Done" messages
			set +m
			SHELL=$(command -v bash) \
				\script ${OVE_SCRIPT_OPTIONS} -c \
				"source ${OVE_BASE_DIR}/ove; ove_init quick && ove-${cmd} ${args}" \
				${OVE_LAST_COMMAND}
			ret=$?

			if [ -n "${OVE_TRACE_CMD+x}" ]; then
				if [ ${OVE_LOGLEVEL} -eq 7 ] || [ ${OVE_LOGLEVEL} -eq 8 ]; then
					if [ ${EUID} != 0 ]; then
						sudo pkill -SIGINT -f ${bcc_tool}
					else
						\pkill -SIGINT -f ${bcc_tool}
					fi
				else
					\pkill -SIGINT -f strace
				fi

				[ -e ${OVE_PROJECT_TMP_DIR}/trace.pid ] && \
					\rm ${OVE_PROJECT_TMP_DIR}/trace.pid
				[ -e ${OVE_PROJECT_TMP_DIR}/trace.cont ] && \
					\rm ${OVE_PROJECT_TMP_DIR}/trace.cont

				while true; do
					if [ ${OVE_LOGLEVEL} -eq 3 ] || [ ${OVE_LOGLEVEL} -eq 4 ]; then
						ove_analyze_strace_execve_timing ${OVE_PROJECT_TMP_DIR}/trace-${cmd}
					elif [ ${OVE_LOGLEVEL} -eq 5 ]; then
						ove_analyze_strace_connect ${OVE_PROJECT_TMP_DIR}/trace-${cmd}
					elif [ ${OVE_LOGLEVEL} -eq 6 ]; then
						ove_strace_create_graph ${OVE_PROJECT_TMP_DIR}/trace-${cmd} ${cmd}
					elif [ ${OVE_LOGLEVEL} -eq 7 ] || [ ${OVE_LOGLEVEL} -eq 8 ]; then
						\head -n -1 ${OVE_PROJECT_TMP_DIR}/trace-${cmd}/trace-${cmd}
					fi
					break
				done | \tee -a ${OVE_LAST_COMMAND}

				unset OVE_TRACE_CMD
			fi

			\sed -i -e 's/\r$//' -e 's/\x0//' ${OVE_LAST_COMMAND}
			\ln -s -f ${OVE_LAST_COMMAND} ${OVE_LOG_DIR}/last

			return ${ret}
		else
			{
				ove-"${cmd}" ${args}
			} 2>&1 | \tee -i ${OVE_LAST_COMMAND}
			ret=${PIPESTATUS[0]}
			\sed -i 's/\x0//g' ${OVE_LAST_COMMAND}
			\ln -s -f ${OVE_LAST_COMMAND} ${OVE_LOG_DIR}/last
			return ${ret}
		fi
	fi
}

# fzf:[loop]:OVE fzf [duckduckgo.com/?q=fzf]
function ove-fzf {
	local args
	local cmd

	if ! command -v fzf > /dev/null; then
		return 1
	fi

	# sanity check
	if ! ove_get_base_dir > /dev/null; then
		return 1
	fi

	if [ $# -gt 1 ]; then
		ove-help "^${FUNCNAME/ove-/} "
		return 1
	fi

	while true; do
		# shellcheck disable=SC2016
		cmd=$(\xargs -n 1 <<<${OVE_ALL_COMMANDS} | \
			\grep -v '!' | \
			\fzf \
			--cycle \
			--preview '${OVE_INIT_STRING}; ove-help ^{1}\\s' \
			--preview-window=down:1 \
		)
		[ "${cmd}" == "" ] && break

		if \tr ' ' '\n' <<<"${OVE_BUILT_INS_WITHOUT_ARGS}" | \grep -q ^${cmd}$; then
			if [ "$1" == "loop" ]; then
				echo "$ ove-loop x x x ${cmd}"
				ove-loop x x x ${cmd}
				echo -
			else
				ove-run 0 ${cmd}
			fi
			continue
		fi

		COMP_WORDS=(ove ${cmd} ' ')
		COMP_LINE="ove ${cmd}"
		COMP_CWORD=3
		COMP_POINT=${#COMP_LINE}
		ove_bash_complete
		if [ ${#COMPREPLY[@]} -eq 0 ]; then
			if [ $1 == "loop" ]; then
				echo "$ ove-loop x x x ${cmd}"
				ove-loop x x x ${cmd}
				echo -
			else
				ove-run 0 ${cmd}
			fi
		else
			args=$(printf '%s\n' "${COMPREPLY[@]}" | \
				LC_ALL="C" \sort -u | \
				fzf \
					--cycle \
					--preview "echo ESC\|CTRL+C to skip args $ ove ${cmd} {}" \
					--preview-window=down:1)

			if [ "$1" == "loop" ]; then
				echo "$ ove-loop x x x ${cmd} ${args}"
				ove-loop x x x ${cmd} ${args}
				echo -
			else
				ove-run 0 ${cmd} ${args}
			fi
		fi
	done
}

function ove_projects_init {
	unset ove_projects_name
	unset ove_projects_deps
	unset ove_projects_path
	unset ove_projects_needs
	unset ove_projects_version
	unset ove_projects_name2index

	declare -a -g ove_projects_name
	declare -a -g ove_projects_deps
	declare -a -g ove_projects_path
	declare -a -g ove_projects_needs
	declare -a -g ove_projects_version
	declare -A -g ove_projects_name2index

	ove_number_of_projects=0
}

# not really a complete YAML parser
function ove_parse_yaml {
	local line

	while IFS=: read -r line; do
		[[ ${line} == "---" ]] && continue
		\sed -e 's/: /:/g' -e "s/\([a-z]\+\):/\" ove_${line%%:*}_\1=\"/g" -e "s/$/\"/g" -e "s/^\" //g" -e "s/ \"/\"/g" <<<${line#*: } &
	done < <(\sed -e 's/^\([a-z]\+:$\)/\n\1/g' -e 's/#.*//g' $1 | \awk NF=NF RS= OFS=' ')
	wait
}

# uniq list of project commands
function ove_project_commands_list {
	local f
	local proj
	local search_dirs

	# for each project, look for executable files
	# ignore files with hyphens and underscore
	for proj in ${OVE_PROJECT_LIST} common; do
		# ignore projects without a project directory
		[ ! -d ${OVE_PROJECT_DIR}/projects/${proj} ] && continue

		search_dirs+="${proj} "
	done

	[ "${search_dirs}" == "" ] && return

	for f in $(cd ${OVE_PROJECT_DIR}/projects && \find -L ${search_dirs} -perm -u=x -type f); do
		echo ${f#*/}
	done | \
		\grep -v '[-_]' | \
		LC_ALL="C" \sort -u | \
		\xargs
}

# uniq list of mandatory attributes
function ove_projects_attributes {
	if [ -f "${OVE_PROJECT_DIR}"/projs ]; then
		\grep -E -o '  \w+:' "${OVE_PROJECT_DIR}"/projs | \
			\cut -d: -f1 | \
			\tr -d ' ' | \
			LC_ALL="C" \sort -u
	fi
}

# $1: dir (optional)
function ove_list_tags_and_branches {
	local d

	[ $# -eq 0 ] && d=${OVE_PROJECT_DIR} || d=$1
	! [ -d ${d} ] && return

	(
	\git -C "${d}" tag
	\git -C "${d}" branch --no-color --all --list | \
		\grep -v HEAD | \
		\tr -d '*' | \
		\xargs | \
		\tr ' ' '\n'
	) | LC_ALL="C" \sort -V
}

# $1: dir (optional)
function ove_list_branches {
	local d

	[ $# -eq 0 ] && d=${OVE_PROJECT_DIR} || d=$1
	! [ -d ${d} ] && return

	(
	\git -C "${d}" branch --no-color --all --list | \
		\grep -v HEAD | \
		\tr -d '*' | \
		\xargs | \
		\tr ' ' '\n'
	) | LC_ALL="C" \sort -V
}

# iterate through projects
function ove_projects_parse {
	local i
	local m
	local projects
	local tmp_var

	ove_number_of_projects=0

	[ ! -e "${OVE_PROJECT_DIR}/projs" ] && return

	if ! eval $(ove_parse_yaml "${OVE_PROJECT_DIR}/projs") 2> /dev/null; then
		ove_echo_error_noprefix "possible format error(s) in '${OVE_PROJECT_DIR}/projs'"
		if command -v yamllint > /dev/null; then
			\yamllint "${OVE_PROJECT_DIR}/projs"
		fi
		return 1
	fi

	# create ove-functions for all project commands
	for m in ${OVE_PROJECT_COMMANDS}; do
		eval "ove-${m}() {
			local i
			local helptext=\"${m}:[PROJECT...]:run the '${m}' step for all or individual projects\"
			local p

			if ! ove_build_pre \$*; then
				return 1
			fi

			# common .pre
			if [ -e \${OVE_PROJECT_DIR}/projects/common/${m}.pre ]; then
				source \${OVE_PROJECT_DIR}/projects/common/${m}.pre
			fi

			if [ \$# -eq 0 ]; then
				i=0
				while ((i < ove_number_of_projects)); do
					if ! ove_projects_cmd "\${ove_projects_name[\${i}]}" ${m}; then
						return 1
					fi
					(( i+=1 ))
				done
			else
				for p in \$@; do
					if ! ove_projects_cmd \${p} ${m}; then
						return 1
					fi
				done
			fi

			# common .post
			if [ -e \${OVE_PROJECT_DIR}/projects/common/${m}.post ]; then
				source \${OVE_PROJECT_DIR}/projects/common/${m}.post
			fi
		}"
	done

	# create parallel ove-functions for all project commands
	for m in ${OVE_PROJECT_COMMANDS}; do
		eval "ove-${m}-parallel() {
			local i
			local helptext=\"${m}-parallel:[PROJECT...]:run the '${m}' step for all or individual projects (in parallel)\"
			local p

			if ! ove_build_pre \$*; then
				return 1
			fi

			# common .pre
			if [ -e \${OVE_PROJECT_DIR}/projects/common/${m}.pre ]; then
				source \${OVE_PROJECT_DIR}/projects/common/${m}.pre
			fi

			if [ \$# -eq 0 ]; then
				i=0
				while ((i < ove_number_of_projects)); do
					{
						if ! ove_projects_cmd "\${ove_projects_name[\${i}]}" ${m}; then
							kill -USR1 \$\$
						fi
					} &
					(( i+=1 ))
				done
			else
				for p in \$@; do
					{
						if ! ove_projects_cmd \${p} ${m}; then
							kill -USR1 \$\$
						fi
					} &
				done
			fi

			wait

			# common .post
			if [ -e \${OVE_PROJECT_DIR}/projects/common/${m}.post ]; then
				source \${OVE_PROJECT_DIR}/projects/common/${m}.post
			fi
		}"
	done

	read -a projects -r <<<"${OVE_PROJECT_LIST}"
	ove_number_of_projects=${#projects[@]}

	# set projects deps|name|path|needs|version
	i=0
	while ((i < ove_number_of_projects)); do
		# name
		ove_projects_name[${i}]=${projects[${i}]}
		unset ove_${projects[${i}]}

		# index
		ove_projects_name2index[${projects[${i}]}]=${i}

		# deps
		tmp_var="ove_${projects[${i}]}_deps"
		ove_projects_deps[${i}]=${!tmp_var}
		unset ${tmp_var}

		# path
		tmp_var="ove_${projects[${i}]}_path"
		ove_projects_path[${i}]=${!tmp_var}
		unset ${tmp_var}

		# needs
		tmp_var="ove_${projects[${i}]}_needs"
		ove_projects_needs[${i}]=${!tmp_var}
		unset ${tmp_var}

		# version
		tmp_var="ove_${projects[${i}]}_version"
		ove_projects_version[${i}]=${!tmp_var}
		unset ${tmp_var}

		(( i+=1 ))
	done

	if ! ove_validate_projs; then
		return 1
	fi

	if [ $(ove_repos_fetched) -eq $(\wc -w <<<${OVE_REPO_LIST}) ]; then
		unset OVE_PROJECT_LIST_BUILDABLE
	else
		ove_buildable_projects
	fi

	OVE_BUILD_ORDER="$(ove-build-order)"
}

function ove_list_projects_without_deps {
	local i

	i=0
	while ((i < ove_number_of_projects)); do
		if [ "${ove_projects_deps[${i}]}" == "" ]; then
			echo -n "${ove_projects_name[${i}]} "
		fi
		(( i+=1 ))
	done
}

function ove_list_projects_with_deps {
	local i

	i=0
	while ((i < ove_number_of_projects)); do
		if [ "${ove_projects_deps[${i}]}" != "" ]; then
			echo -n "${ove_projects_name[${i}]} "
		fi
		(( i+=1 ))
	done
}

function ove_list_projects_paths {
	local i
	local s

	i=0
	while ((i < ove_number_of_projects)); do
		s+="${OVE_BASE_DIR}/${ove_projects_path[${i}]} "
		(( i+=1 ))
	done

	echo -n "${s}"
}

# $1: target
# $2: command
function ove_projects_cmd {
	local cmd
	local i
	local path
	local re
	local ret
	local target

	target=$1
	cmd=$2
	ret=0

	# sanity check
	! [ -e "${OVE_PROJECT_DIR}/projects/${target}/${cmd}" ] && return

	i=${ove_projects_name2index[${target}]}

	# create dir if needed
	[ ! -d "${OVE_BASE_DIR}"/"${ove_projects_path[${i}]}" ] \
		&& \mkdir -vp "${OVE_BASE_DIR}"/"${ove_projects_path[${i}]}"

	path="${OVE_BASE_DIR}/${ove_projects_path[${i}]}"

	if [ ${OVE_LOGLEVEL} -ne 0 ]; then
		ove_echo_cyan_error "${target}: ${cmd}"
	fi

	if [ "${OVE_DRY_RUN}" -eq 0 ]; then
		pushd "${path}" &>/dev/null
	fi

	if [[ ${FUNCNAME[*]} == *-parallel ]] && [ -n "${OVE_FORCE_SERIALIZE_COMMANDS}" ]; then
		re=\\b${cmd}\\b
		if [[ "${OVE_FORCE_SERIALIZE_COMMANDS}" =~ ${re} ]]; then
			exec {fd}>${OVE_PROJECT_TMP_DIR}/${cmd}.lock
			flock ${fd}
		fi
	fi

	# common for this command?
	if [ -e "${OVE_PROJECT_DIR}/projects/common/${cmd}" ]; then
		# shellcheck disable=SC1090
		source "${OVE_PROJECT_DIR}/projects/common/${cmd}"
		# preserve return code
		ret="$?"
	fi

	if [ ${ret} -eq 0 ]; then
		# "$1"/$2 is no longer needed
		shift 2

		if [ ${OVE_DRY_RUN} -eq 0 ]; then
			# run it
			eval "${target}_version=${ove_projects_version[${i}]} \
				${OVE_PROJECT_DIR}/projects/${target}/${cmd} \
				${OVE_REDIRECT_OUTPUT}"
		else
			# dry: print the command
			ove_echo_stderr_noprefix "cd ${path} && ${OVE_PROJECT_DIR}/projects/${target}/${cmd}"
		fi

		# preserve return code
		ret="$?"
	fi

	# exit directory
	[ "${OVE_DRY_RUN}" -eq 0 ] && popd &>/dev/null

	if [ "${ret}" -ne 0 ]; then
		ove_echo_error "${target}: ${cmd}"
	else
		if [ ${OVE_LOGLEVEL} -ne 0 ]; then
			ove_echo_cyan_error "${target}: ${cmd}: done"
		fi
	fi

	return "${ret}"
}

function ove_revtab_init {
	unset ove_revtab_fetch_url
	unset ove_revtab_push_url
	unset ove_revtab_rev
	unset ove_revtab_git_name

	declare -a -g ove_revtab_fetch_url
	declare -a -g ove_revtab_push_url
	declare -a -g ove_revtab_rev
	declare -a -g ove_revtab_git_name
	declare -A -g ove_revtab_name2index

	ove_revtab_num_repositories=0
}

function ove_revtab_parse {
	local array
	local line
	local lineno=0

	[ ! -e "${OVE_PROJECT_DIR}/revtab" ] && return

	ove_revtab_num_repositories=0

	while read -r line; do
		(( lineno+=1 ))
		# skip comments and blank lines
		[ "${line:0:1}" == "#" ] && continue
		[ "${line}" == "" ] && continue

		read -a array -r <<<"${line}"

		if [ "${array[1]}" == "" ] || [ "${array[2]}" == "" ] || [ "${array[3]}" == "" ]; then
			ove_echo_warning_noprefix "${OVE_PROJECT_DIR}/revtab:${lineno} format error"
			continue
		fi

		ove_revtab_git_name[${ove_revtab_num_repositories}]=${array[0]}
		ove_revtab_fetch_url[${ove_revtab_num_repositories}]=${array[1]}
		ove_revtab_push_url[${ove_revtab_num_repositories}]=${array[2]}
		ove_revtab_rev[${ove_revtab_num_repositories}]=${array[3]}
		ove_revtab_name2index[${array[0]}]=${ove_revtab_num_repositories}

		(( ove_revtab_num_repositories+=1 ))
	done < "${OVE_PROJECT_DIR}/revtab"

	if ! ove_validate_revtab; then
		return 1
	fi

	OVE_REPO_LIST=$(ove_revtab_list_fullpath)
}

# $1: repo name (either 'name' or '${OVE_BASE_DIR}/'name')
function ove_repo2fullpath {
	local i
	local name
	local repo_fullpath

	name=${1/${OVE_BASE_DIR}\/}
	if [ "${name}" == "${OVE_PROJECT_NAME}" ]; then
		repo_fullpath="${OVE_BASE_DIR}/${OVE_PROJECT_NAME}"
	elif [ -v ove_revtab_name2index[${name}] ]; then
		i=${ove_revtab_name2index[${name}]}
		repo_fullpath="${OVE_BASE_DIR}/${ove_revtab_git_name[${i}]}"
	fi

	echo ${repo_fullpath}
}

# $1: repo name (either 'name' or '${OVE_BASE_DIR}/'name')
function ove_repo2shortpath {
	local i
	local name
	local repo_shortpath

	[ $# -ne 1 ] && return 1

	name=${1/${OVE_BASE_DIR}\/}
	if [ "${name}" == "${OVE_PROJECT_NAME}" ]; then
		repo_shortpath="${OVE_PROJECT_NAME}"
	elif [ -v ove_revtab_name2index[${name}] ]; then
		i=${ove_revtab_name2index[${name}]}
		repo_shortpath="${ove_revtab_git_name[${i}]}"
	fi

	echo ${repo_shortpath}
}

# $1: repo
function ove_status_one_repo {
	local i
	local repo_fullpath
	local repo_shortpath
	local revision
	local s

	[ $# -ne 1 ] && return 1

	repo_fullpath=$(ove_repo2fullpath $1)
	if [ "${repo_fullpath}" == "" ] || ! [ -d "${repo_fullpath}" ]; then
		return
	fi

	repo_shortpath="$(ove_repo2shortpath $1)"
	i=${ove_revtab_name2index[${repo_shortpath}]}

	if [ "${repo_shortpath}" == "${OVE_PROJECT_NAME}" ]; then
		revision="$(\git -C "${OVE_PROJECT_DIR}" describe --tags --always 2> /dev/null)"
		[ -n "${revision}" ] || revision=" "
	else
		revision="${ove_revtab_rev[${i}]}"
	fi

	s=$(\git -c color.status=always -C "${repo_fullpath}" status -bs -uno)
	s=${s//$'\n'/ }
	printf "${repo_shortpath}:${revision}:$s\n"
}

function ove_validate_repo_list {
	local repos

	while true; do
		[ $# -eq 0 ] && break
		if [ "$1" == "${OVE_PROJECT_NAME}" ] || [ -v ove_revtab_name2index[${1}] ]; then
			repos+="$(ove_repo2shortpath $1)\n"
		fi
		shift
	done

	echo -e "${repos}" | LC_ALL="C" \sort -u | \xargs -n1
}

function ove_revtab_status {
	local f
	local repo
	local repos
	local o

	if [ $# -ge 1 ]; then
		repos=$(ove_validate_repo_list "$@")
	else
		repos=${OVE_REPO_LIST}
	fi

	[ "${repos}" == "" ] && return

	if [ -w "${OVE_PROJECT_STATE_DIR}" ]; then
		f="${OVE_PROJECT_STATE_DIR}"
	else
		f="${OVE_TMP}"
	fi
	o=${f}

	f+="/$(\date '+%Y%m%d-%H%M%S%N')-revtab-status"

	for repo in ${repos}; do
		ove_status_one_repo ${repo} >> ${f} &
	done

	wait

	LC_ALL="C" \sort -o ${f} ${f}
	if [ "${OVE_COLUMN_WRAP_BUG}" -eq 1 ]; then
		\column -t -s: <<<$(\fold -w 2048 -s ${f})
	else
		\column -t -s: <${f}
	fi

	\mv "${f}" "${o}/revtab-status"
}

# $1: ahead|behind
function ove_revtab_status_parse_one {
	local git_args
	local git_fmt
	local repo_fullpath
	local git_status
	local i
	local nbr_commits
	local tense

	tense=$1
	shift

	git_fmt='%<(15,trunc)%h?%<(15,trunc)%ar?%<(40,mtrunc)%ae?%s'
	repo_fullpath=$(ove_repo2fullpath $1)

	if [ "${repo_fullpath}" == "" ] || ! [ -d "${repo_fullpath}" ]; then
		return
	fi

	git_status=$(\git -C "${repo_fullpath}" status -zbs -uno | \tr '\0' ' ')
	nbr_commits=0

	# keep 'ahead X, behind Y'
	git_status=${git_status##*[}
	git_status=${git_status%%]*}

	if [[ "${git_status}" == *"${tense}"* ]]; then
		if [ "${tense}" == "ahead" ]; then
			git_status=${git_status%%,*}
			nbr_commits=${git_status##${tense} }
		elif [ "${tense}" == "behind" ]; then
			nbr_commits=${git_status##*${tense} }
			git_args="FETCH_HEAD"
		else
			return 1
		fi

		ove_echo_yellow_noprefix "$(ove_repo2shortpath $1): ${nbr_commits} new commit(s):"
		\git --no-pager -C "${repo_fullpath}" log ${git_args} -n ${nbr_commits} --format="${git_fmt}" | \
			\column -t -s?
		echo
	fi
}

# $1: ahead|behind
function ove_revtab_status_parse {
	local repo
	local repos
	local tense

	[ $# -eq 0 ] && return 1

	tense="$1"
	shift

	# turn off monitor mode to get rid of "Done" messages
	set +m

	if [ $# -ge 1 ]; then
		repos=$(ove_validate_repo_list "$@")
	elif ove_any_repo ${tense}; then
		repos=$(ove_list_repos ${tense})
	else
		repos=${OVE_REPO_LIST}
	fi

	for repo in ${repos}; do
		ove_revtab_status_parse_one ${tense} ${repo}
	done | \head -n -1

	# turn on monitor mode
	set -m
}

function ove_revtab_list {
	local i
	local str
	local url

	i=0

	if [ "${ove_revtab_num_repositories}" == 0 ]; then
		echo "run 'ove fetch' first!"
		return 1
	fi

	while ((i < ove_revtab_num_repositories)); do
		str+="${ove_revtab_git_name[${i}]} ${ove_revtab_fetch_url[${i}]} ${ove_revtab_push_url[${i}]} ${ove_revtab_rev[${i}]}\n"
		(( i+=1 ))
	done

	url=$(\git -C "${OVE_PROJECT_DIR}" config --get remote.origin.url)
	if [ "${url}" != "" ]; then
		str+="${OVE_PROJECT_NAME} ${url} ${url} $(\git -C "${OVE_PROJECT_DIR}" rev-parse --abbrev-ref HEAD 2> /dev/null)\n"
	else
		str+="${OVE_PROJECT_NAME} noremote noremote $(\git -C "${OVE_PROJECT_DIR}" rev-parse --abbrev-ref HEAD 2> /dev/null)\n"
	fi

	printf "${str}" | \
		LC_ALL="C" \sort | \
		\column -t
}

function ove_repos_fetched {
	local f=0
	local repo

	for repo in ${OVE_REPO_LIST}; do
		[ -d ${repo} ] && (( f+=1 ))
	done

	echo ${f}
}

function ove_verify_checksums {
	local cfgs
	local md5

	if [ ${OVE_REVTAB_CHECK} -eq 1 ]; then
		md5=$(ove_repos_fingerprint)
		# got updated?
		if [ -n "${OVE_REPOS_MD5+x}" ] && [ "${md5}" != "${OVE_REPOS_MD5}" ]; then
			return 1
		fi
	fi

	if [ -e "${OVE_PROJECT_DIR}/revtab" ]; then
		md5=$(\md5sum ${OVE_PROJECT_DIR}/revtab)
		md5=${md5% *}
		# got updated?
		if [ -n "${OVE_REVTAB_MD5+x}" ] && [ "${md5}" != "${OVE_REVTAB_MD5}" ]; then
			return 1
		# just created?
		elif [ -z "${OVE_REVTAB_MD5+x}" ]; then
			return 1
		fi
	elif [ -n "${OVE_REVTAB_MD5+x}" ]; then
		# got removed?
		unset OVE_REVTAB_MD5
		return 1
	fi

	if [ -e "${OVE_PROJECT_DIR}/projs" ]; then
		md5=$(\md5sum ${OVE_PROJECT_DIR}/projs)
		md5=${md5% *}
		# got updated?
		if [ -n "${OVE_PROJS_MD5+x}" ] && [ "${md5}" != "${OVE_PROJS_MD5}" ]; then
			return 1
		# just created?
		elif [ -z "${OVE_PROJS_MD5+x}" ]; then
			return 1
		fi
	elif [ -n "${OVE_PROJS_MD5+x}" ]; then
		# got removed?
		unset OVE_PROJS_MD5
		return 1
	fi

	read -r -a cfgs < <(ove_list_oveconfig_files)
	if [ "${#cfgs[@]}" -ne 0 ]; then
		md5=$(ove_file_fingerprint "${cfgs[@]}")
		# got updated?
		if [ -n "${OVE_CONFIG_MD5+x}" ] && [ "${md5}" != "${OVE_CONFIG_MD5}" ]; then
			return 1
		# just created?
		elif [ -z "${OVE_CONFIG_MD5+x}" ]; then
			return 1
		fi
	elif [ -n "${OVE_CONFIG_MD5+x}" ]; then
		# got removed?
		unset OVE_CONFIG_MD5
		return 1
	fi

	md5=$(ove_file_fingerprint $(ove_list_scripts_directories))
	# got updated?
	if [ -n "${OVE_SCRIPTS_MD5+x}" ] && [ "${md5}" != "${OVE_SCRIPTS_MD5}" ]; then
		return 1
	fi

	if [ "${OVE_REPOS_FETCHED}" != "" ] && [ $(ove_repos_fetched) -ne ${OVE_REPOS_FETCHED} ]; then
		return 1
	fi

	# OVE_BASE_DIR got lost?
	if [ -z "${OVE_BASE_DIR+x}" ]; then
		return 1
	fi

	return 0
}

function ove_update_checksum_config {
	local cfgs

	read -r -a cfgs < <(ove_list_oveconfig_files)
	if [ ${#cfgs[@]} -ne 0 ]; then
		OVE_CONFIG_MD5=$(ove_file_fingerprint "${cfgs[@]}")
		export OVE_CONFIG_MD5
	fi
}

function ove_repos_fingerprint {
	local md5

	md5=$(ove-forall-parallel stat --format '%Y' .git/HEAD | LC_ALL="C" \sort | \md5sum)
	md5=${md5% *}
	echo "${md5}"
}

function ove_update_checksum {
	local md5

	if [ -e "${OVE_PROJECT_DIR}/revtab" ]; then
		md5=$(\md5sum ${OVE_PROJECT_DIR}/revtab)
		md5=${md5% *}
		OVE_REVTAB_MD5=${md5}
		export OVE_REVTAB_MD5
	fi

	if [ -e "${OVE_PROJECT_DIR}/projs" ]; then
		md5=$(\md5sum ${OVE_PROJECT_DIR}/projs)
		md5=${md5% *}
		OVE_PROJS_MD5=${md5}
		export OVE_PROJS_MD5
	fi

	ove_update_checksum_config

	if [ ${OVE_REVTAB_CHECK} -eq 1 ]; then
		OVE_REPOS_MD5=$(ove_repos_fingerprint)
		export OVE_REPOS_MD5
	fi

	OVE_SCRIPTS_MD5=$(ove_file_fingerprint "${!ove_scripts_paths[@]}")
	export OVE_SCRIPTS_MD5

	OVE_REPOS_FETCHED=$(ove_repos_fetched)
	export OVE_REPOS_FETCHED
}

# $1: name
# $2: fetch url
# $3: push url
function ove_revtab_check_fetch_push {
	local name
	local remote_url
	local revtab_url

	name=$1
	[ -d "${OVE_BASE_DIR}/${name}/.git" ] || return

	# fetch URL
	if ! remote_url=$(\git -C "${OVE_BASE_DIR}/${name}" remote get-url origin 2> /dev/null); then
		return
	fi
	revtab_url="$2"
	if [ "${remote_url}" != "${revtab_url}" ]; then
		\git -C "${OVE_BASE_DIR}/${name}" remote set-url origin "${revtab_url}"
	fi

	# push URL
	if ! remote_url=$(\git -C "${OVE_BASE_DIR}/${name}" remote get-url --push origin 2> /dev/null); then
		return
	fi
	revtab_url="$3"
	if [ "${remote_url}" != "${revtab_url}" ]; then
		\git -C "${OVE_BASE_DIR}/${name}" remote set-url --push origin "${revtab_url}"
	fi
}

# $1: name
# $2: fetch url
# $3: push url
# $4: rev
function ove_revtab_check_one {
	local branch_name
	local co=0
	local detached=0
	local m
	local name
	local rev_is_branch=0
	local revision
	local sha_a
	local sha_b

	name=$1
	[ -d "${OVE_BASE_DIR}/${name}/.git" ] || return

	revision=$4
	sha_a=$(\git -C ${OVE_BASE_DIR}/${name} rev-list -n 1 --abbrev-commit HEAD --)
	sha_b=$(\git -C ${OVE_BASE_DIR}/${name} rev-list -n 1 --abbrev-commit ${revision} -- 2> /dev/null)
	[ $? -ne 0 ] && sha_b=""

	if [ "${sha_a}" != "${sha_b}" ]; then
		# diff => checkout
		co=1
	else
		\git -C "${OVE_BASE_DIR}/${name}" symbolic-ref -q HEAD > /dev/null || detached=1
		[[ "$(ove_list_branches ${OVE_BASE_DIR}/${name} | \xargs)" =~ (^| )${revision}($| ) ]] && rev_is_branch=1

		# detached and rev is a branch => checkout
		if [ ${detached} -eq 1 ] && [ ${rev_is_branch} -eq 1 ]; then
			co=1
		# not detached and rev is not a branch => checkout
		elif [ ${detached} -eq 0 ] && [ ${rev_is_branch} -eq 0 ]; then
			co=1
		# switched branch?
		elif [ ${detached} -eq 0 ] && [ ${rev_is_branch} -eq 1 ]; then
			branch_name=$(\git -C ${OVE_BASE_DIR}/${name} rev-parse --abbrev-ref HEAD)
			if [ "${branch_name}" != "${revision}" ]; then
				co=1
			fi
		fi
	fi

	if [ ${co} -eq 1 ]; then
		if ove_repo_is_dirty ${OVE_BASE_DIR}/${name}; then
			ove_echo_error_noprefix "${name}: cannot checkout '${revision}' as repo is dirty"
		else
			m=$(\xargs -n1 <<<${OVE_REPO_LIST//${OVE_BASE_DIR}\/} | \wc -L)
			ove_revtab_checkout ${name} |& \sed -e "1s|^|$(ove_echo_yellow_noprefix ${name})$(printf "%0.s " $(eval echo {1..$((${m} + 2 - ${#name}))}))|g" \
				-e "2,10s|^|$(printf "%0.s " $(eval echo {1..$((${m} + 2))}))|g"
			ove_patch_repositories
		fi
	fi

	ove_revtab_check_fetch_push "$1" "$2" "$3"
}

function ove_revtab_check {
	local i
	local n=${FUNCNAME^^}

	[ -n "${!n}" ] && [ "${!n}" -eq 0 ] && return
	[ "${ove_revtab_num_repositories}" == 0 ] && return 1

	set +m

	i=0
	while ((i < ove_revtab_num_repositories)); do
		ove_revtab_check_one \
			${ove_revtab_git_name[${i}]} \
			${ove_revtab_fetch_url[${i}]} \
			${ove_revtab_push_url[${i}]} \
			${ove_revtab_rev[${i}]} &
		(( i+=1 ))
	done | \grep -v '^\['
	wait
}

function ove_revtab_list_fullpath {
	local repo
	local s

	for repo in "${ove_revtab_git_name[@]}"; do
		s+="${OVE_BASE_DIR}/${repo} "
	done
	s+="${OVE_PROJECT_DIR}"

	echo ${s}
}

function ove_revtab_list_basename {
	local repo
	local s

	for repo in "${ove_revtab_git_name[@]}" ${OVE_PROJECT_NAME}; do
		s+="${repo} "
	done

	echo ${s}
}

function ove_revtab_forall {
	local repo
	local repo_basename

	for repo in ${OVE_REPO_LIST}; do
		! [ -d "${repo}" ] && continue
		repo_basename=${repo/${OVE_BASE_DIR}\/}
		eval "pushd ${repo} &>/dev/null && $1; popd&>/dev/null"
	done
}

function ove_cap_jobs {
	local job_list

	if [ $# -ne 1 ] || [ $1 -eq 0 ]; then
		return
	fi

	mapfile -t job_list < <(jobs -p -r)
	[ "${#job_list[@]}" -ge "${1}" ] && wait -n
}

function ove_revtab_forall_parallel {
	(
	local max_parallel=0
	local repo
	local repo_basename

	[ $# -eq 2 ] && max_parallel=$2

	for repo in ${OVE_REPO_LIST}; do
		! [ -d "${repo}" ] && continue
		repo_basename=${repo/${OVE_BASE_DIR}\/}
		pushd "${repo}" &>/dev/null && eval "$1" &
		ove_cap_jobs ${max_parallel}
	done
	wait
	)
}

function ove_revtab_forsome {
	local i
	local repo
	local repo_basename

	for i in ${*:2}; do
		for repo in ${OVE_REPO_LIST}; do
			! [ -d "${repo}" ] && continue
			if [ "${repo}" == "${OVE_BASE_DIR}/${i}" ]; then
				repo_basename=${repo/${OVE_BASE_DIR}\/}
				eval "pushd ${repo} &>/dev/null && $1; popd&>/dev/null"
			fi
		done
	done
}

# $1  : cmd
# $2  : max jobs
# $3..: repos
function ove_revtab_forsome_parallel {
	(
	local repo
	local i

	for i in ${*:3}; do
		for repo in ${OVE_REPO_LIST}; do
			! [ -d "${repo}" ] && continue
			if [ "${repo}" == "${OVE_BASE_DIR}/${i}" ]; then
				eval "pushd ${repo} &>/dev/null; $1; popd&>/dev/null" &
				ove_cap_jobs ${2}
			fi
		done
	done
	wait
	)
}

function ove_revtab_clone_and_checkout_one {
	local i=$1
	local fetch_url
	local name
	local push_url

	fetch_url="${ove_revtab_fetch_url[${i}]}"
	push_url="${ove_revtab_push_url[${i}]}"
	name="${ove_revtab_git_name[${i}]}"
	while true; do
		if ! \git clone "${fetch_url}" "${OVE_BASE_DIR}/${name}"; then
			return 1
		fi
		break
	done |& \sed "s|^|${name}  |g"

	ove_revtab_checkout "${name}"
	ove_revtab_check_fetch_push "${name}" "${fetch_url}" "${push_url}"
}

# $*: optional list of repositories
function ove_revtab_clone_and_checkout {
	(
	local i
	local repo
	local repos

	if [ $# -gt 0 ]; then
		repos=$(ove_validate_repo_list "$@")
		[ "${repos}" == "" ] && return 1
		for repo in ${repos}; do
			if [ ! -d "${OVE_BASE_DIR}/${repo}" ]; then
				i=${ove_revtab_name2index[${1}]}
				ove_revtab_clone_and_checkout_one ${i} &
				ove_cap_jobs ${OVE_CLONE_MAX_PARALLEL}
			fi
			shift
		done
	else
		i=0
		while ((i < ove_revtab_num_repositories)); do
			if [ ! -d "${OVE_BASE_DIR}/${ove_revtab_git_name[${i}]}" ]; then
				ove_revtab_clone_and_checkout_one ${i} &
				ove_cap_jobs ${OVE_CLONE_MAX_PARALLEL}
			fi
			(( i+=1 ))
		done
	fi

	wait
	)
}

function ove_revtab_checkout_one {
	local name
	local revision

	name=${ove_revtab_git_name[${1}]}
	revision=${ove_revtab_rev[${1}]}
	while true; do
		if ! \git -C "${OVE_BASE_DIR}/${name}" -c advice.detachedHead=false checkout "${revision}"; then
			return 1
		fi
		break
	done |& \sed -e "s|^|${name}  |g"
}

# $*: optional list of repositories
function ove_revtab_checkout {
	(
	local i
	local repo
	local repos

	if [ $# -gt 0 ]; then
		repos=$(ove_validate_repo_list "$@")
		[ "${repos}" == "" ] && return 1
		for repo in ${repos}; do
			i=${ove_revtab_name2index[${1}]}
			ove_revtab_checkout_one ${i} &
			shift
		done
	else
		i=0
		while ((i < ove_revtab_num_repositories)); do
			ove_revtab_checkout_one ${i} &
			(( i+=1 ))
		done
	fi

	wait
	)
}

function ove_revtab_pull_one {
	local base
	local cmd
	local loc
	local remote
	local repo
	local repo_fullpath
	local upstream

	repo="$1"
	upstream="@{u}"

	repo_fullpath=$(ove_repo2fullpath $1)
	if [ "${repo_fullpath}" == "" ] || ! [ -d "${repo_fullpath}" ]; then
		return
	fi

	# check if detached
	if ! \git -C "${repo_fullpath}" rev-parse -q "${upstream}" &> /dev/null; then
		return
	fi

	loc=$(\git -C "${repo_fullpath}" rev-parse @)
	remote=$(\git -C "${repo_fullpath}" rev-parse "${upstream}")
	base=$(\git -C "${repo_fullpath}" merge-base @ "${upstream}")

	if [ "${loc}" = "${remote}" ]; then
		# up-to-date
		:
	elif [ "${remote}" = "${base}" ]; then
		# need to push
		:
	else
		if [ "$(ove_revtab_status_parse_one ahead ${repo})" != "" ]; then
			if [ "$(\git config --global user.email)" == "" ] || [ "$(\git config --global user.name)" == "" ]; then
				ove_echo_error_noprefix "not possible to 'git pull --rebase' '${repo}' as git user.email/user.name is not set"
				return 1
			fi
		fi

		ove_echo_yellow_noprefix "${repo}"
		cmd="\git -C ${repo_fullpath} pull --rebase"
		if ! eval ${cmd}; then
			ove_echo_error_noprefix "${cmd}"
		fi
	fi
}

# $*: optional list of repositories
function ove_revtab_fetch {
	local co_list
	local i
	local m

	if ! ove_revtab_parse; then
		return 1
	fi

	if [ $# -ge 1 ]; then
		ove_revtab_clone_and_checkout "$@"
		m=$(\xargs -n1 <<<"$@" | \wc -L)
		ove_revtab_forsome_parallel "\git -C \${repo} fetch --all --tag |& \sed -e \"s|^|\${i}\$(printf \"%0.s \" \$(eval echo {1..\$((${m} + 2 - \${#i}))}))|g\"" ${OVE_FETCH_MAX_PARALLEL} "$@"
		return $?
	fi

	i=0
	while ((i < ove_revtab_num_repositories)); do
		if [ ! -d "${OVE_BASE_DIR}/${ove_revtab_git_name[${i}]}" ]; then
			co_list+="${ove_revtab_git_name[${i}]} "
		fi
		(( i+=1 ))
	done

	[ "${co_list}" != "" ] && ove_revtab_clone_and_checkout ${co_list}

	m=$(\xargs -n1 <<<${OVE_REPO_LIST//${OVE_BASE_DIR}\/} | \wc -L)
	ove_revtab_forall_parallel "\git -C \${repo} fetch --all --tags |& \sed -e \"s|^|\${repo_basename}\$(printf \"%0.s \" \$(eval echo {1..\$((${m} + 2 - \${#repo_basename}))}))|g\"" ${OVE_FETCH_MAX_PARALLEL}
	return $?
}

# $1: dir
function ove_is_base_dir {
	if [[ -L ${1}/ove && -L ${1}/.owel ]]; then
		return 0
	else
		return 1
	fi
}

function ove_get_base_dir {
	local s

	pushd . &> /dev/null
	s=$(pwd -P)
	while [ "${s}" != "" ]; do
		if ove_is_base_dir "${s}"; then
			echo "${s}"
			break
		fi
		s=${s%/*}
	done

	popd > /dev/null

	# base directory found?
	if [ "${s}" == "" ]; then
		ove_echo_error_noprefix "not in an OVE workspace. Try 'ove cd'"
		return 1

	# First time? Do nothing
	elif [ -z "${OVE_BASE_DIR+x}" ]; then
		:

	# Have we moved to another OVE workspace? source that project
	elif [ "${s}" != "${OVE_BASE_DIR}" ] && [[ $- == *i* ]]; then
		cd ${s} && . ove > /dev/null && cd -
	fi
}
export -f ove_get_base_dir

function ove_list_projects {
	if [ -f "${OVE_PROJECT_DIR}"/projs ]; then
		\grep -o '^[a-zA-Z0-9_]\+' ${OVE_PROJECT_DIR}/projs | \
			LC_ALL="C" \sort | \
			\xargs "${OVE_ECHO}"
	fi
}
export -f ove_list_projects

# $*: file(s)
function ove_file_md5sum {
	[ $# -eq 0 ] && return 1

	if command -v md5deep > /dev/null; then
		\md5deep -s -o f -r "${@}"
	else
		\find "${@}" -type f -print0 | \xargs -0 md5sum
	fi
}

# $*: file(s)
function ove_file_fingerprint {
	local md5

	[ $# -eq 0 ] && return 1

	if [ -n "${OVE_DRY_RUN+x}" ] && [ "${OVE_DRY_RUN}" -eq 1 ]; then
		echo
		return
	fi

	md5=$(ove_file_md5sum "${@}" | \
		\awk '{print $1}' | \
		LC_ALL="C" \sort | \
		\md5sum)
	echo ${md5% *}
}

# make:[PROJECT[-nodeps]]:build project(s)
function ove-make {
	local fingerprint_a
	local fingerprint_b
	local i
	local proj
	local stage_dir_updated_by
	local target
	local withdeps

	target="$*"
	withdeps="true"

	[ $# -eq 0 ] && target="all"

	if [[ ${target} == *-nodeps ]]; then
		withdeps="false"
		target=${target%-nodeps}
	fi

	# build all?
	if [ "${target}" == "all" ]; then
		if ! ove_build_pre; then
			return 1
		fi

		for proj in ${OVE_BUILD_ORDER}; do
			i=${ove_projects_name2index[${proj}]}

			# does proj have any dependencies?
			if [ "${ove_projects_deps[${i}]}" != "" ]; then
				# check if some of the deps has modified the stage dir
				for dep in ${ove_projects_deps[${i}]}; do
					if [[ "${stage_dir_updated_by}" == *"${dep}"* ]]; then
						ove_projects_cmd "${proj}" clean
						break
					fi
				done
			fi

			fingerprint_a=$(ove_file_fingerprint ${OVE_STAGE_DIR})
			ove_projects_cmd "${proj}" build
			ove_projects_cmd "${proj}" install
			fingerprint_b=$(ove_file_fingerprint ${OVE_STAGE_DIR})

			# remember if project modified the stage dir
			if [ "${fingerprint_a}" != "${fingerprint_b}" ]; then
				stage_dir_updated_by+="${proj} "
			fi
		done
	else
		if ! ove_build_pre ${target}; then
			return 1
		fi

		if [ "${withdeps}" == "false" ]; then
			ove_projects_cmd "${target}" build
		else
			if [[ "$(caller 0)" != *"ove-make"* ]]; then
				# keep track of projects built
				_ove_projects_built=""
			fi

			if ! [[ -v ove_projects_name2index[${target}] ]]; then
				ove_echo_error_noprefix "unknown target '${target}'"
				return 1
			fi

			i=${ove_projects_name2index[${target}]}
			# has deps?
			if [ "${ove_projects_deps[${i}]}" != "" ]; then
				fingerprint_a=$(ove_file_fingerprint ${OVE_STAGE_DIR})

				for dep in ${ove_projects_deps[${i}]}; do
					if ! [[ -v ove_projects_name2index[${dep}] ]]; then
						ove_echo_yellow_noprefix "warning: project '${dep}' not found, skipping"
						continue
					fi

					# already built? next!
					if [[ "${_ove_projects_built}" == *"${dep}"* ]]; then
						continue
					fi

					if ! ove-make "${dep}"; then
						return 1
					fi
				done

				fingerprint_b=$(ove_file_fingerprint ${OVE_STAGE_DIR})

				# clean the project if OVE_STAGE_DIR was updated
				if [ "${fingerprint_a}" != "${fingerprint_b}" ]; then
					ove_projects_cmd "${target}" clean
				fi
			fi

			if ! ove_projects_cmd "${target}" build; then
				return 1
			fi

			if ! ove_projects_cmd "${target}" install; then
				return 1
			fi

			# remember projects built
			_ove_projects_built+="${target} "

			# cleanup
			if [[ "$(caller 0)" != *"ove-make"* ]]; then
				unset _ove_projects_built
			fi
		fi
	fi
}

# list-projects:[verbose]:list projects
function ove-list-projects {
	local f_basename
	local f
	local p
	local projects

	if [ "$1" == 'verbose' ]; then
		projects=${OVE_PROJECT_LIST}
		for p in ${projects}; do
			# ignore projects without a project directory
			[ ! -d "${OVE_PROJECT_DIR}"/projects/${p} ] && continue

			ove_echo_cyan_noprefix "${p}"
			for f in bootstrap configure build install clean; do
				[ -x ${OVE_PROJECT_DIR}/projects/${p}/${f} ] || continue
				echo -e "\t${f}"
				\sed -e 's|^|\t\t|g' <${OVE_PROJECT_DIR}/projects/${p}/${f}
			done

			while read -r line; do
				f_basename=${line##*/}
				[[ "bootstrap configure build install clean" =~ ${f_basename} ]] && continue
				echo -e "\t${f_basename}"
				\sed -e 's|^|\t\t|g' <${OVE_PROJECT_DIR}/projects/${p}/${f_basename}
			done < <(\find "${OVE_PROJECT_DIR}"/projects/${p} -perm -u=x -type f)
			echo
		done | \head -n -1
	else
		[ "${OVE_PROJECT_LIST}" != "" ] &&
			\xargs -n1 <<<${OVE_PROJECT_LIST}
	fi

	return 0
}

# digraph: :create a DOT directed graph for all projects
function ove-digraph {
	local i

	[ ${ove_number_of_projects} -eq 0 ] && return

	echo "digraph $(\tr '-' '_' <<<${OVE_PROJECT_NAME}) {"

	i=0
	while ((i < ove_number_of_projects)); do
		if [ "${ove_projects_deps[${i}]}" != "" ]; then
			for d in ${ove_projects_deps[${i}]}; do
				echo "    ${ove_projects_name[${i}]} -> ${d};"
			done
		else
			echo "    ${ove_projects_name[${i}]};"
		fi
		(( i+=1 ))
	done

	echo "}"
}

function ove_build_topology {
	local i

	i=0
	while ((i < ove_number_of_projects)); do
		if [ "${ove_projects_deps[${i}]}" != "" ]; then
			for d in ${ove_projects_deps[${i}]}; do
				[[ -v ove_projects_name2index[${d}] ]] || continue
				echo "${ove_projects_name[${i}]} ${d}"
			done
		fi
		(( i+=1 ))
	done | \tsort | \tac | \xargs
}

# build-order: :show build order
function ove-build-order {
	local autonomous_projs
	local topology

	[ ${ove_number_of_projects} -eq 0 ] && return

	# just a bunch of projects without deps?
	if [ "$(ove_list_projects_with_deps)" == "" ]; then
		ove_list_projects_without_deps
		return
	fi

	topology=$(ove_build_topology)
	autonomous_projs=$(LC_ALL="C" \comm -3 \
		<(printf "%s\n" ${OVE_PROJECT_LIST}) \
		<(\tr ' ' '\n' <<<${topology} | LC_ALL="C" \sort))

	echo ${autonomous_projs} ${topology}
}

# forowel:COMMAND:run 'COMMAND' for all OVE workspaces on this host
function ove-forowel {
	local cmd
	local i
	local projs

	[ $# -eq 0 ] && return

	i=0
	mapfile -t projs < <(ove-locate | \grep '^/')
	while ((i < ${#projs[@]})); do
		cmd+=$(printf "
			echo '# %s'
			cd %s
			ove_init
			$*
			" $(ove_echo_green_noprefix ${projs[i]##*/}) ${projs[i]})
		(( i+=1 ))
	done
	eval "${cmd}"
}

# forowel-parallel:COMMAND:run 'COMMAND' in parallel for all OVE workspaces on this host
function ove-forowel-parallel {
	local cmd
	local i
	local projs

	[ $# -eq 0 ] && return

	i=0
	mapfile -t projs < <(ove-locate | \grep '^/')
	while ((i < ${#projs[@]})); do
		cmd=$(printf "
			cd %s
			ove_init
			$*
			" ${projs[i]})
		(( i+=1 ))
		{
			eval "${cmd}"
		} &
	done
	wait
}

# forall:COMMAND:run 'COMMAND' for all git repositories
function ove-forall {
	[ $# -ne 0 ] && ove_revtab_forall "$*"
}

# forall-parallel:COMMAND:run 'COMMAND' in parallel for all git repositories
function ove-forall-parallel {
	[ $# -ne 0 ] && ove_revtab_forall_parallel "$*"
}

# list-systests: :list available system tests
function ove-list-systests {
	! [ -e ${OVE_PROJECT_DIR}/systests ] && return
	(
	\grep -E -v '^$|^\s*\#|.*:|^#.*' "${OVE_PROJECT_DIR}"/systests | \
		\awk '{print $1}'
	\grep : "${OVE_PROJECT_DIR}"/systests | \
		\grep -v '#' | \
		\cut -d: -f1

	if [ -e ${OVE_PROJECT_DIR}/systests-groups ]; then
		\grep : "${OVE_PROJECT_DIR}"/systests-groups | \
			\sed 's|[-:[:space:]]||g'
	fi) | LC_ALL="C" \sort
}

# list-systests-aliases: :list available system test aliases
function ove-list-systests-aliases {
	! [ -e ${OVE_PROJECT_DIR}/systests ] && return

	\grep : "${OVE_PROJECT_DIR}"/systests | \
		\grep -v '#' | \
		\cut -d: -f1 | \
		LC_ALL="C" \sort
}

# list-scripts: :list available scripts
function ove-list-scripts {
	local p
	local repo

	# project scripts
	if [ -d "${OVE_PROJECT_DIR}/scripts" ]; then
		\find ${OVE_PROJECT_DIR}/scripts -perm -u=x -not -name '*.help' -type f
	fi

	# OVE scripts
	if [ -d "${OVE_DIR}/scripts" ]; then
		\find ${OVE_DIR}/scripts -perm -u=x -not -name '*.help' -type f
	fi

	# repo scripts
	for repo in $(ove_revtab_list_fullpath); do
		! [ -d "${repo}/.ove/scripts" ] && continue
		p+="${repo}/.ove/scripts "
	done
	[ "${p}" != "" ] && \
		\find -L ${p} -perm -u=x -not -name '*.help' -type f

	return 0
}

function ove_list_scripts_directories {
	local d
	local repo

	while true; do
		# project scripts
		[ -d "${OVE_PROJECT_DIR}/scripts" ] && d+="${OVE_PROJECT_DIR}/scripts "
		# OVE scripts
		[ -d "${OVE_DIR}/scripts" ] && d+="${OVE_DIR}/scripts "
		# repo scripts
		for repo in ${OVE_REPO_LIST}; do
			[ -d "${repo}/.ove/scripts" ] || continue
			d+="${repo}/.ove/scripts "
		done
		\find -L ${d} -perm -u=x -not -name '*.help' -type f
		break
	done | \xargs dirname | LC_ALL="C" \sort -u
}

function ove_echo {
	local diff
	local diff_ns
	local diff_s
	local now
	local now_ns
	local now_s

	diff="00:00:00"
	diff_ns="000000000"

	now=$(\date +%s:%N)
	now_s=${now%:*}
	now_ns=${now#*:}
	# remove leading zeros
	now_ns=$((10#${now_ns}))

	if [ "${OVE_PREV_S}" != "" ]; then
		diff_ns="$((now_ns - OVE_PREV_NS))"
		diff_s=$((now_s - OVE_PREV_S))
		if [ "${diff_ns}" -lt 0 ]; then
			(( diff_s-=1 ))
			diff_ns="$((1000000000 + diff_ns))"
		fi

		diff="$(\awk '{printf "%02d:%02d:%02d\n", int($1/3600),int(($1%3600)/60),int($1%60)}' <<<${diff_s})"
	fi

	echo -e "$(\date -d @${now_s} +'%Y-%m-%d %H:%M:%S').$(printf "%09d" ${now_ns}) (+${diff}:$(printf "%09d" ${diff_ns})):$*"

	OVE_PREV_S=${now_s}
	OVE_PREV_NS=${now_ns}
}

function ove_echo_cyan {
	ove_echo "${ove_cyan}""$*""${ove_blank}"
}

function ove_echo_cyan_error {
	ove_echo "${ove_cyan}""$*""${ove_blank}" 1>&2;
}

function ove_echo_yellow {
	ove_echo "${ove_yellow}""$*""${ove_blank}"
}

function ove_echo_green_noprefix {
	echo -e "${ove_green}""$*""${ove_blank}"
}

function ove_echo_red {
	ove_echo "${ove_red}""$*""${ove_blank}"
}

function ove_echo_red_noprefix {
	echo -e "${ove_red}""$*""${ove_blank}"
}

function ove_echo_yellow_noprefix {
	echo -e "${ove_yellow}""$*""${ove_blank}"
}

function ove_echo_warning {
	ove_echo_yellow "warning: $*" 1>&2;
}

function ove_echo_cyan_noprefix {
	echo -e "${ove_cyan}""$*""${ove_blank}"
}

function ove_echo_note_noprefix {
	echo -e "${ove_cyan}NOTE:${ove_blank} $*"
}

function ove_echo_error {
	ove_echo_red "error: $*" 1>&2;
}

function ove_echo_error_noprefix {
	ove_echo_red_noprefix "error: $*" 1>&2;
}

function ove_echo_warning_noprefix {
	ove_echo_yellow_noprefix "warning: $*" 1>&2;
}

function ove_echo_stderr {
	ove_echo "$@" 1>&2;
}

function ove_echo_stderr_noprefix {
	echo "$@" 1>&2;
}

function ove_echo_command_not_found {
	local msg="command '$1' not found"

	[ $# -eq 2 ] && msg+=". $2"
	ove_echo_error_noprefix "${msg}"
}

# systest:[TEST|GROUP...]:run one or more system tests/groups described in ${OVE_PROJECT_DIR}/systests-groups and ${OVE_PROJECT_DIR}/systests
function ove-systest {
	local exit_status
	local groups
	local i
	local match
	local nbr_tests
	local new_test_list
	local q
	local result
	local summary
	local systest_cmd
	local systest_exit_code
	local systest_path
	local systest_row
	local systest_timeout
	local systest_type
	local test_list
	local test_name
	local timeout_cmd

	[ -e ${OVE_PROJECT_DIR}/systests ] || return 1

	if [ $# -eq 0 ]; then
		ove-help "^${FUNCNAME/ove-/} "
		return 1
	fi

	if ! [ -e ${OVE_PROJECT_DIR}/systests-groups ]; then
		test_list="$*"
	else
		groups=$(\grep : ${OVE_PROJECT_DIR}/systests-groups | \
			\sed 's|[-:[:space:]]||g'| \
			LC_ALL="C" \sort)

		if [ "${groups}" == "" ]; then
			test_list="$*"
		elif ! command -v python3 > /dev/null; then
			ove_echo_yellow_noprefix "python3 not found, not possible to launch 'yex'"
			test_list="$*"
		else
			for test_name in "$@"; do
				if \grep -w -q ${test_name} <<<${groups}; then
					test_list+=" $(${OVE_DIR}/yex ${OVE_PROJECT_DIR}/systests-groups -s -r --groups "${test_name}")"
				else
					test_list+=" ${test_name}"
				fi
			done
		fi
	fi

	[ "${test_list}" == "" ] && echo "error: no tests found" && return 1

	# repeat?
	if [ -n "${OVE_SYSTEST_REPEAT+x}" ] && \
		[ "${OVE_SYSTEST_REPEAT}" -gt 1 ]; then

		for test_name in ${test_list}; do
			for q in $(\seq 1 ${OVE_SYSTEST_REPEAT}); do
				new_test_list+=" ${test_name}"
			done
		done

		test_list=${new_test_list}
	fi

	# skip tests
	if [ -n "${OVE_SYSTEST_SKIP+x}" ] && \
		[ "${OVE_SYSTEST_SKIP}" -gt 1 ]; then

		i=0
		for test_name in ${test_list}; do
			if (( i % OVE_SYSTEST_SKIP == 0 )); then
				new_test_list+=" ${test_name}"
			fi
			(( i=i+1 ))
		done

		test_list=${new_test_list}
	fi

	nbr_tests=$(\wc -w <<<${test_list})
	if [ ${nbr_tests} -gt 1 ]; then
		echo "${FUNCNAME[0]}:Will run ${nbr_tests} test cases:"
		i=0
		for test_name in ${test_list}; do
			(( i=i+1 ))
			printf "${FUNCNAME[0]}:[%03d/%03d    ]:${test_name}\n" ${i} ${nbr_tests}
		done
		echo
	fi

	# trap SIGINT to allow user to press CTRL+C
	trap true SIGINT

	i=0
	for test_name in ${test_list}; do
		(( i=i+1 ))

		# alias?
		match=$(\grep -c ^${test_name}: "${OVE_PROJECT_DIR}"/systests)
		if [ ${match} -eq 1 ]; then
			test_name=$(\grep ^${test_name}: "${OVE_PROJECT_DIR}"/systests | \
				\cut -d: -f2)
		else
			match=$(\grep -c -w ^${test_name} "${OVE_PROJECT_DIR}"/systests)
			if [ ${match} -eq 0 ]; then
				ove_echo_error_noprefix "${FUNCNAME[0]}:can not find '${test_name}'"
				continue
			elif [ ${match} -gt 1 ]; then
				ove_echo_error_noprefix "${FUNCNAME[0]}:${match} match(es) for '${test_name}'"
				\grep ^${test_name} "${OVE_PROJECT_DIR}"/systests
				continue
			fi
		fi

		read -r -a systest_row <<<"$(\grep -w ^${test_name} "${OVE_PROJECT_DIR}"/systests)"
		test_name=${systest_row[0]}
		systest_timeout=${systest_row[1]}
		systest_type=${systest_row[2]}
		systest_path=${OVE_BASE_DIR}/${systest_row[3]//\"}
		systest_cmd=${systest_row[*]:4}
		systest_cmd=${systest_cmd//\"}

		if ! [ -d "${systest_path}" ]; then
			ove_echo_error_noprefix "'${systest_path}' is not a valid path for systest: '${test_name}'"
			continue
		fi

		pushd "${systest_path}" &> /dev/null
		shift
		printf "${FUNCNAME[0]}:[%03d/%03d    ]:${test_name}\n" ${i} ${nbr_tests}

		OVE_SYSTEST_ACTIVE_TEST_CASE=${test_name}
		OVE_SYSTEST_ITERATION=${i}
		OVE_SYSTEST_NBR_TESTS=${nbr_tests}
		export OVE_SYSTEST_ACTIVE_TEST_CASE
		export OVE_SYSTEST_ITERATION
		export OVE_SYSTEST_NBR_TESTS

		if [ "${OVE_DRY_RUN}" -eq 1 ]; then
			# dry run
			result=$(printf "${FUNCNAME[0]}:[%03d/%03d ${ove_green}OK${ove_blank}]:${test_name}" ${i} ${nbr_tests})
		else
			if [ ${systest_timeout} -eq 0 ]; then
				timeout_cmd=""
			else
				timeout_cmd="timeout --foreground --kill-after 30s ${systest_timeout}"
			fi

			if ${timeout_cmd} ${systest_cmd}; then
				# test passed
				result=$(printf "${FUNCNAME[0]}:[%03d/%03d ${ove_green}OK${ove_blank}]:${test_name}" ${i} ${nbr_tests})
			else
				systest_exit_code=$?

				if [ ${systest_exit_code} -eq 124 ]; then
					exit_status="TIMEOUT"
				elif [ ${systest_exit_code} -eq 126 ]; then
					exit_status="PERMISSION_DENIED"
				elif [ ${systest_exit_code} -eq 127 ]; then
					exit_status="CAN_NOT_FIND_CMD"
				elif [ ${systest_exit_code} -gt 128 ] && [ ${systest_exit_code} -lt 166 ]; then
					exit_status="SIG$(kill -l ${systest_exit_code})"
				elif [ -e /usr/include/sysexits.h ] && \
					\grep -P -q "#define EX_[A-Z]+\s+${systest_exit_code}" /usr/include/sysexits.h; then
					exit_status=$(\grep -P "#define EX_[A-Z]+\s${systest_exit_code}" /usr/include/sysexits.h | \
						\grep -o -P 'EX_[A-Z]+')
				elif [ -e ${OVE_PROJECT_DIR}/${OVE_PROJECT_NAME}-sysexits.h ] && \
					\grep -P -q "#define [A-Z0-9_]+\s+${systest_exit_code}$" ${OVE_PROJECT_DIR}/${OVE_PROJECT_NAME}-sysexits.h; then
					exit_status=$(\grep -P "#define [A-Z0-9_]+\s+${systest_exit_code}$" ${OVE_PROJECT_DIR}/${OVE_PROJECT_NAME}-sysexits.h | \
						\cut -f1 | \
						\cut -d' ' -f2)
				else
					exit_status="${systest_exit_code}"
				fi

				# test failed
				result=$(printf "${FUNCNAME[0]}:[%03d/%03d ${ove_yellow}NOK${ove_blank} ${exit_status}]:${test_name}"  ${i} ${nbr_tests})

				# type 1 systest or SIGINT => stop loop
				if [ ${systest_type} -eq 1 ] || [ ${exit_status} == "SIGINT" ] ; then
					echo ${result}
					summary+="${result}\n"
					popd &> /dev/null
					break
				fi
			fi
		fi

		summary+="${result}\n"
		echo -e ${summary}
		popd &> /dev/null
	done
	echo
	if [ ${nbr_tests} -gt 1 ]; then
		echo ${FUNCNAME[0]}:Summary:
		echo -e ${summary}
	fi
	echo "OVE log: ${OVE_LAST_COMMAND}"

	return ${systest_exit_code}
}

# helper function for a few revtab functions below
function ove_revtab_sanity_check {
	if [ $# -ne 2 ]; then
		ove_echo_error_noprefix "please provide two revisions for '${OVE_PROJECT_DIR}'"
		return 1
	fi

	if [ "$1" == "$2" ]; then
		ove_echo_error_noprefix "please provide two different revisions for '${OVE_PROJECT_DIR}'"
		return 2
	fi

	if ! \git -C "${OVE_PROJECT_DIR}" cat-file -e "$1" &> /dev/null; then
		ove_echo_error_noprefix "'$1' is not a valid revision"
		return 3
	fi

	if ! \git -C "${OVE_PROJECT_DIR}" cat-file -e "$2" &> /dev/null; then
		ove_echo_error_noprefix "'$2' is not a valid revision"
		return 4
	fi

	if ! \git -C "${OVE_PROJECT_DIR}" --no-pager show $1:revtab &> /dev/null; then
		ove_echo_error_noprefix "revtab for '$1' is not available"
		return 5
	fi

	if ! \git -C "${OVE_PROJECT_DIR}" --no-pager show $2:revtab &> /dev/null; then
		ove_echo_error_noprefix "revtab for '$2' is not available"
		return 6
	fi
}

# revtab-diff:<rev> <rev>:print changes between two project revisions
function ove-revtab-diff {
	local a
	local b
	local r
	local sha_1
	local sha_2

	ove_revtab_sanity_check "$@" || return $?

	# save revtab for rev A and rev B
	a=$(\git -C "${OVE_PROJECT_DIR}" --no-pager show $1:revtab | \
		\grep -v \# | \
		\xargs -n4)
	b=$(\git -C "${OVE_PROJECT_DIR}" --no-pager show $2:revtab | \
		\grep -v \# | \
		\xargs -n4)

	# extract repo
	printf "${a}" | \
		\awk '{print $1}' | \
		LC_ALL="C" \sort > ${OVE_PROJECT_TMP_DIR}/repos_A
	printf "${b}" | \
		\awk '{print $1}' | \
		LC_ALL="C" \sort > ${OVE_PROJECT_TMP_DIR}/repos_B

	# extract repo/rev
	printf "${a}" | \
		\awk '{print $1,$4}' | \
		LC_ALL="C" \sort > ${OVE_PROJECT_TMP_DIR}/rev_A
	printf "${b}" | \
		\awk '{print $1,$4}' | \
		LC_ALL="C" \sort  > ${OVE_PROJECT_TMP_DIR}/rev_B

	while true; do
		# repos only in A
		for r in $(LC_ALL="C" \comm -2 -3 ${OVE_PROJECT_TMP_DIR}/repos_A ${OVE_PROJECT_TMP_DIR}/repos_B); do
			\grep "^${r} " ${OVE_PROJECT_TMP_DIR}/rev_A | \sed -e 's/^/a /g'
		done

		# repos only in B
		for r in $(LC_ALL="C" \comm -1 -3 ${OVE_PROJECT_TMP_DIR}/repos_A ${OVE_PROJECT_TMP_DIR}/repos_B); do
			\grep "^${r} " ${OVE_PROJECT_TMP_DIR}/rev_B | \sed -e 's/^/b /g'
		done

		# repos common for A and B
		for r in $(LC_ALL="C" \comm -1 -2 ${OVE_PROJECT_TMP_DIR}/repos_A ${OVE_PROJECT_TMP_DIR}/repos_B); do
			sha_1=$(\grep "^${r} " ${OVE_PROJECT_TMP_DIR}/rev_A | \
				\awk '{print $2}')
			sha_2=$(\grep "^${r} " ${OVE_PROJECT_TMP_DIR}/rev_B | \
				\awk '{print $2}')
			[ "${sha_1}" == "${sha_2}" ] && continue
			echo c ${r} ${sha_1} ${sha_2}
		done

		break
	done | \column -t

	# cleanup
	\rm ${OVE_PROJECT_TMP_DIR}/repos_A \
		${OVE_PROJECT_TMP_DIR}/repos_B \
		${OVE_PROJECT_TMP_DIR}/rev_A \
		${OVE_PROJECT_TMP_DIR}/rev_B
}

# helper function for diff/log/shortlog-project functions
function ove_extract_only_a {
	local line=${*}
	local repo
	local sha_1

	repo=$(\awk '{print $2}' <<<${line})
	sha_1=$(\awk '{print $3}' <<<${line})
	if [ -d ${OVE_BASE_DIR}/${repo} ] && [ -d ${OVE_BASE_DIR}/${repo}/.git ]; then
		only_a+="  ${repo}|$(\git -C ${OVE_BASE_DIR}/${repo} log -1 --oneline --pretty="  %C(auto)%h|%s" ${sha_1})\n"
	else
		only_a+="${line:1}\n"
	fi
}

# helper function for diff/log/shortlog-project functions
function ove_extract_only_b {
	local line=${*}
	local repo
	local sha_1

	repo=$(\awk '{print $2}' <<<${line})
	sha_1=$(\awk '{print $3}' <<<${line})
	if [ -d ${OVE_BASE_DIR}/${repo} ] && [ -d ${OVE_BASE_DIR}/${repo}/.git ]; then
		only_b+="  ${repo}|$(\git -C ${OVE_BASE_DIR}/${repo} log -1 --oneline --pretty="  %C(auto)%h|%s" ${sha_1})\n"
	else
		only_b+="${line:1}\n"
	fi
}

# helper function for diff/log/shortlog-project functions
function ove_print_only_a_and_b {
	if [ "${only_a}" != "" ]; then
		echo
		ove_echo_yellow_noprefix "only in '$1':"
		printf "${only_a}" | \column -t -s'|'
	fi

	if [ "${only_b}" != "" ]; then
		echo
		ove_echo_yellow_noprefix "only in '$2':"
		printf "${only_b}" | \column -t -s'|'
	fi
}

# $1: repo
# $2: rev
function ove_validate_rev {
	local repo="$1"
	local revision="$2"

	if ! \git -C "${OVE_BASE_DIR}/${repo}" cat-file -e "${revision}" &> /dev/null; then
		ove_echo_error_noprefix "${repo}: '${revision}' is not a valid revision, try 'ove fetch ${repo}'"
		return 1
	fi
}

# helper function for diff/log/shortlog-project functions
function ove_extract_repo_and_sha {
	local line=${*}

	repo=$(\awk '{print $2}' <<<${line})
	sha_1=$(\awk '{print $3}' <<<${line})
	if ! ove_validate_rev ${repo} ${sha_1}; then
		return 1
	fi
	sha_2=$(\awk '{print $4}' <<<${line})
	if ! ove_validate_rev ${repo} ${sha_2}; then
		return 1
	fi
}

# diff-project:<rev> <rev>:diff the entire project
function ove-diff-project {
	local cmd
	local diff
	local line
	local only_a
	local only_b
	local repo
	local sha_1
	local sha_2

	ove_revtab_sanity_check "$@" || return $?

	cmd="\git -C ${OVE_PROJECT_DIR} diff --color=always $1 $2"
	diff=$(eval ${cmd})
	if [ "${diff}" != "" ]; then
		echo -e "${diff}" | ${OVE_PAGER} -Ps"${OVE_PROJECT_NAME}\:${cmd/./\\.}"
	fi

	while IFS= read -r line; do
		[ "${line}" == "" ] && break
		if [ ${line:0:1} == "a" ]; then
			ove_extract_only_a ${line}
		elif [ ${line:0:1} == "b" ]; then
			ove_extract_only_b ${line}
		elif [ ${line:0:1} == "c" ]; then
			ove_extract_repo_and_sha ${line} || continue
			cmd="\git -C ${OVE_BASE_DIR}/${repo} diff --color=always ${sha_1} ${sha_2}"
			diff=$(eval ${cmd})
			if [ "${diff}" != "" ]; then
				echo -e "${diff}" | ${OVE_PAGER} -Ps"${repo}\:${cmd/./\\.}"
			fi
		fi
	done <<<"$(ove-revtab-diff "$1" "$2")"

	ove_print_only_a_and_b $1 $2
}

# log-project:<rev> <rev>:git log the project '${OVE_PROJECT_NAME}'
function ove-log-project {
	local diff
	local line
	local only_a
	local only_b
	local repo
	local sha_1
	local sha_2

	ove_revtab_sanity_check "$@" || return $?

	diff=$(\git --no-pager -C "${OVE_PROJECT_DIR}" log --oneline --pretty="  %C(auto)%h %s" "$1".."$2")
	if [ "${diff}" != "" ]; then
		ove_echo_yellow_noprefix "${OVE_PROJECT_NAME}:"
		echo -e "${diff}"
	fi

	while IFS= read -r line; do
		[ "${line}" == "" ] && break
		if [ ${line:0:1} == "a" ]; then
			ove_extract_only_a ${line}
		elif [ ${line:0:1} == "b" ]; then
			ove_extract_only_b ${line}
		elif [ ${line:0:1} == "c" ]; then
			ove_extract_repo_and_sha ${line} || continue
			diff=$(\git --no-pager -C ${OVE_BASE_DIR}/${repo} log --oneline --pretty="  %C(auto)%h %s" ${sha_1}..${sha_2})
			if [ "${diff}" != "" ]; then
				echo
				ove_echo_yellow_noprefix "${repo}:"
				echo -e "${diff}"
			fi
		fi
	done <<<"$(ove-revtab-diff "$1" "$2")"

	ove_print_only_a_and_b $1 $2
}

# shortlog-project:<rev> <rev>:git shortlog the project
function ove-shortlog-project {
	local diff
	local line
	local only_a
	local only_b
	local repo
	local sha_1
	local sha_2

	ove_revtab_sanity_check "$@" || return $?

	diff=$(\git --no-pager -C "${OVE_PROJECT_DIR}" shortlog --email --oneline "$1".."$2")
	if [ "${diff}" != "" ]; then
		ove_echo_yellow_noprefix ${OVE_PROJECT_NAME}:
		echo -e "${diff}"
		echo
	fi

	while IFS= read -r line; do
		[ "${line}" == "" ] && break
		if [ ${line:0:1} == "a" ]; then
			ove_extract_only_a ${line}
		elif [ ${line:0:1} == "b" ]; then
			ove_extract_only_b ${line}
		elif [ ${line:0:1} == "c" ]; then
			ove_extract_repo_and_sha ${line} || continue
			diff=$(\git --no-pager -C ${OVE_BASE_DIR}/${repo} shortlog --email --oneline ${sha_1}..${sha_2} | \sed -e 's/^/  /g')
			if [ "${diff}" != "" ]; then
				ove_echo_yellow_noprefix "${repo}:"
				echo -e "${diff}"
				echo
			fi
		fi
	done <<<"$(ove-revtab-diff "$1" "$2")"

	ove_print_only_a_and_b $1 $2
}

# help function that will print OVE workspace info
#
# $1 = path to OVE workspace directory
function ove_locate_print {
	local num_projs
	local num_repos
	local ove_dir

	ove_dir="$1/.owel"

	! [ -d ${ove_dir} ] && return

	num_repos=$(\awk '{print $1}' ${ove_dir}/revtab | \
		\sed -e 's/#.*$//' -e '/^$/d' | \
		\wc -l)
	OVE_PROJECT_DIR=${ove_dir} num_projs=$(ove_list_projects | \
		\wc -w)
	\dirname ${ove_dir}
	[ -e "${ove_dir}/SETUP" ] && echo "  $(\cat ${ove_dir}/SETUP)"
	echo "  repos [${num_repos}]: $(\awk '{print $1}' ${ove_dir}/revtab | \
		\sed -e 's/#.*$//' -e '/^$/d' | \
		\tr '\n' ' ')"
	OVE_PROJECT_DIR=${ove_dir} echo "  projs [${num_projs}]: $(ove_list_projects)"
	echo
}

# setup: :print how to set this project up
function ove-setup {
	[ -e "${OVE_PROJECT_DIR}/SETUP" ] && \cat "${OVE_PROJECT_DIR}/SETUP"

	return 0
}

# refresh:[PATTERN...]:refresh OVE workspaces on this host
function ove-refresh {
	local i
	local p
	local proj_base
	local proj_list
	local projs
	local str

	mapfile -t projs < <(ove-locate | \grep '^/')
	if [ $# -eq 0 ]; then
		proj_list="$(seq 0 $((${#projs[@]} - 1)))"
	else
		i=0
		while ((i < ${#projs[@]})); do
			proj_base=${projs[i]##*/}
			for p in "$@"; do
				[[ "${proj_base,,}" =~ ${p,,} ]] && proj_list+="$i "
			done
			(( i+=1 ))
		done
	fi

	for i in ${proj_list}; do
		str+=$(printf "
			echo '$ # %s'
			echo '$ cd %s'
			cd %s
			ove_init
			echo '$ ove fetch'
			ove fetch
			if ove news > /dev/null; then
				ove news
				while true; do
					read -p '%s [?,a,A,c,d,n,p,q,s,x]? ' -r -n1
					echo
					if [[ \${REPLY} =~ ^[Pp]$ ]]; then
						echo '$ ove pull'
						ove pull
						echo
					elif [[ \${REPLY} =~ ^[a]$ ]]; then
						echo '$ ove ahead'
						ove ahead
						echo
					elif [[ \${REPLY} =~ ^[A]$ ]]; then
						echo '$ ove show-ahead'
						ove show-ahead
						echo
					elif [[ \${REPLY} =~ ^[Cc]$ ]]; then
						echo '$ ove checkout'
						ove checkout
						echo
					elif [[ \${REPLY} =~ ^[Dd]$ ]]; then
						echo '$ ove diff'
						ove diff
						echo
					elif [[ \${REPLY} =~ ^[Xx]$ ]]; then
						echo '$ ove pull'
						if ove pull; then
							break
						fi
						echo
					elif [[ \${REPLY} =~ ^[Ll]$ ]]; then
						echo '$ ove log'
						ove log
						echo
					elif [[ \${REPLY} =~ ^[s]$ ]]; then
						echo '$ ove status'
						ove status
						echo
					elif [[ \${REPLY} =~ ^[S]$ ]]; then
						echo '$ ove show-news'
						ove show-news
						echo
					elif [[ \${REPLY} =~ ^[Qq]$ ]]; then
						return
					elif [[ \${REPLY} =~ ^[Nn]$ ]]; then
						break
					elif [[ \${REPLY} =~ ^[?]$ ]]; then
						echo 'a - ahead'
						echo 'A - show ahead'
						echo 'c - checkout'
						echo 'd - diff'
						echo 'l - log'
						echo 'n - next'
						echo 'p - pull'
						echo 'q - quit'
						echo 's - status'
						echo 'S - show news'
						echo 'x - pull and next'
						echo '? - this help'
						continue
					fi
				done
			fi
			echo" $(ove_echo_green_noprefix ${projs[i]##*/}) ${projs[i]} ${projs[i]} $(ove_echo_green_noprefix ${projs[i]##*/}))
	done
	eval "${str}"
}

function ove_locate_owels {
	local a
	local b
	local diff
	local invalidate_cache
	local o
	local owels

	if [ -e "${OVE_GLOBAL_STATE_DIR}/owel.cache" ]; then
		a=$(\stat --format '%Y' "${OVE_GLOBAL_STATE_DIR}/owel.cache")
		b=$(\date +%s)
		if [ $((b-a)) -lt 600 ]; then
			for o in $(\cat "${OVE_GLOBAL_STATE_DIR}/owel.cache"); do
				if ! [ -d ${o} ]; then
					invalidate_cache=true
				fi

			done

			if ! [ "${invalidate_cache}" = true ]; then
				\cat "${OVE_GLOBAL_STATE_DIR}/owel.cache"
				return
			fi
		fi
	fi

	if command -v locate > /dev/null; then
		owels=$(\locate -e -r '\.owel$')
	else
		owels=$(\find ${OVE_LOCATE_SEARCH_DIR} -type l -name .owel 2> /dev/null)
	fi

	if [ "${owels}" == "" ]; then
		return 1
	fi

	for o in ${owels}; do
		if ! [ -e ${o}/revtab ]; then
			owels=${owels/${o}/}
		fi
	done

	owels=${owels//\/.owel/}

	\xargs -n1 <<<${owels} | \
		\tee "${OVE_GLOBAL_STATE_DIR}/owel.cache"
}

function ove_list_workspaces_full {
	local owel
	local owels

	owels=$(ove_locate_owels)

	if [ "${owels}" == "" ]; then
		ove_echo_error_noprefix "no OVE workspace(s) found"
		return 1
	fi

	for owel in ${owels}; do
		[ -O ${owel}/ove ] && echo ${owel}
	done | LC_ALL="C" \sort
}

function ove_list_workspaces_base {
	local owel

	for owel in $(ove_list_workspaces_full); do
		echo ${owel##*/}
	done | LC_ALL="C" \sort
}

# locate: :print OVE workspaces owned by you on this host
function ove-locate {
	local owel
	local owels

	owels=$(ove_list_workspaces_full)
	for owel in ${owels}; do
		ove_locate_print ${owel}
	done | \head -n -1
}

# locate-all: :print all OVE workspaces on this host
function ove-locate-all {
	local owel
	local owels

	owels=$(ove_locate_owels)
	if [ "${owels}" == "" ]; then
		ove_echo_error_noprefix "no OVE workspace(s) found"
		return 1
	fi

	for owel in ${owels}; do
		ove_locate_print ${owel}
	done | \head -n -1
}

# helper for ove_set_workspace
function ove_set_workspaces_helper {
	local i=0

	[ -z ${projs+x} ] && return 1
	[ ${#projs[@]} -eq 0 ] && return 1
	while ((i < ${#projs[@]})); do
		printf "%d # %s # %s\n" $((i + 1)) $(ove_echo_green_noprefix ${projs[i]##*/}) ${projs[i]}
		# shellcheck disable=SC2030
		(( i+=1 ))
	done | \column -t -s#
}

# move to a specific OVE workspace
# $1: PATTERN
function ove_set_workspace {
	local i=0
	local p
	local projs

	mapfile -t projs < <(ove-locate | \grep '^/')
	[ ${#projs[@]} -eq 0 ] && return 1
	if [ $# -eq 0 ]; then
		ove_set_workspaces_helper
		echo
		read -r -p "Workspace#: "
		if ! [[ "${REPLY}" =~ ^[0-9]+$ ]]; then
			[ "${REPLY}" != "" ] && \
				echo "error: just numbers"
			return 1
		fi

		if [ ${REPLY} -gt ${#projs[@]} ] || [ ${REPLY} -eq 0 ]; then
			echo "error: out of bounds"
			return 2
		fi

		eval $(printf "cd %s; . ove > /dev/null\n" ${projs[$((REPLY - 1))]})
	elif [ $# -eq 1 ]; then
		while ((i < ${#projs[@]})); do
			p=${projs[i]##*/}
			if [[ "${p,,}" =~ ${1,,} ]]; then
				eval $(printf "cd %s; . ove > /dev/null\n" ${projs[i]})
				return
			fi
			(( i+=1 ))
		done

		echo "error: workspace '$1' not found"
		echo "Your OVE workspace(s) on this host:"
		ove_set_workspaces_helper
		return 1
	fi
}

# branch:[GIT...]|[GIT... NAME]:list branch(es) OR create-and-checkout 'NAME' branch for 'GIT...' and update 'revtab' accordingly
function ove-branch {
	local a
	local args
	local branch_name
	local branch_start_point
	local cmd
	local i
	local r
	local repos

	if [ $# -lt 2 ]; then
		# shellcheck disable=SC2016
		cmd='ove_echo_yellow_noprefix ${repo_basename} && \git --no-pager -C ${repo} branch -vv; echo'
		if [ $# -eq 0 ]; then
		        ove_revtab_forall "${cmd}"
		else
		        ove_revtab_forsome "${cmd}" "$@"
		fi

		return 0
	fi

	read -r -a a <<<"$*"
	# all but last arg
	args=${a[*]:0:${#a[*]}-1}
	branch_name=${a[*]: -1}
	repos=$(ove_validate_repo_list ${args})
	if [ "${repos}" == "" ]; then
		echo "error: repo(s) '${args}' is not valid repo(s)"
		return 1
	fi

	for r in ${repos}; do
		if ! [ -d "${OVE_BASE_DIR}/${r}" ]; then
			echo "error: repo '${r}' is not yet fetched"
			continue
		fi

		while true; do
			read -r -p "${r}: starting point for branch '${branch_name}'? (leave empty to create branch from current HEAD): "
			[ "${REPLY}" == "" ] && break
			if ! \git -C "${OVE_BASE_DIR}/${r}" cat-file -e "${REPLY}" &> /dev/null; then
				ove_echo_error_noprefix "'${REPLY}' is not a valid revision for ${r}, try again"
				continue
			fi
			branch_start_point=${REPLY}
			break
		done

		# checkout branch
		if ! \git -C "${OVE_BASE_DIR}/${r}" checkout -b ${branch_name} ${branch_start_point} |& \sed "s|^|${r}: |g"; then
			continue
		fi

		[ -e "${OVE_PROJECT_DIR}/revtab" ] || continue
		[ "${OVE_PROJECT_NAME}" == "${r}" ] && continue

		# update revtab
		i=${ove_revtab_name2index[${r}]}
		\sed -i "s|^\(${r} .*\)${ove_revtab_rev[${i}]}|\1${branch_name}|g" "${OVE_PROJECT_DIR}/revtab"
	done
}

# remote:[GIT...]:git remote -v for all/specified git repositories
function ove-remote {
	local cmd

	# shellcheck disable=SC2016
	cmd='ove_echo_yellow_noprefix ${repo_basename} && \git --no-pager -C ${repo} remote -v'

	if [ $# -eq 0 ]; then
		ove_revtab_forall "${cmd}"
	else
		ove_revtab_forsome "${cmd}" "$@"
	fi
}

# remote-set-url:URL [GIT...]:change the URL of 'origin' remote for all/specified repositories
function ove-remote-set-url {
	local cmd
	local url

	[ $# -eq 0 ] && return 1
	url=$1
	shift

	# shellcheck disable=SC2016
	cmd='ove_echo_yellow_noprefix ${repo_basename} && \git --no-pager -C ${repo} remote set-url origin ${url}/${repo_basename} && \git --no-pager -C ${repo} remote -v'

	if [ $# -eq 0 ]; then
		ove_revtab_forall "${cmd}"
	else
		ove_revtab_forsome "${cmd}" "$@"
	fi
}

# remote-check: :sanity check that all remotes are online
function ove-remote-check {
	local i

	i=0
	while ((i < ove_revtab_num_repositories)); do
		if ! \git -C "${PWD}" ls-remote ${ove_revtab_fetch_url[${i}]} HEAD > /dev/null; then
			return 1
		fi

		(( i+=1 ))
	done
}

function ove_repo_is_dirty {
	if test -z "$(\git --no-pager -C ${1} status --porcelain -uno)"; then
		return 1
	else
		return 0
	fi
}

function ove_dirty_repos {
	local repo

	# shellcheck disable=SC2016
	for repo in $(ove_revtab_forall_parallel 'ove_repo_is_dirty ${repo} && echo ${PWD}'); do
		ove_repo2shortpath ${repo}
	done
}

function ove_stashed_repos {
	local repo

	# shellcheck disable=SC2016
	for repo in $(ove_revtab_forall_parallel 'test -z "$(\git --no-pager -C ${repo} stash show 2> /dev/null)" || echo ${PWD}'); do
		ove_repo2shortpath ${repo}
	done
}

# $1: drop or pop
function ove_stash_forsome {
	local cmd

	if ! [ -w "${OVE_PROJECT_STATE_DIR}" ]; then
		ove_echo_error_noprefix "you are not allowed to 'stash $1'"
		return 1
	fi

	! [ -f ${OVE_PROJECT_STATE_DIR}/ove-stashed-repos ] && return
	cmd="\git stash $1 -q"
	ove_revtab_forsome "${cmd}" "$(\sed "s|${OVE_BASE_DIR}/||g" ${OVE_PROJECT_STATE_DIR}/ove-stashed-repos | \xargs)"
	\rm ${OVE_PROJECT_STATE_DIR}/ove-stashed-repos
}

function ove_stash_pop {
	ove_stash_forsome pop
}

function ove_stash_drop {
	ove_stash_forsome drop
}

function ove_stash_save {
	local cmd
	local dirty_repos
	local now

	if ! [ -w "${OVE_PROJECT_STATE_DIR}" ]; then
		ove_echo_error_noprefix "you are not allowed to 'stash'"
		return 1
	fi

	[ -f ${OVE_PROJECT_STATE_DIR}/ove-stashed-repos ] && return

	dirty_repos=$(ove_dirty_repos)
	[ "${dirty_repos}" == "" ] && return

	true > ${OVE_PROJECT_STATE_DIR}/ove-stashed-repos
	now=$(\date '+%Y%m%d-%H%M%S')
	cmd="\git -C \${repo} stash save -q stashed by OVE@${now} && echo \${repo} >> ${OVE_PROJECT_STATE_DIR}/ove-stashed-repos"

	ove_revtab_forsome "${cmd}" "${dirty_repos}"
}

function ove_stash_inspect {
	local cmd
	local stashed_repos

	stashed_repos=$(ove_stashed_repos)
	[ "${stashed_repos}" == "" ] && return

	cmd="\git --no-pager -C \${repo} stash"
	if [ "$1" == "show" ]; then
		cmd+=" show -p"
	elif [ "$1" == "list" ]; then
		cmd+=" list"
	else
		return
	fi

	ove_revtab_forsome "ove_echo_yellow_noprefix \${repo_basename}: && ${cmd}" "${stashed_repos}"
}

function ove_stash_show {
	ove_stash_inspect show
}

function ove_stash_list {
	ove_stash_inspect list
}

# stash:[drop|list|pop|show]:git stash [drop|list|pop|show] for all git repositories
function ove-stash {
	if [ "$1" == "pop" ] ||
		[ "$1" == "list" ] ||
		[ "$1" == "show" ] ||
		[ "$1" == "drop" ]; then
		ove_stash_$1
	elif [ $# -eq 0 ]; then
		ove_stash_save
	else
		ove-help "^${FUNCNAME/ove-/} "
		return 1
	fi
}

# diff:[GIT...]:git diff for all/specified git repositories
function ove-diff {
	local cmd
	local repos

	cmd="\git --no-pager -C \${repo} diff-files --quiet || \
		(ove_echo_yellow_noprefix \${repo_basename} && \
		\git --no-pager -C \${repo} diff --color=always ${OVE_DIFF_OPTIONS})"

	[ $# -eq 0 ] && repos="$(ove_dirty_repos)" || repos="$*"

	ove_revtab_forsome "${cmd}" "${repos}" | ${OVE_PAGER}
}

# wdiff:[GIT...]:git diff (word diff) for all/specified git repositories
function ove-wdiff {
	local OVE_DIFF_OPTIONS

	OVE_DIFF_OPTIONS="--color-words=."
	ove-diff "$@"
}

# wdiff-cached:[GIT...]:git diff --cached (word diff) for all/specified git repositories
function ove-wdiff-cached {
	local OVE_DIFF_OPTIONS

	OVE_DIFF_OPTIONS="--color-words=."
	ove-diff-cached "$@"
}

# diff-cached:[GIT...]:git diff --cached for all/specified repositories
function ove-diff-cached {
	local cmd
	local repos

	cmd="\git --no-pager -C \${repo} diff-index --quiet --cached HEAD -- || \
		(ove_echo_yellow_noprefix \${repo_basename} && \
		\git --no-pager -C \${repo} diff --color=always --cached ${OVE_DIFF_OPTIONS})"

	[ $# -eq 0 ] && repos="$(ove_dirty_repos)" || repos="$*"

	ove_revtab_forsome "${cmd}" "${repos}" | ${OVE_PAGER}
}

# reset:[GIT...]:git reset -p for all/specified repositories
function ove-reset {
	local cmd

	# shellcheck disable=SC2016
	cmd='\git --no-pager -C ${repo} diff-index --quiet --cached HEAD -- ||'
	# shellcheck disable=SC2016
	cmd+=' (ove_echo_yellow_noprefix ${repo_basename} && \git -C ${repo} reset -p)'

	if [ $# -eq 0 ]; then
		ove_revtab_forall "${cmd}"
	else
		ove_revtab_forsome "${cmd}" "$@"
	fi
}

# reset-hard:[GIT...]:git reset --hard for all/specified repositories, use with care
function ove-reset-hard {
	local cmd

	# shellcheck disable=SC2016
	cmd='\git -C ${repo} reset -q --hard'

	if [ $# -eq 0 ]; then
		ove_revtab_forall "${cmd}"
	else
		ove_revtab_forsome "${cmd}" "$@"
	fi
}

# add:[GIT...]:git add -p for all/specified repositories
function ove-add {
	local cmd
	local repos

	# shellcheck disable=SC2016
	cmd='\git --no-pager -C ${repo} diff-files --quiet ||'
	# shellcheck disable=SC2016
	cmd+=' (ove_echo_yellow_noprefix ${repo_basename} && \git --no-pager -C ${repo} add -p)'

	[ $# -eq 0 ] && repos="$(ove_dirty_repos)" || repos="$*"

	ove_revtab_forsome "${cmd}" "${repos}"
}

# commit:[GIT...]:git commit for all/specified git repositories
function ove-commit {
	local cmd

	cmd="\git --no-pager -C \${repo} diff --cached --quiet || \
		(ove_echo_yellow_noprefix \${repo_basename} && \
		\git -C \${repo} commit -t <(echo; echo \# git: \${repo}; echo \#; \git -C \${repo} diff --cached -U0 | \sed 's/^/# /g'))"

	if [ $# -eq 0 ]; then
		ove_revtab_forsome "${cmd}" "$(ove_dirty_repos)"
	else
		ove_revtab_forsome "${cmd}" "$@"
	fi
}

# list-missing-projects:[PROJECT...]:list any missing project(s)
function ove-list-missing-projects {
	local d
	declare -A m
	local projs

	if [ $# -eq 0 ]; then
		projs="${OVE_PROJECT_LIST}"
	else
		projs="${*}"
	fi

	for d in $(ove_get_deps_recursive ${projs}); do
		[[ -v ove_projects_name2index[${d}] ]] || m[${d}]=
	done

	if [ ${#m[@]} -ne 0 ]; then
		\xargs -n1 <<<"${!m[@]}" | LC_ALL="C" \sort
	fi
}

# $* = proj(s)
function ove_get_deps_recursive {
	local dep
	local i
	local proj

	for proj in "$@"; do
		[[ -v ove_projects_name2index[${proj}] ]] || continue
		i=${ove_projects_name2index[${proj}]}
		for dep in ${ove_projects_deps[${i}]}; do
			echo -n "${dep} "
			ove_get_deps_recursive ${dep}
		done
	done
}

# $1 = proj
function ove_get_paths_recursive {
	local dep
	local i

	[ $# -ne 1 ] && return 1

	[[ -v ove_projects_name2index[${1}] ]] || return
	i=${ove_projects_name2index[$1]}

	if [ "${ove_projects_deps[${i}]}" == "" ]; then
		echo -n "${OVE_BASE_DIR}/${ove_projects_path[${i}]} "
		return
	fi

	for dep in ${ove_projects_deps[${i}]}; do
		echo -n "${OVE_BASE_DIR}/${ove_projects_path[${i}]} "
		ove_get_paths_recursive ${dep}
	done
}

function ove_validate_revtab {
	local d
	local doublets

	[ ! -e "${OVE_PROJECT_DIR}/revtab" ] && return

	doublets="$(\grep -E -v '^$|^#' ${OVE_PROJECT_DIR}/revtab | \
		\awk 'a[$1]++{print $1}')"

	# check for doublets
	if [ "${doublets}" != "" ]; then
		ove_echo_error_noprefix "found repo doublet(s) in '${OVE_PROJECT_DIR}/revtab':"

		for d in ${doublets}; do
			\grep -n "^${d} " ${OVE_PROJECT_DIR}/revtab
		done
		return 1
	fi
}

function ove_validate_self {
	local funcs

	if \grep ^function ${OVE_SELF} | \grep -q -v 'function ove'; then
		ove_echo_error_noprefix "functions need to start with 'ove-' or 'ove_'"
		\grep ^function ${OVE_SELF} | \grep -v 'function ove'
		return 1
	fi

	funcs=$(\grep -B1 '^function ove-' ${OVE_SELF})

	if [ "$(\grep '^$' -A1 <<< "${funcs}" | \
		\awk '{print $2}' | \
		\xargs)" != "" ]; then
		ove_echo_error_noprefix "add help for the following function(s):"
		\grep '^$' -A1 <<< "${funcs}" | \
			\awk '{print $2}' | \
			\xargs
		return 1
	fi

	OVE_BUILT_INS_WITHOUT_ARGS=$(\grep ': :' <<< "${funcs}" | \
		\cut -b3- | \
		\cut -d: -f1 | \
		LC_ALL="C" \sort | \
		\tr '\n' ' ' | \
		\xargs "${OVE_ECHO}")

	export OVE_BUILT_INS_WITHOUT_ARGS
}

function ove_validate_projs {
	local d
	local doublets
	local i

	[ ! -e "${OVE_PROJECT_DIR}/projs" ] && return

	i=0
	while ((i < ove_number_of_projects)); do
		if [ "${ove_projects_deps[${i}]}" != "" ]; then
			for d in ${ove_projects_deps[${i}]}; do
				echo "${ove_projects_name[${i}]} ${d}"
			done
		fi
		(( i+=1 ))
	done | \tsort > /dev/null

	# shellcheck disable=SC2181
	if [ $? -ne 0 ]; then
		ove_echo_error_noprefix "circular dependency in '${OVE_PROJECT_DIR}/projs', see output from 'tsort' above"
		return 1
	fi

	doublets=$(\grep -o '^[a-zA-Z0-9_]\+' ${OVE_PROJECT_DIR}/projs | \
		\awk 'a[$1]++{print $1}')

	if [ "${doublets}" != "" ]; then
		ove_echo_error_noprefix "found project doublet(s) in '${OVE_PROJECT_DIR}/projs':"

		for d in ${doublets}; do
			\grep -n "^${d}:" ${OVE_PROJECT_DIR}/projs
		done
		return 1
	fi
}

# $@: a list of packages
function ove_install_packages {
	local cmd
	local missing_packages
	local missing_packages_sorted

	missing_packages=$(ove_packages_not_installed "$@")

	# no missing packages?
	[ "${missing_packages}" == "" ] && return

	# sort the list
	missing_packages_sorted="$(\xargs -n1 "${OVE_ECHO}" <<<${missing_packages} | \
		LC_ALL="C" \sort -u | \
		\xargs "${OVE_ECHO}")"

	if [ "${OVE_DRY_RUN}" -eq 1 ]; then
		ove_echo_yellow "would prompt to install this/these package(s):"
		\xargs -n1 <<<${missing_packages_sorted}
		return
	fi

	if [ "${OVE_OS_PACKAGE_MANAGER}" == "unknown" ]; then
		ove_echo_error_noprefix "${FUNCNAME[0]}: fatal: package manager is not set"
		return 1
	fi

	if ! command -v ${OVE_OS_PACKAGE_MANAGER} > /dev/null; then
		ove_echo_command_not_found "${OVE_OS_PACKAGE_MANAGER}"
		return 2
	fi

	cmd="${OVE_OS_PACKAGE_MANAGER} ${OVE_OS_PACKAGE_MANAGER_ARGS} ${missing_packages_sorted}"

	echo "missing package(s):"
	echo
	echo "To fix this, run the following command:"
	echo
	[ ${EUID} != 0 ] && cmd="sudo ${cmd}"
	echo -e "\t${cmd}"
	echo
	return 1
}

# export:[PROJECT...]:export project(s)
function ove-export {
	local attr
	local b
	local deps
	local i
	local paths
	local projs
	local re
	local tmp_var

	\mkdir -p ${OVE_PROJECT_TMP_DIR}/export ${OVE_PROJECT_TMP_DIR}/export/projects
	true > ${OVE_PROJECT_TMP_DIR}/export/revtab
	true > ${OVE_PROJECT_TMP_DIR}/export/projs
	[ -d ${OVE_PROJECT_TMP_DIR}/export/projects ] && \rm -rf ${OVE_PROJECT_TMP_DIR}/export/projects

	while true; do
		if [ $# -ge 1 ]; then
			if ! [[ -v ove_projects_name2index[$1] ]]; then
				ove_echo_error_noprefix "unknown project '$1'"
				shift
				[ $# -eq 0 ] && break
				continue
			fi

			deps=$(ove_get_deps_recursive $1)
		fi

		for b in $(\xargs -n1 <<<${OVE_BUILD_ORDER} | LC_ALL="C" \sort); do
			if [ $# -ge 1 ]; then
				re=\\b${b}\\b
				if ! [[ "${deps}" =~ ${re} ]] && [ "${b}" != "$1" ]; then
					continue
				fi
			fi

			# already exported?
			if \grep -q ^${b}: ${OVE_PROJECT_TMP_DIR}/export/projs; then
				continue
			fi

			projs+="${b} "
			str+="${b}:\n"
			i=${ove_projects_name2index[${b}]}
			for attr in $(ove_projects_attributes); do
				tmp_var="ove_projects_${attr}[${i}]"
				[ "${!tmp_var}" != "" ] && \
					str+="  ${attr}:\n$(\tr ' ' '\n' <<<${!tmp_var} | \
					LC_ALL="C" \sort -u | \
					\sed -e 's|^|    |g')\n"

				paths+="${OVE_BASE_DIR}/${ove_projects_path[${i}]} "
			done
			str+="\n"
		done

		printf "${str}" | \sed '$ d' > ${OVE_PROJECT_TMP_DIR}/export/projs

		for b in ${projs}; do
			\mkdir -p ${OVE_PROJECT_TMP_DIR}/export/projects/${b}
			if \find ${OVE_PROJECT_DIR}/projects/${b} -mindepth 1 -print -quit 2> /dev/null | \grep -q .; then
				\cp -ar ${OVE_PROJECT_DIR}/projects/${b}/* ${OVE_PROJECT_TMP_DIR}/export/projects/${b}
			fi
		done

		shift
		[ $# -eq 0 ] && break
	done

	! [ -s ${OVE_PROJECT_TMP_DIR}/export/projs ] && return 1

	# YAML header
	\sed -i '1i ---' ${OVE_PROJECT_TMP_DIR}/export/projs

	for b in $(\tr ' ' '\n' <<<${paths} | LC_ALL="C" \sort -u); do
		while true; do
			[ "${b}" == "" ] && break
			if \xargs -n 1 <<<${OVE_REPO_LIST} 2> /dev/null | \grep -q ^${b}$; then
				ove-list-repositories | \grep "^$(ove_repo2shortpath ${b}) " >> ${OVE_PROJECT_TMP_DIR}/export/revtab
				break
			fi
			b="${b%/*}"
		done
	done
	LC_ALL="C" \sort -u -o ${OVE_PROJECT_TMP_DIR}/export/revtab ${OVE_PROJECT_TMP_DIR}/export/revtab

	\tree ${OVE_PROJECT_TMP_DIR}/export
	\tar -C "${OVE_PROJECT_TMP_DIR}/export" -cjf "${OVE_PROJECT_TMP_DIR}/export.tar.bz2" .
	echo
	echo "${OVE_PROJECT_TMP_DIR}/export.tar.bz2"

	return 0
}

# import:[FILE]:import project(s), see export
function ove-import {
	local f

	if [ $# -eq 0 ]; then
		f="${OVE_PROJECT_TMP_DIR}/export.tar.bz2"
	elif [ $# -eq 1 ]; then
		f="$1"
	else
		echo "error: too many args"
		return 1
	fi

	if ! [ -s "${f}" ]; then
		echo "error: file '${f}' is not found or file size is 0"
		return 2
	fi

	\tar -C "${OVE_PROJECT_DIR}" -xf "${f}"
}

function ove_build_pre {
	local p
	local q
	local re
	local repos

	if [ $# -eq 0 ]; then
		if [ -n "${OVE_PROJECT_LIST_BUILDABLE+x}" ] && \
			[ "${OVE_PROJECT_LIST_BUILDABLE}" != "${OVE_PROJECT_LIST}" ]; then
			ove_echo_error_noprefix "'$(LC_ALL="C" \comm -3 \
				<(\xargs -n1 <<<${OVE_PROJECT_LIST} | LC_ALL="C" \sort) \
				<(\xargs -n1 <<<${OVE_PROJECT_LIST_BUILDABLE} | LC_ALL="C" \sort) |
				\xargs)' is not buildable project(s). Try: 'ove fetch'"
			return 1
		fi
	else
		while true; do
			if ! [[ -v ove_projects_name2index[$1] ]]; then
				ove_echo_error_noprefix "unknown project '$1'"
				return 1
			fi

			if [ -n "${OVE_PROJECT_LIST_BUILDABLE+x}" ]; then
				re=\\b$1\\b
				if ! [[ "${OVE_PROJECT_LIST_BUILDABLE}" =~ ${re} ]]; then
					for p in $(ove_get_paths_recursive $1 | \xargs -n1 | LC_ALL="C" \sort -u); do
						[ -d ${p} ] && continue
						for q in ${OVE_REPO_LIST}; do
							if [[ ${p} == *"${q}"* ]] && ! [ -d "${q}" ]; then
								repos+="$(ove_repo2shortpath ${q}) "
							fi
						done
					done
					if [ "${repos}" != "" ]; then
						repos=$(\xargs -n1 <<<${repos} | LC_ALL="C" \sort -u | \xargs)
						ove_echo_error_noprefix "'$1' is not a buildable project. Try: 'ove fetch ${repos}'"
					fi
					return 1
				fi
			fi
			shift
			[ $# -eq 0 ] && break
		done
	fi

	# create stage/archive directories if needed
	[ ! -d "${OVE_STAGE_DIR}" ] && \mkdir -p "${OVE_STAGE_DIR}"
	[ ! -d "${OVE_ARCHIVE_DIR}" ] && \mkdir -p "${OVE_ARCHIVE_DIR}"

	return 0
}

function ove_build_post {
	local f

	if [ -d ${OVE_STAGE_DIR} ] && \
		[ "$(\find ${OVE_STAGE_DIR} -maxdepth 1)" == "${OVE_STAGE_DIR}" ]; then
		f+="${OVE_STAGE_DIR} "
	fi

	if [ -d ${OVE_ARCHIVE_DIR} ] && \
		[ "$(\find ${OVE_ARCHIVE_DIR} -maxdepth 1)" == "${OVE_ARCHIVE_DIR}" ]; then
		f+="${OVE_ARCHIVE_DIR} "
	fi

	[ "${f}" != "" ] && \rmdir ${f}
}

function ove_get_build_list {
	local b

	b="$(ove_get_deps_recursive "$@") $*"
	b="$(\xargs -n1 <<<${b} | LC_ALL="C" \sort -u | \xargs)"

	echo ${b}
}

# install-pkg:[PROJECT...]:install needed OS packages
function ove-install-pkg {
	local b
	local build_list
	local i
	local n
	local p
	local pack_list
	local re

	if ! ove_build_pre "$@"; then
		return 1
	fi

	trap ove_build_post EXIT

	if [ $# -ge 1 ]; then
		for p in "$@"; do
			if ! [[ -v ove_projects_name2index[${p}] ]]; then
				ove_echo_error_noprefix "unknown project '${p}'"
				return 1
			fi
		done

		build_list="$(ove_get_build_list "$@")"
	fi

	for b in ${OVE_BUILD_ORDER}; do
		if [ $# -ge 1 ]; then
			re=\\b${b}\\b
			if ! [[ "${build_list}" =~ ${re} ]]; then
				continue
			fi
		fi

		i=${ove_projects_name2index[${b}]}
		for n in ${ove_projects_needs[${i}]}; do
			pack_list+="${n} "
		done
	done

	# install packages
	if [ "${pack_list}" != "" ]; then
		if ! ove_install_packages ${pack_list}; then
			ove_echo_error_noprefix "${FUNCNAME[0]}: missing package(s)"
			return 1
		fi
	fi
}

# buildme:[PROJECT...]:build project(s) from scratch (=bootstrap, configure, build, install)
function ove-buildme {
	local b
	local build_list
	local p
	local re

	# install packages
	if ! ove-install-pkg "$@"; then
		return 1
	fi

	if [ $# -ge 1 ]; then
		build_list="$(ove_get_build_list "$@")"
	fi

	# bootstrap
	for b in ${OVE_BUILD_ORDER}; do
		if [ $# -ge 1 ]; then
			re=\\b${b}\\b
			if ! [[ "${build_list}" =~ ${re} ]]; then
				continue
			fi
		fi

		! [ -e "${OVE_PROJECT_DIR}/projects/${b}/bootstrap" ] && continue

		if [ "$(type -t ove-bootstrap)" == "function" ] && \
			! eval ove-bootstrap ${b} ${OVE_REDIRECT_OUTPUT}; then
			ove_echo_error_noprefix "${FUNCNAME[0]}: ove-bootstrap ${b} failed"
			return 1
		fi
	done

	for b in ${OVE_BUILD_ORDER}; do
		if [ $# -ge 1 ]; then
			re=\\b${b}\\b
			if ! [[ "${build_list}" =~ ${re} ]]; then
				continue
			fi
		fi

		for p in configure build install; do
			if [ "$(type -t ove-${p})" == "function" ] && \
				! eval ove-${p} ${b} ${OVE_REDIRECT_OUTPUT}; then
				ove_echo_error_noprefix "${FUNCNAME[0]}: ove-${p} ${b} failed"
				return 1
			fi
		done
	done

	return 0
}

# buildme-parallel:[PROJECT...]:build project(s) from scratch (=bootstrap, configure, build, install)
function ove-buildme-parallel {
	local b
	local build_list
	local dep
	local inotify_max_user_instances
	local p
	local pid
	local pids
	local re
	local wait_for_deps

	# install packages
	if ! ove-install-pkg "$@"; then
		return 1
	fi

	if [ $# -ge 1 ]; then
		build_list="$(ove_get_build_list "$@")"
	fi

	# bootstrap
	for b in ${OVE_BUILD_ORDER}; do
		if [ $# -ge 1 ]; then
			re=\\b${b}\\b
			if ! [[ "${build_list}" =~ ${re} ]]; then
				continue
			fi
		fi

		! [ -e "${OVE_PROJECT_DIR}/projects/${b}/bootstrap" ] && continue

		{
			if [ "$(type -t ove-bootstrap)" == "function" ] && \
				! eval ove-bootstrap ${b} ${OVE_REDIRECT_OUTPUT}; then
				ove_echo_error_noprefix "${FUNCNAME[0]}: bootstrap ${b} failed"
				kill -USR1 $$
			fi
		} &
		pids+="$! "
	done

	wait ${pids}
	pids=""

	# pids db
	declare -A pids_db=()

	inotify_max_user_instances=$(($(\cat /proc/sys/fs/inotify/max_user_instances) - 20))
	for b in ${OVE_BUILD_ORDER}; do
		if [ $# -ge 1 ]; then
			re=\\b${b}\\b
			if ! [[ "${build_list}" =~ ${re} ]]; then
				continue
			fi
		fi

		wait_for_deps=""
		for dep in $(ove_get_deps_recursive ${b}); do
			if ! [ -e /proc/${pids_db[${dep}]} ]; then
				pids_db[${dep}]=""
				continue
			fi

			wait_for_deps+="${pids_db[${dep}]} "
		done

		{
			for p in ${wait_for_deps}; do
				\tail -s 0.01 --pid=${p} -f /dev/null &
			done
			[ "${wait_for_deps}" != "" ] && wait

			for p in configure build install; do
				if [ "$(type -t ove-${p})" == "function" ] && \
					! eval ove-${p} ${b} ${OVE_REDIRECT_OUTPUT}; then
					ove_echo_error_noprefix "${FUNCNAME[0]}: ${p} ${b} failed"
					kill -USR1 $$
				fi
			done
		} &
		pid=$!
		pids_db[${b}]=${pid}
		pids+=" ${pid}"

		while true; do
			if [ $(\pgrep -f 'tail -s 0.01' | \wc -l) -gt ${inotify_max_user_instances} ]; then
				sleep 0.1
				continue
			fi
			break
		done
	done

	wait ${pids}

	return 0
}

# diff-check:[OPTIONS]:git diff --check [OPTIONS]
function ove-diff-check {
	local cmd

	cmd="echo \${PWD}; \git --no-pager -C \${repo} diff --check $* -- \$(\git -C \${repo} diff --name-only)"
	ove_revtab_forall "${cmd}"
}

# list-repositories: :list all git repositories
function ove-list-repositories {
	ove_revtab_list
}

# env:[PATTERN]:show OVE env
function ove-env {
	local e
	local str
	local v

	if [ $# -eq 0 ]; then
		v=$(compgen -A variable | \grep OVE_)
	else
		v=$(compgen -A variable | \grep OVE_ | \grep -i $1)
	fi

	for e in ${v}; do
		str+="${e}:${!e}\n"
	done

	printf "${str}" | \
		LC_ALL="C" \sort | \
		\column -t -s:
}

# status:[GIT...]:git status -zbs -uno for all/specified repositories
function ove-status {
	# turn off monitor mode to get rid of "Done" messages
	set +m

	ove_revtab_status "$@" | \
		\grep -v '^\['

	# turn on monitor mode
	set -m
}

# news:[GIT...]:list upstream changes for all/specified repositories
function ove-news {
	if [ -w "${OVE_PROJECT_STATE_DIR}" ]; then
		ove_revtab_status_parse behind "$@" | \tee ${OVE_PROJECT_STATE_DIR}/revtab-news
	else
		ove_revtab_status_parse behind "$@"
	fi
}

# show-news:[GIT...]:run 'ove show' on upstream changes for all/specified repositories
function ove-show-news {
	local sha_list

	# refresh news
	ove-news "$@" > /dev/null

	sha_list="$(\grep -o '^[a-f0-9]\+' ${OVE_PROJECT_STATE_DIR}/revtab-news | \tac)"
	[ "${sha_list}" == "" ] && return

	ove-show ${sha_list}
}

# ahead:[GIT...]:list local commits not yet published for all/specified repositories
function ove-ahead {
	if [ -w "${OVE_PROJECT_STATE_DIR}" ]; then
		ove_revtab_status_parse ahead "$@" | \tee ${OVE_PROJECT_STATE_DIR}/revtab-ahead
	else
		ove_revtab_status_parse ahead "$@"
	fi
}

# show-ahead:[GIT...]:run 'ove show' on local commits not yet published for all/specified repositories
function ove-show-ahead {
	local sha_list

	# refresh ahead
	ove-ahead "$@" > /dev/null

	sha_list="$(\grep -o '^[a-f0-9]\+' ${OVE_PROJECT_STATE_DIR}/revtab-ahead | \tac)"
	[ "${sha_list}" == "" ] && return

	ove-show ${sha_list}
}

# reset-ahead: :git reset --hard HEAD~N where N is #commits ahead for ALL repositories
function ove-reset-ahead {
	ove-ahead | \
		\sed -r \
		-e "s/\x1b\[1;3[0-9];7m//g" \
		-e "s/\x1b\[[0-9]+m//g" \
		-e "s/\x1b\[m//g" | \
		\grep --color=never ': [0-9]\+ new commit' | \
		while IFS=' ' read -r repo n foo bar; do
			repo=${repo/:/}
			\git -C ${OVE_BASE_DIR}/${repo} reset --hard HEAD~${n} |& \sed -e "s/^/${repo}: /g"
		done
}

# format-patch:[NAME]:create a bz2 archive for all local commits not yet published
function ove-format-patch {
	local d
	local f

	d="${OVE_PROJECT_TMP_DIR}/format-patch"
	\mkdir -p ${d}
	\find ${d} -mindepth 1 -maxdepth 1 -type d -exec rm -rf {} \;

	ove-ahead | \
		\sed -r \
		-e "s/\x1b\[1;3[0-9];7m//g" \
		-e "s/\x1b\[[0-9]+m//g" \
		-e "s/\x1b\[m//g" | \
		\grep --color=never ': [0-9]\+ new commit' | \
		while IFS=' ' read -r repo n foo bar; do
			repo=${repo/:/}
			\mkdir -p ${d}/${repo}
			\git -C ${OVE_BASE_DIR}/${repo} format-patch -q -${n} -o ${d}/${repo}
		done

	[ $(\find ${d} -type f | \wc -l) -eq 0 ] && return || \tree -a "${d}"

	echo
	if [ $# -eq 1 ]; then
		f="$1"
	else
		f="${PWD}/${OVE_PROJECT_NAME}-patches-$(\date '+%Y%m%d-%H%M%S').tar.bz2"
	fi

	\tar -C "${d}" -cjf "${f}" .
	\ls -lh "${f}"
}

# am:FILE:apply a bz2 archive file created with 'format-patch'
function ove-am {
	local d
	local r
	local repos

	[ $# -eq 1 ] || return 1
	[ -e $1 ] || return 2

	d="${OVE_PROJECT_TMP_DIR}/am"
	\mkdir -p ${d}
	\find ${d} -mindepth 1 -maxdepth 1 -type d -exec rm -rf {} \;

	# unpack
	\tar -C "${d}" -xf "$1" || return 3

	repos=$(\find ${d} -type f -print0 | \xargs -0 dirname | LC_ALL="C" \sort -u)
	[ "${repos}" == "" ] && return 4
	for r in ${repos}; do
		r=${r/${d}\/}

		ove_echo_yellow_noprefix ${r}
		# apply patch(es)
		if ! \git -C ${OVE_BASE_DIR}/${r} am ${d}/${r}/*; then
			\git -C ${OVE_BASE_DIR}/${r} am --abort
		fi
	done
}

# $1: behind|ahead
function ove_any_repo {
	ove_revtab_status &> /dev/null

	if \grep -q "${1}.*]" ${OVE_PROJECT_STATE_DIR}/revtab-status; then
		return 0
	else
		return 1
	fi
}

# $1: behind|ahead
function ove_list_repos {
	[ -e ${OVE_PROJECT_STATE_DIR}/revtab-status ] || return

	\grep "${1}.*]" ${OVE_PROJECT_STATE_DIR}/revtab-status | \cut -d: -f1
}

# pull:[GIT...]:git pull --rebase for all/specified repositories
function ove-pull {
	local repo
	local repos

	# turn off monitor mode to get rid of "Done" messages
	set +m

	if [ $# -ge 1 ]; then
		for repo in $(ove_validate_repo_list ${*//${OVE_BASE_DIR}\/}); do
			if ove_repo_is_dirty ${OVE_BASE_DIR}/${repo}; then
				ove_echo_error_noprefix "cannot pull '${repo}' as it is dirty"
				continue
			fi
			repos+="${repo} "
		done
	else
		if ove_any_repo behind; then
			for repo in $(ove_list_repos behind); do
				if ove_repo_is_dirty ${OVE_BASE_DIR}/${repo}; then
					ove_echo_error_noprefix "cannot pull '${repo}' as it is dirty"
					continue
				fi

				repos+="${repo} "
			done
		else
			repos=${OVE_REPO_LIST//${OVE_BASE_DIR}\/}
		fi
	fi

	for repo in ${repos}; do
		ove_revtab_pull_one ${repo} | \grep -v '^\['
		if [ ${PIPESTATUS[0]} -ne 0 ]; then
			return 1
		fi

		if [ "${repo##*/}" == "${OVE_PROJECT_NAME}" ]; then
			ove_revtab_check
		fi
	done

	if [ "${repos}" != "" ]; then
		ove_revtab_status ${repos} | \grep -v '^\['
	fi

	# turn on monitor mode
	set -m
}

# apply:PATCH:apply one OVE patch
function ove-apply {
	local lineno
	local p
	local patches
	local q
	local repo_basename

	if [ $# -ne 1 ]; then
		ove-help "^${FUNCNAME/ove-/} "
		return 1
	fi

	if ! command -v csplit > /dev/null; then
		ove_echo_command_not_found "csplit"
		return 1
	fi

	if ! [ -e "$1" ]; then
		ove_echo_error_noprefix "'$1' patch file not found"
		return 1
	fi

	if ! [ -s "$1" ]; then
		ove_echo_error_noprefix "'$1' is empty"
		return 1
	fi

	\cp -a "$1" "${OVE_PROJECT_TMP_DIR}"
	cd ${OVE_PROJECT_TMP_DIR} || return 1
	p="${OVE_PROJECT_TMP_DIR}/${1##*/}"

	# get a list of line numbers where to split the file
	lineno=$(\grep -n "${ove_yellow_x}" "${p}"| \tail -n +2 | \cut -d: -f1 | \xargs)

	# remove color codes
	\sed -i \
		-r \
		-e "s/\x1b\[1;3[0-9];7m//g" \
		-e "s/\x1b\[[0-9]+m//g" \
		-e "s/\x1b\[m//g" ${p}

	if ! \file "${p}" | \grep -q "unified diff"; then
		ove_echo_error_noprefix "'${p}' is not a unified diff"
		return 1
	fi

	# remove any old patch file(s)
	\find ${PWD} -maxdepth 1 -name 'ove-apply-patch*' -exec rm {} \;

	if [ "${lineno}" == "" ]; then
		patches=${p}
	else
		# one patch per git
		if ! \csplit -s -z --prefix ove-apply-patch ${p} ${lineno}; then
			ove_echo_error_noprefix "ops, csplit failed"
			return 1
		fi

		patches=$(\find ${PWD} -maxdepth 1 -name 'ove-apply-patch*' | LC_ALL="C" \sort)
	fi

	for p in ${patches}; do
		repo_basename=$(\head -1 -q ${p})
		repo_basename=${repo_basename/${OVE_BASE_DIR}\/}
		repo_fullpath=$(ove_repo2fullpath ${repo_basename})
		if [ "${repo_fullpath}" == "" ] || ! [ -d "${repo_fullpath}" ]; then
			ove_echo_error_noprefix "'${repo_basename}': unknown repo, next..."
			continue
		fi

		# rename the patch
		q="${OVE_PROJECT_TMP_DIR}/ove-apply-${repo_basename////-}.patch"
		\mv ${p} ${q}
		if [ -d "${repo_fullpath}" ] && \
			[ -d ${repo_fullpath}/.git ]; then
			# Run 'git apply --check' and if ok, apply the patch
			if ! \git -C "${repo_fullpath}" apply --check ${q} 2> /dev/null; then
				ove_echo_yellow_noprefix "${repo_basename}: patch '${ove_yellow}${q}${ove_blank}' does not apply without errors"
				continue
			fi

			# apply the patch
			\git -C "${repo_fullpath}" apply ${q}
		fi
	done

	return 0
}

function ove_patch_repositories {
	! [ -d ${OVE_PROJECT_DIR}/patches ] && return

	# shellcheck disable=SC2016
	ove_revtab_forall '[ -d ${OVE_PROJECT_DIR}/patches/${repo_basename} ] &&
		for p in $(\find ${OVE_PROJECT_DIR}/patches/${repo_basename} -name "*.patch"); do
			if \git -C ${repo} apply --check $p 2> /dev/null; then
				echo "${repo_basename}: apply patch: $p"
				\git -C ${repo} apply $p 2> /dev/null
			fi
		done'
}

# gitmodules2revtab: :import git submodules
function ove-gitmodules2revtab {
	local repo
	local repos_with_submodules
	local sha
	local submodule

	for repo in ${OVE_REPO_LIST}; do
		[ -s ${repo}/.gitmodules ] && repos_with_submodules+="${repo} "
	done

	[ "${repos_with_submodules}" == "" ] && return

	for repo in ${repos_with_submodules}; do
		for submodule in $(\git -C ${repo} submodule--helper list | \awk '{print $4}'); do
			url=$(\git -C ${repo} config --file .gitmodules --list | \
				\grep "^submodule.${submodule}.url=" | \
				\cut -d= -f2)
			[ "${url}" == "" ] && continue

			sha=$(\git -C ${repo} submodule--helper list | \
				\awk '{print $4,$2}' | \
				\grep "^${submodule} " | \awk '{print $2}')
			[ "${sha}" == "" ] && continue

			echo "${repo//${OVE_BASE_DIR}\/}/${submodule} ${url} ${url} ${sha}"
		done
	done >> ${OVE_PROJECT_DIR}/revtab

	# sort and prettify
	LC_ALL="C" \sort -u -o ${OVE_PROJECT_DIR}/revtab <(\column -t ${OVE_PROJECT_DIR}/revtab)
}

# do:DIR COMMAND:run a command within DIR relative to ${OVE_BASE_DIR}
function ove-do {
	local cmd
	local dir

	dir=${1/${OVE_BASE_DIR}}
	cmd="${*:2}"

	if ! [ -d "${OVE_BASE_DIR}/${dir}" ]; then
		ove_echo_error_noprefix "'${OVE_BASE_DIR}/${dir}' is not a directory"
		return 1
	fi

	cd ${OVE_BASE_DIR}/${dir} && eval "${cmd}"
}

# fetch:[GIT...]:git fetch --all for all/specified repositories, ends with ove status
function ove-fetch {
	local repos

	if [ $# -ne 0 ]; then
		repos=$(ove_validate_repo_list "$@")
		[ "${repos}" == "" ] && return 1
	fi

	if ! ove_revtab_fetch ${repos}; then
		return $?
	fi

	[ $# -eq 0 ] && ove_patch_repositories

	ove-status ${repos}
}

# tag: :list all project tags
function ove-tag {
	\git -C "${OVE_PROJECT_DIR}" log --tags --simplify-by-decoration --pretty="format:%ai %D"
}

# log: :project commit log for branch '${OVE_PROJECT_CI_BRANCH}'
function ove-log {
	local b

	if \git -C "${OVE_PROJECT_DIR}" branch -r | \grep -q ${OVE_PROJECT_CI_BRANCH}; then
		b="${OVE_PROJECT_CI_BRANCH}"
	fi

	\git -C "${OVE_PROJECT_DIR}" log --decorate ${b}
}

# checkout:[rev[ [purge|autostash]]]:git checkout -p for all git repositories OR checkout a new project revision, use 'purge' with care
function ove-checkout {
	local cmd
	local dirty_repos
	local m
	local proj
	local repo
	local revision

	revision="$1"

	if [ $# -eq 0 ]; then
		dirty_repos=$(ove_dirty_repos)

		# shellcheck disable=SC2016
		cmd='\git -C ${repo} diff --quiet || (ove_echo_yellow_noprefix ${repo_basename}; \git -C ${repo} checkout -p)'
		ove_revtab_forsome "${cmd}" "${dirty_repos}"

		[[ "${dirty_repos}" =~ ${OVE_PROJECT_NAME} ]] && ove_reinit
	elif [ $# -eq 1 ] || [ $# -eq 2 ]; then
		if [ "$2" == "purge" ]; then
			# shellcheck disable=SC2016
			cmd='\git -C ${repo} reset; \git -C ${repo} checkout .'

			read -p "Proceed to run '${cmd}' for all git repositories? (y/N) " -r
			echo
			if [[ ${REPLY} =~ ^[Yy]$ ]]; then
				read -p "Are you really sure? (y/N) " -r
				echo
				if [[ ${REPLY} =~ ^[Yy]$ ]]; then
					ove_revtab_forall "${cmd}"
				fi
			fi
		elif [ "$2" == "autostash" ]; then
			dirty_repos=$(ove_dirty_repos)

			for repo in ${dirty_repos}; do
				\git -C "${repo}" stash save -q "stashed by ove-checkout"
			done
		else
			dirty_repos=$(ove_dirty_repos)

			if [ "${dirty_repos}" != "" ]; then
				ove_echo_error_noprefix "you have staged/unstaged changes in the following repositories:"
				ove-status ${dirty_repos}
				return 1
			fi
		fi

		\git -C "${OVE_PROJECT_DIR}" fetch --all

		m=$(\xargs -n1 <<<${OVE_REPO_LIST//${OVE_BASE_DIR}\/} | \wc -L)
		\git -C "${OVE_PROJECT_DIR}" -c advice.detachedHead=false checkout "${revision}" |& \
			\sed -e "1s|^|$(ove_echo_yellow_noprefix ${OVE_PROJECT_NAME})$(printf "%0.s " $(eval echo {1..$((${m} + 2 - ${#OVE_PROJECT_NAME}))}))|g" \
			-e "2s|^|$(printf "%0.s " $(eval echo {1..$((${m} + 2))}))|g"
		if [ ${PIPESTATUS[0]} -ne 0 ]; then
			# cleanup
			if [ "$2" == "autostash" ]; then
				for repo in ${dirty_repos}; do
					\git -C "${repo}" stash pop -q
				done
			fi

			return 1
		fi

		echo ---

		# init everything
		ove_init

		# clone and checkout
		ove_revtab_clone_and_checkout

		# validate revtab revision
		ove_revtab_check

		if [ "$2" == "autostash" ]; then
			for repo in ${dirty_repos}; do
				\git -C "${repo}" stash pop -q
			done
		fi

		ove_patch_repositories
	fi
}

# list-commands: :list commands
function ove-list-commands {
	local a
	local b

	a=$(\grep -B1 "^function ove-" "${OVE_BASE_DIR}"/ove | \
		\grep '\#' | \
		\cut -b3-| \
		LC_ALL="C" \sort)
	b=$(set | \
		\grep helptext | \
		\grep -v '\$'| \
		\cut -d'"' -f2)

	printf "${a}\n${b}" | \
		LC_ALL="C" \sort | \
		\column -s: -t
}

# help:[PATTERN]:OVE help
function ove-help {
	local h
	local longest_argument
	local longest_function
	local longest_function_project
	local nbr_of_hypens

	if [ $# -ne 0 ]; then
		for h in "$@"; do
			ove-help | \grep -E --color=always "${h}"
		done
		return 0
	fi

	longest_function=$(\grep -B1 "^function ove-" ${OVE_SELF} | \
		\grep '\#' | \
		\cut -b3- | \
		\cut -d: -f1 | \
		\wc -L)
	longest_function_project=$(set | \
		\grep helptext | \
		\grep -v '\$' | \
		\cut -d'"' -f2 | \
		\cut -d: -f1 | \
		\wc -L)
	longest_argument=$(\grep -B1 "^function ove-" ${OVE_SELF} | \
		\grep '\#' | \
		\cut -b3- | \
		\cut -d: -f2 | \
		\wc -L)
	longest_argument_project=$(set | \
		\grep helptext | \
		\grep -v '\$' | \
		\cut -d'"' -f2 | \
		\cut -d: -f2 | \
		\wc -L)
	longest=${longest_function}
	longest_a=${longest_argument}
	[ ${longest_function_project} -gt ${longest_function} ] && longest=${longest_function_project}
	[ ${longest_argument_project} -gt ${longest_argument} ] && longest_a=${longest_argument_project}
	nbr_of_hypens=$((longest + longest_a + 15))
	printf "%-"$((longest + 2))"s%-"$((longest_a + 2))"s%7s%s\n" "Command" "Arguments" "Description"
	printf "%0.s-" $(eval echo {1..${nbr_of_hypens}})
	echo
	ove-list-commands
	echo
	\cat <<EOF

Examples
=====

Build
-----
# Do the initial build
#
# Steps performed for each project: bootstrap, configure, build, install

	$ ove buildme

# Build all projects in order. 'clean' will be performed if needed.
#
# Steps performed for each project: [clean], build, install

	$ ove make

# Build a specific project and all project dependencies. 'clean' will be performed if needed.
#
# Steps performed for each project: [clean], make, make install

	$ ove make projA

# Clean all projects.
#
# Steps performed for each project: clean

	$ ove clean

# Properly remove all files for all git repositories.
#
# Steps performed for each repository: git clean -dffx

	$ ove mrproper

Source control
--------------
# Status of all git repositories
#
# Steps performed for each repository: git status -zbs -uno

	$ ove status

# Synchronize with the outside world
#
# Steps performed for each repository: git fetch --all

	$ ove fetch

# Curious mind? List patches your friends have upstreamed since your last pull.

	$ ove news

# Checkout revision

	$ ove checkout 1.0.2

# Search all git repositories
#
# Steps performed for each repository: git grep

	$ ove grep DEADBEEF
EOF

	# Project specific help text
	if [ -e "${OVE_PROJECT_DIR}"/help ]; then
		echo
		echo "Project '${OVE_PROJECT_NAME}' help"
		printf "%0.s-" $(eval echo {1..$(($(echo ${OVE_PROJECT_NAME} | \wc -L) + 15))})
		echo
		\cat "${OVE_PROJECT_DIR}/help"
	fi
}

# ag:PATTERN:search OVE workspace using The Silver Searcher [duckduckgo.com/?q=The+Silver+Searcher]
function ove-ag {
	if ! command -v ag > /dev/null; then
		ove_echo_command_not_found "ag"
		return 1
	fi

	[ $# -eq 0 ] && echo "No pattern, try again" && return 1

	ove_revtab_forall_parallel '\ag --color "'"$*"'" | \sed -e 's@^@\${PWD}/@g''
}

# grep:PATTERN:grep OVE workspace
function ove-grep {
	[ $# -eq 0 ] && echo "No pattern, try again" && return 1
	# shellcheck disable=SC2016
	ove_revtab_forall_parallel '\git --no-pager -C ${repo} \grep --color=always "'"$*"'" | \sed -e 's@^@\${PWD}/@g''
}

# blame-history:PATTERN:git log -S for all git repositories
function ove-blame-history {
	[ $# -eq 0 ] && echo "No pattern, try again" && return 1
	# shellcheck disable=SC2016
	ove_revtab_forall '\git --no-pager -C ${repo} log --color=always -p -S "'"$*"'"'
}

# blame:PATTERN:git grep-blame-log combo
function ove-blame {
	local f
	local i
	local line
	local repo
	local res
	local s
	local sha
	local str

	[ $# -eq 0 ] && ove_echo_error_noprefix "no pattern, try again" && return 1

	s="$*"

	if [ "${OVE_REPO_LIST}" == "" ]; then
		echo "run 'ove fetch' first!"
		return 1
	fi

	for repo in ${OVE_REPO_LIST}; do
		! [ -d "${repo}" ] && continue
		mapfile -t res < <(\git -C "${repo}" --no-pager grep --no-color -I -n "${s}" | \cut -d: -f1,2)

		for i in "${res[@]}"; do
			f=$(\cut -d: -f1 <<<"${i}")
			line=$(\cut -d: -f2 <<<"${i}")
			sha=$(\git -C "${repo}" --no-pager blame -L"${line}","${line}" "${f}" | \cut -d' ' -f1)
			str="${repo}/${f}:${line}"
			if [ "${sha}" == "00000000" ]; then
				str+=" [ Not Committed Yet ]"
			fi
			if [ "${sha}" != "00000000" ]; then
				\git -C "${repo}" --no-pager log --color=always -1 "${sha}"
			fi
			echo
			\head -"${line}" "${repo}"/"${f}" | \
				\tail -1 | \
				\grep --color=always "${s}" | \
				\sed -e 's/^/    /g'
			echo
			echo "    File: ${str}"
			echo
		done
	done
}

# $1: oveconfig file
# $2: config
# $3: value
function ove_config_one {
	local cfg=$1
	local var

	shift
	if [ $# -eq 0 ]; then
		\grep ${grep_prefix} -E -v '^#|^$' ${cfg} | \
			LC_ALL="C" \sort | \
			\grep -E --color=always "${grep_postfix}"
	elif [ $# -eq 1 ]; then
		if \grep -q -i $1 ${cfg}; then
			\grep ${grep_prefix} -E -v '^#|^$' ${cfg} | \
			\grep -i $1 | \
			\grep -E --color=always "${grep_postfix}"
		fi
	elif [ $# -gt 1 ]; then
		var=$1
		if \grep -q -w ${var} ${cfg}; then
			\sed -i -e "s|\(^${var}\s\+\).*|\1${*:2}|g" ${cfg}
			ove_config_one ${cfg} ${var}
		fi
	fi
}

# add-config:FILE CONFIG VALUE:add config/value pair to one oveconfig file
function ove-add-config {
	local cfg
	local val
	local var

	if [ $# -lt 3 ]; then
		ove-help "^${FUNCNAME/ove-/} "
		return 1
	fi

	cfg=$(\readlink -f $1)
	if ! ove_config_validate_filename ${cfg}; then
		return 1
	fi
	var=$2
	val="${*:3}"

	if [ -w "${cfg%/*}" ]; then
		if \grep -q "^${var} " ${cfg} &> /dev/null; then
			\sed -i "s|^${var}.*|${var} ${val}|g" ${cfg}
		else
			echo "${var} ${val}" >> ${cfg}
		fi
		ove_update_checksum_config
		ove_config_init
	fi

	return 0
}

function ove_config_validate_filename {
	local f

	for f in ${OVE_ALL_CONFIG_FILES}; do
		[ "$1" == "${f}" ] && return 0
	done

	return 1
}

function ove_config_validate_file {
	local f

	f=$(\readlink -f $1)
	[ -s "$f" ] || return 1
	ove_config_validate_filename "${f}" || return 1

	return 0
}

function ove_config2file {
	\grep -H "^${1} " \
		${OVE_ALL_CONFIG_FILES} 2> /dev/null | \
		\tail -1 | \
		\cut -d: -f1
}

function ove_list_oveconfig_files {
	local f
	local files

	for f in ${OVE_ALL_CONFIG_FILES}; do
		[ -e "${f}" ] && files+=("${f}")
	done

	[ ${#files[@]} -eq 0 ] && return
	echo "${files[@]}"
}

# config:[FILE[CONFIG[[VALUE]]]]|[CONFIG[[VALUE]]]:show/modify .oveconfig files, configs are read in order so last config takes precedence
function ove-config {
	local cfg
	local cfg_diff
	local cfgs
	local d
	local grep_prefix
	local grep_postfix

	if [ $# -gt 0 ] && ove_config_validate_file $1; then
		cfgs=("${1}")
		shift
	else
		read -r -a cfgs < <(ove_list_oveconfig_files)
	fi

	if [ ${#cfgs[@]} -eq 0 ]; then
		ove_echo_error_noprefix "no oveconfig found"
		return 1
	elif [ ${#cfgs[@]} -gt 1 ]; then
		grep_prefix="-H"
	fi

	# try to mark any local changes in ${OVE_PROJECT_DIR}/.oveconfig
	grep_postfix='$'
	if \git -C ${OVE_PROJECT_DIR} ls-files --error-unmatch ${OVE_PROJECT_DIR}/.oveconfig &> /dev/null; then
		cfg_diff="$(\git -C ${OVE_PROJECT_DIR} diff --no-color -U1 --raw ${OVE_PROJECT_DIR}/.oveconfig | \
			\grep '^+[A-Z]\+'| \
			\cut -b2- | \
			\awk '{print $1}')"
		for d in ${cfg_diff}; do
			grep_postfix+="|\b${d}\b"
		done
	fi

	# shellcheck disable=SC2126
	if [ $# -gt 1 ] && [ $(\grep "^${1} " ${cfgs[*]} | \wc -l) -gt 1 ]; then
		ove_echo_yellow_noprefix "'${1}' is present in more than one .oveconfig:"
		while true; do
			\grep "^${1} " "${cfgs[@]}" | \cut -d: -f1
			read -r -p "config: "
			for cfg in ${cfgs[*]}; do
				if [ "${REPLY}" == "${cfg}" ]; then
					cfgs=("${REPLY}")
					break 2
				fi
			done
			echo "error: try again, specify one of these files:"
		done
	fi

	for cfg in "${cfgs[@]}"; do
		ove_config_one ${cfg} "$@"
	done | \sed -e 's|^\(/.*\):|\1#|' -e 's| \+|#|' | \column -t -s'#'

	if [ $# -gt 1 ]; then
		ove_update_checksum_config
		ove_config_init
	fi
}

# ls-files:[PATTERN]:git ls-files for all git repositories
function ove-ls-files {
	local cmd

	if [ $# -eq 0 ]; then
		# shellcheck disable=SC2016
		cmd='\git -C ${repo} ls-files | while read line; do echo -e ${PWD}/${line}; done'
	else
		# shellcheck disable=SC2016
		cmd="re=$*; \git -C \${repo} ls-files | while read line; do [[ \${PWD}/\${line} =~ \${re} ]] && echo -e \${PWD}/\${line}; done"
	fi

	ove_revtab_forall_parallel "${cmd}" | LC_ALL="C" \sort
}

# list-modified-files: :list modified files
function ove-list-modified-files {
	local cmd

	# shellcheck disable=SC2016
	cmd='\git --no-pager -C ${repo} diff-index --quiet HEAD || \git -C ${repo} diff --name-only HEAD | \sed -e "s|^|${repo}/|g"'

	ove_revtab_forsome_parallel "${cmd}" 0 "$(ove_dirty_repos)" | LC_ALL="C" \sort -u
}

# list-committed-files:[DAYS]:list committed files within 7 or DAYS day(s)
function ove-list-committed-files {
	local cmd
	local days

	[ $# -eq 1 ] && days="$1" || days=7

	# shellcheck disable=SC2016
	cmd='\git --no-pager -C ${repo} log --all --no-merges --author="$(\git config --get user.name)" --name-only --pretty=format:"" --since="'${days}' days" | while read line; do [ -f ${PWD}/${line} ] && echo -e ${PWD}/${line}; done'

	ove_revtab_forall "${cmd}" | LC_ALL="C" \sort -u
}

function ove_edit {
	declare -A f_hash
	local editor
	local f
	local files
	local files_by_epoch

	files=$(ove-list-modified-files)

	[ "${files}" == "" ] && return

	editor="$1"
	shift

	# sanity check
	if ! command -v ${editor} > /dev/null; then
		ove_echo_command_not_found "${editor}"
		return 1
	fi

	# stat every file
	files_by_epoch=$(for f in ${files}; do echo $(\stat --format '%Y' ${f}):${f}; done | \
		LC_ALL="C" \sort -r | \
		\cut -d: -f2)

	if [ $# -eq 0 ]; then
		files="${files_by_epoch}"
	else
		f=
		while [ $# -ne 0 ]; do
			test "${f_hash["${1}"]+isset}" && shift && continue
			f_hash["${1}"]=1
			f+=$(printf "${files_by_epoch}" | \
				\sed -e "s|${OVE_BASE_DIR}/||g" | \
				\grep -i $1 | \
				\sed -e "s|^|${OVE_BASE_DIR}/|g")
			f+=" "
			shift
		done

		files="${f}"
	fi

	if [ "${files}" != "" ]; then
		if [ "${editor}" == "vi" ]; then
			\vi -o ${files} -c "wincmd H"
		elif [ "${editor}" == "emacs" ]; then
			\emacs ${files}
		else
			ove_echo_stderr_noprefix "unknown editor"
		fi
	fi
}

# emacs:[PATTERN|FILE...]:open modified files in emacs
function ove-emacs {
	ove_edit emacs "$@"
}

# vi:[PATTERN|FILE...]:open modified files in vi
function ove-vi {
	ove_edit vi "$@"
}

# mrproper:[y]:remove untracked files AND removes '${OVE_STAGE_DIR}/*' AND removes '${OVE_ARCHIVE_DIR}/*', use with care
function ove-mrproper {
	local archive_dir_size
	local nbr_untracked_files
	local stage_dir_size

	if [ "$1" == "y" ]; then
		# shellcheck disable=SC2016
		ove_revtab_forall '\git --no-pager -C ${repo} clean -dffx > /dev/null'
		! [ "${OVE_STAGE_DIR}" == "" ] && \rm -rf ${OVE_STAGE_DIR:?}/*
		! [ "${OVE_ARCHIVE_DIR}" == "" ] && \rm -rf ${OVE_ARCHIVE_DIR:?}/*

		return 0
	fi

	# shellcheck disable=SC2016
	nbr_untracked_files=$(ove_revtab_forall_parallel '\git -C ${repo} clean -dffxn'| \wc -l)
	if [ "${nbr_untracked_files}" -ne 0 ]; then
		# dry-run first
		# shellcheck disable=SC2016
		ove_revtab_forall 'a=$(\git --no-pager -C ${repo} clean -dffxn); [ "${a}" != "" ] && printf "${a}\n" | \sed -e "s|Would remove \(.*\)$|${PWD}/\1|g"'
		echo
		read -p "Proceed to remove ${nbr_untracked_files} untracked files/directories (list above) using 'git clean -dffx'? (y/N) " -r
		if [[ ${REPLY} =~ ^[Yy]$ ]]; then
			echo
			read -p "Are you really sure? (y/N) " -r
			echo
			if [[ ${REPLY} =~ ^[Yy]$ ]]; then
				# shellcheck disable=SC2016
				ove_revtab_forall '\git --no-pager -C ${repo} clean -dffx'
			fi
		fi
	fi

	stage_dir_size="$(\tree ${OVE_STAGE_DIR} | \tail -1)"
	if [ "${stage_dir_size}" != "0 directories, 0 files" ]; then
		# all but the last line
		\tree -C ${OVE_STAGE_DIR} | \head -n -1

		read -p "Proceed to remove ${stage_dir_size} (list above) from '${OVE_STAGE_DIR}' using 'rm -rf'? (y/N) " -r
		echo
		if [[ ${REPLY} =~ ^[Yy]$ ]]; then
			echo "$ rm -rf ${OVE_STAGE_DIR}/*"
			echo
			read -p "Are you really sure you want to run the above command? (y/N) " -r
			echo
			if [[ ${REPLY} =~ ^[Yy]$ ]]; then
				if ! [ "${OVE_STAGE_DIR}" == "" ]; then
					\rm -rf ${OVE_STAGE_DIR:?}/*
				fi
			fi
		fi
	fi

	archive_dir_size="$(\tree ${OVE_ARCHIVE_DIR} | \tail -1)"
	if [ "${archive_dir_size}" != "0 directories, 0 files" ]; then
		# all but the last line
		\tree -C ${OVE_ARCHIVE_DIR} | \head -n -1

		read -p "Proceed to remove ${archive_dir_size} (list above) from '${OVE_ARCHIVE_DIR}' using 'rm -rf'? (y/N) " -r
		echo
		if [[ ${REPLY} =~ ^[Yy]$ ]]; then
			echo "$ rm -rf ${OVE_ARCHIVE_DIR}/*"
			echo
			read -p "Are you really sure you want to run the above command? (y/N) " -r
			echo
			if [[ ${REPLY} =~ ^[Yy]$ ]]; then
				if ! [ "${OVE_ARCHIVE_DIR}" == "" ]; then
					\rm -rf ${OVE_ARCHIVE_DIR:?}/*
				fi
			fi
		fi
	fi
}

# !:[PATTERN]:view last command output in pager (=${OVE_PAGER}) or print lines matching PATTERN
function ove-! {
	[ -f "${OVE_LAST_COMMAND}" ] || return

	if [ $# -eq 0 ]; then
		${OVE_PAGER} ${OVE_LAST_COMMAND}
		return $?
	fi

	if command -v ag > /dev/null; then
		\ag -H -i "$@" ${OVE_LAST_COMMAND}
	else
		echo ${OVE_LAST_COMMAND}
		\grep -i "$@" ${OVE_LAST_COMMAND}
	fi
}

# describe:[GIT...]:git describe+log+status combo for all/specified git repositories
function ove-describe {
	local func

	func=ove_revtab_forall_parallel

	[ $# -gt 0 ] && func=ove_revtab_forsome

	# shellcheck disable=SC2016
	${func} 'echo $(echo ${repo} | \sed -e "s|${OVE_BASE_DIR}/||g")@$(\git describe --tags --always --dirty --long)@"$(\git log --format="%<(20,trunc)%s" -1)"@"$(\git -c color.status=never status -s -uno | \tr "\n" " ")"' "$@" |\
		\column -t -s'@' | \
		LC_ALL="C" \sort
}

# list-heads:[GIT...]:git log for all/specified git repositories
function ove-list-heads {
	local cmd

	# shellcheck disable=SC2016
	cmd='echo $(echo -n "$(echo ${repo} | \sed -e "s|${OVE_BASE_DIR}/||g")?" && '
	# shellcheck disable=SC2016
	cmd+='\git --no-pager -C ${repo} log -1 --no-merges --format=%h?%ar?%ae?%s 2> /dev/null)'

	while true; do
		if [ $# -eq 0 ]; then
			ove_revtab_forall_parallel "${cmd}"
		else
			ove_revtab_forsome "${cmd}" "$*"
		fi

		break
	done | LC_ALL="C" \sort | \column -t -s? 2> /dev/null
}

# ls-remote: :git ls-remote <URL> HEAD for all git repositories
function ove-ls-remote {
	local i
	local repo
	local ret
	local sha
	local str
	local url

	i=0
	ret=0
	while ((i < ove_revtab_num_repositories)); do
		repo="${ove_revtab_git_name[${i}]}"
		url="${ove_revtab_fetch_url[${i}]}"
		[ "${url}" == "noremote" ] && (( i+=1 )) && continue

		sha=$(\git ls-remote ${url} HEAD | \awk '{print $1}')
		if [ "${sha}" == "" ]; then
			ove_echo_error_noprefix "ls-remote failed for '${url}'"
			(( ret+=1 ))
		else
			str+="${repo}:${sha}\n"
		fi
		(( i+=1 ))
	done

	url=$(\git -C "${OVE_PROJECT_DIR}" config --get remote.origin.url)
	if [ "${url}" == "" ] || [ "${url}" == "noremote" ]; then
		:
	else
		sha=$(\git -C "${OVE_PROJECT_DIR}" ls-remote ${url} HEAD | \awk '{print $1}')
		if [ "${sha}" == "" ]; then
			ove_echo_error_noprefix "ls-remote failed for '${url}'"
			(( ret+=1 ))
		else
			str+="${OVE_PROJECT_NAME}:${sha}\n"
		fi
	fi

	printf "${str}" | \
		LC_ALL="C" \sort | \
		\column -t -s:

	return ${ret}
}

# heads2revtab:[GIT...]:update 'revtab' with current SHA-1
function ove-heads2revtab {
	local repo
	local repos
	local sha_1

	if [ $# -eq 0 ]; then
		repos=$(ove_revtab_list_basename)
	else
		repos=$*
	fi

	for repo in ${repos}; do
		sha_1=$(\git -C "${OVE_BASE_DIR}"/${repo} rev-parse HEAD)
		\sed -i -e 's|^'${repo}'\(\s\+.*\s\+.*\s\+\)\(.*\)$|'${repo}'\1'${sha_1}'|g' "${OVE_PROJECT_DIR}"/revtab
	done

	\git --no-pager -C "${OVE_PROJECT_DIR}" diff revtab
}

# head-tail:FILE [NUM]:display first/last 3(=NUM) lines of a text file
function ove-head-tail {
	local c
	local f
	local n

	if [[ $# -eq 0 || $# -gt 2 || ( $# -eq 2 && ! "$2" =~ ^[0-9]+$ ) ]]; then
		ove-help "^${FUNCNAME/ove-/} "
		return 1
	fi

	f=$1
	if ! [ -e ${f} ]; then
		ove_echo_error_noprefix "file '${f}' not found"
		return 1
	fi

	if ! \file -bL --mime ${f} | \grep -q '^text'; then
		ove_echo_error_noprefix "'${f}' is not a text file, use xxd/hexdump"
		return 1
	fi

	[ $# -eq 1 ] && c=3 || c=$2
	n=$(\wc -l <${f})
	if [ ${n} -gt $((c + c)) ]; then
		\cat -n ${f} | \head -${c}
		echo -e "\t..."
		\cat -n ${f} | \tail -${c}
	else
		\cat -n ${f}
	fi
}

# what-is:DIRECTORY...:classify files using 'file' within a directory
function ove-what-is {
	local dir

	for dir in "$@"; do
		[ ! -d "${dir}" ] && continue
		echo "${dir}":
		\find "${dir}" -not -path '*.git*' -print0 | \
			\xargs -0 -P"$(nproc)" file | \
			\awk '{$1=""; print $0}' | \
			LC_ALL="C" \sort | \
			\uniq -c | \
			LC_ALL="C" \sort -nr
	done
}

# show:[rev...]:ove list-heads or search for 'rev' within all git repositories. If found run 'git show rev'
function ove-show {
	local SHA

	if [ $# -eq 0 ]; then
		# shellcheck disable=SC2119
		ove-list-heads
		return
	fi

	for SHA in "$@"; do
		# remove dirty tags
		SHA=${SHA%-dirty}
		ove_revtab_forall "
		if \git --no-pager -C \${repo} show ${SHA} -- &> /dev/null; then \
			clear; \
			if [ ${OVE_LESS_MORE_OPTIONS} -eq 1 ]; then
				less_opt=\"-X -R -Ps'\${repo_basename} ${SHA}'\";
			else
				less_opt=\"less -R\";
			fi;
			LESS=\${less_opt} \git -p -C \${repo} show --color=always ${SHA} --;
			unset less_opt
		fi"
	done
}

# cd:[PATTERN|?] :'cd ${OVE_BASE_DIR}' OR switch to a OVE workspace specified by PATTERN
function ove-cd {
	if [ $# -eq 0 ]; then
		cd "${OVE_BASE_DIR}"
	elif [ $# -eq 1 ] && [ "$1" == "?" ]; then
		ove_set_workspace
	else
		ove_set_workspace "$@"
	fi
}

# version: :print OVE version
function ove-version {
	echo "OVE [SHA-1: ${OVE_SHA} @ ${OVE_OS} ${OVE_OS_VER}]"
}

# revtab-check:[0|1]:disable/enable if OVE should keep repos in sync with 'revtab'
function ove-revtab-check {
	local cfg
	local reinit=0

	if [ $# -eq 1 ] && ! [[ "${1}" =~ ^[0-1]$ ]]; then
		return 1
	elif [ $# -eq 1 ]; then
		if [ ${OVE_REVTAB_CHECK} -eq 0 ] && [ ${1} -eq 1 ]; then
			reinit=1
		fi

		OVE_REVTAB_CHECK=$1

		cfg=$(ove_config2file OVE_REVTAB_CHECK)
		[ "${cfg}" == "" ] && cfg="${OVE_PROJECT_STATE_DIR}/.oveconfig"
		ove-add-config ${cfg} OVE_REVTAB_CHECK ${OVE_REVTAB_CHECK}
	fi

	if [ ${OVE_REVTAB_CHECK} -eq 1 ]; then
		echo "revtab check (=OVE_REVTAB_CHECK) is ENABLED for this workspace"
		[ ${reinit} -eq 1 ] && ove_reinit
	else
		echo "revtab check (=OVE_REVTAB_CHECK) is DISABLED for this workspace"
	fi
}

# loglevel:[LEVEL] :show or change loglevel [0-7]
function ove-loglevel {
	local bcc_tool
	local cfg
	local prefix
	local sysctl_f

	set +x
	if [ $# -eq 1 ] && ! [[ "${1}" =~ ^[0-8]$ ]]; then
		echo "error: try 0-8"
		return 1
	elif [ $# -eq 1 ]; then
		if [ $1 -gt 2 ] && [ $1 -lt 7 ]; then
			if ! command -v strace > /dev/null; then
				ove_echo_command_not_found "strace"
				return 1
			fi

			if [ -e /proc/sys/kernel/yama/ptrace_scope ] && [ $(\cat /proc/sys/kernel/yama/ptrace_scope) -ne 0 ]; then
				ove_echo_error_noprefix "the kernel does not allow you to trace all processes"
				echo
				echo "To fix this for now:"
				[ ${EUID} != 0 ] && prefix="sudo"
				echo " ${prefix} bash -c 'echo 0 > /proc/sys/kernel/yama/ptrace_scope'"
				echo
				echo "To fix this permanently:"
				sysctl_f=$(\grep -l kernel.yama.ptrace_scope /etc/sysctl.d/*)
				if [ "${sysctl_f}" != "" ]; then
					echo " ${prefix} bash -c 'echo 0 > /proc/sys/kernel/yama/ptrace_scope; sed -i -e \"s/kernel.yama.ptrace_scope.*/kernel.yama.ptrace_scope = 0/g\" ${sysctl_f}'"
				else
					echo " ${prefix} bash -c 'echo 0 > /proc/sys/kernel/yama/ptrace_scope; echo \"kernel.yama.ptrace_scope = 0\" > /etc/sysctl.d/10-ptrace.conf'"
				fi
				return 1
			fi
		fi

		if [ $1 -ge 7 ] && [ $1 -le 9 ]; then
			if [ ${1} -eq 7 ]; then
				bcc_tool="execsnoop"
			else
				bcc_tool="tcpconnect"
			fi

			if ! command -v python3 > /dev/null; then
				ove_echo_command_not_found "python3" "Needed by '${bcc_tool}'."
				return 1
			fi

			if ! [ -e /usr/share/bcc/tools/${bcc_tool} ]; then
				ove_echo_error_noprefix "'/usr/share/bcc/tools/${bcc_tool}' not found."
				return 1
			fi

			if [ ${EUID} != 0 ]; then
				if ! sudo -n true; then
					if ! sudo true; then
						ove_echo_error_noprefix "'${bcc_tool}' need non-interactive 'sudo'"
						return 1
					fi
				fi
			fi
		fi

		OVE_LOGLEVEL=$1
		cfg=$(ove_config2file OVE_LOGLEVEL)
		[ "${cfg}" == "" ] && cfg="${OVE_PROJECT_STATE_DIR}/.oveconfig"
		ove-add-config ${cfg} OVE_LOGLEVEL $1
	fi

	while true; do
		echo "0: silence is golden"
		echo "1: normal"
		echo "2: debug                [set -x]"
		echo "3: execve timeline      [strace]"
		echo "4: execve time analysis [strace]"
		echo "5: connect analysis     [strace]"
		echo "6: graph analysis       [strace]"
		echo "7: execsnoop            [bcc]"
		echo "8: tcpconnect           [bcc]"
		break
	done | \grep -E --color "$|${OVE_LOGLEVEL}"

	if [ $# -eq 1 ]; then
		OVE_REDIRECT_OUTPUT=""
		if [ $1 -eq 0 ]; then
			OVE_REDIRECT_OUTPUT="> /dev/null"
		elif [ $1 -eq 1 ]; then
			set +x
		elif [ $1 -eq 2 ]; then
			set -x
		fi
	fi
}

# dry-run:[0|1]:toggle or set OVE_DRY_RUN
function ove-dry-run {
	if [ $# -eq 1 ] && ! [[ "$1" =~ ^[0-1]$ ]]; then
		ove-help ^${FUNCNAME/ove-/}
		return 1
	fi

	if [ $# -eq 0 ]; then
		OVE_DRY_RUN=$((OVE_DRY_RUN ^= 1))
	else
		OVE_DRY_RUN=$1
	fi

	ove-env ^OVE_DRY_RUN
}

# lastlog:[cmin]:list OVE logs created within last 60 min or cmin min
function ove-lastlog {
	local cmin=60

	if [ $# -eq 1 ]; then
		if ! [[ "${1}" =~ ^[0-9]+$ ]]; then
			echo "error: just numbers"
			return 1
		fi

		cmin=$1
	fi

	\find ${OVE_LOG_DIR} -type f -cmin -${cmin} -print0 | \
		\xargs -0 stat --format '%Y:%n:%s' | \
		LC_ALL="C" \sort -nr | \
		\cut -d: -f2- | \
		\grep -v ${FUNCNAME[0]} | \
		\sed "s/\(^.*-ove-\(.*\)-${HOSTNAME}-\(.*\).log\):\(.*\)/\3@\2@\1@\4/g" | \
		\column -t -s@
}

# rm-logs:[DAYS]:remove OVE logs older than 30|DAYS days. DAYS=0 => all logs
function ove-rm-logs {
	local days=30
	local find_opt="-mtime +${days}"

	if  [ $# -gt 1 ]; then
		ove-help ^${FUNCNAME/ove-/}
		return 1
	fi

	if [ $# -eq 1 ]; then
		if ! [[ "${1}" =~ ^[0-9]+$ ]]; then
			echo "error: just numbers"
			return 1
		fi

		if [ $1 -eq 0 ]; then
			find_opt=""
		else
			days=$1
			find_opt="-mtime +${days}"
		fi
	fi

	find_opt="-maxdepth 2 -type f ${find_opt} -print"

	if [ "$(\find ${OVE_LOG_DIR} ${find_opt} -quit)" == "" ]; then
		ove_echo_error_noprefix "no OVE log files older than ${days} days found here: ${OVE_LOG_DIR}"
		return 1
	fi

	\find ${OVE_LOG_DIR} ${find_opt} | \cat -n
	echo
	echo -n "Proceed to remove "
	if [ $# -eq 1 ] && [ $1 -eq 0 ]; then
		read -p "ALL files (list above) from '${OVE_LOG_DIR}' (y/N) " -r
	else
		read -p "files older than ${days} days (list above) from '${OVE_LOG_DIR}' (y/N) " -r
	fi
	[[ ${REPLY} =~ ^[Yy]$ ]] || return 1
	read -p "Are you really sure? (y/N) " -r
	[[ ${REPLY} =~ ^[Yy]$ ]] || return 1

	\find ${OVE_LOG_DIR} ${find_opt} | \
		\grep -v ${OVE_LAST_COMMAND} | \
		\xargs rm -v
	\find ${OVE_LOG_DIR} -maxdepth 1 -empty -type d -delete

	return 0
}

# authors: :list author summary for all git repositories
function ove-authors {
	local repo

	declare -A urls

	if [ "${OVE_REPO_LIST}" == "" ]; then
		echo "run 'ove fetch' first!"
		return 1
	fi

	for repo in ${OVE_REPO_LIST}; do
		if [ ! -d "${repo}" ] || [ "${repo}" == "${OVE_DIR}" ]; then
			continue
		fi

		# Try to avoid that a git is counted more than one time
		url=$(\git --no-pager -C "${repo}" remote -v | \
			\grep fetch | \
			\cut -f2 | \
			\cut -d' ' -f1 | \
			\uniq | \
			\sed -e 's/[^a-zA-Z0-9\-]/_/g' | \
			\sed -e 's/_git$//g')

		if [ "${url}" != "" ]; then
			test "${urls["${url}"]+isset}" && continue
			urls["${url}"]=1
		fi

		\git --no-pager -C "${repo}" log --pretty="%ae"
	done | \
		LC_ALL="C" \sort | \
		\uniq -c | \
		LC_ALL="C" \sort -nr
}

# domains: :list email domain summary for all git repositories
function ove-domains {
	ove-authors | \grep '@' | \cut -d@ -f2 | LC_ALL="C" \sort | \uniq -c | LC_ALL="C" \sort -nr
}

function ove_bash_complete {
	local cmd
	local cur
	local opts
	local size
	local subcommand
	local wordlist

	# sanity check
	if ! ove_get_base_dir &> /dev/null; then
		return 1
	fi

	if ! ove_verify_checksums && ! ove_reinit; then
		return 1
	fi

	COMPREPLY=()

	cur="${COMP_WORDS[COMP_CWORD]}"
	subcommand="${COMP_WORDS[1]}"
	size=$((${#COMP_WORDS[@]} - 1))

	# project commands
	for cmd in ${OVE_PROJECT_COMMANDS}; do
		if [ "${cmd}" == "${subcommand}" ] ||
			[ "${cmd}-parallel" == "${subcommand}" ]; then
			if [ ${size} -ge 2 ]; then
				COMPREPLY=( $(compgen -W "${OVE_PROJECT_LIST}" -- "${cur}") )
				return
			fi
		fi
	done

	# scripts
	for cmd in ${OVE_SCRIPTS_LIST}; do
		if [ "${cmd}" == "${subcommand}" ] && [ -e "${ove_scripts_name2path[${cmd}]}/${cmd}.complete" ]; then
			source "${ove_scripts_name2path[${cmd}]}/${cmd}.complete"
			return
		fi
	done

	# commands without arguments: do nothing
	if [ ${size} -eq 2 ]; then
		if echo ${OVE_BUILT_INS_WITHOUT_ARGS} | \tr ' ' '\n' | \grep -q ^${subcommand}$; then
			return
		fi
	fi

	wordlist=""
	if [ "${subcommand}" == "make" ]; then
		if [ ${size} -eq 2 ]; then
			wordlist=${OVE_PROJECT_LIST}
		elif [ ${size} -gt 2 ]; then
			return
		fi
	elif [ "${subcommand}" == "buildme" ] ||
		[ "${subcommand}" == "buildme-parallel" ] ||
		[ "${subcommand}" == "export" ] ||
		[ "${subcommand}" == "install-pkg" ] ||
		[ "${subcommand}" == "list-missing-projects" ]; then
		wordlist=${OVE_PROJECT_LIST}
	elif [ "${subcommand}" == "run" ]; then
		if [ ${size} -eq 2 ]; then
			wordlist="TIMEOUT"
		elif [ ${size} -eq 3 ]; then
			wordlist="${OVE_ALL_COMMANDS}"
		else
			return
		fi
	elif [ "${subcommand}" == "loop" ]; then
		if [ ${size} -eq 2 ]; then
			wordlist="TIMEOUT"
		elif [ ${size} -eq 3 ]; then
			wordlist="INOTIFY"
		elif [ ${size} -eq 4 ]; then
			wordlist="MAX-COUNT"
		elif [ ${size} -eq 5 ]; then
			wordlist="${OVE_ALL_COMMANDS}"
		else
			return
		fi
	elif [ "${subcommand}" == "checkout" ]; then
		if [ ${size} -eq 2 ]; then
			wordlist=$(ove_list_tags_and_branches)
		elif [ ${size} -eq 3 ]; then
			wordlist="purge autostash"
		else
			return
		fi
	elif [ "${subcommand}" == "list-projects" ]; then
		[ ${size} -ne 2 ] && return
		wordlist="verbose"
	elif [ "${subcommand}" == "fzf" ]; then
		[ ${size} -ne 2 ] && return
		wordlist="loop"
	elif [ "${subcommand}" == "stash" ]; then
		if [ ${size} -eq 2 ]; then
			wordlist="drop list pop show"
		else
			return
		fi
	elif [ "${subcommand}" == "show" ]; then
		if [ ${size} -ge 2 ]; then
			wordlist="$(ove_revtab_forall_parallel '\git tag') HEAD FETCH_HEAD ORIG_HEAD MERGE_HEAD CHERRY_PICK_HEAD"
			wordlist+=" $(ove-list-heads | \awk '{print $2}')"
			if [ -e ${OVE_PROJECT_STATE_DIR}/revtab-news ]; then
				wordlist+=" $(\grep -o '^[a-f0-9]\+' ${OVE_PROJECT_STATE_DIR}/revtab-news)"
			fi
			if [ -e ${OVE_PROJECT_STATE_DIR}/revtab-ahead ]; then
				wordlist+=" $(\grep -o '^[a-f0-9]\+' ${OVE_PROJECT_STATE_DIR}/revtab-ahead)"
			fi
		fi
	elif [ "${subcommand}" == "diff-project" ] ||
		[ "${subcommand}" == "log-project" ] ||
		[ "${subcommand}" == "shortlog-project" ]; then
		if [ ${size} -lt 4 ]; then
			wordlist=$(ove_list_tags_and_branches)
		else
			return
		fi
	elif [ "${subcommand}" == "do" ]; then
		if [ ${size} -eq 2 ]; then
			wordlist=$(ove_revtab_list_basename)
		elif [ ${size} -eq 3 ]; then
			[ -d ${OVE_BASE_DIR}/${COMP_WORDS[2]} ] &&
				wordlist=$(\find $(\readlink -f ${OVE_BASE_DIR}/${COMP_WORDS[2]}) -perm -u=x -not -path '*.git*' -type f)
		elif [ ${size} -gt 3 ]; then
			return
		fi
	elif [ "${subcommand}" == "cd" ]; then
		if [ ${size} -eq 2 ]; then
			wordlist=$(ove_list_workspaces_base)
		elif [ ${size} -gt 2 ]; then
			return
		fi
	elif [ "${subcommand}" == "refresh" ]; then
		if [ ${size} -ge 2 ]; then
			wordlist=$(ove_list_workspaces_base)
		fi
	elif [ "${subcommand}" == "vi" ] ||
		[ "${subcommand}" == "emacs" ]; then
		if [ ${size} -ge 2 ] && [ "$(ove-list-modified-files)" != "" ]; then
			wordlist=$(ove-list-modified-files | \
				\xargs -n1 basename)
		else
			return
		fi
	elif [ "${subcommand}" == "add-config" ]; then
		if [ ${size} -eq 2 ]; then
			wordlist=${OVE_ALL_CONFIG_FILES}
		elif [ ${size} -eq 3 ]; then
			wordlist="$(type ove_config_builtins_init | \
				\grep -o 'OVE_[A-Z_]\+')"
		fi
	elif [ "${subcommand}" == "config" ]; then
		cmd="ove-config"
		if [ "$(ove_list_oveconfig_files)" != "" ]; then
			if [ ${size} -eq 3 ] && eval ove_config_validate_file ${COMP_WORDS[2]}; then
				cmd+=" ${COMP_WORDS[2]}"
			fi
			if [ ${size} -ge 2 ]; then
				wordlist=$(${cmd} | \sed  -e "s/\x1B\[[0-9;]*[mK]//g" -e "s|^/.*/\.oveconfig||g" -e "s|^:||" | \awk '{print $1}')
			fi
		fi
	elif [ "${subcommand}" == "add" ] ||
		[ "${subcommand}" == "diff" ] ||
		[ "${subcommand}" == "diff-cached" ] ||
		[ "${subcommand}" == "reset" ] ||
		[ "${subcommand}" == "reset-hard" ] ||
		[ "${subcommand}" == "wdiff" ] ||
		[ "${subcommand}" == "wdiff-cached" ]; then
		if [ ${size} -ge 2 ]; then
			wordlist=$(ove_dirty_repos)
		fi
	elif [ "${subcommand}" == "branch" ] ||
		[ "${subcommand}" == "describe" ] ||
		[ "${subcommand}" == "fsck" ] ||
		[ "${subcommand}" == "heads2revtab" ] ||
		[ "${subcommand}" == "list-stash" ] ||
		[ "${subcommand}" == "readme" ] ||
		[ "${subcommand}" == "remote" ] ||
		[ "${subcommand}" == "show-dangling" ]; then
		if [ ${size} -ge 2 ]; then
			wordlist=$(ove_revtab_list_basename)
		fi
	elif [ "${subcommand}" == "news" ] ||
		[ "${subcommand}" == "show-news" ] ||
		[ "${subcommand}" == "pull" ]; then
		if ove_any_repo behind; then
			wordlist=$(ove_list_repos behind)
		else
			wordlist=$(ove_revtab_list_basename)
		fi
	elif [ "${subcommand}" == "ahead" ] ||
		[ "${subcommand}" == "show-ahead" ]; then
		if ove_any_repo ahead; then
			wordlist=$(ove_list_repos ahead)
		else
			wordlist=$(ove_revtab_list_basename)
		fi
	elif [ "${subcommand}" == "fetch" ] ||
		[ "${subcommand}" == "list-heads" ] ||
		[ "${subcommand}" == "status" ]; then
		wordlist=$(ove_revtab_list_basename)
	elif [ "${subcommand}" == "systest" ] ||
		[ "${subcommand}" == "systest-parallel" ]; then
		if [ ${size} -ge 2 ]; then
			wordlist=$(ove-list-systests)
		fi
	elif [ "${subcommand}" == "apply" ]; then
		if [ ${size} -ge 2 ]; then
			return
		fi
	elif [ "${subcommand}" == "env" ]; then
		if [ ${size} -eq 2 ]; then
			wordlist=$(compgen -A variable | \grep OVE_)
		else
			return
		fi
	elif [ "${subcommand}" == "unittest" ]; then
		if [ ${size} -ge 2 ]; then
			wordlist=$(\find ${OVE_DIR}/tests -maxdepth 1 -mindepth 1 -name "t*.test" -type f -exec basename {} .test \;)
		fi
	elif [ "${subcommand}" == "what-is" ]; then
		if [ ${size} -ge 2 ]; then
			wordlist=$(\find $(\readlink -f ${PWD}) -maxdepth 1 -mindepth 1 -not -path '*.git' -type d -exec basename {} \;)
		fi
	elif [ "${subcommand}" == "head-tail" ]; then
		if [ ${size} -ge 2 ]; then
			wordlist=$(\find $(\readlink -f ${PWD}) -maxdepth 1 -mindepth 1 -not -path '*.git' -type f -exec basename {} \;)
		fi
	elif [ "${subcommand}" == "select-configuration" ]; then
		if [ ${size} -eq 2 ]; then
			wordlist="default $(\find "${OVE_PROJECT_DIR}/projects" -name "configure-*" -type l -exec basename {} \; | \sed 's/configure-//g')"
		else
			return
		fi
	elif [ "${subcommand}" == "replicate" ]; then
		if [ "$(type -t _known_hosts_real)" == "function" ]; then
			_known_hosts_real -a -- "$cur"
			return
		fi
	elif [ "${subcommand}" == "tail-lastlog" ] ||
		[ "${subcommand}" == "less-lastlog" ]; then
		if [ ${size} -eq 2 ]; then
			# shellcheck disable=SC2015
			wordlist=$([ -d /var/tmp ] && cd /var/tmp || cd /tmp; \
				\find ./*/ove/logs -maxdepth 0 -type d | \
				\cut -d/ -f2)
		else
			return
		fi
	fi

	if [ "${wordlist}" != "" ]; then
		COMPREPLY=( $(compgen -W "${wordlist}" -- ${cur}) )
	else
		opts="${OVE_ALL_COMMANDS}"
		if compgen -W "${opts}" -- "${cur}" &> /dev/null; then
			COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
		fi
	fi
}

function ove_get_built_ins {
	\grep -o '^function ove-.* ' ${OVE_SELF} | \
		\sed -e ':a;N;$!ba;s/function ove-//g' | \
		LC_ALL="C"  \sort | \
		\tr '\n' ' ' | \
		\xargs "${OVE_ECHO}"
}

function ove_update_tab_complete {
	local array
	local cmd
	local oldIFS

	OVE_BUILT_INS=$(ove_get_built_ins)

	# project commands
	OVE_ALL_COMMANDS=${OVE_PROJECT_COMMANDS}

	# built-in functions
	OVE_ALL_COMMANDS+=" ${OVE_BUILT_INS}"

	# scripts
	if [ "${OVE_SCRIPTS_LIST}" != "" ];then
		OVE_ALL_COMMANDS+=" ${OVE_SCRIPTS_LIST}"
	fi

	# parallel project commands
	for cmd in ${OVE_PROJECT_COMMANDS}; do
		OVE_ALL_COMMANDS+=" ${cmd}-parallel"
	done

	array=(${OVE_ALL_COMMANDS})
	oldIFS=${IFS}
	IFS=$'\n' OVE_ALL_COMMANDS=$(\xargs "${OVE_ECHO}" <<<$(LC_ALL="C" \sort <<<"${array[*]}"))
	IFS=${oldIFS}

	export OVE_ALL_COMMANDS

	complete -o bashdefault -o default -F ove_bash_complete ove
	for cmd in ${OVE_PROJECT_COMMANDS}; do
		complete -W "${OVE_PROJECT_LIST}" "ove-${cmd}"
	done
}

function ove_add_script_func {
	local htext
	local script
	local script_dir

	script_dir=$1
	script=$2

	ove_scripts_name2path[${script}]=${script_dir}
	ove_scripts_paths[${script_dir}]=
	if [ -f ${script_dir}/${script}.help ]; then
		htext=$(<${script_dir}/${script}.help)
		eval "ove-${script}() {
		local helptext=\"${htext}\"
		local __scriptname=ove-${script}
		\"${script_dir}\"/${script} \$*
		}"
	else
		eval "ove-${script}() {
		local helptext=\"${script}: :run '${script_dir}/${script}'\"
		local __scriptname=ove-${script}
		\"${script_dir}\"/${script} \$*
		}"
	fi
}

function ove_scripts_init {
	local array
	local oldIFS
	local prev_scripts
	local repo
	local script
	local script_list
	declare -A -g ove_scripts_name2path
	declare -A -g ove_scripts_paths

	OVE_SCRIPTS_LIST=

	# unset any ove- functions marked with "__scriptname"
	if prev_scripts=$(set | \grep '^    local __scriptname=.*'); then
		prev_scripts=${prev_scripts//    local __scriptname=}
		prev_scripts=${prev_scripts//;}
		[ "${prev_scripts}" != "" ] && unset -f ${prev_scripts}
	fi

	# project scripts
	if [ -d "${OVE_PROJECT_DIR}/scripts" ]; then
		script_list=$(\find ${OVE_PROJECT_DIR}/scripts -perm -u=x -not -name '*.help' -type f)
		for script in ${script_list}; do
			ove_add_script_func ${OVE_PROJECT_DIR}/scripts ${script##*/}
			OVE_SCRIPTS_LIST+="${script##*/} "
		done
	fi

	# OVE scripts
	if [ -d "${OVE_DIR}/scripts" ]; then
		script_list=$(\find ${OVE_DIR}/scripts -perm -u=x -not -name '*.help' -type f)
		for script in ${script_list}; do
			ove_add_script_func ${OVE_DIR}/scripts ${script##*/}
			OVE_SCRIPTS_LIST+="${script##*/} "
		done
	fi

	# repo scripts
	for repo in $(ove_revtab_list_fullpath); do
		! [ -d "${repo}/.ove/scripts" ] && continue
		script_list=$(\find -L ${repo}/.ove/scripts -perm -u=x -not -name '*.help' -type f)
		for script in ${script_list}; do
			ove_add_script_func ${repo}/.ove/scripts ${script##*/}
			OVE_SCRIPTS_LIST+="${script##*/} "
		done
	done

	array=(${OVE_SCRIPTS_LIST})
	oldIFS=${IFS}
	IFS=$'\n' OVE_SCRIPTS_LIST=$(\xargs "${OVE_ECHO}" <<<$(LC_ALL="C" \sort <<<"${array[*]}"))
	IFS=${oldIFS}
}

# show-configuration: :show current build configuration for each project
function ove-show-configuration {
	[ -d "${OVE_PROJECT_DIR}/projects" ] && \
		\tree -l -P 'configure' -I 'configure-*' ${OVE_PROJECT_DIR}/projects
}

# select-configuration:[PATTERN|default]:select build configuration for each project
function ove-select-configuration {
	local c
	local configs
	local iter
	local nbr_of_configs
	local p
	local projects

	# list of projects
	projects=${OVE_PROJECT_LIST}
	iter=1
	for p in ${projects}; do
		# ignore projects without a project directory
		[ ! -d "${OVE_PROJECT_DIR}/projects/${p}" ] && continue

		# multiple configurations, ask which one to select
		configs=$(\find "${OVE_PROJECT_DIR}/projects/${p}" -name "configure-*" -type l)
		nbr_of_configs=$(\find "${OVE_PROJECT_DIR}/projects/${p}" -name "configure-*" -type l | \wc -l)
		if [ "${nbr_of_configs}" -gt 1 ]; then
			# pattern, select config
			if [ $# -eq 1 ]; then
				# use the default configuration
				if [ $1 == "default" ]; then
					\git -C ${OVE_PROJECT_DIR} checkout ${OVE_PROJECT_DIR}/projects/${p}/configure
					continue
				fi

				for c in ${configs}; do
					if \grep -w -q configure-$1 <<< "${c##*/}"; then
						ove_echo_green_noprefix ${p}:
						pushd ${OVE_PROJECT_DIR}/projects/${p} &>/dev/null
						\ln -sfv configure-$1 configure
						popd &>/dev/null
						break
					fi
				done
				continue
			fi

			# no pattern, ask user
			ove_echo_green_noprefix ${p}:
			echo "0: default"
			(( iter=1 ))
			for c in ${configs}; do
				echo -n "${iter}: "
				\basename $(echo ${c} | \sed 's/configure-//g')
				(( iter+=1 ))
			done
			echo
			read -p "Select configuration? " -r
			echo
			if [[ ${REPLY} =~ ^[0-9]+$ ]] && [[ ${REPLY} -le ${nbr_of_configs} ]]; then
				if [[ ${REPLY} == 0 ]]; then
					\git -C ${OVE_PROJECT_DIR} checkout ${OVE_PROJECT_DIR}/projects/${p}/configure
				else
					cfg=$(echo ${configs} | \cut -d' ' -f${REPLY})
					cfg_basename=${cfg##*/}
					pushd ${OVE_PROJECT_DIR}/projects/${p} &>/dev/null
					\ln -sfv ${cfg_basename} configure
					popd &>/dev/null
				fi
			fi
		fi
	done

	ove-show-configuration
}

function ove_dirs_init {
	local OVE_STATE_LINK_NAME
	local OVE_TMP_LINK_NAME

	OVE_STATE_LINK_NAME="${OVE_BASE_DIR}/.ove.state"
	OVE_TMP_LINK_NAME="${OVE_BASE_DIR}/.ove.tmp"

	# global state
	[ -d /var/tmp ] && OVE_GLOBAL_STATE_DIR=/var${OVE_TMP} || OVE_GLOBAL_STATE_DIR=${OVE_TMP}
	export OVE_GLOBAL_STATE_DIR

	# project state
	if ! [ -h ${OVE_STATE_LINK_NAME} ] || [ "$(\readlink -f ${OVE_STATE_LINK_NAME})" == "" ]; then
		[ -h ${OVE_STATE_LINK_NAME} ] && \rm ${OVE_STATE_LINK_NAME}
		OVE_PROJECT_STATE_DIR=$(\mktemp -u -d -p ${OVE_GLOBAL_STATE_DIR}/${OVE_PROJECT_NAME} state-XXXXXXXXXX)

		\mkdir -p ${OVE_PROJECT_STATE_DIR}
		\ln -s ${OVE_PROJECT_STATE_DIR} ${OVE_STATE_LINK_NAME}

		# always re-create tmp link
		[ -h ${OVE_TMP_LINK_NAME} ] && \rm ${OVE_TMP_LINK_NAME}
	else
		OVE_PROJECT_STATE_DIR=$(\readlink -f ${OVE_STATE_LINK_NAME})
		! [ -e "${OVE_STATE_LINK_NAME}" ] && \mkdir -p ${OVE_PROJECT_STATE_DIR}
	fi
	export OVE_PROJECT_STATE_DIR

	# project tmp
	if ! [ -h ${OVE_TMP_LINK_NAME} ] || [ "$(\readlink -f ${OVE_TMP_LINK_NAME})" == "" ]; then
		[ -h ${OVE_TMP_LINK_NAME} ] && \rm ${OVE_TMP_LINK_NAME}
		# re-use last 10 characters from OVE_PROJECT_STATE_DIR
		OVE_PROJECT_TMP_DIR="${OVE_TMP}/${OVE_PROJECT_NAME}/tmp-${OVE_PROJECT_STATE_DIR: -10}"
		\mkdir -p ${OVE_PROJECT_TMP_DIR}
		\ln -s ${OVE_PROJECT_TMP_DIR} ${OVE_TMP_LINK_NAME}
	else
		OVE_PROJECT_TMP_DIR=$(\readlink -f ${OVE_TMP_LINK_NAME})
		! [ -e "${OVE_TMP_LINK_NAME}" ] && \mkdir -p ${OVE_PROJECT_TMP_DIR}
	fi
	export OVE_PROJECT_TMP_DIR
}

function ove_config_init {
	local f

	# keep the order
	OVE_ALL_CONFIG_FILES="${OVE_PROJECT_DIR}/.oveconfig"
	OVE_ALL_CONFIG_FILES+=" ${OVE_PROJECT_STATE_DIR}/.oveconfig"
	OVE_ALL_CONFIG_FILES+=" ${OVE_GLOBAL_STATE_DIR}/.oveconfig"
	OVE_ALL_CONFIG_FILES+=" ${HOME}/.oveconfig"
	export OVE_ALL_CONFIG_FILES

	for f in ${OVE_ALL_CONFIG_FILES}; do
		[ -e "${f}" ] && ove_read_config ${f}
	done
}

function ove_config_builtins_init {
	if [ -z "${OVE_DRY_RUN+x}" ]; then
		export OVE_DRY_RUN=0
	fi

	if [ -z "${OVE_FETCH_MAX_PARALLEL+x}" ]; then
		export OVE_FETCH_MAX_PARALLEL=0
	fi

	if [ -z "${OVE_CLONE_MAX_PARALLEL+x}" ]; then
		export OVE_CLONE_MAX_PARALLEL=0
	fi

	if [ -z "${OVE_LOCATE_SEARCH_DIR+x}" ]; then
		OVE_LOCATE_SEARCH_DIR=$(\readlink -f $(\dirname ${HOME}))
		export OVE_LOCATE_SEARCH_DIR
	fi

	if [ -z "${OVE_DEFAULT_BRANCH_NAME+x}" ]; then
		export OVE_DEFAULT_BRANCH_NAME="main"
	fi

	if [ -z "${OVE_PROJECT_CI_BRANCH+x}" ]; then
		export OVE_PROJECT_CI_BRANCH="origin/${OVE_DEFAULT_BRANCH_NAME}"
	fi

	if [ -z "${OVE_LOGLEVEL+x}" ]; then
		export OVE_LOGLEVEL=1
		export OVE_REDIRECT_OUTPUT=""
	fi

	if [ -z "${OVE_AUTOCORRECT+x}" ]; then
		export OVE_AUTOCORRECT=0
	fi

	if [ -z "${OVE_REVTAB_CHECK+x}" ]; then
		export OVE_REVTAB_CHECK=1
	fi

	if [ -z "${OVE_LOG_DIR_DISK_USAGE_WARNING_MB+x}" ]; then
		export OVE_LOG_DIR_DISK_USAGE_WARNING_MB=100
	fi
}

# re-initialize
function ove_reinit {
	if ! ove_init; then
		return 1
	fi

	ove_post_checks
}

# init:initialize OVE workspace
function ove_init {
	local dir
	local script_help

	if ! dir=$(ove_get_base_dir); then
		return 1
	fi
	OVE_BASE_DIR="${dir}"

	OVE_ECHO=$(\which echo)
	OVE_PROJECT_DIR=$(\readlink -f ${OVE_BASE_DIR}/.owel)
	OVE_PROJECT_NAME=${OVE_PROJECT_DIR##*/}
	OVE_PROJECT_LIST=$(ove_list_projects)
	OVE_PROJECT_COMMANDS=$(ove_project_commands_list)
	OVE_DIR="$(cd "$(\dirname "$(\readlink -f ${OVE_BASE_DIR}/${BASH_SOURCE[0]##*/})")"; pwd -P)"
	dir="$(\readlink -f ${OVE_BASE_DIR}/${BASH_SOURCE[0]##*/})"
	OVE_BASENAME="${dir##*/}"
	OVE_SELF="${OVE_DIR}/${OVE_BASENAME}"

	ove_dirs_init
	ove_config_init
	ove_revtab_init
	if ! ove_revtab_parse; then
		return 1
	fi
	ove_projects_init
	if ! ove_projects_parse; then
		return 1
	fi
	ove_scripts_init

	ove_sanitise_vars

	if [ "${OVE_LOGLEVEL}" == "2" ]; then
		set -x
	fi

	if [ -n "${OVE_TRACE_CMD+x}" ]; then
		echo ${BASHPID} > ${OVE_PROJECT_TMP_DIR}/trace.pid
		while true; do
			[ -e ${OVE_PROJECT_TMP_DIR}/trace.cont ] && break
		done
	fi

	[ "$1" == "quick" ] && return 0

	if ! ove_validate_self; then
		return 1
	fi

	if ! [ -L ${OVE_BASE_DIR}/README ]; then
		if [ -s ${OVE_PROJECT_DIR}/README ]; then
			( cd ${OVE_BASE_DIR} && \ln -s -r ${OVE_PROJECT_DIR}/README .)
		elif [ -s ${OVE_PROJECT_DIR}/README.md ]; then
			( cd ${OVE_BASE_DIR} && \ln -s -r ${OVE_PROJECT_DIR}/README.md README )
		fi
	fi

	ove_update_tab_complete

	ove_config_builtins_init

	export OVE_REPO_LIST
	export OVE_ECHO
	export OVE_BUILD_ORDER
	export OVE_BASE_DIR
	export OVE_PROJECT_DIR
	export OVE_PROJECT_LIST
	export OVE_PROJECT_COMMANDS
	export OVE_DIR
	export OVE_BASENAME
	export OVE_SELF
	export OVE_PROJECT_NAME

	OVE_LOG_DIR="${OVE_GLOBAL_STATE_DIR}/logs"
	export OVE_LOG_DIR
	! [ -d "${OVE_LOG_DIR}" ] && \mkdir -p "${OVE_LOG_DIR}"

	OVE_STAGE_DIR=${OVE_BASE_DIR}/stage
	export OVE_STAGE_DIR
	OVE_ARCHIVE_DIR=${OVE_BASE_DIR}/archives
	export OVE_ARCHIVE_DIR
	: "${OVE_PREFIX:=/usr}"
	export OVE_PREFIX
	OVE_LDFLAGS=" -L${OVE_STAGE_DIR}${OVE_PREFIX}/lib -Wl,-rpath-link=${OVE_STAGE_DIR}${OVE_PREFIX}/lib"
	export OVE_LDFLAGS
	OVE_CPPFLAGS=" -I${OVE_STAGE_DIR}${OVE_PREFIX}/include"
	export OVE_CPPFLAGS
	OVE_SHA=$(\git -C ${OVE_DIR} rev-parse --short HEAD)
	export OVE_SHA
	OVE_LAST_COMMAND=
	export OVE_LAST_COMMAND
	# shellcheck disable=SC2016
	OVE_INIT_STRING='eval source ${OVE_BASE_DIR}/ove; ove_init quick'
	export OVE_INIT_STRING
	OVE_PAGER="less -R"
	export OVE_PAGER

	# Update executable and run-time library paths
	PATH=${PATH}:${OVE_STAGE_DIR}${OVE_PREFIX}/bin
	export PATH

	LD_LIBRARY_PATH=${OVE_STAGE_DIR}${OVE_PREFIX}/lib
	export LD_LIBRARY_PATH

	if ! ( for i in {1..205} ; do echo -n 123456789, ; done ; echo ) | \column -t -s "," &> /dev/null; then
		OVE_COLUMN_WRAP_BUG=1
	else
		OVE_COLUMN_WRAP_BUG=0
	fi
	export OVE_COLUMN_WRAP_BUG

	if \less --version |& \head -1 | \grep -q '^less [0-9]\+'; then
		OVE_LESS_MORE_OPTIONS=1
	else
		OVE_LESS_MORE_OPTIONS=0
	fi
	export OVE_LESS_MORE_OPTIONS

	OVE_SCRIPT_OPTIONS+="-q "
	script_help=$(2>&1 \script --help)
	if [[ "${script_help}" != *"invalid option"* ]]; then
		[[ "${script_help}" == *"-e"* ]] && OVE_SCRIPT_OPTIONS+="-e "
		[[ "${script_help}" == *"-f"* ]] && OVE_SCRIPT_OPTIONS+="-f "
	fi
	export OVE_SCRIPT_OPTIONS

	ove_update_checksum

	return 0
}

function ove_corrupt_repos {
	local repo

	for repo in ${OVE_REPO_LIST}; do
		# ignore repos not yet fetched
		[ -d ${repo} ] || continue
		# repos without a .git directory
		[ -d ${repo}/.git ] || echo -n "${repo/${OVE_BASE_DIR}\/} "
	done
}

function ove_disk_usage_check {
	local log_dir_disk_usage

	# log dir disk usage
	if [ ${OVE_LOG_DIR_DISK_USAGE_WARNING_MB} -ne 0 ]; then
		log_dir_disk_usage=$(\du -B 1M -s ${OVE_LOG_DIR})
		log_dir_disk_usage=${log_dir_disk_usage%%$'\t'*}
		if [ $log_dir_disk_usage -ge ${OVE_LOG_DIR_DISK_USAGE_WARNING_MB} ]; then
			echo
			ove_echo_note_noprefix "the directory '${OVE_LOG_DIR}' is ${log_dir_disk_usage}MB, you might want to:"
			echo
			echo "- remove OVE logs older than X days:"
			echo -e "\tove rm-logs X"
			echo "- increase the threshold (=${OVE_LOG_DIR_DISK_USAGE_WARNING_MB}MB) for this NOTE 10x times:"
			echo -e "\tove add-config ${OVE_GLOBAL_STATE_DIR}/.oveconfig OVE_LOG_DIR_DISK_USAGE_WARNING_MB $((OVE_LOG_DIR_DISK_USAGE_WARNING_MB * 10))"
			echo "- suppress this NOTE:"
			echo -e "\tove add-config ${OVE_GLOBAL_STATE_DIR}/.oveconfig OVE_LOG_DIR_DISK_USAGE_WARNING_MB 0"
		fi
	fi
}

function ove_post_checks {
	local c
	local corrupt_repos
	local doublets
	local f
	local res
	local script

	# check for systest doublets
	if [ -e ${OVE_PROJECT_DIR}/systests ]; then
		# yes, this is ugly
		mapfile -t doublets < <(\grep -E -v '#|^$' ${OVE_PROJECT_DIR}/systests | \
			\awk '{print $1}' | \
			\cut -d: -f1 | \
			LC_ALL="C" \sort | \
			\uniq -d)
		if [ "${doublets[*]}" != "" ]; then
			echo
			ove_echo_yellow_noprefix "warning: found ${#doublets[*]} systest duplicate(s):"
			for c in ${doublets[*]}; do
				\grep -H -n -w ^${c} ${OVE_PROJECT_DIR}/systests
			done
		fi
	fi

	# check for config doublets
	for f in $(ove_list_oveconfig_files); do
		mapfile -t doublets < <(\grep -E -v '#|^$' ${f} | \awk '{print $1}' | LC_ALL="C" \sort | \uniq -d)
		if [ "${doublets[*]}" != "" ]; then
			echo
			ove_echo_yellow_noprefix "warning: found ${#doublets[*]} config duplicate(s):"
			for c in ${doublets[*]}; do
				\grep -H -n -w ${c} ${f}
			done
		fi
	done

	# keep ${HOME}/.ove.bash up-to-date
	if [ -e "${HOME}/.ove.bash" ] && ! \diff -q "${OVE_DIR}/ove.bash" "${HOME}/.ove.bash"; then
		\cp -b -v "${OVE_DIR}/ove.bash" "${HOME}/.ove.bash"
	fi

	# check for script doublets
	mapfile -t doublets < <(for script in $(ove-list-scripts); do echo ${script##*/}; done | \
		LC_ALL="C" \sort | \
		\uniq -d)
	if [ "${doublets[*]}" != "" ]; then
		echo
		ove_echo_yellow_noprefix "warning: found ${#doublets[*]} script duplicate(s):"
		for script in ${doublets[*]}; do
			ove-list-scripts | \grep "/${script}$"
		done
	fi

	# check for corrupt repos
	corrupt_repos="$(ove_corrupt_repos)"
	if [ "${corrupt_repos}" != "" ]; then
		echo
		ove_echo_error_noprefix "corrupt repo(s): ${corrupt_repos}"
		echo
		ove_echo_red_noprefix "fix this by running the following two commands:"
		echo
		echo -e "\t$ rm -rf ${corrupt_repos}"
		echo -e "\t$ ove fetch ${corrupt_repos}"
		echo
	fi

	# inform user if logs etc. take too much space
	ove_disk_usage_check

	# validate revtab revision
	ove_revtab_check
}

function ove_buildable_projects {
	local deps
	local i
	local proj
	local proj_path
	local projs_and_deps_not_buildable
	local projs_not_buildable
	local q
	local re
	declare -A projs_hash

	# remove projects with paths within git repos not yet fetched
	for proj in ${OVE_PROJECT_LIST}; do
		i=${ove_projects_name2index[${proj}]}
		proj_path="${OVE_BASE_DIR}/${ove_projects_path[${i}]}"
		for q in ${OVE_REPO_LIST}; do
			if [[ ${proj_path} == *"${q}"* ]] && ! [ -d "${q}" ]; then
				test "${projs_hash["${proj}"]+isset}" && continue
				projs_hash["${proj}"]=1
				projs_not_buildable+="${proj} "
			fi
		done
	done

	if [ "${projs_not_buildable}" == "" ]; then
		unset OVE_PROJECT_LIST_BUILDABLE
		return
	fi

	# remove none buildable projects and its dependencies
	projs_and_deps_not_buildable="${projs_not_buildable}"
	for proj in ${OVE_PROJECT_LIST}; do
		deps=$(ove_get_deps_recursive ${proj})
		for q in ${projs_not_buildable}; do
			re=\\b${q}\\b
			if [[ "${deps}" =~ ${re} ]]; then
				re=\\b${proj}\\b
				# already marked as removed?
				if [[ "${projs_and_deps_not_buildable}" =~ ${re} ]]; then
					continue
				fi
				projs_and_deps_not_buildable+="${proj} "
			fi
		done
	done

	OVE_PROJECT_LIST_BUILDABLE=$(LC_ALL="C" \comm -3 \
		<(echo ${OVE_PROJECT_LIST} | \xargs -n1 | LC_ALL="C" \sort) \
		<(\xargs -n1 <<<"${projs_and_deps_not_buildable}" | LC_ALL="C" \sort) |
		\xargs)
	export OVE_PROJECT_LIST_BUILDABLE
}

# init:|[DIR]|[DIR NAME]:scan directories and look for git repositories, if found create/update a OVE workspace
function ove-init {
	local d
	local dir
	local do_init_git
	local doublets
	local fetch_url
	local i
	local name
	local ove_link
	local owel_default
	local owel_name
	local push_url
	local repo
	local revision
	local revtabs
	local revtab_file
	local str

	if [ $# -eq 0 ]; then
		while true; do
			read -r -p "Directory to scan for git repositories? Leave blank to search in '$PWD': "
			if [ "${REPLY}" == "" ]; then
				if ove_is_base_dir "${PWD}"; then
					ove_echo_error_noprefix "'${PWD}' is already a OVE workspace. Remove the symblic link '${PWD}/.owel' to be able to re-init this directory."
					continue
				fi

				dir=${PWD}
				break
			fi

			if ! [ -d ${REPLY} ]; then
				ove_echo_error_noprefix "'${REPLY}' is not a directory, try again"
				continue
			fi

			if ove_is_base_dir "${REPLY}"; then
				ove_echo_error_noprefix "'${REPLY}' is already a OVE workspace. Remove the symbolic link '${REPLY%/}/.owel' to be able to re-init this directory."
				continue
			fi
			dir=${REPLY}
			break
		done

	elif [ $# -lt 3 ]; then
		if ! [ -d ${1} ]; then
			ove_echo_error_noprefix "'${1}' is not a directory"
			return 1
		fi
		if ove_is_base_dir "${1}"; then
			ove_echo_error_noprefix "'${1}' is already a OVE workspace. Remove the symbolic link '${1%/}/.owel' to be able to re-init this directory."
			return 1
		fi
		dir=${1}
	fi

	# remove any trailing slash
	[ ${#dir} -ne 1 ] && dir="${dir%/}"

	if ! [ -w "${dir}" ]; then
		ove_echo_error_noprefix "sorry you are not allowed to create files/directories here: '${dir}'"
		return 1
	fi

	if [ -e ${dir}/ove ] && ! [ -L ${dir}/ove ]; then
		ove_echo_error_noprefix "you already have a file/directory named '${dir}/ove', rename/remove to proceed"
		return 1
	fi

	mapfile -t revtabs < <(\find ${dir} -mindepth 2 -maxdepth 2 -name revtab)
	if [ $# -lt 2 ] && [ ${#revtabs[*]} -eq 1 ]; then
		owel_default="$(\basename $(\dirname ${revtabs[0]}))"
	else
		owel_default="top"
	fi

	if [ $# -eq 0 ] || [ $# -eq 1 ]; then
		while true; do
			read -r -p "Top level repo name? Leave blank to name it '${owel_default}': "
			if [ "${REPLY}" == "" ]; then
				owel_name="${owel_default}"
			else
				owel_name="${REPLY}"
			fi
			break
		done
	elif [ $# -eq 2 ]; then
		owel_name=${2}
	fi

	dir=$(\readlink -f ${dir})
	i=0
	do_init_git=0

	# updating an existing git repo?
	if [ -d ${dir}/${owel_name}/.git ]; then
		owel_remote=$(\git -C "${dir}/${owel_name}" remote -v | \
			\grep fetch | \
			\awk '{print $2}')
	else
		do_init_git=1
	fi

	while read -r repo; do
		if ! \git -C ${repo} log -1 --oneline &> /dev/null; then
			continue
		fi

		name=$(\dirname "${repo}")
		name=${name/${dir}\//}

		fetch_url=$(\git -C "${repo}" remote -v | \
			\grep fetch | \
			\awk '{print $2}')
		[ "${fetch_url}" == "" ] && fetch_url="noremote"
		# ignore OWEL remote
		[ "${fetch_url}" == "${owel_remote}" ] && continue

		push_url=$(\git -C "${repo}" remote -v | \
			\grep push | \
			\awk '{print $2}')
		[ "${push_url}" == "" ] && push_url="noremote"

		# detached?
		if ! \git -C "${repo}" symbolic-ref -q HEAD > /dev/null; then
			revision=$(\git -C "${repo}" rev-parse --short HEAD)
		else
			revision=$(\git -C "${repo}" branch | \
				\cut -d' ' -f2 | \
				\tr -d '\n')
		fi

		((i++))
		echo -en "Scanning '${dir}'. #repos: ${i}\r"
		str+="${name} ${fetch_url} ${push_url} ${revision}\n"
	done < <(\find "${dir}" -type d -name .git 2>/dev/null)

	if [ ${i} -eq 0 ]; then
		ove_echo_error_noprefix "no git repositories found here: '${dir}'"
		return 1
	fi

	echo
	\mkdir -p ${dir}/${owel_name}

	if [ ${do_init_git} -eq 1 ]; then
		\git -C ${dir}/${owel_name} init || return 2
	fi

	# owel symlink
	(cd ${dir} && \ln -s ${owel_name} .owel)

	# symlink self
	if ! [ -L ${dir}/ove ]; then
		if [ "${OVE_SELF}" == "" ]; then
			ove_link=$(\readlink -f ${BASH_SOURCE[0]})
		else
			ove_link=${OVE_SELF}
		fi
		(cd ${dir} && \ln -s ${ove_link} ove)
	fi

	# create a revtab file
	revtab_file="${dir}/${owel_name}/revtab"
	printf "${str}" | \
		\column -t | \
		LC_ALL="C" \sort > ${revtab_file}

	# inform user on repos with same fetch url
	mapfile -t doublets < <(\awk '{print $2}' ${revtab_file} | \grep -v noremote | LC_ALL="C" \sort | \uniq -d)
	if [ "${doublets[*]}" != "" ]; then
		ove_echo_note_noprefix "found a few repos with the same fetch url:"
		for d in ${doublets[*]}; do
			\grep -H -n "${d}" ${revtab_file}
			echo "--"
		done | \column -t
	fi

	echo "---"
	echo "Init summary:"
	echo "* created/updated '${revtab_file}' and with ${i} repositories"
	if [ "${ove_link}" != "" ]; then
		echo "* created a symbolic link '${dir}/ove' -> '${ove_link}'"
	fi
	echo "* created a symbolic link '${dir}/.owel' -> '${dir}/${owel_name}'"

	if [ ${do_init_git} -eq 1 ]; then
		echo "* created a empty git repository here: '${dir}/${owel_name}'"
	fi
	if [ ${#doublets[*]} -ne 0 ]; then
		echo "* found that a few repos are mentioned more than one time in '${revtab_file}', details above"
	fi
	if [ ${dir} != "${PWD}" ]; then
		cd ${dir} || return 1
		echo "* changed current working directory to ${dir}"
	fi
}

# $1: command
function ove_command_to_package {
	local package

	# column
	if [ "$1" == "column" ]; then
		if [[ ${OVE_OS} == *"Ubuntu"* ]] || \
			[[ ${OVE_OS} == *"Debian"* ]]; then
			package="bsdmainutils"
		elif [[ ${OVE_OS} == *"Gentoo"* ]]; then
			package="sys-apps/util-linux"
		else
			package="util-linux"
		fi
	# git
	elif [ "$1" == "git" ]; then
		if [[ ${OVE_OS} == *"Alpine"* ]]; then
			package="git git-perl"
		elif [[ ${OVE_OS} == *"Gentoo"* ]]; then
			package="dev-vcs/git"
		fi
	# less
	elif [ "$1" == "less" ]; then
		if [[ ${OVE_OS} == *"Gentoo"* ]]; then
			package="sys-apps/less"
		fi
	# locate
	elif [ "$1" == "locate" ]; then
		package="mlocate"
	# pgrep
	elif [ "$1" == "pgrep" ]; then
		if [[ ${OVE_OS} == *"Ubuntu"* ]] || \
			[[ ${OVE_OS} == *"Debian"* ]]; then
			package="procps"
		fi
	# script
	elif [ "$1" == "script" ]; then
		if [[ ${OVE_OS} == *"Ubuntu"* ]] || \
			[[ ${OVE_OS} == *"Debian"* ]]; then
			package="bsdutils"
		elif [[ ${OVE_OS} == *"Gentoo"* ]]; then
			package="sys-apps/util-linux"
		else
			package="util-linux"
		fi
	# tree
	elif [ "$1" == "tree" ]; then
		if [[ ${OVE_OS} == *"Gentoo"* ]]; then
			package="app-text/tree"
		fi
	# tsort
	elif [ "$1" == "tsort" ]; then
		package="coreutils"
	# xz
	elif [ "$1" == "xz" ]; then
		if [[ ${OVE_OS} == *"Ubuntu"* ]] || \
			[[ ${OVE_OS} == *"Debian"* ]]; then
			package="xz-utils"
		elif [[ ${OVE_OS} == *"Gentoo"* ]]; then
			package="app-arch/xz"
		fi
	fi

	[ "${package}" != "" ] && echo ${package} || echo $1
}

function ove_deps {
	local dep
	local deps
	local pack
	local str_cmds
	local str_packs

	str_packs=""
	str_cmds=""

	deps=()
	deps+=('bzip2')
	deps+=('column')
	deps+=('file')
	deps+=('git')
	deps+=('gzip')
	deps+=('less')
	deps+=('pgrep')
	deps+=('script')
	deps+=('tree')
	deps+=('tsort')
	deps+=('which')

	for dep in "${deps[@]}"; do
		if ! command -v ${dep} > /dev/null; then
			str_cmds+="${dep} "
			pack=$(ove_command_to_package ${dep})
			if [ "${pack}" != "" ]; then
				str_packs+="${pack} "
			fi
		fi
	done

	if [ "${str_cmds}" != "" ]; then
		ove_echo_error_noprefix "missing command(s):"
		echo
		for dep in ${str_cmds}; do
			echo -e "\t${dep}"
		done | LC_ALL="C" \sort
		echo
		echo "To fix this, run the following command:"
		echo
		echo -e "\t${OVE_OS_PACKAGE_MANAGER} ${OVE_OS_PACKAGE_MANAGER_ARGS} ${str_packs}"
		echo
		return 1
	fi

	ove_version_check || return 1

	return 0
}

# $*: list of packages
# returns a list of packages NOT installed
function ove_packages_not_installed {
	local p_sort

	[ $# -eq 0 ] && return

	p_sort=$(\xargs -n1 <<<"$@" | LC_ALL="C" \sort -u)

	if [[ ${OVE_OS} == *"Arch Linux"* ]]; then
		LC_ALL="C" \comm -2 -3 <(\xargs -n1 <<<${p_sort}) <(\pacman -Q | \awk '{print $1}')
	elif [[ ${OVE_OS} == *"Alpine"* ]]; then
		LC_ALL="C" \comm -2 -3 <(\xargs -n1 <<<${p_sort}) <(\apk info | LC_ALL="C" \sort)
	elif [[ ${OVE_OS} == *"CentOS"* ]] || \
		[[ ${OVE_OS} == *"Fedora"* ]] || \
		[[ ${OVE_OS} == *"RedHatEnterpriseServer"* ]]; then
		LC_ALL="C" \comm -2 -3 <(\xargs -n1 <<<${p_sort}) <(\rpm -qa --qf "%{NAME}\n"| LC_ALL="C" \sort)
	elif [[ ${OVE_OS} == *"Debian"* ]] || \
		[[ ${OVE_OS} == *"Raspbian"* ]] || \
		[[ ${OVE_OS} == *"Ubuntu"* ]]; then
		dpkg-query -W -f='${Package}:${Status}\n' ${p_sort} 2>&1 | \
			\grep -v ":install ok installed" | \
			\sed -e 's/dpkg-query: no packages found matching //g' -e 's/:.*//g' | \
			\xargs
	elif [[ ${OVE_OS} == *"void"* ]]; then
		LC_ALL="C" \comm -2 -3 \
			<(\xargs -n1 <<<${p_sort}) \
			<(\xbps-query --list-pkgs | \awk '{print $2}' | \rev | \cut -d- -f2- | \rev | LC_ALL="C" \sort | \xargs -n1)
	else
		ove_echo_error_noprefix "function '${FUNCNAME[0]}' is not implemented for ${OVE_OS}"
	fi
}

function ove_determine_dist_version_and_pack_manager {
	if [ -e /etc/os-release ]; then
		OVE_OS=$(source /etc/os-release; echo ${NAME})
		OVE_OS_VER=$(source /etc/os-release; echo ${VERSION_ID})
	elif command -v lsb_release > /dev/null; then
		OVE_OS=$(\lsb_release --id --short)
		OVE_OS_VER=$(\lsb_release --release --short)
	else
		ove_echo_warning_noprefix "unable to determine distro"
		OVE_OS=$(\uname -s)
		OVE_OS_VER=$(\uname -r)
	fi


	if [[ ${OVE_OS} == *"Alpine"* ]]; then
		OVE_OS_PACKAGE_MANAGER="apk"
		OVE_OS_PACKAGE_MANAGER_ARGS="add"
	elif [[ ${OVE_OS} == *"Arch Linux"* ]]; then
		OVE_OS_PACKAGE_MANAGER="pacman"
		OVE_OS_PACKAGE_MANAGER_ARGS="-S"
	elif [[ ${OVE_OS} == *"CentOS"* ]]; then
		OVE_OS_PACKAGE_MANAGER="yum"
		OVE_OS_PACKAGE_MANAGER_ARGS="install"
	elif [[ ${OVE_OS} == *"Debian"* ]] || \
		[[ ${OVE_OS} == *"Raspbian"* ]] || \
		[[ ${OVE_OS} == *"Ubuntu"* ]]; then
		OVE_OS_PACKAGE_MANAGER="apt"
		OVE_OS_PACKAGE_MANAGER_ARGS="install"
	elif [[ ${OVE_OS} == *"Fedora"* ]] || \
		[[ ${OVE_OS} == *"RedHatEnterpriseServer"* ]]; then
		OVE_OS_PACKAGE_MANAGER="dnf"
		OVE_OS_PACKAGE_MANAGER_ARGS="install"
	elif [[ ${OVE_OS} == *"Gentoo"* ]]; then
		OVE_OS_PACKAGE_MANAGER="emerge"
		OVE_OS_PACKAGE_MANAGER_ARGS=""
	elif [[ ${OVE_OS} == *"openSUSE"* ]] || \
		[[ ${OVE_OS} == *"SLES"* ]]; then
		OVE_OS_PACKAGE_MANAGER="zypper"
		OVE_OS_PACKAGE_MANAGER_ARGS="install"
	elif [[ ${OVE_OS} == *"void"* ]]; then
		OVE_OS_PACKAGE_MANAGER="xbps-install"
		OVE_OS_PACKAGE_MANAGER_ARGS=""
	else
		OVE_OS_PACKAGE_MANAGER="unknown"
		OVE_OS_PACKAGE_MANAGER_ARGS=""
	fi

	export OVE_OS
	export OVE_OS_VER
	export OVE_OS_PACKAGE_MANAGER
	export OVE_OS_PACKAGE_MANAGER_ARGS
}

# fsck:[GIT...]:git fsck --full for all/specified git repositories
function ove-fsck {
	local cmd

	cmd="ove_echo_yellow_noprefix \$(pwd -P) && \
		\git -C \${repo} fsck --full || \
		ove_echo_error_noprefix \'\git -C \$(pwd -P) fsck --full\' returned != 0, corrupt repo?; echo"

	if [ $# -eq 0 ]; then
		ove_revtab_forall "${cmd}"
	else
		ove_revtab_forsome "${cmd}" "$*"
	fi
}

# show-dangling:[GIT...]:show dangling git objects (=blob|commit|tag|tree) for all/specified git repositories
function ove-show-dangling {
	local sha_list

	sha_list=$(ove-fsck "$@" | \grep '^dangling' | \awk '{print $3}')
	[ "${sha_list}" == "" ] || ove-show ${sha_list}
}

# readme:[GIT...]:display README files for all/specified git repositories
function ove-readme {
	local cmd

	# shellcheck disable=SC2016
	cmd='\find ${PWD} -maxdepth 1 -name "README*" -print0 | '
	cmd+='\xargs -r -0 \head -v |'
	# shellcheck disable=SC2016
	cmd+='\sed -e "1 i$(ove_echo_yellow_noprefix $(pwd -P))" -e "s/^/\t/g"'

	if [ $# -eq 0 ]; then
		ove_revtab_forall "${cmd}"
	else
		ove_revtab_forsome "${cmd}" "$*"
	fi
}

# replicate:HOST:replicate OVE workspace on HOST
function ove-replicate {
	local d
	local host
	local p
	local s

	if [ $# -ne 1 ]; then
		ove-help ^${FUNCNAME/ove-/}
		return 1
	fi

	s="$(ove-setup)"
	if [ "${s}" == "" ]; then
		ove_echo_error_noprefix "'${OVE_PROJECT_DIR}/SETUP' file not found"
		return 2
	fi

	host="$1"
	if ! \ssh -q ${host} exit; then
		ove_echo_error_noprefix "'${host}' is not reachable via ssh"
		return 3
	fi

	# remote directory
	d=$(\ssh ${host} mktemp -d)

	# only diffs relative to the index is included (for now)
	p=$(\mktemp -p ${OVE_PROJECT_TMP_DIR})
	ove-diff > ${p}
	if [ -s "${p}" ]; then
		p_remote="${d}/${OVE_PROJECT_NAME}.patch"
		if ! scp -q ${p} ${host}:${p_remote}; then
			ove_echo_error_noprefix "not possible to transfer patch file to '${host}'"
			\rm ${p}
			return 4
		fi
	fi

	if ! \ssh ${host} "
		echo $ ssh ${host};
		echo $ cd ${d}; cd ${d};
		echo $ '${s}'; eval ${s};
		cd \$(\find \${PWD} -maxdepth 1 -mindepth 1 -type d);
		echo $ pwd; echo \${PWD};
		echo $ source ove; source ove;
		ove_init;
		echo $ ove fetch; ove-fetch;
		[ -e \"${p_remote}\" ] && echo '$ ove apply ${p_remote}' && ove-apply ${p_remote};
		echo $ ove status; ove-status"; then
		ove_echo_error_noprefix "trying to replicate OVE workspace on '${host}'"
	else
		echo
		echo "OVE workspace has been replicated to '${host}:${d}'"
	fi

	\rm ${p}
}

function ove_unittest_preparations {
	local a
	local b
	local i
	local nbr_of_files
	local nbr_of_projs
	local nbr_of_repos
	local nbr_of_systests
	local unittest_dir

	nbr_of_files=$1
	nbr_of_projs=$2
	nbr_of_repos=$3
	nbr_of_systests=$4

	unittest_dir="${OVE_PROJECT_TMP_DIR}/unittest"

	echo "${unittest_dir}"
	[ -d ${unittest_dir} ] && \
		\rm -rf ${unittest_dir}
	\mkdir -p ${unittest_dir}/.ove

	cd ${unittest_dir} || return 1
	\ln -s ${OVE_SELF} ove
	\ln -s ${OVE_DIR}/tests .

	# remotes
	\mkdir -p remotes

	# create some remote bare repos
	for a in $(\seq 1 ${nbr_of_repos}) top; do
		\mkdir -p ${unittest_dir}/remotes/git-${a}
		if ! [ -d .git ]; then
			\git init -q --bare ${unittest_dir}/remotes/git-${a}
			git -C ${unittest_dir}/remotes/git-${a} symbolic-ref HEAD refs/heads/${OVE_DEFAULT_BRANCH_NAME}
		fi
	done

	# clone all repositories
	\mkdir -p testing/src
	for a in $(\seq 1 ${nbr_of_repos}); do
		if [ $((a%2)) -eq 0 ]; then
			\git clone -q remotes/git-${a} ${unittest_dir}/testing/src/git-${a} &> /dev/null
		else
			\git clone -q remotes/git-${a} ${unittest_dir}/git-${a} &> /dev/null
		fi
	done
	\git clone -q ${unittest_dir}/remotes/git-top &> /dev/null
	\ln -s git-top .owel

	# add some files
	for a in $(\seq 1 ${nbr_of_repos}); do
		if [ $((a%2)) -eq 0 ]; then
			cd ${unittest_dir}/testing/src/git-${a}
		else
			cd ${unittest_dir}/git-${a}
		fi

		for i in $(\seq 1 ${nbr_of_files}); do
			filename=$(\head /dev/urandom | \tr -dc A-Za-z0-9 | \head -c 13 ; echo '')
			touch ${filename}
			\git add ${filename}
			\git commit -q -m "${filename}"
			[ $i -eq 1 ] && \git checkout -q -b ${OVE_DEFAULT_BRANCH_NAME} 2> /dev/null
			\git tag 0.0.${i}
			\git push -q origin ${OVE_DEFAULT_BRANCH_NAME}
			[ $i -eq 1 ] && \git branch -q --set-upstream-to=origin/${OVE_DEFAULT_BRANCH_NAME}
			\git push -q --tags
		done
	done

	# create revtab
	for a in $(\seq 1 ${nbr_of_repos}); do
		if [ $((a%2)) -eq 0 ]; then
			echo "testing/src/git-${a} ${unittest_dir}/remotes/git-${a} ${unittest_dir}/remotes/git-${a} ${OVE_DEFAULT_BRANCH_NAME}" >> ${unittest_dir}/git-top/revtab
		else
			echo "git-${a} ${unittest_dir}/remotes/git-${a} ${unittest_dir}/remotes/git-${a} ${OVE_DEFAULT_BRANCH_NAME}" >> ${unittest_dir}/git-top/revtab
		fi
	done

	# create projs
	for a in $(\seq 1 ${nbr_of_projs}); do
		echo "p${a}:" >> ${unittest_dir}/git-top/projs
		echo "  path: .owel" >> ${unittest_dir}/git-top/projs
		if [ ${a} -lt ${nbr_of_projs} ]; then
			echo "  deps: p$((a+1))" >> ${unittest_dir}/git-top/projs
		fi
		echo >> ${unittest_dir}/git-top/projs
		\mkdir -p ${unittest_dir}/git-top/projects/p${a}
		for b in bootstrap configure build install; do
			echo "#!/bin/bash" > ${unittest_dir}/git-top/projects/p${a}/${b}
			echo "echo ${b} p${a}" >> ${unittest_dir}/git-top/projects/p${a}/${b}
			chmod +x ${unittest_dir}/git-top/projects/p${a}/${b}
		done
	done

	# create systests
	for a in $(\seq 1 ${nbr_of_systests}); do
		echo "ok${a} 10 0 \"\" true" >> ${unittest_dir}/git-top/systests
		echo "nok${a} 10 0 \"\" false" >> ${unittest_dir}/git-top/systests
	done
	# create systests-groups
	echo "all:" >> ${unittest_dir}/git-top/systests-groups
	for a in $(\seq 1 ${nbr_of_systests}); do
		echo "- ok${a}" >> ${unittest_dir}/git-top/systests-groups
		echo "- nok${a}" >> ${unittest_dir}/git-top/systests-groups
	done

	# commit and push
	\git -C ${unittest_dir}/git-top add .
	\git -C ${unittest_dir}/git-top commit -q -m "test"
	\git -C ${unittest_dir}/git-top checkout -q -b ${OVE_DEFAULT_BRANCH_NAME} 2> /dev/null
	\git -C ${unittest_dir}/git-top push -q origin ${OVE_DEFAULT_BRANCH_NAME}
	\git -C ${unittest_dir}/git-top branch -q --set-upstream-to=origin/${OVE_DEFAULT_BRANCH_NAME}
}

# unittest:[TEST...]:run all/specific unit tests
function ove-unittest {
	local a
	local b
	local do_preparations
	local i
	local nbr_of_files
	local nbr_of_projs
	local nbr_of_repos
	local nbr_of_systests
	local tests

	if ! command -v shelltest > /dev/null; then
		ove_echo_command_not_found "shelltestrunner" "Version 1.9 or greater is needed."
		return 1
	fi

	if [ $# -eq 0 ]; then
		tests="tests/t*.test"
	else
		for a in "$@"; do
			if ! [ -e "${OVE_DIR}/tests/${a}.test" ]; then
				continue
			fi
			tests+="tests/${a}.test "
		done

		if [ "${tests}" == "" ]; then
			echo "error: select test(s) from:"
			\find ${OVE_DIR}/tests -name 't*.test' -type f -exec basename {} .test \; | LC_ALL="C" \sort
			return 1
		fi
	fi

	nbr_of_files=3
	nbr_of_projs=400
	nbr_of_repos=100
	nbr_of_systests=3

	do_preparations=1
	if [ -t 1 ] && [ -d ${OVE_PROJECT_TMP_DIR}/unittest ]; then
		do_preparations=0
		read -p "reuse '${OVE_PROJECT_TMP_DIR}/unittest'? (Y/n) " -r
		if [[ ${REPLY} =~ ^[Nn]$ ]]; then
			do_preparations="1"
		fi
	fi

	[ ${do_preparations} -eq 1 ] && \
		ove_unittest_preparations ${nbr_of_files} ${nbr_of_projs} ${nbr_of_repos} ${nbr_of_systests}

	# launch shelltestrunner
	cd ${OVE_PROJECT_TMP_DIR}/unittest || return 2
	shelltest=$(command -v shelltest)
	if [ ${OVE_LOGLEVEL} -eq 2 ]; then
		shelltest_opts=" --debug "
	fi

	\env -i - HOME=${HOME} USER=${USER} \
		${shelltest} ${tests} \
		${shelltest_opts} \
		--color \
		--diff \
		-a \
		-DOVE_TEST_STRING="source ove > /dev/null; ove_init > /dev/null; ove-loglevel 0 > /dev/null" \
		-DOVE_DEFAULT_BRANCH_NAME=${OVE_DEFAULT_BRANCH_NAME} \
		-Dnbr_of_systests=$(((nbr_of_systests * 2) + 1)) \
		-Dnbr_of_repos=$((nbr_of_repos + 1 )) \
		-Dnbr_of_files=$((nbr_of_files * nbr_of_repos + (4 * nbr_of_projs) + 4)) \
		-DOVE_DIR=${OVE_DIR} \
		-DOVE_TEST_BASE="$(\sed -e 's|/|\\/|g' <<<${OVE_PROJECT_TMP_DIR}/unittest)"
}

# less-lastlog:[USER]:peek into user(s) last OVE log using less
function ove-less-lastlog {
	ove_watch_logs "less" "$@"
}

# tail-lastlog:[USER]:peek into user(s) last OVE log using tail -f
function ove-tail-lastlog {
	ove_watch_logs "tail" "$@"
}

# $1: tail|less
# ${@:2}: users
function ove_watch_logs {
	local cmd
	local _cmd
	local d
	local i
	local ignore
	local log
	local u
	local users

	cmd=$1
	if [ "${cmd}" == "tail" ]; then
		cmd="\tail -f"
	elif [ "${cmd}" == "less" ]; then
		cmd="\less"
	else
		return 1
	fi
	shift

	if [ -d /var/tmp ]; then
		d="/var/tmp"
	else
		d="/tmp"
	fi

	# shellcheck disable=SC2164
	mapfile -t users < <(cd ${d}; \find ./*/ove/logs -maxdepth 0 -type d | \cut -d/ -f2)

	[ "${users[*]}" == "" ] && return 2

	ignore="tail-lastlog|less-lastlog"
	if [ -n "${TMUX}" ]; then
		for u in ${users[*]}; do
			[ $# -eq 1 ] && [ "${u}" != "${1}" ] && continue

			log=$(\find ${d}/${u}/ove/logs/current/ -type f | \
				\grep -v -E "${ignore}" | \
				LC_ALL="C" \sort | \
				\tail -1)

			if [ "${cmd}" == "\less" ] && [ "${OVE_LESS_MORE_OPTIONS}" -eq 1 ]; then
				_cmd="\less -Ps\"${log}\""
			else
				_cmd=${cmd}
			fi

			tmux split-window -h "${_cmd} ${log}"
			[ $# -eq 1 ] && return
			tmux select-layout tiled
		done
	else
		if [ $# -eq 1 ]; then
			u=$1
		elif [ ${#users[*]} -eq 1 ]; then
			u=${users[0]}
		else
			i=1
			for u in ${users[*]}; do
				echo "$i:$u"
				((i++))
			done
			read -r -p "user: "
			if ! [[ "${REPLY}" =~ ^[0-9]+$ ]] || [ "${REPLY}" -gt ${#users[*]} ]; then
				return 1
			fi
			echo
			u=${users[$((REPLY - 1))]}
		fi

		[ -d "${d}/${u}" ] || return 3
		log=$(\find ${d}/${u}/ove/logs/current/ -type f | \
			\grep -v -E "${ignore}" | \
			LC_ALL="C" \sort | \
			\tail -1)
		eval ${cmd} ${log}
	fi
}

# add-repo:URL|URL NAME|URL NAME REV:add a new repo to this OVE workspace
function ove-add-repo {
	local name
	local revision=${OVE_DEFAULT_BRANCH_NAME}
	local url

	if [ $# -eq 0 ] || [ $# -gt 3 ]; then
		ove-help "^${FUNCNAME/ove-/} "
		return 1
	fi

	url="${1}"
	if [ $# -eq 1 ]; then
		name="${1##*/}"
		name="${name%%.*}"

		read -r -p "name? (leave empty to name it '${name}'): "
		[ "${REPLY}" != "" ] && name="${REPLY}"
	elif [ $# -eq 2 ]; then
		name="${2}"
	elif [ $# -eq 3 ]; then
		name="${2}"
		revision="${3}"
	fi

	if [ $# -eq 1 ] || [ $# -eq 2 ]; then
		read -r -p "revision? (leave empty to use '${revision}'): "
		[ "${REPLY}" != "" ] && revision="${REPLY}"
	fi

	# update revtab
	echo "${name} ${url} ${url} ${revision}" | \tee -a "${OVE_PROJECT_DIR}/revtab"

	# parse revtab
	if ! ove_revtab_parse; then
		# remove last line
		\sed -i '$ d' "${OVE_PROJECT_DIR}/revtab"
		return 1
	fi

	if ! ove-fetch "${name}"; then
		return 1
	fi

	return 0
}

# generate-doc: :generate OVE documentation (ove-cmd-list.md/ove.bash)
function ove-generate-doc {
	local a
	local b
	local header
	local sorted

	a=$(\grep -B1 "^function ove-" "${OVE_BASE_DIR}"/ove | \
		\grep '\#' | \
		\cut -b3-)
	b=$(set | \
		\grep helptext | \
		\grep -v '\$'| \
		\cut -d'"' -f2 | \
		\grep -v -f<(\xargs -n1 <<<${OVE_SCRIPTS_LIST} | \sed -e 's|^|^|g' -e 's|$|:|g'))

	header="| Command:| Arguments:| Description: |"
	sorted=$(printf "${a}\n${b}" | \
		\sed \
		-e 's/|/@/g' \
		-e 's/:/ :| /g' \
		-e 's/^/| /g' \
		-e 's/$/: |/g' | \
		LC_ALL="C" \sort)

	printf "${header}\n|-|-|-|\n${sorted}\n" | \
		\sed -e 's/\@/\\|/g' | \
		\column -s: -t \
		> ${OVE_DIR}/ove-cmd-list.md

	\sed -i "s/^ove_built_ins=.*/ove_built_ins=\"$(ove_get_built_ins)\"/g" ${OVE_DIR}/ove.bash

	return 0
}

# shell-check: :run shellcheck on OVE
function ove-shell-check {
	local exclude

	if ! command -v shellcheck > /dev/null; then
		ove_echo_command_not_found "shellcheck"
		return 1
	fi

	# this {/} is literal...
	exclude+="SC1083,"

	# can't follow non-constant source
	exclude+="SC1090,"

	# quote this to prevent word splitting
	exclude+="SC2046,"

	# double quote to prevent globbing and word splitting
	exclude+="SC2086,"

	# use foo "$@" if function's $1 should mean script's $1
	exclude+="SC2119,"

	# foo references arguments, but none are ever passed
	exclude+="SC2120"

	(cd "${OVE_DIR}" && \shellcheck -x -e ${exclude} "${OVE_SELF}" > "${OVE_TMP}/shell-check")
	\grep -c -o ' SC[0-9]\+.*' "${OVE_TMP}/shell-check" > "${OVE_TMP}/shellcheck.summary"
	\grep -o ' SC[0-9]\+.*' "${OVE_TMP}/shell-check" | LC_ALL="C" \sort | \uniq -c | LC_ALL="C" \sort -nr >> "${OVE_TMP}/shellcheck.summary"
	\cp -a "${OVE_TMP}/shellcheck.summary" "${OVE_DIR}/tests/.shellcheck"
	\git --no-pager -C "${OVE_DIR}" diff -- tests/.shellcheck

	if \git -C "${OVE_DIR}" diff-files  --quiet -- tests/.shellcheck; then
		return 0
	else
		return 1
	fi
}

function ove_externals {
	local cmds=()
	local cmd

	cmds+=('ag')
	cmds+=('awk')
	cmds+=('basename')
	cmds+=('cat')
	cmds+=('column')
	cmds+=('comm')
	cmds+=('cp')
	cmds+=('csplit')
	cmds+=('cut')
	cmds+=('date')
	cmds+=('dirname')
	cmds+=('du')
	cmds+=('file')
	cmds+=('find')
	cmds+=('fold')
	cmds+=('git')
	cmds+=('grep')
	cmds+=('head')
	cmds+=('inotifywait')
	cmds+=('less')
	cmds+=('locate')
	cmds+=('lsb_release')
	cmds+=('md5deep')
	cmds+=('md5sum')
	cmds+=('mkdir')
	cmds+=('mktemp')
	cmds+=('pgrep')
	cmds+=('pkill')
	cmds+=('readlink')
	cmds+=('rev')
	cmds+=('rm')
	cmds+=('rmdir')
	cmds+=('sed')
	cmds+=('sort')
	cmds+=('ssh')
	cmds+=('stat')
	cmds+=('tac')
	cmds+=('tail')
	cmds+=('tar')
	cmds+=('tee')
	cmds+=('timeout')
	cmds+=('tr')
	cmds+=('tree')
	cmds+=('tsort')
	cmds+=('uname')
	cmds+=('uniq')
	cmds+=('wc')
	cmds+=('which')
	cmds+=('xargs')
	cmds+=('yamllint')

	for cmd in "${cmds[@]}"; do
		echo "${cmd}:"
		\grep -v "\\\\${cmd} " ${OVE_SELF} | \
			\grep "[[:blank:] ()]\+${cmd}\b" | \
			\grep -v "${cmd}-" | \
			\sed -e "s|^#.*${cmd}.*||g" -e "s|^\t\+#.*${cmd}.*||g" -e "s|.*command.*${cmd}.*||g" -e '/^$/d' | \
			\grep --color=auto -w ${cmd}
		echo
	done | \head -n -1 | \sed 's|^\s\+||g' > "${OVE_DIR}/tests/.externals"

	\git --no-pager -C "${OVE_DIR}" diff -- tests/.externals
	if \git -C "${OVE_DIR}" diff-files  --quiet -- tests/.externals; then
		return 0
	else
		return 1
	fi
}

# nop: :do nothing
function ove-nop {
	:
}

# pre-push: :shell-check+unittest+generate-doc combo
function ove-pre-push {
	ove_echo "shell-check"
	ove-shell-check
	ove_echo "unittest"
	ove-unittest
	ove_echo "generate-doc"
	ove-generate-doc
	ove_echo "blame"
	ove-blame "${USER}"
	ove_echo "externals"
	ove_externals
	ove_echo "status"
	ove-status .ove
}

ove_main "$@"
